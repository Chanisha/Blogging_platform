/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/create/page"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C91965%5C%5CDesktop%5C%5Cblogging%5C%5Csrc%5C%5Capp%5C%5Ccreate%5C%5Cpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!":
/*!******************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C91965%5C%5CDesktop%5C%5Cblogging%5C%5Csrc%5C%5Capp%5C%5Ccreate%5C%5Cpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false! ***!
  \******************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/app/create/page.tsx */ \"(app-pages-browser)/./src/app/create/page.tsx\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyQyUzQSU1QyU1Q1VzZXJzJTVDJTVDOTE5NjUlNUMlNUNEZXNrdG9wJTVDJTVDYmxvZ2dpbmclNUMlNUNzcmMlNUMlNUNhcHAlNUMlNUNjcmVhdGUlNUMlNUNwYWdlLnRzeCUyMiUyQyUyMmlkcyUyMiUzQSU1QiU1RCU3RCZzZXJ2ZXI9ZmFsc2UhIiwibWFwcGluZ3MiOiJBQUFBLDRLQUFvRyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvP2FhZTgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCJDOlxcXFxVc2Vyc1xcXFw5MTk2NVxcXFxEZXNrdG9wXFxcXGJsb2dnaW5nXFxcXHNyY1xcXFxhcHBcXFxcY3JlYXRlXFxcXHBhZ2UudHN4XCIpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C91965%5C%5CDesktop%5C%5Cblogging%5C%5Csrc%5C%5Capp%5C%5Ccreate%5C%5Cpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/createPopper.js":
/*!*********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/createPopper.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createPopper: function() { return /* binding */ createPopper; },\n/* harmony export */   detectOverflow: function() { return /* reexport safe */ _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"]; },\n/* harmony export */   popperGenerator: function() { return /* binding */ popperGenerator; }\n/* harmony export */ });\n/* harmony import */ var _dom_utils_getCompositeRect_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./dom-utils/getCompositeRect.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js\");\n/* harmony import */ var _dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./dom-utils/getLayoutRect.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js\");\n/* harmony import */ var _dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./dom-utils/listScrollParents.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js\");\n/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./dom-utils/getOffsetParent.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js\");\n/* harmony import */ var _utils_orderModifiers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/orderModifiers.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/orderModifiers.js\");\n/* harmony import */ var _utils_debounce_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/debounce.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/debounce.js\");\n/* harmony import */ var _utils_mergeByName_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/mergeByName.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/mergeByName.js\");\n/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/detectOverflow.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/detectOverflow.js\");\n/* harmony import */ var _dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dom-utils/instanceOf.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js\");\n\n\n\n\n\n\n\n\n\nvar DEFAULT_OPTIONS = {\n  placement: 'bottom',\n  modifiers: [],\n  strategy: 'absolute'\n};\n\nfunction areValidElements() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return !args.some(function (element) {\n    return !(element && typeof element.getBoundingClientRect === 'function');\n  });\n}\n\nfunction popperGenerator(generatorOptions) {\n  if (generatorOptions === void 0) {\n    generatorOptions = {};\n  }\n\n  var _generatorOptions = generatorOptions,\n      _generatorOptions$def = _generatorOptions.defaultModifiers,\n      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,\n      _generatorOptions$def2 = _generatorOptions.defaultOptions,\n      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\n  return function createPopper(reference, popper, options) {\n    if (options === void 0) {\n      options = defaultOptions;\n    }\n\n    var state = {\n      placement: 'bottom',\n      orderedModifiers: [],\n      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),\n      modifiersData: {},\n      elements: {\n        reference: reference,\n        popper: popper\n      },\n      attributes: {},\n      styles: {}\n    };\n    var effectCleanupFns = [];\n    var isDestroyed = false;\n    var instance = {\n      state: state,\n      setOptions: function setOptions(setOptionsAction) {\n        var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;\n        cleanupModifierEffects();\n        state.options = Object.assign({}, defaultOptions, state.options, options);\n        state.scrollParents = {\n          reference: (0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isElement)(reference) ? (0,_dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(reference) : reference.contextElement ? (0,_dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(reference.contextElement) : [],\n          popper: (0,_dom_utils_listScrollParents_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(popper)\n        }; // Orders the modifiers based on their dependencies and `phase`\n        // properties\n\n        var orderedModifiers = (0,_utils_orderModifiers_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])((0,_utils_mergeByName_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers\n\n        state.orderedModifiers = orderedModifiers.filter(function (m) {\n          return m.enabled;\n        });\n        runModifierEffects();\n        return instance.update();\n      },\n      // Sync update – it will always be executed, even if not necessary. This\n      // is useful for low frequency updates where sync behavior simplifies the\n      // logic.\n      // For high frequency updates (e.g. `resize` and `scroll` events), always\n      // prefer the async Popper#update method\n      forceUpdate: function forceUpdate() {\n        if (isDestroyed) {\n          return;\n        }\n\n        var _state$elements = state.elements,\n            reference = _state$elements.reference,\n            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements\n        // anymore\n\n        if (!areValidElements(reference, popper)) {\n          return;\n        } // Store the reference and popper rects to be read by modifiers\n\n\n        state.rects = {\n          reference: (0,_dom_utils_getCompositeRect_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(reference, (0,_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(popper), state.options.strategy === 'fixed'),\n          popper: (0,_dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(popper)\n        }; // Modifiers have the ability to reset the current update cycle. The\n        // most common use case for this is the `flip` modifier changing the\n        // placement, which then needs to re-run all the modifiers, because the\n        // logic was previously ran for the previous placement and is therefore\n        // stale/incorrect\n\n        state.reset = false;\n        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier\n        // is filled with the initial data specified by the modifier. This means\n        // it doesn't persist and is fresh on each update.\n        // To ensure persistent data, use `${name}#persistent`\n\n        state.orderedModifiers.forEach(function (modifier) {\n          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\n        });\n\n        for (var index = 0; index < state.orderedModifiers.length; index++) {\n          if (state.reset === true) {\n            state.reset = false;\n            index = -1;\n            continue;\n          }\n\n          var _state$orderedModifie = state.orderedModifiers[index],\n              fn = _state$orderedModifie.fn,\n              _state$orderedModifie2 = _state$orderedModifie.options,\n              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,\n              name = _state$orderedModifie.name;\n\n          if (typeof fn === 'function') {\n            state = fn({\n              state: state,\n              options: _options,\n              name: name,\n              instance: instance\n            }) || state;\n          }\n        }\n      },\n      // Async and optimistically optimized update – it will not be executed if\n      // not necessary (debounced to run at most once-per-tick)\n      update: (0,_utils_debounce_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(function () {\n        return new Promise(function (resolve) {\n          instance.forceUpdate();\n          resolve(state);\n        });\n      }),\n      destroy: function destroy() {\n        cleanupModifierEffects();\n        isDestroyed = true;\n      }\n    };\n\n    if (!areValidElements(reference, popper)) {\n      return instance;\n    }\n\n    instance.setOptions(options).then(function (state) {\n      if (!isDestroyed && options.onFirstUpdate) {\n        options.onFirstUpdate(state);\n      }\n    }); // Modifiers have the ability to execute arbitrary code before the first\n    // update cycle runs. They will be executed in the same order as the update\n    // cycle. This is useful when a modifier adds some persistent data that\n    // other modifiers need to use, but the modifier is run after the dependent\n    // one.\n\n    function runModifierEffects() {\n      state.orderedModifiers.forEach(function (_ref) {\n        var name = _ref.name,\n            _ref$options = _ref.options,\n            options = _ref$options === void 0 ? {} : _ref$options,\n            effect = _ref.effect;\n\n        if (typeof effect === 'function') {\n          var cleanupFn = effect({\n            state: state,\n            name: name,\n            instance: instance,\n            options: options\n          });\n\n          var noopFn = function noopFn() {};\n\n          effectCleanupFns.push(cleanupFn || noopFn);\n        }\n      });\n    }\n\n    function cleanupModifierEffects() {\n      effectCleanupFns.forEach(function (fn) {\n        return fn();\n      });\n      effectCleanupFns = [];\n    }\n\n    return instance;\n  };\n}\nvar createPopper = /*#__PURE__*/popperGenerator(); // eslint-disable-next-line import/no-unused-modules\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvY3JlYXRlUG9wcGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUErRDtBQUNOO0FBQ1E7QUFDSjtBQUNOO0FBQ1o7QUFDTTtBQUNNO0FBQ0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNFQUFzRSxhQUFhO0FBQ25GO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1Asb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QztBQUNBLHFCQUFxQixtRUFBUyxjQUFjLDJFQUFpQix5Q0FBeUMsMkVBQWlCO0FBQ3ZILGtCQUFrQiwyRUFBaUI7QUFDbkMsV0FBVztBQUNYOztBQUVBLCtCQUErQixvRUFBYyxDQUFDLGlFQUFXLHlEQUF5RDs7QUFFbEg7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDOztBQUVBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBLHFCQUFxQiwwRUFBZ0IsWUFBWSx5RUFBZTtBQUNoRSxrQkFBa0IsdUVBQWE7QUFDL0IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQSw2Q0FBNkMsS0FBSzs7QUFFbEQ7QUFDQSxzRUFBc0U7QUFDdEUsU0FBUzs7QUFFVCw0QkFBNEIsdUNBQXVDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxjQUFjLDhEQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEdBQUc7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ08sbURBQW1EIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvY3JlYXRlUG9wcGVyLmpzPzI2ZGEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGdldENvbXBvc2l0ZVJlY3QgZnJvbSBcIi4vZG9tLXV0aWxzL2dldENvbXBvc2l0ZVJlY3QuanNcIjtcbmltcG9ydCBnZXRMYXlvdXRSZWN0IGZyb20gXCIuL2RvbS11dGlscy9nZXRMYXlvdXRSZWN0LmpzXCI7XG5pbXBvcnQgbGlzdFNjcm9sbFBhcmVudHMgZnJvbSBcIi4vZG9tLXV0aWxzL2xpc3RTY3JvbGxQYXJlbnRzLmpzXCI7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gXCIuL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBvcmRlck1vZGlmaWVycyBmcm9tIFwiLi91dGlscy9vcmRlck1vZGlmaWVycy5qc1wiO1xuaW1wb3J0IGRlYm91bmNlIGZyb20gXCIuL3V0aWxzL2RlYm91bmNlLmpzXCI7XG5pbXBvcnQgbWVyZ2VCeU5hbWUgZnJvbSBcIi4vdXRpbHMvbWVyZ2VCeU5hbWUuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi91dGlscy9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IHsgaXNFbGVtZW50IH0gZnJvbSBcIi4vZG9tLXV0aWxzL2luc3RhbmNlT2YuanNcIjtcbnZhciBERUZBVUxUX09QVElPTlMgPSB7XG4gIHBsYWNlbWVudDogJ2JvdHRvbScsXG4gIG1vZGlmaWVyczogW10sXG4gIHN0cmF0ZWd5OiAnYWJzb2x1dGUnXG59O1xuXG5mdW5jdGlvbiBhcmVWYWxpZEVsZW1lbnRzKCkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuICFhcmdzLnNvbWUoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gIShlbGVtZW50ICYmIHR5cGVvZiBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCA9PT0gJ2Z1bmN0aW9uJyk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcG9wcGVyR2VuZXJhdG9yKGdlbmVyYXRvck9wdGlvbnMpIHtcbiAgaWYgKGdlbmVyYXRvck9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIGdlbmVyYXRvck9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfZ2VuZXJhdG9yT3B0aW9ucyA9IGdlbmVyYXRvck9wdGlvbnMsXG4gICAgICBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYgPSBfZ2VuZXJhdG9yT3B0aW9ucy5kZWZhdWx0TW9kaWZpZXJzLFxuICAgICAgZGVmYXVsdE1vZGlmaWVycyA9IF9nZW5lcmF0b3JPcHRpb25zJGRlZiA9PT0gdm9pZCAwID8gW10gOiBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYsXG4gICAgICBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyID0gX2dlbmVyYXRvck9wdGlvbnMuZGVmYXVsdE9wdGlvbnMsXG4gICAgICBkZWZhdWx0T3B0aW9ucyA9IF9nZW5lcmF0b3JPcHRpb25zJGRlZjIgPT09IHZvaWQgMCA/IERFRkFVTFRfT1BUSU9OUyA6IF9nZW5lcmF0b3JPcHRpb25zJGRlZjI7XG4gIHJldHVybiBmdW5jdGlvbiBjcmVhdGVQb3BwZXIocmVmZXJlbmNlLCBwb3BwZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0gZGVmYXVsdE9wdGlvbnM7XG4gICAgfVxuXG4gICAgdmFyIHN0YXRlID0ge1xuICAgICAgcGxhY2VtZW50OiAnYm90dG9tJyxcbiAgICAgIG9yZGVyZWRNb2RpZmllcnM6IFtdLFxuICAgICAgb3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBkZWZhdWx0T3B0aW9ucyksXG4gICAgICBtb2RpZmllcnNEYXRhOiB7fSxcbiAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlLFxuICAgICAgICBwb3BwZXI6IHBvcHBlclxuICAgICAgfSxcbiAgICAgIGF0dHJpYnV0ZXM6IHt9LFxuICAgICAgc3R5bGVzOiB7fVxuICAgIH07XG4gICAgdmFyIGVmZmVjdENsZWFudXBGbnMgPSBbXTtcbiAgICB2YXIgaXNEZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB2YXIgaW5zdGFuY2UgPSB7XG4gICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICBzZXRPcHRpb25zOiBmdW5jdGlvbiBzZXRPcHRpb25zKHNldE9wdGlvbnNBY3Rpb24pIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2V0T3B0aW9uc0FjdGlvbiA9PT0gJ2Z1bmN0aW9uJyA/IHNldE9wdGlvbnNBY3Rpb24oc3RhdGUub3B0aW9ucykgOiBzZXRPcHRpb25zQWN0aW9uO1xuICAgICAgICBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCk7XG4gICAgICAgIHN0YXRlLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucywgc3RhdGUub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIHN0YXRlLnNjcm9sbFBhcmVudHMgPSB7XG4gICAgICAgICAgcmVmZXJlbmNlOiBpc0VsZW1lbnQocmVmZXJlbmNlKSA/IGxpc3RTY3JvbGxQYXJlbnRzKHJlZmVyZW5jZSkgOiByZWZlcmVuY2UuY29udGV4dEVsZW1lbnQgPyBsaXN0U2Nyb2xsUGFyZW50cyhyZWZlcmVuY2UuY29udGV4dEVsZW1lbnQpIDogW10sXG4gICAgICAgICAgcG9wcGVyOiBsaXN0U2Nyb2xsUGFyZW50cyhwb3BwZXIpXG4gICAgICAgIH07IC8vIE9yZGVycyB0aGUgbW9kaWZpZXJzIGJhc2VkIG9uIHRoZWlyIGRlcGVuZGVuY2llcyBhbmQgYHBoYXNlYFxuICAgICAgICAvLyBwcm9wZXJ0aWVzXG5cbiAgICAgICAgdmFyIG9yZGVyZWRNb2RpZmllcnMgPSBvcmRlck1vZGlmaWVycyhtZXJnZUJ5TmFtZShbXS5jb25jYXQoZGVmYXVsdE1vZGlmaWVycywgc3RhdGUub3B0aW9ucy5tb2RpZmllcnMpKSk7IC8vIFN0cmlwIG91dCBkaXNhYmxlZCBtb2RpZmllcnNcblxuICAgICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzID0gb3JkZXJlZE1vZGlmaWVycy5maWx0ZXIoZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICByZXR1cm4gbS5lbmFibGVkO1xuICAgICAgICB9KTtcbiAgICAgICAgcnVuTW9kaWZpZXJFZmZlY3RzKCk7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZS51cGRhdGUoKTtcbiAgICAgIH0sXG4gICAgICAvLyBTeW5jIHVwZGF0ZSDigJMgaXQgd2lsbCBhbHdheXMgYmUgZXhlY3V0ZWQsIGV2ZW4gaWYgbm90IG5lY2Vzc2FyeS4gVGhpc1xuICAgICAgLy8gaXMgdXNlZnVsIGZvciBsb3cgZnJlcXVlbmN5IHVwZGF0ZXMgd2hlcmUgc3luYyBiZWhhdmlvciBzaW1wbGlmaWVzIHRoZVxuICAgICAgLy8gbG9naWMuXG4gICAgICAvLyBGb3IgaGlnaCBmcmVxdWVuY3kgdXBkYXRlcyAoZS5nLiBgcmVzaXplYCBhbmQgYHNjcm9sbGAgZXZlbnRzKSwgYWx3YXlzXG4gICAgICAvLyBwcmVmZXIgdGhlIGFzeW5jIFBvcHBlciN1cGRhdGUgbWV0aG9kXG4gICAgICBmb3JjZVVwZGF0ZTogZnVuY3Rpb24gZm9yY2VVcGRhdGUoKSB7XG4gICAgICAgIGlmIChpc0Rlc3Ryb3llZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfc3RhdGUkZWxlbWVudHMgPSBzdGF0ZS5lbGVtZW50cyxcbiAgICAgICAgICAgIHJlZmVyZW5jZSA9IF9zdGF0ZSRlbGVtZW50cy5yZWZlcmVuY2UsXG4gICAgICAgICAgICBwb3BwZXIgPSBfc3RhdGUkZWxlbWVudHMucG9wcGVyOyAvLyBEb24ndCBwcm9jZWVkIGlmIGByZWZlcmVuY2VgIG9yIGBwb3BwZXJgIGFyZSBub3QgdmFsaWQgZWxlbWVudHNcbiAgICAgICAgLy8gYW55bW9yZVxuXG4gICAgICAgIGlmICghYXJlVmFsaWRFbGVtZW50cyhyZWZlcmVuY2UsIHBvcHBlcikpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gU3RvcmUgdGhlIHJlZmVyZW5jZSBhbmQgcG9wcGVyIHJlY3RzIHRvIGJlIHJlYWQgYnkgbW9kaWZpZXJzXG5cblxuICAgICAgICBzdGF0ZS5yZWN0cyA9IHtcbiAgICAgICAgICByZWZlcmVuY2U6IGdldENvbXBvc2l0ZVJlY3QocmVmZXJlbmNlLCBnZXRPZmZzZXRQYXJlbnQocG9wcGVyKSwgc3RhdGUub3B0aW9ucy5zdHJhdGVneSA9PT0gJ2ZpeGVkJyksXG4gICAgICAgICAgcG9wcGVyOiBnZXRMYXlvdXRSZWN0KHBvcHBlcilcbiAgICAgICAgfTsgLy8gTW9kaWZpZXJzIGhhdmUgdGhlIGFiaWxpdHkgdG8gcmVzZXQgdGhlIGN1cnJlbnQgdXBkYXRlIGN5Y2xlLiBUaGVcbiAgICAgICAgLy8gbW9zdCBjb21tb24gdXNlIGNhc2UgZm9yIHRoaXMgaXMgdGhlIGBmbGlwYCBtb2RpZmllciBjaGFuZ2luZyB0aGVcbiAgICAgICAgLy8gcGxhY2VtZW50LCB3aGljaCB0aGVuIG5lZWRzIHRvIHJlLXJ1biBhbGwgdGhlIG1vZGlmaWVycywgYmVjYXVzZSB0aGVcbiAgICAgICAgLy8gbG9naWMgd2FzIHByZXZpb3VzbHkgcmFuIGZvciB0aGUgcHJldmlvdXMgcGxhY2VtZW50IGFuZCBpcyB0aGVyZWZvcmVcbiAgICAgICAgLy8gc3RhbGUvaW5jb3JyZWN0XG5cbiAgICAgICAgc3RhdGUucmVzZXQgPSBmYWxzZTtcbiAgICAgICAgc3RhdGUucGxhY2VtZW50ID0gc3RhdGUub3B0aW9ucy5wbGFjZW1lbnQ7IC8vIE9uIGVhY2ggdXBkYXRlIGN5Y2xlLCB0aGUgYG1vZGlmaWVyc0RhdGFgIHByb3BlcnR5IGZvciBlYWNoIG1vZGlmaWVyXG4gICAgICAgIC8vIGlzIGZpbGxlZCB3aXRoIHRoZSBpbml0aWFsIGRhdGEgc3BlY2lmaWVkIGJ5IHRoZSBtb2RpZmllci4gVGhpcyBtZWFuc1xuICAgICAgICAvLyBpdCBkb2Vzbid0IHBlcnNpc3QgYW5kIGlzIGZyZXNoIG9uIGVhY2ggdXBkYXRlLlxuICAgICAgICAvLyBUbyBlbnN1cmUgcGVyc2lzdGVudCBkYXRhLCB1c2UgYCR7bmFtZX0jcGVyc2lzdGVudGBcblxuICAgICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlLm1vZGlmaWVyc0RhdGFbbW9kaWZpZXIubmFtZV0gPSBPYmplY3QuYXNzaWduKHt9LCBtb2RpZmllci5kYXRhKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHN0YXRlLm9yZGVyZWRNb2RpZmllcnMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgaWYgKHN0YXRlLnJlc2V0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBzdGF0ZS5yZXNldCA9IGZhbHNlO1xuICAgICAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfc3RhdGUkb3JkZXJlZE1vZGlmaWUgPSBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzW2luZGV4XSxcbiAgICAgICAgICAgICAgZm4gPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUuZm4sXG4gICAgICAgICAgICAgIF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUub3B0aW9ucyxcbiAgICAgICAgICAgICAgX29wdGlvbnMgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUyID09PSB2b2lkIDAgPyB7fSA6IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIsXG4gICAgICAgICAgICAgIG5hbWUgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUubmFtZTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHN0YXRlID0gZm4oe1xuICAgICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICAgIG9wdGlvbnM6IF9vcHRpb25zLFxuICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2VcbiAgICAgICAgICAgIH0pIHx8IHN0YXRlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIEFzeW5jIGFuZCBvcHRpbWlzdGljYWxseSBvcHRpbWl6ZWQgdXBkYXRlIOKAkyBpdCB3aWxsIG5vdCBiZSBleGVjdXRlZCBpZlxuICAgICAgLy8gbm90IG5lY2Vzc2FyeSAoZGVib3VuY2VkIHRvIHJ1biBhdCBtb3N0IG9uY2UtcGVyLXRpY2spXG4gICAgICB1cGRhdGU6IGRlYm91bmNlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgaW5zdGFuY2UuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICByZXNvbHZlKHN0YXRlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KSxcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKTtcbiAgICAgICAgaXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoIWFyZVZhbGlkRWxlbWVudHMocmVmZXJlbmNlLCBwb3BwZXIpKSB7XG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuXG4gICAgaW5zdGFuY2Uuc2V0T3B0aW9ucyhvcHRpb25zKS50aGVuKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgaWYgKCFpc0Rlc3Ryb3llZCAmJiBvcHRpb25zLm9uRmlyc3RVcGRhdGUpIHtcbiAgICAgICAgb3B0aW9ucy5vbkZpcnN0VXBkYXRlKHN0YXRlKTtcbiAgICAgIH1cbiAgICB9KTsgLy8gTW9kaWZpZXJzIGhhdmUgdGhlIGFiaWxpdHkgdG8gZXhlY3V0ZSBhcmJpdHJhcnkgY29kZSBiZWZvcmUgdGhlIGZpcnN0XG4gICAgLy8gdXBkYXRlIGN5Y2xlIHJ1bnMuIFRoZXkgd2lsbCBiZSBleGVjdXRlZCBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGUgdXBkYXRlXG4gICAgLy8gY3ljbGUuIFRoaXMgaXMgdXNlZnVsIHdoZW4gYSBtb2RpZmllciBhZGRzIHNvbWUgcGVyc2lzdGVudCBkYXRhIHRoYXRcbiAgICAvLyBvdGhlciBtb2RpZmllcnMgbmVlZCB0byB1c2UsIGJ1dCB0aGUgbW9kaWZpZXIgaXMgcnVuIGFmdGVyIHRoZSBkZXBlbmRlbnRcbiAgICAvLyBvbmUuXG5cbiAgICBmdW5jdGlvbiBydW5Nb2RpZmllckVmZmVjdHMoKSB7XG4gICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgdmFyIG5hbWUgPSBfcmVmLm5hbWUsXG4gICAgICAgICAgICBfcmVmJG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXG4gICAgICAgICAgICBvcHRpb25zID0gX3JlZiRvcHRpb25zID09PSB2b2lkIDAgPyB7fSA6IF9yZWYkb3B0aW9ucyxcbiAgICAgICAgICAgIGVmZmVjdCA9IF9yZWYuZWZmZWN0O1xuXG4gICAgICAgIGlmICh0eXBlb2YgZWZmZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFyIGNsZWFudXBGbiA9IGVmZmVjdCh7XG4gICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlLFxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdmFyIG5vb3BGbiA9IGZ1bmN0aW9uIG5vb3BGbigpIHt9O1xuXG4gICAgICAgICAgZWZmZWN0Q2xlYW51cEZucy5wdXNoKGNsZWFudXBGbiB8fCBub29wRm4pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCkge1xuICAgICAgZWZmZWN0Q2xlYW51cEZucy5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgIH0pO1xuICAgICAgZWZmZWN0Q2xlYW51cEZucyA9IFtdO1xuICAgIH1cblxuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcbn1cbmV4cG9ydCB2YXIgY3JlYXRlUG9wcGVyID0gLyojX19QVVJFX18qL3BvcHBlckdlbmVyYXRvcigpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCB7IGRldGVjdE92ZXJmbG93IH07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/createPopper.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/contains.js":
/*!***************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/contains.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ contains; }\n/* harmony export */ });\n/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instanceOf.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js\");\n\nfunction contains(parent, child) {\n  var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method\n\n  if (parent.contains(child)) {\n    return true;\n  } // then fallback to custom implementation with Shadow DOM support\n  else if (rootNode && (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isShadowRoot)(rootNode)) {\n      var next = child;\n\n      do {\n        if (next && parent.isSameNode(next)) {\n          return true;\n        } // $FlowFixMe[prop-missing]: need a better way to handle this...\n\n\n        next = next.parentNode || next.host;\n      } while (next);\n    } // Give up, the result is false\n\n\n  return false;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2NvbnRhaW5zLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQStDO0FBQ2hDO0FBQ2YsMkRBQTJEOztBQUUzRDtBQUNBO0FBQ0EsSUFBSTtBQUNKLHVCQUF1Qiw0REFBWTtBQUNuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBLFFBQVE7QUFDUixNQUFNOzs7QUFHTjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2NvbnRhaW5zLmpzPzI4ZTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNTaGFkb3dSb290IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29udGFpbnMocGFyZW50LCBjaGlsZCkge1xuICB2YXIgcm9vdE5vZGUgPSBjaGlsZC5nZXRSb290Tm9kZSAmJiBjaGlsZC5nZXRSb290Tm9kZSgpOyAvLyBGaXJzdCwgYXR0ZW1wdCB3aXRoIGZhc3RlciBuYXRpdmUgbWV0aG9kXG5cbiAgaWYgKHBhcmVudC5jb250YWlucyhjaGlsZCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyB0aGVuIGZhbGxiYWNrIHRvIGN1c3RvbSBpbXBsZW1lbnRhdGlvbiB3aXRoIFNoYWRvdyBET00gc3VwcG9ydFxuICBlbHNlIGlmIChyb290Tm9kZSAmJiBpc1NoYWRvd1Jvb3Qocm9vdE5vZGUpKSB7XG4gICAgICB2YXIgbmV4dCA9IGNoaWxkO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChuZXh0ICYmIHBhcmVudC5pc1NhbWVOb2RlKG5leHQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddOiBuZWVkIGEgYmV0dGVyIHdheSB0byBoYW5kbGUgdGhpcy4uLlxuXG5cbiAgICAgICAgbmV4dCA9IG5leHQucGFyZW50Tm9kZSB8fCBuZXh0Lmhvc3Q7XG4gICAgICB9IHdoaWxlIChuZXh0KTtcbiAgICB9IC8vIEdpdmUgdXAsIHRoZSByZXN1bHQgaXMgZmFsc2VcblxuXG4gIHJldHVybiBmYWxzZTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/contains.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ getBoundingClientRect; }\n/* harmony export */ });\n/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instanceOf.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js\");\n/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/math.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/math.js\");\n/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getWindow.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getWindow.js\");\n/* harmony import */ var _isLayoutViewport_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isLayoutViewport.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js\");\n\n\n\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n\n  var clientRect = element.getBoundingClientRect();\n  var scaleX = 1;\n  var scaleY = 1;\n\n  if (includeScale && (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element)) {\n    scaleX = element.offsetWidth > 0 ? (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_1__.round)(clientRect.width) / element.offsetWidth || 1 : 1;\n    scaleY = element.offsetHeight > 0 ? (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_1__.round)(clientRect.height) / element.offsetHeight || 1 : 1;\n  }\n\n  var _ref = (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isElement)(element) ? (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(element) : window,\n      visualViewport = _ref.visualViewport;\n\n  var addVisualOffsets = !(0,_isLayoutViewport_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])() && isFixedStrategy;\n  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;\n  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;\n  var width = clientRect.width / scaleX;\n  var height = clientRect.height / scaleY;\n  return {\n    width: width,\n    height: height,\n    top: y,\n    right: x + width,\n    bottom: y + height,\n    left: x,\n    x: x,\n    y: y\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUEyRDtBQUNsQjtBQUNGO0FBQ2M7QUFDdEM7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsNkRBQWE7QUFDbkMsdUNBQXVDLHFEQUFLO0FBQzVDLHdDQUF3QyxxREFBSztBQUM3Qzs7QUFFQSxhQUFhLHlEQUFTLFlBQVkseURBQVM7QUFDM0M7O0FBRUEsMEJBQTBCLGdFQUFnQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzPzQ1NTUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaXNFbGVtZW50LCBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IHsgcm91bmQgfSBmcm9tIFwiLi4vdXRpbHMvbWF0aC5qc1wiO1xuaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmltcG9ydCBpc0xheW91dFZpZXdwb3J0IGZyb20gXCIuL2lzTGF5b3V0Vmlld3BvcnQuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCBpbmNsdWRlU2NhbGUsIGlzRml4ZWRTdHJhdGVneSkge1xuICBpZiAoaW5jbHVkZVNjYWxlID09PSB2b2lkIDApIHtcbiAgICBpbmNsdWRlU2NhbGUgPSBmYWxzZTtcbiAgfVxuXG4gIGlmIChpc0ZpeGVkU3RyYXRlZ3kgPT09IHZvaWQgMCkge1xuICAgIGlzRml4ZWRTdHJhdGVneSA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIGNsaWVudFJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgc2NhbGVYID0gMTtcbiAgdmFyIHNjYWxlWSA9IDE7XG5cbiAgaWYgKGluY2x1ZGVTY2FsZSAmJiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgc2NhbGVYID0gZWxlbWVudC5vZmZzZXRXaWR0aCA+IDAgPyByb3VuZChjbGllbnRSZWN0LndpZHRoKSAvIGVsZW1lbnQub2Zmc2V0V2lkdGggfHwgMSA6IDE7XG4gICAgc2NhbGVZID0gZWxlbWVudC5vZmZzZXRIZWlnaHQgPiAwID8gcm91bmQoY2xpZW50UmVjdC5oZWlnaHQpIC8gZWxlbWVudC5vZmZzZXRIZWlnaHQgfHwgMSA6IDE7XG4gIH1cblxuICB2YXIgX3JlZiA9IGlzRWxlbWVudChlbGVtZW50KSA/IGdldFdpbmRvdyhlbGVtZW50KSA6IHdpbmRvdyxcbiAgICAgIHZpc3VhbFZpZXdwb3J0ID0gX3JlZi52aXN1YWxWaWV3cG9ydDtcblxuICB2YXIgYWRkVmlzdWFsT2Zmc2V0cyA9ICFpc0xheW91dFZpZXdwb3J0KCkgJiYgaXNGaXhlZFN0cmF0ZWd5O1xuICB2YXIgeCA9IChjbGllbnRSZWN0LmxlZnQgKyAoYWRkVmlzdWFsT2Zmc2V0cyAmJiB2aXN1YWxWaWV3cG9ydCA/IHZpc3VhbFZpZXdwb3J0Lm9mZnNldExlZnQgOiAwKSkgLyBzY2FsZVg7XG4gIHZhciB5ID0gKGNsaWVudFJlY3QudG9wICsgKGFkZFZpc3VhbE9mZnNldHMgJiYgdmlzdWFsVmlld3BvcnQgPyB2aXN1YWxWaWV3cG9ydC5vZmZzZXRUb3AgOiAwKSkgLyBzY2FsZVk7XG4gIHZhciB3aWR0aCA9IGNsaWVudFJlY3Qud2lkdGggLyBzY2FsZVg7XG4gIHZhciBoZWlnaHQgPSBjbGllbnRSZWN0LmhlaWdodCAvIHNjYWxlWTtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgdG9wOiB5LFxuICAgIHJpZ2h0OiB4ICsgd2lkdGgsXG4gICAgYm90dG9tOiB5ICsgaGVpZ2h0LFxuICAgIGxlZnQ6IHgsXG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ getClippingRect; }\n/* harmony export */ });\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/enums.js\");\n/* harmony import */ var _getViewportRect_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getViewportRect.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js\");\n/* harmony import */ var _getDocumentRect_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./getDocumentRect.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js\");\n/* harmony import */ var _listScrollParents_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./listScrollParents.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js\");\n/* harmony import */ var _getOffsetParent_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./getOffsetParent.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js\");\n/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./getDocumentElement.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js\");\n/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./getComputedStyle.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js\");\n/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./instanceOf.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js\");\n/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBoundingClientRect.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js\");\n/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./getParentNode.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js\");\n/* harmony import */ var _contains_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./contains.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/contains.js\");\n/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./getNodeName.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js\");\n/* harmony import */ var _utils_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/rectToClientRect.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/rectToClientRect.js\");\n/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../utils/math.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/math.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction getInnerBoundingClientRect(element, strategy) {\n  var rect = (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(element, false, strategy === 'fixed');\n  rect.top = rect.top + element.clientTop;\n  rect.left = rect.left + element.clientLeft;\n  rect.bottom = rect.top + element.clientHeight;\n  rect.right = rect.left + element.clientWidth;\n  rect.width = element.clientWidth;\n  rect.height = element.clientHeight;\n  rect.x = rect.left;\n  rect.y = rect.top;\n  return rect;\n}\n\nfunction getClientRectFromMixedType(element, clippingParent, strategy) {\n  return clippingParent === _enums_js__WEBPACK_IMPORTED_MODULE_1__.viewport ? (0,_utils_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])((0,_getViewportRect_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(element, strategy)) : (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_4__.isElement)(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : (0,_utils_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])((0,_getDocumentRect_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(element)));\n} // A \"clipping parent\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\n\n\nfunction getClippingParents(element) {\n  var clippingParents = (0,_listScrollParents_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"])((0,_getParentNode_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(element));\n  var canEscapeClipping = ['absolute', 'fixed'].indexOf((0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(element).position) >= 0;\n  var clipperElement = canEscapeClipping && (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_4__.isHTMLElement)(element) ? (0,_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"])(element) : element;\n\n  if (!(0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_4__.isElement)(clipperElement)) {\n    return [];\n  } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414\n\n\n  return clippingParents.filter(function (clippingParent) {\n    return (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_4__.isElement)(clippingParent) && (0,_contains_js__WEBPACK_IMPORTED_MODULE_11__[\"default\"])(clippingParent, clipperElement) && (0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_12__[\"default\"])(clippingParent) !== 'body';\n  });\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping parents\n\n\nfunction getClippingRect(element, boundary, rootBoundary, strategy) {\n  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);\n  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);\n  var firstClippingParent = clippingParents[0];\n  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {\n    var rect = getClientRectFromMixedType(element, clippingParent, strategy);\n    accRect.top = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_13__.max)(rect.top, accRect.top);\n    accRect.right = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_13__.min)(rect.right, accRect.right);\n    accRect.bottom = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_13__.min)(rect.bottom, accRect.bottom);\n    accRect.left = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_13__.max)(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromMixedType(element, firstClippingParent, strategy));\n  clippingRect.width = clippingRect.right - clippingRect.left;\n  clippingRect.height = clippingRect.bottom - clippingRect.top;\n  clippingRect.x = clippingRect.left;\n  clippingRect.y = clippingRect.top;\n  return clippingRect;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldENsaXBwaW5nUmVjdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBdUM7QUFDWTtBQUNBO0FBQ0k7QUFDSjtBQUNNO0FBQ0o7QUFDTTtBQUNJO0FBQ2hCO0FBQ1Y7QUFDTTtBQUNpQjtBQUNoQjs7QUFFNUM7QUFDQSxhQUFhLHFFQUFxQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRCQUE0QiwrQ0FBUSxHQUFHLHNFQUFnQixDQUFDLCtEQUFlLHVCQUF1Qix5REFBUywwRUFBMEUsc0VBQWdCLENBQUMsK0RBQWUsQ0FBQyxrRUFBa0I7QUFDcE8sRUFBRTtBQUNGO0FBQ0E7OztBQUdBO0FBQ0Esd0JBQXdCLGlFQUFpQixDQUFDLDZEQUFhO0FBQ3ZELHdEQUF3RCxnRUFBZ0I7QUFDeEUsNENBQTRDLDZEQUFhLFlBQVksZ0VBQWU7O0FBRXBGLE9BQU8seURBQVM7QUFDaEI7QUFDQSxJQUFJOzs7QUFHSjtBQUNBLFdBQVcseURBQVMsb0JBQW9CLHlEQUFRLG9DQUFvQyw0REFBVztBQUMvRixHQUFHO0FBQ0gsRUFBRTtBQUNGOzs7QUFHZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isb0RBQUc7QUFDckIsb0JBQW9CLG9EQUFHO0FBQ3ZCLHFCQUFxQixvREFBRztBQUN4QixtQkFBbUIsb0RBQUc7QUFDdEI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldENsaXBwaW5nUmVjdC5qcz9kOThkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHZpZXdwb3J0IH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZ2V0Vmlld3BvcnRSZWN0IGZyb20gXCIuL2dldFZpZXdwb3J0UmVjdC5qc1wiO1xuaW1wb3J0IGdldERvY3VtZW50UmVjdCBmcm9tIFwiLi9nZXREb2N1bWVudFJlY3QuanNcIjtcbmltcG9ydCBsaXN0U2Nyb2xsUGFyZW50cyBmcm9tIFwiLi9saXN0U2Nyb2xsUGFyZW50cy5qc1wiO1xuaW1wb3J0IGdldE9mZnNldFBhcmVudCBmcm9tIFwiLi9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5pbXBvcnQgeyBpc0VsZW1lbnQsIGlzSFRNTEVsZW1lbnQgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IGZyb20gXCIuL2dldEJvdW5kaW5nQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IGdldFBhcmVudE5vZGUgZnJvbSBcIi4vZ2V0UGFyZW50Tm9kZS5qc1wiO1xuaW1wb3J0IGNvbnRhaW5zIGZyb20gXCIuL2NvbnRhaW5zLmpzXCI7XG5pbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4vZ2V0Tm9kZU5hbWUuanNcIjtcbmltcG9ydCByZWN0VG9DbGllbnRSZWN0IGZyb20gXCIuLi91dGlscy9yZWN0VG9DbGllbnRSZWN0LmpzXCI7XG5pbXBvcnQgeyBtYXgsIG1pbiB9IGZyb20gXCIuLi91dGlscy9tYXRoLmpzXCI7XG5cbmZ1bmN0aW9uIGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSB7XG4gIHZhciByZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIGZhbHNlLCBzdHJhdGVneSA9PT0gJ2ZpeGVkJyk7XG4gIHJlY3QudG9wID0gcmVjdC50b3AgKyBlbGVtZW50LmNsaWVudFRvcDtcbiAgcmVjdC5sZWZ0ID0gcmVjdC5sZWZ0ICsgZWxlbWVudC5jbGllbnRMZWZ0O1xuICByZWN0LmJvdHRvbSA9IHJlY3QudG9wICsgZWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gIHJlY3QucmlnaHQgPSByZWN0LmxlZnQgKyBlbGVtZW50LmNsaWVudFdpZHRoO1xuICByZWN0LndpZHRoID0gZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgcmVjdC5oZWlnaHQgPSBlbGVtZW50LmNsaWVudEhlaWdodDtcbiAgcmVjdC54ID0gcmVjdC5sZWZ0O1xuICByZWN0LnkgPSByZWN0LnRvcDtcbiAgcmV0dXJuIHJlY3Q7XG59XG5cbmZ1bmN0aW9uIGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGNsaXBwaW5nUGFyZW50LCBzdHJhdGVneSkge1xuICByZXR1cm4gY2xpcHBpbmdQYXJlbnQgPT09IHZpZXdwb3J0ID8gcmVjdFRvQ2xpZW50UmVjdChnZXRWaWV3cG9ydFJlY3QoZWxlbWVudCwgc3RyYXRlZ3kpKSA6IGlzRWxlbWVudChjbGlwcGluZ1BhcmVudCkgPyBnZXRJbm5lckJvdW5kaW5nQ2xpZW50UmVjdChjbGlwcGluZ1BhcmVudCwgc3RyYXRlZ3kpIDogcmVjdFRvQ2xpZW50UmVjdChnZXREb2N1bWVudFJlY3QoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKSk7XG59IC8vIEEgXCJjbGlwcGluZyBwYXJlbnRcIiBpcyBhbiBvdmVyZmxvd2FibGUgY29udGFpbmVyIHdpdGggdGhlIGNoYXJhY3RlcmlzdGljIG9mXG4vLyBjbGlwcGluZyAob3IgaGlkaW5nKSBvdmVyZmxvd2luZyBlbGVtZW50cyB3aXRoIGEgcG9zaXRpb24gZGlmZmVyZW50IGZyb21cbi8vIGBpbml0aWFsYFxuXG5cbmZ1bmN0aW9uIGdldENsaXBwaW5nUGFyZW50cyhlbGVtZW50KSB7XG4gIHZhciBjbGlwcGluZ1BhcmVudHMgPSBsaXN0U2Nyb2xsUGFyZW50cyhnZXRQYXJlbnROb2RlKGVsZW1lbnQpKTtcbiAgdmFyIGNhbkVzY2FwZUNsaXBwaW5nID0gWydhYnNvbHV0ZScsICdmaXhlZCddLmluZGV4T2YoZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbikgPj0gMDtcbiAgdmFyIGNsaXBwZXJFbGVtZW50ID0gY2FuRXNjYXBlQ2xpcHBpbmcgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSA/IGdldE9mZnNldFBhcmVudChlbGVtZW50KSA6IGVsZW1lbnQ7XG5cbiAgaWYgKCFpc0VsZW1lbnQoY2xpcHBlckVsZW1lbnQpKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl06IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8xNDE0XG5cblxuICByZXR1cm4gY2xpcHBpbmdQYXJlbnRzLmZpbHRlcihmdW5jdGlvbiAoY2xpcHBpbmdQYXJlbnQpIHtcbiAgICByZXR1cm4gaXNFbGVtZW50KGNsaXBwaW5nUGFyZW50KSAmJiBjb250YWlucyhjbGlwcGluZ1BhcmVudCwgY2xpcHBlckVsZW1lbnQpICYmIGdldE5vZGVOYW1lKGNsaXBwaW5nUGFyZW50KSAhPT0gJ2JvZHknO1xuICB9KTtcbn0gLy8gR2V0cyB0aGUgbWF4aW11bSBhcmVhIHRoYXQgdGhlIGVsZW1lbnQgaXMgdmlzaWJsZSBpbiBkdWUgdG8gYW55IG51bWJlciBvZlxuLy8gY2xpcHBpbmcgcGFyZW50c1xuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENsaXBwaW5nUmVjdChlbGVtZW50LCBib3VuZGFyeSwgcm9vdEJvdW5kYXJ5LCBzdHJhdGVneSkge1xuICB2YXIgbWFpbkNsaXBwaW5nUGFyZW50cyA9IGJvdW5kYXJ5ID09PSAnY2xpcHBpbmdQYXJlbnRzJyA/IGdldENsaXBwaW5nUGFyZW50cyhlbGVtZW50KSA6IFtdLmNvbmNhdChib3VuZGFyeSk7XG4gIHZhciBjbGlwcGluZ1BhcmVudHMgPSBbXS5jb25jYXQobWFpbkNsaXBwaW5nUGFyZW50cywgW3Jvb3RCb3VuZGFyeV0pO1xuICB2YXIgZmlyc3RDbGlwcGluZ1BhcmVudCA9IGNsaXBwaW5nUGFyZW50c1swXTtcbiAgdmFyIGNsaXBwaW5nUmVjdCA9IGNsaXBwaW5nUGFyZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjY1JlY3QsIGNsaXBwaW5nUGFyZW50KSB7XG4gICAgdmFyIHJlY3QgPSBnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZShlbGVtZW50LCBjbGlwcGluZ1BhcmVudCwgc3RyYXRlZ3kpO1xuICAgIGFjY1JlY3QudG9wID0gbWF4KHJlY3QudG9wLCBhY2NSZWN0LnRvcCk7XG4gICAgYWNjUmVjdC5yaWdodCA9IG1pbihyZWN0LnJpZ2h0LCBhY2NSZWN0LnJpZ2h0KTtcbiAgICBhY2NSZWN0LmJvdHRvbSA9IG1pbihyZWN0LmJvdHRvbSwgYWNjUmVjdC5ib3R0b20pO1xuICAgIGFjY1JlY3QubGVmdCA9IG1heChyZWN0LmxlZnQsIGFjY1JlY3QubGVmdCk7XG4gICAgcmV0dXJuIGFjY1JlY3Q7XG4gIH0sIGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGZpcnN0Q2xpcHBpbmdQYXJlbnQsIHN0cmF0ZWd5KSk7XG4gIGNsaXBwaW5nUmVjdC53aWR0aCA9IGNsaXBwaW5nUmVjdC5yaWdodCAtIGNsaXBwaW5nUmVjdC5sZWZ0O1xuICBjbGlwcGluZ1JlY3QuaGVpZ2h0ID0gY2xpcHBpbmdSZWN0LmJvdHRvbSAtIGNsaXBwaW5nUmVjdC50b3A7XG4gIGNsaXBwaW5nUmVjdC54ID0gY2xpcHBpbmdSZWN0LmxlZnQ7XG4gIGNsaXBwaW5nUmVjdC55ID0gY2xpcHBpbmdSZWN0LnRvcDtcbiAgcmV0dXJuIGNsaXBwaW5nUmVjdDtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ getCompositeRect; }\n/* harmony export */ });\n/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getBoundingClientRect.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js\");\n/* harmony import */ var _getNodeScroll_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./getNodeScroll.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js\");\n/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getNodeName.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js\");\n/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./instanceOf.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js\");\n/* harmony import */ var _getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./getWindowScrollBarX.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js\");\n/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getDocumentElement.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js\");\n/* harmony import */ var _isScrollParent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./isScrollParent.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js\");\n/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/math.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/math.js\");\n\n\n\n\n\n\n\n\n\nfunction isElementScaled(element) {\n  var rect = element.getBoundingClientRect();\n  var scaleX = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_0__.round)(rect.width) / element.offsetWidth || 1;\n  var scaleY = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_0__.round)(rect.height) / element.offsetHeight || 1;\n  return scaleX !== 1 || scaleY !== 1;\n} // Returns the composite rect of an element relative to its offsetParent.\n// Composite means it takes into account transforms as well as layout.\n\n\nfunction getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n\n  var isOffsetParentAnElement = (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(offsetParent);\n  var offsetParentIsScaled = (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(offsetParent) && isElementScaled(offsetParent);\n  var documentElement = (0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(offsetParent);\n  var rect = (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(elementOrVirtualElement, offsetParentIsScaled, isFixed);\n  var scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  var offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if ((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078\n    (0,_isScrollParent_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(documentElement)) {\n      scroll = (0,_getNodeScroll_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(offsetParent);\n    }\n\n    if ((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(offsetParent)) {\n      offsets = (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(offsetParent, true);\n      offsets.x += offsetParent.clientLeft;\n      offsets.y += offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = (0,_getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(documentElement);\n    }\n  }\n\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldENvbXBvc2l0ZVJlY3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQStEO0FBQ2hCO0FBQ0o7QUFDSztBQUNXO0FBQ0Y7QUFDUjtBQUNSOztBQUV6QztBQUNBO0FBQ0EsZUFBZSxxREFBSztBQUNwQixlQUFlLHFEQUFLO0FBQ3BCO0FBQ0EsRUFBRTtBQUNGOzs7QUFHZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0MsNkRBQWE7QUFDN0MsNkJBQTZCLDZEQUFhO0FBQzFDLHdCQUF3QixrRUFBa0I7QUFDMUMsYUFBYSxxRUFBcUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsMkRBQVc7QUFDbkIsSUFBSSw4REFBYztBQUNsQixlQUFlLDZEQUFhO0FBQzVCOztBQUVBLFFBQVEsNkRBQWE7QUFDckIsZ0JBQWdCLHFFQUFxQjtBQUNyQztBQUNBO0FBQ0EsTUFBTTtBQUNOLGtCQUFrQixtRUFBbUI7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRDb21wb3NpdGVSZWN0LmpzP2FlYzgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmcm9tIFwiLi9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCBnZXROb2RlU2Nyb2xsIGZyb20gXCIuL2dldE5vZGVTY3JvbGwuanNcIjtcbmltcG9ydCBnZXROb2RlTmFtZSBmcm9tIFwiLi9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmltcG9ydCBnZXRXaW5kb3dTY3JvbGxCYXJYIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbEJhclguanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgaXNTY3JvbGxQYXJlbnQgZnJvbSBcIi4vaXNTY3JvbGxQYXJlbnQuanNcIjtcbmltcG9ydCB7IHJvdW5kIH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjtcblxuZnVuY3Rpb24gaXNFbGVtZW50U2NhbGVkKGVsZW1lbnQpIHtcbiAgdmFyIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB2YXIgc2NhbGVYID0gcm91bmQocmVjdC53aWR0aCkgLyBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IDE7XG4gIHZhciBzY2FsZVkgPSByb3VuZChyZWN0LmhlaWdodCkgLyBlbGVtZW50Lm9mZnNldEhlaWdodCB8fCAxO1xuICByZXR1cm4gc2NhbGVYICE9PSAxIHx8IHNjYWxlWSAhPT0gMTtcbn0gLy8gUmV0dXJucyB0aGUgY29tcG9zaXRlIHJlY3Qgb2YgYW4gZWxlbWVudCByZWxhdGl2ZSB0byBpdHMgb2Zmc2V0UGFyZW50LlxuLy8gQ29tcG9zaXRlIG1lYW5zIGl0IHRha2VzIGludG8gYWNjb3VudCB0cmFuc2Zvcm1zIGFzIHdlbGwgYXMgbGF5b3V0LlxuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENvbXBvc2l0ZVJlY3QoZWxlbWVudE9yVmlydHVhbEVsZW1lbnQsIG9mZnNldFBhcmVudCwgaXNGaXhlZCkge1xuICBpZiAoaXNGaXhlZCA9PT0gdm9pZCAwKSB7XG4gICAgaXNGaXhlZCA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpO1xuICB2YXIgb2Zmc2V0UGFyZW50SXNTY2FsZWQgPSBpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCkgJiYgaXNFbGVtZW50U2NhbGVkKG9mZnNldFBhcmVudCk7XG4gIHZhciBkb2N1bWVudEVsZW1lbnQgPSBnZXREb2N1bWVudEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgdmFyIHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudE9yVmlydHVhbEVsZW1lbnQsIG9mZnNldFBhcmVudElzU2NhbGVkLCBpc0ZpeGVkKTtcbiAgdmFyIHNjcm9sbCA9IHtcbiAgICBzY3JvbGxMZWZ0OiAwLFxuICAgIHNjcm9sbFRvcDogMFxuICB9O1xuICB2YXIgb2Zmc2V0cyA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcblxuICBpZiAoaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgfHwgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmICFpc0ZpeGVkKSB7XG4gICAgaWYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgIT09ICdib2R5JyB8fCAvLyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzEwNzhcbiAgICBpc1Njcm9sbFBhcmVudChkb2N1bWVudEVsZW1lbnQpKSB7XG4gICAgICBzY3JvbGwgPSBnZXROb2RlU2Nyb2xsKG9mZnNldFBhcmVudCk7XG4gICAgfVxuXG4gICAgaWYgKGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgb2Zmc2V0cyA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChvZmZzZXRQYXJlbnQsIHRydWUpO1xuICAgICAgb2Zmc2V0cy54ICs9IG9mZnNldFBhcmVudC5jbGllbnRMZWZ0O1xuICAgICAgb2Zmc2V0cy55ICs9IG9mZnNldFBhcmVudC5jbGllbnRUb3A7XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIG9mZnNldHMueCA9IGdldFdpbmRvd1Njcm9sbEJhclgoZG9jdW1lbnRFbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IHJlY3QubGVmdCArIHNjcm9sbC5zY3JvbGxMZWZ0IC0gb2Zmc2V0cy54LFxuICAgIHk6IHJlY3QudG9wICsgc2Nyb2xsLnNjcm9sbFRvcCAtIG9mZnNldHMueSxcbiAgICB3aWR0aDogcmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0XG4gIH07XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ getComputedStyle; }\n/* harmony export */ });\n/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getWindow.js\");\n\nfunction getComputedStyle(element) {\n  return (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(element).getComputedStyle(element);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldENvbXB1dGVkU3R5bGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBdUM7QUFDeEI7QUFDZixTQUFTLHlEQUFTO0FBQ2xCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldENvbXB1dGVkU3R5bGUuanM/NDk0OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSB7XG4gIHJldHVybiBnZXRXaW5kb3coZWxlbWVudCkuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ getDocumentElement; }\n/* harmony export */ });\n/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instanceOf.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js\");\n\nfunction getDocumentElement(element) {\n  // $FlowFixMe[incompatible-return]: assume body is always available\n  return (((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isElement)(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]\n  element.document) || window.document).documentElement;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldERvY3VtZW50RWxlbWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUE0QztBQUM3QjtBQUNmO0FBQ0EsV0FBVyx5REFBUztBQUNwQjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldERvY3VtZW50RWxlbWVudC5qcz85ZDg0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzRWxlbWVudCB9IGZyb20gXCIuL2luc3RhbmNlT2YuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSB7XG4gIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl06IGFzc3VtZSBib2R5IGlzIGFsd2F5cyBhdmFpbGFibGVcbiAgcmV0dXJuICgoaXNFbGVtZW50KGVsZW1lbnQpID8gZWxlbWVudC5vd25lckRvY3VtZW50IDogLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gIGVsZW1lbnQuZG9jdW1lbnQpIHx8IHdpbmRvdy5kb2N1bWVudCkuZG9jdW1lbnRFbGVtZW50O1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ getDocumentRect; }\n/* harmony export */ });\n/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getDocumentElement.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js\");\n/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getComputedStyle.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js\");\n/* harmony import */ var _getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getWindowScrollBarX.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js\");\n/* harmony import */ var _getWindowScroll_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getWindowScroll.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js\");\n/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/math.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/math.js\");\n\n\n\n\n // Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable\n\nfunction getDocumentRect(element) {\n  var _element$ownerDocumen;\n\n  var html = (0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(element);\n  var winScroll = (0,_getWindowScroll_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(element);\n  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n  var width = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_2__.max)(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n  var height = (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_2__.max)(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n  var x = -winScroll.scrollLeft + (0,_getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(element);\n  var y = -winScroll.scrollTop;\n\n  if ((0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(body || html).direction === 'rtl') {\n    x += (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_2__.max)(html.clientWidth, body ? body.clientWidth : 0) - width;\n  }\n\n  return {\n    width: width,\n    height: height,\n    x: x,\n    y: y\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldERvY3VtZW50UmVjdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBeUQ7QUFDSjtBQUNNO0FBQ1I7QUFDWixDQUFDO0FBQ3hDOztBQUVlO0FBQ2Y7O0FBRUEsYUFBYSxrRUFBa0I7QUFDL0Isa0JBQWtCLCtEQUFlO0FBQ2pDO0FBQ0EsY0FBYyxtREFBRztBQUNqQixlQUFlLG1EQUFHO0FBQ2xCLGtDQUFrQyxtRUFBbUI7QUFDckQ7O0FBRUEsTUFBTSxnRUFBZ0I7QUFDdEIsU0FBUyxtREFBRztBQUNaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldERvY3VtZW50UmVjdC5qcz9jM2Q1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsQmFyWCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGxCYXJYLmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbC5qc1wiO1xuaW1wb3J0IHsgbWF4IH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjsgLy8gR2V0cyB0aGUgZW50aXJlIHNpemUgb2YgdGhlIHNjcm9sbGFibGUgZG9jdW1lbnQgYXJlYSwgZXZlbiBleHRlbmRpbmcgb3V0c2lkZVxuLy8gb2YgdGhlIGA8aHRtbD5gIGFuZCBgPGJvZHk+YCByZWN0IGJvdW5kcyBpZiBob3Jpem9udGFsbHkgc2Nyb2xsYWJsZVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXREb2N1bWVudFJlY3QoZWxlbWVudCkge1xuICB2YXIgX2VsZW1lbnQkb3duZXJEb2N1bWVuO1xuXG4gIHZhciBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICB2YXIgd2luU2Nyb2xsID0gZ2V0V2luZG93U2Nyb2xsKGVsZW1lbnQpO1xuICB2YXIgYm9keSA9IChfZWxlbWVudCRvd25lckRvY3VtZW4gPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZWxlbWVudCRvd25lckRvY3VtZW4uYm9keTtcbiAgdmFyIHdpZHRoID0gbWF4KGh0bWwuc2Nyb2xsV2lkdGgsIGh0bWwuY2xpZW50V2lkdGgsIGJvZHkgPyBib2R5LnNjcm9sbFdpZHRoIDogMCwgYm9keSA/IGJvZHkuY2xpZW50V2lkdGggOiAwKTtcbiAgdmFyIGhlaWdodCA9IG1heChodG1sLnNjcm9sbEhlaWdodCwgaHRtbC5jbGllbnRIZWlnaHQsIGJvZHkgPyBib2R5LnNjcm9sbEhlaWdodCA6IDAsIGJvZHkgPyBib2R5LmNsaWVudEhlaWdodCA6IDApO1xuICB2YXIgeCA9IC13aW5TY3JvbGwuc2Nyb2xsTGVmdCArIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCk7XG4gIHZhciB5ID0gLXdpblNjcm9sbC5zY3JvbGxUb3A7XG5cbiAgaWYgKGdldENvbXB1dGVkU3R5bGUoYm9keSB8fCBodG1sKS5kaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgeCArPSBtYXgoaHRtbC5jbGllbnRXaWR0aCwgYm9keSA/IGJvZHkuY2xpZW50V2lkdGggOiAwKSAtIHdpZHRoO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ getHTMLElementScroll; }\n/* harmony export */ });\nfunction getHTMLElementScroll(element) {\n  return {\n    scrollLeft: element.scrollLeft,\n    scrollTop: element.scrollTop\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldEhUTUxFbGVtZW50U2Nyb2xsLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0SFRNTEVsZW1lbnRTY3JvbGwuanM/YjNkNyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRIVE1MRWxlbWVudFNjcm9sbChlbGVtZW50KSB7XG4gIHJldHVybiB7XG4gICAgc2Nyb2xsTGVmdDogZWxlbWVudC5zY3JvbGxMZWZ0LFxuICAgIHNjcm9sbFRvcDogZWxlbWVudC5zY3JvbGxUb3BcbiAgfTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ getLayoutRect; }\n/* harmony export */ });\n/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBoundingClientRect.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js\");\n // Returns the layout rect of an element relative to its offsetParent. Layout\n// means it doesn't take into account transforms.\n\nfunction getLayoutRect(element) {\n  var clientRect = (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(element); // Use the clientRect sizes if it's not been transformed.\n  // Fixes https://github.com/popperjs/popper-core/issues/1223\n\n  var width = element.offsetWidth;\n  var height = element.offsetHeight;\n\n  if (Math.abs(clientRect.width - width) <= 1) {\n    width = clientRect.width;\n  }\n\n  if (Math.abs(clientRect.height - height) <= 1) {\n    height = clientRect.height;\n  }\n\n  return {\n    x: element.offsetLeft,\n    y: element.offsetTop,\n    width: width,\n    height: height\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldExheW91dFJlY3QuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBK0QsQ0FBQztBQUNoRTs7QUFFZTtBQUNmLG1CQUFtQixxRUFBcUIsV0FBVztBQUNuRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qcz83NjBmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4vZ2V0Qm91bmRpbmdDbGllbnRSZWN0LmpzXCI7IC8vIFJldHVybnMgdGhlIGxheW91dCByZWN0IG9mIGFuIGVsZW1lbnQgcmVsYXRpdmUgdG8gaXRzIG9mZnNldFBhcmVudC4gTGF5b3V0XG4vLyBtZWFucyBpdCBkb2Vzbid0IHRha2UgaW50byBhY2NvdW50IHRyYW5zZm9ybXMuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldExheW91dFJlY3QoZWxlbWVudCkge1xuICB2YXIgY2xpZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50KTsgLy8gVXNlIHRoZSBjbGllbnRSZWN0IHNpemVzIGlmIGl0J3Mgbm90IGJlZW4gdHJhbnNmb3JtZWQuXG4gIC8vIEZpeGVzIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvMTIyM1xuXG4gIHZhciB3aWR0aCA9IGVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gIHZhciBoZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodDtcblxuICBpZiAoTWF0aC5hYnMoY2xpZW50UmVjdC53aWR0aCAtIHdpZHRoKSA8PSAxKSB7XG4gICAgd2lkdGggPSBjbGllbnRSZWN0LndpZHRoO1xuICB9XG5cbiAgaWYgKE1hdGguYWJzKGNsaWVudFJlY3QuaGVpZ2h0IC0gaGVpZ2h0KSA8PSAxKSB7XG4gICAgaGVpZ2h0ID0gY2xpZW50UmVjdC5oZWlnaHQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IGVsZW1lbnQub2Zmc2V0TGVmdCxcbiAgICB5OiBlbGVtZW50Lm9mZnNldFRvcCxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHRcbiAgfTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js":
/*!******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ getNodeName; }\n/* harmony export */ });\nfunction getNodeName(element) {\n  return element ? (element.nodeName || '').toLowerCase() : null;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE5vZGVOYW1lLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBZTtBQUNmO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Tm9kZU5hbWUuanM/OTVkZCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXROb2RlTmFtZShlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50ID8gKGVsZW1lbnQubm9kZU5hbWUgfHwgJycpLnRvTG93ZXJDYXNlKCkgOiBudWxsO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ getNodeScroll; }\n/* harmony export */ });\n/* harmony import */ var _getWindowScroll_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getWindowScroll.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js\");\n/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getWindow.js\");\n/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./instanceOf.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js\");\n/* harmony import */ var _getHTMLElementScroll_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getHTMLElementScroll.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js\");\n\n\n\n\nfunction getNodeScroll(node) {\n  if (node === (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(node) || !(0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(node)) {\n    return (0,_getWindowScroll_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(node);\n  } else {\n    return (0,_getHTMLElementScroll_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(node);\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE5vZGVTY3JvbGwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBbUQ7QUFDWjtBQUNTO0FBQ2E7QUFDOUM7QUFDZixlQUFlLHlEQUFTLFdBQVcsNkRBQWE7QUFDaEQsV0FBVywrREFBZTtBQUMxQixJQUFJO0FBQ0osV0FBVyxvRUFBb0I7QUFDL0I7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXROb2RlU2Nyb2xsLmpzP2ZkYmIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGdldFdpbmRvd1Njcm9sbCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGwuanNcIjtcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IGdldEhUTUxFbGVtZW50U2Nyb2xsIGZyb20gXCIuL2dldEhUTUxFbGVtZW50U2Nyb2xsLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXROb2RlU2Nyb2xsKG5vZGUpIHtcbiAgaWYgKG5vZGUgPT09IGdldFdpbmRvdyhub2RlKSB8fCAhaXNIVE1MRWxlbWVudChub2RlKSkge1xuICAgIHJldHVybiBnZXRXaW5kb3dTY3JvbGwobm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdldEhUTUxFbGVtZW50U2Nyb2xsKG5vZGUpO1xuICB9XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ getOffsetParent; }\n/* harmony export */ });\n/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./getWindow.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getWindow.js\");\n/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./getNodeName.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js\");\n/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getComputedStyle.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js\");\n/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./instanceOf.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js\");\n/* harmony import */ var _isTableElement_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./isTableElement.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js\");\n/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getParentNode.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js\");\n/* harmony import */ var _utils_userAgent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/userAgent.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/userAgent.js\");\n\n\n\n\n\n\n\n\nfunction getTrueOffsetParent(element) {\n  if (!(0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) || // https://github.com/popperjs/popper-core/issues/837\n  (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(element).position === 'fixed') {\n    return null;\n  }\n\n  return element.offsetParent;\n} // `.offsetParent` reports `null` for fixed elements, while absolute elements\n// return the containing block\n\n\nfunction getContainingBlock(element) {\n  var isFirefox = /firefox/i.test((0,_utils_userAgent_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])());\n  var isIE = /Trident/i.test((0,_utils_userAgent_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])());\n\n  if (isIE && (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element)) {\n    // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport\n    var elementCss = (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(element);\n\n    if (elementCss.position === 'fixed') {\n      return null;\n    }\n  }\n\n  var currentNode = (0,_getParentNode_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(element);\n\n  if ((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isShadowRoot)(currentNode)) {\n    currentNode = currentNode.host;\n  }\n\n  while ((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(currentNode) && ['html', 'body'].indexOf((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(currentNode)) < 0) {\n    var css = (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(currentNode); // This is non-exhaustive but covers the most common CSS properties that\n    // create a containing block.\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n\n    if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {\n      return currentNode;\n    } else {\n      currentNode = currentNode.parentNode;\n    }\n  }\n\n  return null;\n} // Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\n\n\nfunction getOffsetParent(element) {\n  var window = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(element);\n  var offsetParent = getTrueOffsetParent(element);\n\n  while (offsetParent && (0,_isTableElement_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(offsetParent) && (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n\n  if (offsetParent && ((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(offsetParent) === 'html' || (0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(offsetParent) === 'body' && (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(offsetParent).position === 'static')) {\n    return window;\n  }\n\n  return offsetParent || getContainingBlock(element) || window;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldE9mZnNldFBhcmVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUF1QztBQUNJO0FBQ1U7QUFDUztBQUNiO0FBQ0Y7QUFDQzs7QUFFaEQ7QUFDQSxPQUFPLDZEQUFhO0FBQ3BCLEVBQUUsZ0VBQWdCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7OztBQUdBO0FBQ0Esa0NBQWtDLCtEQUFXO0FBQzdDLDZCQUE2QiwrREFBVzs7QUFFeEMsY0FBYyw2REFBYTtBQUMzQjtBQUNBLHFCQUFxQixnRUFBZ0I7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQiw2REFBYTs7QUFFakMsTUFBTSw0REFBWTtBQUNsQjtBQUNBOztBQUVBLFNBQVMsNkRBQWEsMENBQTBDLDJEQUFXO0FBQzNFLGNBQWMsZ0VBQWdCLGVBQWU7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjs7O0FBR2U7QUFDZixlQUFlLHlEQUFTO0FBQ3hCOztBQUVBLHlCQUF5Qiw4REFBYyxrQkFBa0IsZ0VBQWdCO0FBQ3pFO0FBQ0E7O0FBRUEsdUJBQXVCLDJEQUFXLDZCQUE2QiwyREFBVyw2QkFBNkIsZ0VBQWdCO0FBQ3ZIO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanM/MmEyYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuL2dldFdpbmRvdy5qc1wiO1xuaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi9nZXRDb21wdXRlZFN0eWxlLmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50LCBpc1NoYWRvd1Jvb3QgfSBmcm9tIFwiLi9pbnN0YW5jZU9mLmpzXCI7XG5pbXBvcnQgaXNUYWJsZUVsZW1lbnQgZnJvbSBcIi4vaXNUYWJsZUVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRQYXJlbnROb2RlIGZyb20gXCIuL2dldFBhcmVudE5vZGUuanNcIjtcbmltcG9ydCBnZXRVQVN0cmluZyBmcm9tIFwiLi4vdXRpbHMvdXNlckFnZW50LmpzXCI7XG5cbmZ1bmN0aW9uIGdldFRydWVPZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHwgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BvcHBlcmpzL3BvcHBlci1jb3JlL2lzc3Vlcy84MzdcbiAgZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQub2Zmc2V0UGFyZW50O1xufSAvLyBgLm9mZnNldFBhcmVudGAgcmVwb3J0cyBgbnVsbGAgZm9yIGZpeGVkIGVsZW1lbnRzLCB3aGlsZSBhYnNvbHV0ZSBlbGVtZW50c1xuLy8gcmV0dXJuIHRoZSBjb250YWluaW5nIGJsb2NrXG5cblxuZnVuY3Rpb24gZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHtcbiAgdmFyIGlzRmlyZWZveCA9IC9maXJlZm94L2kudGVzdChnZXRVQVN0cmluZygpKTtcbiAgdmFyIGlzSUUgPSAvVHJpZGVudC9pLnRlc3QoZ2V0VUFTdHJpbmcoKSk7XG5cbiAgaWYgKGlzSUUgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSkge1xuICAgIC8vIEluIElFIDksIDEwIGFuZCAxMSBmaXhlZCBlbGVtZW50cyBjb250YWluaW5nIGJsb2NrIGlzIGFsd2F5cyBlc3RhYmxpc2hlZCBieSB0aGUgdmlld3BvcnRcbiAgICB2YXIgZWxlbWVudENzcyA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG5cbiAgICBpZiAoZWxlbWVudENzcy5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgdmFyIGN1cnJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcblxuICBpZiAoaXNTaGFkb3dSb290KGN1cnJlbnROb2RlKSkge1xuICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUuaG9zdDtcbiAgfVxuXG4gIHdoaWxlIChpc0hUTUxFbGVtZW50KGN1cnJlbnROb2RlKSAmJiBbJ2h0bWwnLCAnYm9keSddLmluZGV4T2YoZ2V0Tm9kZU5hbWUoY3VycmVudE5vZGUpKSA8IDApIHtcbiAgICB2YXIgY3NzID0gZ2V0Q29tcHV0ZWRTdHlsZShjdXJyZW50Tm9kZSk7IC8vIFRoaXMgaXMgbm9uLWV4aGF1c3RpdmUgYnV0IGNvdmVycyB0aGUgbW9zdCBjb21tb24gQ1NTIHByb3BlcnRpZXMgdGhhdFxuICAgIC8vIGNyZWF0ZSBhIGNvbnRhaW5pbmcgYmxvY2suXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0NvbnRhaW5pbmdfYmxvY2sjaWRlbnRpZnlpbmdfdGhlX2NvbnRhaW5pbmdfYmxvY2tcblxuICAgIGlmIChjc3MudHJhbnNmb3JtICE9PSAnbm9uZScgfHwgY3NzLnBlcnNwZWN0aXZlICE9PSAnbm9uZScgfHwgY3NzLmNvbnRhaW4gPT09ICdwYWludCcgfHwgWyd0cmFuc2Zvcm0nLCAncGVyc3BlY3RpdmUnXS5pbmRleE9mKGNzcy53aWxsQ2hhbmdlKSAhPT0gLTEgfHwgaXNGaXJlZm94ICYmIGNzcy53aWxsQ2hhbmdlID09PSAnZmlsdGVyJyB8fCBpc0ZpcmVmb3ggJiYgY3NzLmZpbHRlciAmJiBjc3MuZmlsdGVyICE9PSAnbm9uZScpIHtcbiAgICAgIHJldHVybiBjdXJyZW50Tm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufSAvLyBHZXRzIHRoZSBjbG9zZXN0IGFuY2VzdG9yIHBvc2l0aW9uZWQgZWxlbWVudC4gSGFuZGxlcyBzb21lIGVkZ2UgY2FzZXMsXG4vLyBzdWNoIGFzIHRhYmxlIGFuY2VzdG9ycyBhbmQgY3Jvc3MgYnJvd3NlciBidWdzLlxuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldE9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIHZhciB3aW5kb3cgPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIHZhciBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQpO1xuXG4gIHdoaWxlIChvZmZzZXRQYXJlbnQgJiYgaXNUYWJsZUVsZW1lbnQob2Zmc2V0UGFyZW50KSAmJiBnZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCkucG9zaXRpb24gPT09ICdzdGF0aWMnKSB7XG4gICAgb2Zmc2V0UGFyZW50ID0gZ2V0VHJ1ZU9mZnNldFBhcmVudChvZmZzZXRQYXJlbnQpO1xuICB9XG5cbiAgaWYgKG9mZnNldFBhcmVudCAmJiAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSA9PT0gJ2h0bWwnIHx8IGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgPT09ICdib2R5JyAmJiBnZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCkucG9zaXRpb24gPT09ICdzdGF0aWMnKSkge1xuICAgIHJldHVybiB3aW5kb3c7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGdldENvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB8fCB3aW5kb3c7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ getParentNode; }\n/* harmony export */ });\n/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getNodeName.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js\");\n/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getDocumentElement.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js\");\n/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./instanceOf.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js\");\n\n\n\nfunction getParentNode(element) {\n  if ((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(element) === 'html') {\n    return element;\n  }\n\n  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle\n    // $FlowFixMe[incompatible-return]\n    // $FlowFixMe[prop-missing]\n    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    element.parentNode || ( // DOM Element detected\n    (0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isShadowRoot)(element) ? element.host : null) || // ShadowRoot detected\n    // $FlowFixMe[incompatible-call]: HTMLElement is a Node\n    (0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(element) // fallback\n\n  );\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFBhcmVudE5vZGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUEyQztBQUNjO0FBQ1Y7QUFDaEM7QUFDZixNQUFNLDJEQUFXO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksNERBQVk7QUFDaEI7QUFDQSxJQUFJLGtFQUFrQjs7QUFFdEI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRQYXJlbnROb2RlLmpzP2M3ZDIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuL2dldERvY3VtZW50RWxlbWVudC5qc1wiO1xuaW1wb3J0IHsgaXNTaGFkb3dSb290IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0UGFyZW50Tm9kZShlbGVtZW50KSB7XG4gIGlmIChnZXROb2RlTmFtZShlbGVtZW50KSA9PT0gJ2h0bWwnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICByZXR1cm4gKC8vIHRoaXMgaXMgYSBxdWlja2VyIChidXQgbGVzcyB0eXBlIHNhZmUpIHdheSB0byBzYXZlIHF1aXRlIHNvbWUgYnl0ZXMgZnJvbSB0aGUgYnVuZGxlXG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgIGVsZW1lbnQuYXNzaWduZWRTbG90IHx8IC8vIHN0ZXAgaW50byB0aGUgc2hhZG93IERPTSBvZiB0aGUgcGFyZW50IG9mIGEgc2xvdHRlZCBub2RlXG4gICAgZWxlbWVudC5wYXJlbnROb2RlIHx8ICggLy8gRE9NIEVsZW1lbnQgZGV0ZWN0ZWRcbiAgICBpc1NoYWRvd1Jvb3QoZWxlbWVudCkgPyBlbGVtZW50Lmhvc3QgOiBudWxsKSB8fCAvLyBTaGFkb3dSb290IGRldGVjdGVkXG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF06IEhUTUxFbGVtZW50IGlzIGEgTm9kZVxuICAgIGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSAvLyBmYWxsYmFja1xuXG4gICk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ getScrollParent; }\n/* harmony export */ });\n/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getParentNode.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js\");\n/* harmony import */ var _isScrollParent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isScrollParent.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js\");\n/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getNodeName.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js\");\n/* harmony import */ var _instanceOf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./instanceOf.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js\");\n\n\n\n\nfunction getScrollParent(node) {\n  if (['html', 'body', '#document'].indexOf((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(node)) >= 0) {\n    // $FlowFixMe[incompatible-return]: assume body is always available\n    return node.ownerDocument.body;\n  }\n\n  if ((0,_instanceOf_js__WEBPACK_IMPORTED_MODULE_1__.isHTMLElement)(node) && (0,_isScrollParent_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(node)) {\n    return node;\n  }\n\n  return getScrollParent((0,_getParentNode_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(node));\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFNjcm9sbFBhcmVudC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUErQztBQUNFO0FBQ047QUFDSztBQUNqQztBQUNmLDRDQUE0QywyREFBVztBQUN2RDtBQUNBO0FBQ0E7O0FBRUEsTUFBTSw2REFBYSxVQUFVLDhEQUFjO0FBQzNDO0FBQ0E7O0FBRUEseUJBQXlCLDZEQUFhO0FBQ3RDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFNjcm9sbFBhcmVudC5qcz83NjNkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBnZXRQYXJlbnROb2RlIGZyb20gXCIuL2dldFBhcmVudE5vZGUuanNcIjtcbmltcG9ydCBpc1Njcm9sbFBhcmVudCBmcm9tIFwiLi9pc1Njcm9sbFBhcmVudC5qc1wiO1xuaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5pbXBvcnQgeyBpc0hUTUxFbGVtZW50IH0gZnJvbSBcIi4vaW5zdGFuY2VPZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0U2Nyb2xsUGFyZW50KG5vZGUpIHtcbiAgaWYgKFsnaHRtbCcsICdib2R5JywgJyNkb2N1bWVudCddLmluZGV4T2YoZ2V0Tm9kZU5hbWUobm9kZSkpID49IDApIHtcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dOiBhc3N1bWUgYm9keSBpcyBhbHdheXMgYXZhaWxhYmxlXG4gICAgcmV0dXJuIG5vZGUub3duZXJEb2N1bWVudC5ib2R5O1xuICB9XG5cbiAgaWYgKGlzSFRNTEVsZW1lbnQobm9kZSkgJiYgaXNTY3JvbGxQYXJlbnQobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHJldHVybiBnZXRTY3JvbGxQYXJlbnQoZ2V0UGFyZW50Tm9kZShub2RlKSk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ getViewportRect; }\n/* harmony export */ });\n/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getWindow.js\");\n/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getDocumentElement.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js\");\n/* harmony import */ var _getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getWindowScrollBarX.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js\");\n/* harmony import */ var _isLayoutViewport_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isLayoutViewport.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js\");\n\n\n\n\nfunction getViewportRect(element, strategy) {\n  var win = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(element);\n  var html = (0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(element);\n  var visualViewport = win.visualViewport;\n  var width = html.clientWidth;\n  var height = html.clientHeight;\n  var x = 0;\n  var y = 0;\n\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    var layoutViewport = (0,_isLayoutViewport_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])();\n\n    if (layoutViewport || !layoutViewport && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n\n  return {\n    width: width,\n    height: height,\n    x: x + (0,_getWindowScrollBarX_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(element),\n    y: y\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFZpZXdwb3J0UmVjdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUF1QztBQUNrQjtBQUNFO0FBQ047QUFDdEM7QUFDZixZQUFZLHlEQUFTO0FBQ3JCLGFBQWEsa0VBQWtCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdFQUFnQjs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1FQUFtQjtBQUM5QjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0Vmlld3BvcnRSZWN0LmpzPzBlMDUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsQmFyWCBmcm9tIFwiLi9nZXRXaW5kb3dTY3JvbGxCYXJYLmpzXCI7XG5pbXBvcnQgaXNMYXlvdXRWaWV3cG9ydCBmcm9tIFwiLi9pc0xheW91dFZpZXdwb3J0LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRWaWV3cG9ydFJlY3QoZWxlbWVudCwgc3RyYXRlZ3kpIHtcbiAgdmFyIHdpbiA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgdmFyIGh0bWwgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XG4gIHZhciB2aXN1YWxWaWV3cG9ydCA9IHdpbi52aXN1YWxWaWV3cG9ydDtcbiAgdmFyIHdpZHRoID0gaHRtbC5jbGllbnRXaWR0aDtcbiAgdmFyIGhlaWdodCA9IGh0bWwuY2xpZW50SGVpZ2h0O1xuICB2YXIgeCA9IDA7XG4gIHZhciB5ID0gMDtcblxuICBpZiAodmlzdWFsVmlld3BvcnQpIHtcbiAgICB3aWR0aCA9IHZpc3VhbFZpZXdwb3J0LndpZHRoO1xuICAgIGhlaWdodCA9IHZpc3VhbFZpZXdwb3J0LmhlaWdodDtcbiAgICB2YXIgbGF5b3V0Vmlld3BvcnQgPSBpc0xheW91dFZpZXdwb3J0KCk7XG5cbiAgICBpZiAobGF5b3V0Vmlld3BvcnQgfHwgIWxheW91dFZpZXdwb3J0ICYmIHN0cmF0ZWd5ID09PSAnZml4ZWQnKSB7XG4gICAgICB4ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0TGVmdDtcbiAgICAgIHkgPSB2aXN1YWxWaWV3cG9ydC5vZmZzZXRUb3A7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgeDogeCArIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCksXG4gICAgeTogeVxuICB9O1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getWindow.js":
/*!****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getWindow.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ getWindow; }\n/* harmony export */ });\nfunction getWindow(node) {\n  if (node == null) {\n    return window;\n  }\n\n  if (node.toString() !== '[object Window]') {\n    var ownerDocument = node.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView || window : window;\n  }\n\n  return node;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFdpbmRvdy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3cuanM/ZGQ5NiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRXaW5kb3cobm9kZSkge1xuICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuXG4gIGlmIChub2RlLnRvU3RyaW5nKCkgIT09ICdbb2JqZWN0IFdpbmRvd10nKSB7XG4gICAgdmFyIG93bmVyRG9jdW1lbnQgPSBub2RlLm93bmVyRG9jdW1lbnQ7XG4gICAgcmV0dXJuIG93bmVyRG9jdW1lbnQgPyBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdyA6IHdpbmRvdztcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getWindow.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ getWindowScroll; }\n/* harmony export */ });\n/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getWindow.js\");\n\nfunction getWindowScroll(node) {\n  var win = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(node);\n  var scrollLeft = win.pageXOffset;\n  var scrollTop = win.pageYOffset;\n  return {\n    scrollLeft: scrollLeft,\n    scrollTop: scrollTop\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFdpbmRvd1Njcm9sbC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF1QztBQUN4QjtBQUNmLFlBQVkseURBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvZ2V0V2luZG93U2Nyb2xsLmpzPzc3NDEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGdldFdpbmRvdyBmcm9tIFwiLi9nZXRXaW5kb3cuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbChub2RlKSB7XG4gIHZhciB3aW4gPSBnZXRXaW5kb3cobm9kZSk7XG4gIHZhciBzY3JvbGxMZWZ0ID0gd2luLnBhZ2VYT2Zmc2V0O1xuICB2YXIgc2Nyb2xsVG9wID0gd2luLnBhZ2VZT2Zmc2V0O1xuICByZXR1cm4ge1xuICAgIHNjcm9sbExlZnQ6IHNjcm9sbExlZnQsXG4gICAgc2Nyb2xsVG9wOiBzY3JvbGxUb3BcbiAgfTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ getWindowScrollBarX; }\n/* harmony export */ });\n/* harmony import */ var _getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBoundingClientRect.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js\");\n/* harmony import */ var _getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getDocumentElement.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js\");\n/* harmony import */ var _getWindowScroll_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getWindowScroll.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js\");\n\n\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  // Popper 1 is broken in this case and never had a bug report so let's assume\n  // it's not an issue. I don't think anyone ever specifies width on <html>\n  // anyway.\n  // Browsers where the left scrollbar doesn't cause an issue report `0` for\n  // this (e.g. Edge 2019, IE11, Safari)\n  return (0,_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])((0,_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(element)).left + (0,_getWindowScroll_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(element).scrollLeft;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2dldFdpbmRvd1Njcm9sbEJhclguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUErRDtBQUNOO0FBQ047QUFDcEM7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMscUVBQXFCLENBQUMsa0VBQWtCLGtCQUFrQiwrREFBZTtBQUNsRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL2RvbS11dGlscy9nZXRXaW5kb3dTY3JvbGxCYXJYLmpzP2M5YmQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGdldEJvdW5kaW5nQ2xpZW50UmVjdCBmcm9tIFwiLi9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4vZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93U2Nyb2xsIGZyb20gXCIuL2dldFdpbmRvd1Njcm9sbC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50KSB7XG4gIC8vIElmIDxodG1sPiBoYXMgYSBDU1Mgd2lkdGggZ3JlYXRlciB0aGFuIHRoZSB2aWV3cG9ydCwgdGhlbiB0aGlzIHdpbGwgYmVcbiAgLy8gaW5jb3JyZWN0IGZvciBSVEwuXG4gIC8vIFBvcHBlciAxIGlzIGJyb2tlbiBpbiB0aGlzIGNhc2UgYW5kIG5ldmVyIGhhZCBhIGJ1ZyByZXBvcnQgc28gbGV0J3MgYXNzdW1lXG4gIC8vIGl0J3Mgbm90IGFuIGlzc3VlLiBJIGRvbid0IHRoaW5rIGFueW9uZSBldmVyIHNwZWNpZmllcyB3aWR0aCBvbiA8aHRtbD5cbiAgLy8gYW55d2F5LlxuICAvLyBCcm93c2VycyB3aGVyZSB0aGUgbGVmdCBzY3JvbGxiYXIgZG9lc24ndCBjYXVzZSBhbiBpc3N1ZSByZXBvcnQgYDBgIGZvclxuICAvLyB0aGlzIChlLmcuIEVkZ2UgMjAxOSwgSUUxMSwgU2FmYXJpKVxuICByZXR1cm4gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSkubGVmdCArIGdldFdpbmRvd1Njcm9sbChlbGVtZW50KS5zY3JvbGxMZWZ0O1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isElement: function() { return /* binding */ isElement; },\n/* harmony export */   isHTMLElement: function() { return /* binding */ isHTMLElement; },\n/* harmony export */   isShadowRoot: function() { return /* binding */ isShadowRoot; }\n/* harmony export */ });\n/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getWindow.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getWindow.js\");\n\n\nfunction isElement(node) {\n  var OwnElement = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(node).Element;\n  return node instanceof OwnElement || node instanceof Element;\n}\n\nfunction isHTMLElement(node) {\n  var OwnElement = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(node).HTMLElement;\n  return node instanceof OwnElement || node instanceof HTMLElement;\n}\n\nfunction isShadowRoot(node) {\n  // IE 11 has no ShadowRoot\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n\n  var OwnElement = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2luc3RhbmNlT2YuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUF1Qzs7QUFFdkM7QUFDQSxtQkFBbUIseURBQVM7QUFDNUI7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQix5REFBUztBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLHlEQUFTO0FBQzVCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qcz80ODI2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5cbmZ1bmN0aW9uIGlzRWxlbWVudChub2RlKSB7XG4gIHZhciBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLkVsZW1lbnQ7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gaXNIVE1MRWxlbWVudChub2RlKSB7XG4gIHZhciBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLkhUTUxFbGVtZW50O1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBpc1NoYWRvd1Jvb3Qobm9kZSkge1xuICAvLyBJRSAxMSBoYXMgbm8gU2hhZG93Um9vdFxuICBpZiAodHlwZW9mIFNoYWRvd1Jvb3QgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIE93bkVsZW1lbnQgPSBnZXRXaW5kb3cobm9kZSkuU2hhZG93Um9vdDtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBTaGFkb3dSb290O1xufVxuXG5leHBvcnQgeyBpc0VsZW1lbnQsIGlzSFRNTEVsZW1lbnQsIGlzU2hhZG93Um9vdCB9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ isLayoutViewport; }\n/* harmony export */ });\n/* harmony import */ var _utils_userAgent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/userAgent.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/userAgent.js\");\n\nfunction isLayoutViewport() {\n  return !/^((?!chrome|android).)*safari/i.test((0,_utils_userAgent_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])());\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2lzTGF5b3V0Vmlld3BvcnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBZ0Q7QUFDakM7QUFDZixnREFBZ0QsK0RBQVc7QUFDM0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9kb20tdXRpbHMvaXNMYXlvdXRWaWV3cG9ydC5qcz81ZTE2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBnZXRVQVN0cmluZyBmcm9tIFwiLi4vdXRpbHMvdXNlckFnZW50LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc0xheW91dFZpZXdwb3J0KCkge1xuICByZXR1cm4gIS9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QoZ2V0VUFTdHJpbmcoKSk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ isScrollParent; }\n/* harmony export */ });\n/* harmony import */ var _getComputedStyle_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getComputedStyle.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js\");\n\nfunction isScrollParent(element) {\n  // Firefox wants us to check `-x` and `-y` variations as well\n  var _getComputedStyle = (0,_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(element),\n      overflow = _getComputedStyle.overflow,\n      overflowX = _getComputedStyle.overflowX,\n      overflowY = _getComputedStyle.overflowY;\n\n  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2lzU2Nyb2xsUGFyZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXFEO0FBQ3RDO0FBQ2Y7QUFDQSwwQkFBMEIsZ0VBQWdCO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2lzU2Nyb2xsUGFyZW50LmpzPzQ1MDQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGdldENvbXB1dGVkU3R5bGUgZnJvbSBcIi4vZ2V0Q29tcHV0ZWRTdHlsZS5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNTY3JvbGxQYXJlbnQoZWxlbWVudCkge1xuICAvLyBGaXJlZm94IHdhbnRzIHVzIHRvIGNoZWNrIGAteGAgYW5kIGAteWAgdmFyaWF0aW9ucyBhcyB3ZWxsXG4gIHZhciBfZ2V0Q29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCksXG4gICAgICBvdmVyZmxvdyA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93LFxuICAgICAgb3ZlcmZsb3dYID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3dYLFxuICAgICAgb3ZlcmZsb3dZID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3dZO1xuXG4gIHJldHVybiAvYXV0b3xzY3JvbGx8b3ZlcmxheXxoaWRkZW4vLnRlc3Qob3ZlcmZsb3cgKyBvdmVyZmxvd1kgKyBvdmVyZmxvd1gpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ isTableElement; }\n/* harmony export */ });\n/* harmony import */ var _getNodeName_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getNodeName.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js\");\n\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].indexOf((0,_getNodeName_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(element)) >= 0;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2lzVGFibGVFbGVtZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTJDO0FBQzVCO0FBQ2YsdUNBQXVDLDJEQUFXO0FBQ2xEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2lzVGFibGVFbGVtZW50LmpzPzc1OTAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGdldE5vZGVOYW1lIGZyb20gXCIuL2dldE5vZGVOYW1lLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc1RhYmxlRWxlbWVudChlbGVtZW50KSB7XG4gIHJldHVybiBbJ3RhYmxlJywgJ3RkJywgJ3RoJ10uaW5kZXhPZihnZXROb2RlTmFtZShlbGVtZW50KSkgPj0gMDtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/isTableElement.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js":
/*!************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ listScrollParents; }\n/* harmony export */ });\n/* harmony import */ var _getScrollParent_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getScrollParent.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js\");\n/* harmony import */ var _getParentNode_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getParentNode.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getParentNode.js\");\n/* harmony import */ var _getWindow_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getWindow.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getWindow.js\");\n/* harmony import */ var _isScrollParent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isScrollParent.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js\");\n\n\n\n\n/*\ngiven a DOM element, return the list of all scroll parents, up the list of ancesors\nuntil we get to the top window object. This list is what we attach scroll listeners\nto, because if any of these parent elements scroll, we'll need to re-calculate the\nreference element's position.\n*/\n\nfunction listScrollParents(element, list) {\n  var _element$ownerDocumen;\n\n  if (list === void 0) {\n    list = [];\n  }\n\n  var scrollParent = (0,_getScrollParent_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(element);\n  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);\n  var win = (0,_getWindow_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(scrollParent);\n  var target = isBody ? [win].concat(win.visualViewport || [], (0,_isScrollParent_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(scrollParent) ? scrollParent : []) : scrollParent;\n  var updatedList = list.concat(target);\n  return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here\n  updatedList.concat(listScrollParents((0,_getParentNode_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(target)));\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2xpc3RTY3JvbGxQYXJlbnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQW1EO0FBQ0o7QUFDUjtBQUNVO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsK0RBQWU7QUFDcEM7QUFDQSxZQUFZLHlEQUFTO0FBQ3JCLCtEQUErRCw4REFBYztBQUM3RTtBQUNBO0FBQ0EsdUNBQXVDLDZEQUFhO0FBQ3BEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZG9tLXV0aWxzL2xpc3RTY3JvbGxQYXJlbnRzLmpzP2JjN2QiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGdldFNjcm9sbFBhcmVudCBmcm9tIFwiLi9nZXRTY3JvbGxQYXJlbnQuanNcIjtcbmltcG9ydCBnZXRQYXJlbnROb2RlIGZyb20gXCIuL2dldFBhcmVudE5vZGUuanNcIjtcbmltcG9ydCBnZXRXaW5kb3cgZnJvbSBcIi4vZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgaXNTY3JvbGxQYXJlbnQgZnJvbSBcIi4vaXNTY3JvbGxQYXJlbnQuanNcIjtcbi8qXG5naXZlbiBhIERPTSBlbGVtZW50LCByZXR1cm4gdGhlIGxpc3Qgb2YgYWxsIHNjcm9sbCBwYXJlbnRzLCB1cCB0aGUgbGlzdCBvZiBhbmNlc29yc1xudW50aWwgd2UgZ2V0IHRvIHRoZSB0b3Agd2luZG93IG9iamVjdC4gVGhpcyBsaXN0IGlzIHdoYXQgd2UgYXR0YWNoIHNjcm9sbCBsaXN0ZW5lcnNcbnRvLCBiZWNhdXNlIGlmIGFueSBvZiB0aGVzZSBwYXJlbnQgZWxlbWVudHMgc2Nyb2xsLCB3ZSdsbCBuZWVkIHRvIHJlLWNhbGN1bGF0ZSB0aGVcbnJlZmVyZW5jZSBlbGVtZW50J3MgcG9zaXRpb24uXG4qL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBsaXN0U2Nyb2xsUGFyZW50cyhlbGVtZW50LCBsaXN0KSB7XG4gIHZhciBfZWxlbWVudCRvd25lckRvY3VtZW47XG5cbiAgaWYgKGxpc3QgPT09IHZvaWQgMCkge1xuICAgIGxpc3QgPSBbXTtcbiAgfVxuXG4gIHZhciBzY3JvbGxQYXJlbnQgPSBnZXRTY3JvbGxQYXJlbnQoZWxlbWVudCk7XG4gIHZhciBpc0JvZHkgPSBzY3JvbGxQYXJlbnQgPT09ICgoX2VsZW1lbnQkb3duZXJEb2N1bWVuID0gZWxlbWVudC5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2VsZW1lbnQkb3duZXJEb2N1bWVuLmJvZHkpO1xuICB2YXIgd2luID0gZ2V0V2luZG93KHNjcm9sbFBhcmVudCk7XG4gIHZhciB0YXJnZXQgPSBpc0JvZHkgPyBbd2luXS5jb25jYXQod2luLnZpc3VhbFZpZXdwb3J0IHx8IFtdLCBpc1Njcm9sbFBhcmVudChzY3JvbGxQYXJlbnQpID8gc2Nyb2xsUGFyZW50IDogW10pIDogc2Nyb2xsUGFyZW50O1xuICB2YXIgdXBkYXRlZExpc3QgPSBsaXN0LmNvbmNhdCh0YXJnZXQpO1xuICByZXR1cm4gaXNCb2R5ID8gdXBkYXRlZExpc3QgOiAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogaXNCb2R5IHRlbGxzIHVzIHRhcmdldCB3aWxsIGJlIGFuIEhUTUxFbGVtZW50IGhlcmVcbiAgdXBkYXRlZExpc3QuY29uY2F0KGxpc3RTY3JvbGxQYXJlbnRzKGdldFBhcmVudE5vZGUodGFyZ2V0KSkpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/enums.js":
/*!**************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/enums.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   afterMain: function() { return /* binding */ afterMain; },\n/* harmony export */   afterRead: function() { return /* binding */ afterRead; },\n/* harmony export */   afterWrite: function() { return /* binding */ afterWrite; },\n/* harmony export */   auto: function() { return /* binding */ auto; },\n/* harmony export */   basePlacements: function() { return /* binding */ basePlacements; },\n/* harmony export */   beforeMain: function() { return /* binding */ beforeMain; },\n/* harmony export */   beforeRead: function() { return /* binding */ beforeRead; },\n/* harmony export */   beforeWrite: function() { return /* binding */ beforeWrite; },\n/* harmony export */   bottom: function() { return /* binding */ bottom; },\n/* harmony export */   clippingParents: function() { return /* binding */ clippingParents; },\n/* harmony export */   end: function() { return /* binding */ end; },\n/* harmony export */   left: function() { return /* binding */ left; },\n/* harmony export */   main: function() { return /* binding */ main; },\n/* harmony export */   modifierPhases: function() { return /* binding */ modifierPhases; },\n/* harmony export */   placements: function() { return /* binding */ placements; },\n/* harmony export */   popper: function() { return /* binding */ popper; },\n/* harmony export */   read: function() { return /* binding */ read; },\n/* harmony export */   reference: function() { return /* binding */ reference; },\n/* harmony export */   right: function() { return /* binding */ right; },\n/* harmony export */   start: function() { return /* binding */ start; },\n/* harmony export */   top: function() { return /* binding */ top; },\n/* harmony export */   variationPlacements: function() { return /* binding */ variationPlacements; },\n/* harmony export */   viewport: function() { return /* binding */ viewport; },\n/* harmony export */   write: function() { return /* binding */ write; }\n/* harmony export */ });\nvar top = 'top';\nvar bottom = 'bottom';\nvar right = 'right';\nvar left = 'left';\nvar auto = 'auto';\nvar basePlacements = [top, bottom, right, left];\nvar start = 'start';\nvar end = 'end';\nvar clippingParents = 'clippingParents';\nvar viewport = 'viewport';\nvar popper = 'popper';\nvar reference = 'reference';\nvar variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {\n  return acc.concat([placement + \"-\" + start, placement + \"-\" + end]);\n}, []);\nvar placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {\n  return acc.concat([placement, placement + \"-\" + start, placement + \"-\" + end]);\n}, []); // modifiers that need to read the DOM\n\nvar beforeRead = 'beforeRead';\nvar read = 'read';\nvar afterRead = 'afterRead'; // pure-logic modifiers\n\nvar beforeMain = 'beforeMain';\nvar main = 'main';\nvar afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)\n\nvar beforeWrite = 'beforeWrite';\nvar write = 'write';\nvar afterWrite = 'afterWrite';\nvar modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZW51bXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQU87QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDUDtBQUNBLENBQUM7QUFDTTtBQUNQO0FBQ0EsQ0FBQyxPQUFPOztBQUVEO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvZW51bXMuanM/MzA0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgdmFyIHRvcCA9ICd0b3AnO1xuZXhwb3J0IHZhciBib3R0b20gPSAnYm90dG9tJztcbmV4cG9ydCB2YXIgcmlnaHQgPSAncmlnaHQnO1xuZXhwb3J0IHZhciBsZWZ0ID0gJ2xlZnQnO1xuZXhwb3J0IHZhciBhdXRvID0gJ2F1dG8nO1xuZXhwb3J0IHZhciBiYXNlUGxhY2VtZW50cyA9IFt0b3AsIGJvdHRvbSwgcmlnaHQsIGxlZnRdO1xuZXhwb3J0IHZhciBzdGFydCA9ICdzdGFydCc7XG5leHBvcnQgdmFyIGVuZCA9ICdlbmQnO1xuZXhwb3J0IHZhciBjbGlwcGluZ1BhcmVudHMgPSAnY2xpcHBpbmdQYXJlbnRzJztcbmV4cG9ydCB2YXIgdmlld3BvcnQgPSAndmlld3BvcnQnO1xuZXhwb3J0IHZhciBwb3BwZXIgPSAncG9wcGVyJztcbmV4cG9ydCB2YXIgcmVmZXJlbmNlID0gJ3JlZmVyZW5jZSc7XG5leHBvcnQgdmFyIHZhcmlhdGlvblBsYWNlbWVudHMgPSAvKiNfX1BVUkVfXyovYmFzZVBsYWNlbWVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICByZXR1cm4gYWNjLmNvbmNhdChbcGxhY2VtZW50ICsgXCItXCIgKyBzdGFydCwgcGxhY2VtZW50ICsgXCItXCIgKyBlbmRdKTtcbn0sIFtdKTtcbmV4cG9ydCB2YXIgcGxhY2VtZW50cyA9IC8qI19fUFVSRV9fKi9bXS5jb25jYXQoYmFzZVBsYWNlbWVudHMsIFthdXRvXSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICByZXR1cm4gYWNjLmNvbmNhdChbcGxhY2VtZW50LCBwbGFjZW1lbnQgKyBcIi1cIiArIHN0YXJ0LCBwbGFjZW1lbnQgKyBcIi1cIiArIGVuZF0pO1xufSwgW10pOyAvLyBtb2RpZmllcnMgdGhhdCBuZWVkIHRvIHJlYWQgdGhlIERPTVxuXG5leHBvcnQgdmFyIGJlZm9yZVJlYWQgPSAnYmVmb3JlUmVhZCc7XG5leHBvcnQgdmFyIHJlYWQgPSAncmVhZCc7XG5leHBvcnQgdmFyIGFmdGVyUmVhZCA9ICdhZnRlclJlYWQnOyAvLyBwdXJlLWxvZ2ljIG1vZGlmaWVyc1xuXG5leHBvcnQgdmFyIGJlZm9yZU1haW4gPSAnYmVmb3JlTWFpbic7XG5leHBvcnQgdmFyIG1haW4gPSAnbWFpbic7XG5leHBvcnQgdmFyIGFmdGVyTWFpbiA9ICdhZnRlck1haW4nOyAvLyBtb2RpZmllciB3aXRoIHRoZSBwdXJwb3NlIHRvIHdyaXRlIHRvIHRoZSBET00gKG9yIHdyaXRlIGludG8gYSBmcmFtZXdvcmsgc3RhdGUpXG5cbmV4cG9ydCB2YXIgYmVmb3JlV3JpdGUgPSAnYmVmb3JlV3JpdGUnO1xuZXhwb3J0IHZhciB3cml0ZSA9ICd3cml0ZSc7XG5leHBvcnQgdmFyIGFmdGVyV3JpdGUgPSAnYWZ0ZXJXcml0ZSc7XG5leHBvcnQgdmFyIG1vZGlmaWVyUGhhc2VzID0gW2JlZm9yZVJlYWQsIHJlYWQsIGFmdGVyUmVhZCwgYmVmb3JlTWFpbiwgbWFpbiwgYWZ0ZXJNYWluLCBiZWZvcmVXcml0ZSwgd3JpdGUsIGFmdGVyV3JpdGVdOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/enums.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/modifiers/applyStyles.js":
/*!******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/applyStyles.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _dom_utils_getNodeName_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dom-utils/getNodeName.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getNodeName.js\");\n/* harmony import */ var _dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dom-utils/instanceOf.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js\");\n\n // This modifier takes the styles prepared by the `computeStyles` modifier\n// and applies them to the HTMLElements such as popper and arrow\n\nfunction applyStyles(_ref) {\n  var state = _ref.state;\n  Object.keys(state.elements).forEach(function (name) {\n    var style = state.styles[name] || {};\n    var attributes = state.attributes[name] || {};\n    var element = state.elements[name]; // arrow is optional + virtual elements\n\n    if (!(0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) || !(0,_dom_utils_getNodeName_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(element)) {\n      return;\n    } // Flow doesn't support to extend this property, but it's the most\n    // effective way to apply styles to an HTMLElement\n    // $FlowFixMe[cannot-write]\n\n\n    Object.assign(element.style, style);\n    Object.keys(attributes).forEach(function (name) {\n      var value = attributes[name];\n\n      if (value === false) {\n        element.removeAttribute(name);\n      } else {\n        element.setAttribute(name, value === true ? '' : value);\n      }\n    });\n  });\n}\n\nfunction effect(_ref2) {\n  var state = _ref2.state;\n  var initialStyles = {\n    popper: {\n      position: state.options.strategy,\n      left: '0',\n      top: '0',\n      margin: '0'\n    },\n    arrow: {\n      position: 'absolute'\n    },\n    reference: {}\n  };\n  Object.assign(state.elements.popper.style, initialStyles.popper);\n  state.styles = initialStyles;\n\n  if (state.elements.arrow) {\n    Object.assign(state.elements.arrow.style, initialStyles.arrow);\n  }\n\n  return function () {\n    Object.keys(state.elements).forEach(function (name) {\n      var element = state.elements[name];\n      var attributes = state.attributes[name] || {};\n      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them\n\n      var style = styleProperties.reduce(function (style, property) {\n        style[property] = '';\n        return style;\n      }, {}); // arrow is optional + virtual elements\n\n      if (!(0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_0__.isHTMLElement)(element) || !(0,_dom_utils_getNodeName_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(element)) {\n        return;\n      }\n\n      Object.assign(element.style, style);\n      Object.keys(attributes).forEach(function (attribute) {\n        element.removeAttribute(attribute);\n      });\n    });\n  };\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: 'applyStyles',\n  enabled: true,\n  phase: 'write',\n  fn: applyStyles,\n  effect: effect,\n  requires: ['computeStyles']\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2FwcGx5U3R5bGVzLmpzIiwibWFwcGluZ3MiOiI7OztBQUFzRDtBQUNLLENBQUM7QUFDNUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qzs7QUFFeEMsU0FBUyx1RUFBYSxjQUFjLHFFQUFXO0FBQy9DO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1SEFBdUg7O0FBRXZIO0FBQ0E7QUFDQTtBQUNBLE9BQU8sSUFBSSxHQUFHOztBQUVkLFdBQVcsdUVBQWEsY0FBYyxxRUFBVztBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQSxFQUFFOzs7QUFHRiwrREFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvYXBwbHlTdHlsZXMuanM/YjQ5MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZ2V0Tm9kZU5hbWUgZnJvbSBcIi4uL2RvbS11dGlscy9nZXROb2RlTmFtZS5qc1wiO1xuaW1wb3J0IHsgaXNIVE1MRWxlbWVudCB9IGZyb20gXCIuLi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qc1wiOyAvLyBUaGlzIG1vZGlmaWVyIHRha2VzIHRoZSBzdHlsZXMgcHJlcGFyZWQgYnkgdGhlIGBjb21wdXRlU3R5bGVzYCBtb2RpZmllclxuLy8gYW5kIGFwcGxpZXMgdGhlbSB0byB0aGUgSFRNTEVsZW1lbnRzIHN1Y2ggYXMgcG9wcGVyIGFuZCBhcnJvd1xuXG5mdW5jdGlvbiBhcHBseVN0eWxlcyhfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGU7XG4gIE9iamVjdC5rZXlzKHN0YXRlLmVsZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHN0eWxlID0gc3RhdGUuc3R5bGVzW25hbWVdIHx8IHt9O1xuICAgIHZhciBhdHRyaWJ1dGVzID0gc3RhdGUuYXR0cmlidXRlc1tuYW1lXSB8fCB7fTtcbiAgICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW25hbWVdOyAvLyBhcnJvdyBpcyBvcHRpb25hbCArIHZpcnR1YWwgZWxlbWVudHNcblxuICAgIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAhZ2V0Tm9kZU5hbWUoZWxlbWVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEZsb3cgZG9lc24ndCBzdXBwb3J0IHRvIGV4dGVuZCB0aGlzIHByb3BlcnR5LCBidXQgaXQncyB0aGUgbW9zdFxuICAgIC8vIGVmZmVjdGl2ZSB3YXkgdG8gYXBwbHkgc3R5bGVzIHRvIGFuIEhUTUxFbGVtZW50XG4gICAgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdXG5cblxuICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgc3R5bGUpO1xuICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZXNbbmFtZV07XG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSA9PT0gdHJ1ZSA/ICcnIDogdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZWZmZWN0KF9yZWYyKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlO1xuICB2YXIgaW5pdGlhbFN0eWxlcyA9IHtcbiAgICBwb3BwZXI6IHtcbiAgICAgIHBvc2l0aW9uOiBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5LFxuICAgICAgbGVmdDogJzAnLFxuICAgICAgdG9wOiAnMCcsXG4gICAgICBtYXJnaW46ICcwJ1xuICAgIH0sXG4gICAgYXJyb3c6IHtcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnXG4gICAgfSxcbiAgICByZWZlcmVuY2U6IHt9XG4gIH07XG4gIE9iamVjdC5hc3NpZ24oc3RhdGUuZWxlbWVudHMucG9wcGVyLnN0eWxlLCBpbml0aWFsU3R5bGVzLnBvcHBlcik7XG4gIHN0YXRlLnN0eWxlcyA9IGluaXRpYWxTdHlsZXM7XG5cbiAgaWYgKHN0YXRlLmVsZW1lbnRzLmFycm93KSB7XG4gICAgT2JqZWN0LmFzc2lnbihzdGF0ZS5lbGVtZW50cy5hcnJvdy5zdHlsZSwgaW5pdGlhbFN0eWxlcy5hcnJvdyk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIE9iamVjdC5rZXlzKHN0YXRlLmVsZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW25hbWVdO1xuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBzdGF0ZS5hdHRyaWJ1dGVzW25hbWVdIHx8IHt9O1xuICAgICAgdmFyIHN0eWxlUHJvcGVydGllcyA9IE9iamVjdC5rZXlzKHN0YXRlLnN0eWxlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IHN0YXRlLnN0eWxlc1tuYW1lXSA6IGluaXRpYWxTdHlsZXNbbmFtZV0pOyAvLyBTZXQgYWxsIHZhbHVlcyB0byBhbiBlbXB0eSBzdHJpbmcgdG8gdW5zZXQgdGhlbVxuXG4gICAgICB2YXIgc3R5bGUgPSBzdHlsZVByb3BlcnRpZXMucmVkdWNlKGZ1bmN0aW9uIChzdHlsZSwgcHJvcGVydHkpIHtcbiAgICAgICAgc3R5bGVbcHJvcGVydHldID0gJyc7XG4gICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgIH0sIHt9KTsgLy8gYXJyb3cgaXMgb3B0aW9uYWwgKyB2aXJ0dWFsIGVsZW1lbnRzXG5cbiAgICAgIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAhZ2V0Tm9kZU5hbWUoZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQuc3R5bGUsIHN0eWxlKTtcbiAgICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdhcHBseVN0eWxlcycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnd3JpdGUnLFxuICBmbjogYXBwbHlTdHlsZXMsXG4gIGVmZmVjdDogZWZmZWN0LFxuICByZXF1aXJlczogWydjb21wdXRlU3R5bGVzJ11cbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/modifiers/applyStyles.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/modifiers/arrow.js":
/*!************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/arrow.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/getBasePlacement.js\");\n/* harmony import */ var _dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../dom-utils/getLayoutRect.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js\");\n/* harmony import */ var _dom_utils_contains_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../dom-utils/contains.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/contains.js\");\n/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dom-utils/getOffsetParent.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js\");\n/* harmony import */ var _utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/getMainAxisFromPlacement.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js\");\n/* harmony import */ var _utils_within_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/within.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/within.js\");\n/* harmony import */ var _utils_mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/mergePaddingObject.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js\");\n/* harmony import */ var _utils_expandToHashMap_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/expandToHashMap.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/expandToHashMap.js\");\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../enums.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/enums.js\");\n\n\n\n\n\n\n\n\n // eslint-disable-next-line import/no-unused-modules\n\nvar toPaddingObject = function toPaddingObject(padding, state) {\n  padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {\n    placement: state.placement\n  })) : padding;\n  return (0,_utils_mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(typeof padding !== 'number' ? padding : (0,_utils_expandToHashMap_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(padding, _enums_js__WEBPACK_IMPORTED_MODULE_2__.basePlacements));\n};\n\nfunction arrow(_ref) {\n  var _state$modifiersData$;\n\n  var state = _ref.state,\n      name = _ref.name,\n      options = _ref.options;\n  var arrowElement = state.elements.arrow;\n  var popperOffsets = state.modifiersData.popperOffsets;\n  var basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(state.placement);\n  var axis = (0,_utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(basePlacement);\n  var isVertical = [_enums_js__WEBPACK_IMPORTED_MODULE_2__.left, _enums_js__WEBPACK_IMPORTED_MODULE_2__.right].indexOf(basePlacement) >= 0;\n  var len = isVertical ? 'height' : 'width';\n\n  if (!arrowElement || !popperOffsets) {\n    return;\n  }\n\n  var paddingObject = toPaddingObject(options.padding, state);\n  var arrowRect = (0,_dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(arrowElement);\n  var minProp = axis === 'y' ? _enums_js__WEBPACK_IMPORTED_MODULE_2__.top : _enums_js__WEBPACK_IMPORTED_MODULE_2__.left;\n  var maxProp = axis === 'y' ? _enums_js__WEBPACK_IMPORTED_MODULE_2__.bottom : _enums_js__WEBPACK_IMPORTED_MODULE_2__.right;\n  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];\n  var startDiff = popperOffsets[axis] - state.rects.reference[axis];\n  var arrowOffsetParent = (0,_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(arrowElement);\n  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is\n  // outside of the popper bounds\n\n  var min = paddingObject[minProp];\n  var max = clientSize - arrowRect[len] - paddingObject[maxProp];\n  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;\n  var offset = (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_7__.within)(min, center, max); // Prevents breaking syntax highlighting...\n\n  var axisProp = axis;\n  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);\n}\n\nfunction effect(_ref2) {\n  var state = _ref2.state,\n      options = _ref2.options;\n  var _options$element = options.element,\n      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;\n\n  if (arrowElement == null) {\n    return;\n  } // CSS selector\n\n\n  if (typeof arrowElement === 'string') {\n    arrowElement = state.elements.popper.querySelector(arrowElement);\n\n    if (!arrowElement) {\n      return;\n    }\n  }\n\n  if (!(0,_dom_utils_contains_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(state.elements.popper, arrowElement)) {\n    return;\n  }\n\n  state.elements.arrow = arrowElement;\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: 'arrow',\n  enabled: true,\n  phase: 'main',\n  fn: arrow,\n  effect: effect,\n  requires: ['popperOffsets'],\n  requiresIfExists: ['preventOverflow']\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2Fycm93LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBNEQ7QUFDRjtBQUNWO0FBQ2M7QUFDYztBQUNoQztBQUNvQjtBQUNOO0FBQ2EsQ0FBQzs7QUFFeEU7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQSxHQUFHO0FBQ0gsU0FBUyx3RUFBa0IseUNBQXlDLHFFQUFlLFVBQVUscURBQWM7QUFDM0c7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNFQUFnQjtBQUN0QyxhQUFhLDhFQUF3QjtBQUNyQyxvQkFBb0IsMkNBQUksRUFBRSw0Q0FBSztBQUMvQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsdUVBQWE7QUFDL0IsK0JBQStCLDBDQUFHLEdBQUcsMkNBQUk7QUFDekMsK0JBQStCLDZDQUFNLEdBQUcsNENBQUs7QUFDN0M7QUFDQTtBQUNBLDBCQUEwQix5RUFBZTtBQUN6QztBQUNBLHVEQUF1RDtBQUN2RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdEQUFNLG9CQUFvQjs7QUFFekM7QUFDQSx5REFBeUQ7QUFDekQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPLGtFQUFRO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGLCtEQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2Fycm93LmpzP2FiMWEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRMYXlvdXRSZWN0IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0TGF5b3V0UmVjdC5qc1wiO1xuaW1wb3J0IGNvbnRhaW5zIGZyb20gXCIuLi9kb20tdXRpbHMvY29udGFpbnMuanNcIjtcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IHsgd2l0aGluIH0gZnJvbSBcIi4uL3V0aWxzL3dpdGhpbi5qc1wiO1xuaW1wb3J0IG1lcmdlUGFkZGluZ09iamVjdCBmcm9tIFwiLi4vdXRpbHMvbWVyZ2VQYWRkaW5nT2JqZWN0LmpzXCI7XG5pbXBvcnQgZXhwYW5kVG9IYXNoTWFwIGZyb20gXCIuLi91dGlscy9leHBhbmRUb0hhc2hNYXAuanNcIjtcbmltcG9ydCB7IGxlZnQsIHJpZ2h0LCBiYXNlUGxhY2VtZW50cywgdG9wLCBib3R0b20gfSBmcm9tIFwiLi4vZW51bXMuanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG52YXIgdG9QYWRkaW5nT2JqZWN0ID0gZnVuY3Rpb24gdG9QYWRkaW5nT2JqZWN0KHBhZGRpbmcsIHN0YXRlKSB7XG4gIHBhZGRpbmcgPSB0eXBlb2YgcGFkZGluZyA9PT0gJ2Z1bmN0aW9uJyA/IHBhZGRpbmcoT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUucmVjdHMsIHtcbiAgICBwbGFjZW1lbnQ6IHN0YXRlLnBsYWNlbWVudFxuICB9KSkgOiBwYWRkaW5nO1xuICByZXR1cm4gbWVyZ2VQYWRkaW5nT2JqZWN0KHR5cGVvZiBwYWRkaW5nICE9PSAnbnVtYmVyJyA/IHBhZGRpbmcgOiBleHBhbmRUb0hhc2hNYXAocGFkZGluZywgYmFzZVBsYWNlbWVudHMpKTtcbn07XG5cbmZ1bmN0aW9uIGFycm93KF9yZWYpIHtcbiAgdmFyIF9zdGF0ZSRtb2RpZmllcnNEYXRhJDtcblxuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnM7XG4gIHZhciBhcnJvd0VsZW1lbnQgPSBzdGF0ZS5lbGVtZW50cy5hcnJvdztcbiAgdmFyIHBvcHBlck9mZnNldHMgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHM7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpO1xuICB2YXIgYXhpcyA9IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KTtcbiAgdmFyIGlzVmVydGljYWwgPSBbbGVmdCwgcmlnaHRdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMDtcbiAgdmFyIGxlbiA9IGlzVmVydGljYWwgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgaWYgKCFhcnJvd0VsZW1lbnQgfHwgIXBvcHBlck9mZnNldHMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcGFkZGluZ09iamVjdCA9IHRvUGFkZGluZ09iamVjdChvcHRpb25zLnBhZGRpbmcsIHN0YXRlKTtcbiAgdmFyIGFycm93UmVjdCA9IGdldExheW91dFJlY3QoYXJyb3dFbGVtZW50KTtcbiAgdmFyIG1pblByb3AgPSBheGlzID09PSAneScgPyB0b3AgOiBsZWZ0O1xuICB2YXIgbWF4UHJvcCA9IGF4aXMgPT09ICd5JyA/IGJvdHRvbSA6IHJpZ2h0O1xuICB2YXIgZW5kRGlmZiA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtsZW5dICsgc3RhdGUucmVjdHMucmVmZXJlbmNlW2F4aXNdIC0gcG9wcGVyT2Zmc2V0c1theGlzXSAtIHN0YXRlLnJlY3RzLnBvcHBlcltsZW5dO1xuICB2YXIgc3RhcnREaWZmID0gcG9wcGVyT2Zmc2V0c1theGlzXSAtIHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtheGlzXTtcbiAgdmFyIGFycm93T2Zmc2V0UGFyZW50ID0gZ2V0T2Zmc2V0UGFyZW50KGFycm93RWxlbWVudCk7XG4gIHZhciBjbGllbnRTaXplID0gYXJyb3dPZmZzZXRQYXJlbnQgPyBheGlzID09PSAneScgPyBhcnJvd09mZnNldFBhcmVudC5jbGllbnRIZWlnaHQgfHwgMCA6IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudFdpZHRoIHx8IDAgOiAwO1xuICB2YXIgY2VudGVyVG9SZWZlcmVuY2UgPSBlbmREaWZmIC8gMiAtIHN0YXJ0RGlmZiAvIDI7IC8vIE1ha2Ugc3VyZSB0aGUgYXJyb3cgZG9lc24ndCBvdmVyZmxvdyB0aGUgcG9wcGVyIGlmIHRoZSBjZW50ZXIgcG9pbnQgaXNcbiAgLy8gb3V0c2lkZSBvZiB0aGUgcG9wcGVyIGJvdW5kc1xuXG4gIHZhciBtaW4gPSBwYWRkaW5nT2JqZWN0W21pblByb3BdO1xuICB2YXIgbWF4ID0gY2xpZW50U2l6ZSAtIGFycm93UmVjdFtsZW5dIC0gcGFkZGluZ09iamVjdFttYXhQcm9wXTtcbiAgdmFyIGNlbnRlciA9IGNsaWVudFNpemUgLyAyIC0gYXJyb3dSZWN0W2xlbl0gLyAyICsgY2VudGVyVG9SZWZlcmVuY2U7XG4gIHZhciBvZmZzZXQgPSB3aXRoaW4obWluLCBjZW50ZXIsIG1heCk7IC8vIFByZXZlbnRzIGJyZWFraW5nIHN5bnRheCBoaWdobGlnaHRpbmcuLi5cblxuICB2YXIgYXhpc1Byb3AgPSBheGlzO1xuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gKF9zdGF0ZSRtb2RpZmllcnNEYXRhJCA9IHt9LCBfc3RhdGUkbW9kaWZpZXJzRGF0YSRbYXhpc1Byb3BdID0gb2Zmc2V0LCBfc3RhdGUkbW9kaWZpZXJzRGF0YSQuY2VudGVyT2Zmc2V0ID0gb2Zmc2V0IC0gY2VudGVyLCBfc3RhdGUkbW9kaWZpZXJzRGF0YSQpO1xufVxuXG5mdW5jdGlvbiBlZmZlY3QoX3JlZjIpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZjIub3B0aW9ucztcbiAgdmFyIF9vcHRpb25zJGVsZW1lbnQgPSBvcHRpb25zLmVsZW1lbnQsXG4gICAgICBhcnJvd0VsZW1lbnQgPSBfb3B0aW9ucyRlbGVtZW50ID09PSB2b2lkIDAgPyAnW2RhdGEtcG9wcGVyLWFycm93XScgOiBfb3B0aW9ucyRlbGVtZW50O1xuXG4gIGlmIChhcnJvd0VsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfSAvLyBDU1Mgc2VsZWN0b3JcblxuXG4gIGlmICh0eXBlb2YgYXJyb3dFbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLnBvcHBlci5xdWVyeVNlbGVjdG9yKGFycm93RWxlbWVudCk7XG5cbiAgICBpZiAoIWFycm93RWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY29udGFpbnMoc3RhdGUuZWxlbWVudHMucG9wcGVyLCBhcnJvd0VsZW1lbnQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3RhdGUuZWxlbWVudHMuYXJyb3cgPSBhcnJvd0VsZW1lbnQ7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdhcnJvdycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIGZuOiBhcnJvdyxcbiAgZWZmZWN0OiBlZmZlY3QsXG4gIHJlcXVpcmVzOiBbJ3BvcHBlck9mZnNldHMnXSxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydwcmV2ZW50T3ZlcmZsb3cnXVxufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/modifiers/arrow.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/modifiers/computeStyles.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/computeStyles.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   mapToStyles: function() { return /* binding */ mapToStyles; }\n/* harmony export */ });\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/enums.js\");\n/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../dom-utils/getOffsetParent.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js\");\n/* harmony import */ var _dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom-utils/getWindow.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getWindow.js\");\n/* harmony import */ var _dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../dom-utils/getDocumentElement.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js\");\n/* harmony import */ var _dom_utils_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../dom-utils/getComputedStyle.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js\");\n/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/getBasePlacement.js\");\n/* harmony import */ var _utils_getVariation_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/getVariation.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/getVariation.js\");\n/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/math.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/math.js\");\n\n\n\n\n\n\n\n // eslint-disable-next-line import/no-unused-modules\n\nvar unsetSides = {\n  top: 'auto',\n  right: 'auto',\n  bottom: 'auto',\n  left: 'auto'\n}; // Round the offsets to the nearest suitable subpixel based on the DPR.\n// Zooming can change the DPR, but it seems to report a value that will\n// cleanly divide the values into the appropriate subpixels.\n\nfunction roundOffsetsByDPR(_ref, win) {\n  var x = _ref.x,\n      y = _ref.y;\n  var dpr = win.devicePixelRatio || 1;\n  return {\n    x: (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_0__.round)(x * dpr) / dpr || 0,\n    y: (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_0__.round)(y * dpr) / dpr || 0\n  };\n}\n\nfunction mapToStyles(_ref2) {\n  var _Object$assign2;\n\n  var popper = _ref2.popper,\n      popperRect = _ref2.popperRect,\n      placement = _ref2.placement,\n      variation = _ref2.variation,\n      offsets = _ref2.offsets,\n      position = _ref2.position,\n      gpuAcceleration = _ref2.gpuAcceleration,\n      adaptive = _ref2.adaptive,\n      roundOffsets = _ref2.roundOffsets,\n      isFixed = _ref2.isFixed;\n  var _offsets$x = offsets.x,\n      x = _offsets$x === void 0 ? 0 : _offsets$x,\n      _offsets$y = offsets.y,\n      y = _offsets$y === void 0 ? 0 : _offsets$y;\n\n  var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({\n    x: x,\n    y: y\n  }) : {\n    x: x,\n    y: y\n  };\n\n  x = _ref3.x;\n  y = _ref3.y;\n  var hasX = offsets.hasOwnProperty('x');\n  var hasY = offsets.hasOwnProperty('y');\n  var sideX = _enums_js__WEBPACK_IMPORTED_MODULE_1__.left;\n  var sideY = _enums_js__WEBPACK_IMPORTED_MODULE_1__.top;\n  var win = window;\n\n  if (adaptive) {\n    var offsetParent = (0,_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(popper);\n    var heightProp = 'clientHeight';\n    var widthProp = 'clientWidth';\n\n    if (offsetParent === (0,_dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(popper)) {\n      offsetParent = (0,_dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(popper);\n\n      if ((0,_dom_utils_getComputedStyle_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(offsetParent).position !== 'static' && position === 'absolute') {\n        heightProp = 'scrollHeight';\n        widthProp = 'scrollWidth';\n      }\n    } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it\n\n\n    offsetParent = offsetParent;\n\n    if (placement === _enums_js__WEBPACK_IMPORTED_MODULE_1__.top || (placement === _enums_js__WEBPACK_IMPORTED_MODULE_1__.left || placement === _enums_js__WEBPACK_IMPORTED_MODULE_1__.right) && variation === _enums_js__WEBPACK_IMPORTED_MODULE_1__.end) {\n      sideY = _enums_js__WEBPACK_IMPORTED_MODULE_1__.bottom;\n      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : // $FlowFixMe[prop-missing]\n      offsetParent[heightProp];\n      y -= offsetY - popperRect.height;\n      y *= gpuAcceleration ? 1 : -1;\n    }\n\n    if (placement === _enums_js__WEBPACK_IMPORTED_MODULE_1__.left || (placement === _enums_js__WEBPACK_IMPORTED_MODULE_1__.top || placement === _enums_js__WEBPACK_IMPORTED_MODULE_1__.bottom) && variation === _enums_js__WEBPACK_IMPORTED_MODULE_1__.end) {\n      sideX = _enums_js__WEBPACK_IMPORTED_MODULE_1__.right;\n      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : // $FlowFixMe[prop-missing]\n      offsetParent[widthProp];\n      x -= offsetX - popperRect.width;\n      x *= gpuAcceleration ? 1 : -1;\n    }\n  }\n\n  var commonStyles = Object.assign({\n    position: position\n  }, adaptive && unsetSides);\n\n  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({\n    x: x,\n    y: y\n  }, (0,_dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(popper)) : {\n    x: x,\n    y: y\n  };\n\n  x = _ref4.x;\n  y = _ref4.y;\n\n  if (gpuAcceleration) {\n    var _Object$assign;\n\n    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? \"translate(\" + x + \"px, \" + y + \"px)\" : \"translate3d(\" + x + \"px, \" + y + \"px, 0)\", _Object$assign));\n  }\n\n  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + \"px\" : '', _Object$assign2[sideX] = hasX ? x + \"px\" : '', _Object$assign2.transform = '', _Object$assign2));\n}\n\nfunction computeStyles(_ref5) {\n  var state = _ref5.state,\n      options = _ref5.options;\n  var _options$gpuAccelerat = options.gpuAcceleration,\n      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,\n      _options$adaptive = options.adaptive,\n      adaptive = _options$adaptive === void 0 ? true : _options$adaptive,\n      _options$roundOffsets = options.roundOffsets,\n      roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;\n  var commonStyles = {\n    placement: (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(state.placement),\n    variation: (0,_utils_getVariation_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(state.placement),\n    popper: state.elements.popper,\n    popperRect: state.rects.popper,\n    gpuAcceleration: gpuAcceleration,\n    isFixed: state.options.strategy === 'fixed'\n  };\n\n  if (state.modifiersData.popperOffsets != null) {\n    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {\n      offsets: state.modifiersData.popperOffsets,\n      position: state.options.strategy,\n      adaptive: adaptive,\n      roundOffsets: roundOffsets\n    })));\n  }\n\n  if (state.modifiersData.arrow != null) {\n    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {\n      offsets: state.modifiersData.arrow,\n      position: 'absolute',\n      adaptive: false,\n      roundOffsets: roundOffsets\n    })));\n  }\n\n  state.attributes.popper = Object.assign({}, state.attributes.popper, {\n    'data-popper-placement': state.placement\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: 'computeStyles',\n  enabled: true,\n  phase: 'beforeWrite',\n  fn: computeStyles,\n  data: {}\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2NvbXB1dGVTdHlsZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQTREO0FBQ0U7QUFDWjtBQUNrQjtBQUNKO0FBQ0o7QUFDUjtBQUNYLENBQUM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxxREFBSztBQUNaLE9BQU8scURBQUs7QUFDWjtBQUNBOztBQUVPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywyQ0FBSTtBQUNsQixjQUFjLDBDQUFHO0FBQ2pCOztBQUVBO0FBQ0EsdUJBQXVCLHlFQUFlO0FBQ3RDO0FBQ0E7O0FBRUEseUJBQXlCLG1FQUFTO0FBQ2xDLHFCQUFxQiw0RUFBa0I7O0FBRXZDLFVBQVUsMEVBQWdCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOOztBQUVBLHNCQUFzQiwwQ0FBRyxtQkFBbUIsMkNBQUksa0JBQWtCLDRDQUFLLG1CQUFtQiwwQ0FBRztBQUM3RixjQUFjLDZDQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLDJDQUFJLG1CQUFtQiwwQ0FBRyxrQkFBa0IsNkNBQU0sbUJBQW1CLDBDQUFHO0FBQzlGLGNBQWMsNENBQUs7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRSxtRUFBUztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMkJBQTJCLG9DQUFvQztBQUMvRDs7QUFFQSx5QkFBeUIscUNBQXFDO0FBQzlEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzRUFBZ0I7QUFDL0IsZUFBZSxrRUFBWTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDLG1EQUFtRDtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLHlDQUF5QyxrREFBa0Q7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsNENBQTRDO0FBQzVDO0FBQ0EsR0FBRztBQUNILEVBQUU7OztBQUdGLCtEQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvY29tcHV0ZVN0eWxlcy5qcz8xYWRiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHRvcCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgZW5kIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZ2V0T2Zmc2V0UGFyZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0T2Zmc2V0UGFyZW50LmpzXCI7XG5pbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0V2luZG93LmpzXCI7XG5pbXBvcnQgZ2V0RG9jdW1lbnRFbGVtZW50IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0RG9jdW1lbnRFbGVtZW50LmpzXCI7XG5pbXBvcnQgZ2V0Q29tcHV0ZWRTdHlsZSBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldENvbXB1dGVkU3R5bGUuanNcIjtcbmltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgZ2V0VmFyaWF0aW9uIGZyb20gXCIuLi91dGlscy9nZXRWYXJpYXRpb24uanNcIjtcbmltcG9ydCB7IHJvdW5kIH0gZnJvbSBcIi4uL3V0aWxzL21hdGguanNcIjsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG52YXIgdW5zZXRTaWRlcyA9IHtcbiAgdG9wOiAnYXV0bycsXG4gIHJpZ2h0OiAnYXV0bycsXG4gIGJvdHRvbTogJ2F1dG8nLFxuICBsZWZ0OiAnYXV0bydcbn07IC8vIFJvdW5kIHRoZSBvZmZzZXRzIHRvIHRoZSBuZWFyZXN0IHN1aXRhYmxlIHN1YnBpeGVsIGJhc2VkIG9uIHRoZSBEUFIuXG4vLyBab29taW5nIGNhbiBjaGFuZ2UgdGhlIERQUiwgYnV0IGl0IHNlZW1zIHRvIHJlcG9ydCBhIHZhbHVlIHRoYXQgd2lsbFxuLy8gY2xlYW5seSBkaXZpZGUgdGhlIHZhbHVlcyBpbnRvIHRoZSBhcHByb3ByaWF0ZSBzdWJwaXhlbHMuXG5cbmZ1bmN0aW9uIHJvdW5kT2Zmc2V0c0J5RFBSKF9yZWYsIHdpbikge1xuICB2YXIgeCA9IF9yZWYueCxcbiAgICAgIHkgPSBfcmVmLnk7XG4gIHZhciBkcHIgPSB3aW4uZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICByZXR1cm4ge1xuICAgIHg6IHJvdW5kKHggKiBkcHIpIC8gZHByIHx8IDAsXG4gICAgeTogcm91bmQoeSAqIGRwcikgLyBkcHIgfHwgMFxuICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWFwVG9TdHlsZXMoX3JlZjIpIHtcbiAgdmFyIF9PYmplY3QkYXNzaWduMjtcblxuICB2YXIgcG9wcGVyID0gX3JlZjIucG9wcGVyLFxuICAgICAgcG9wcGVyUmVjdCA9IF9yZWYyLnBvcHBlclJlY3QsXG4gICAgICBwbGFjZW1lbnQgPSBfcmVmMi5wbGFjZW1lbnQsXG4gICAgICB2YXJpYXRpb24gPSBfcmVmMi52YXJpYXRpb24sXG4gICAgICBvZmZzZXRzID0gX3JlZjIub2Zmc2V0cyxcbiAgICAgIHBvc2l0aW9uID0gX3JlZjIucG9zaXRpb24sXG4gICAgICBncHVBY2NlbGVyYXRpb24gPSBfcmVmMi5ncHVBY2NlbGVyYXRpb24sXG4gICAgICBhZGFwdGl2ZSA9IF9yZWYyLmFkYXB0aXZlLFxuICAgICAgcm91bmRPZmZzZXRzID0gX3JlZjIucm91bmRPZmZzZXRzLFxuICAgICAgaXNGaXhlZCA9IF9yZWYyLmlzRml4ZWQ7XG4gIHZhciBfb2Zmc2V0cyR4ID0gb2Zmc2V0cy54LFxuICAgICAgeCA9IF9vZmZzZXRzJHggPT09IHZvaWQgMCA/IDAgOiBfb2Zmc2V0cyR4LFxuICAgICAgX29mZnNldHMkeSA9IG9mZnNldHMueSxcbiAgICAgIHkgPSBfb2Zmc2V0cyR5ID09PSB2b2lkIDAgPyAwIDogX29mZnNldHMkeTtcblxuICB2YXIgX3JlZjMgPSB0eXBlb2Ygcm91bmRPZmZzZXRzID09PSAnZnVuY3Rpb24nID8gcm91bmRPZmZzZXRzKHtcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfSkgOiB7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG5cbiAgeCA9IF9yZWYzLng7XG4gIHkgPSBfcmVmMy55O1xuICB2YXIgaGFzWCA9IG9mZnNldHMuaGFzT3duUHJvcGVydHkoJ3gnKTtcbiAgdmFyIGhhc1kgPSBvZmZzZXRzLmhhc093blByb3BlcnR5KCd5Jyk7XG4gIHZhciBzaWRlWCA9IGxlZnQ7XG4gIHZhciBzaWRlWSA9IHRvcDtcbiAgdmFyIHdpbiA9IHdpbmRvdztcblxuICBpZiAoYWRhcHRpdmUpIHtcbiAgICB2YXIgb2Zmc2V0UGFyZW50ID0gZ2V0T2Zmc2V0UGFyZW50KHBvcHBlcik7XG4gICAgdmFyIGhlaWdodFByb3AgPSAnY2xpZW50SGVpZ2h0JztcbiAgICB2YXIgd2lkdGhQcm9wID0gJ2NsaWVudFdpZHRoJztcblxuICAgIGlmIChvZmZzZXRQYXJlbnQgPT09IGdldFdpbmRvdyhwb3BwZXIpKSB7XG4gICAgICBvZmZzZXRQYXJlbnQgPSBnZXREb2N1bWVudEVsZW1lbnQocG9wcGVyKTtcblxuICAgICAgaWYgKGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiAhPT0gJ3N0YXRpYycgJiYgcG9zaXRpb24gPT09ICdhYnNvbHV0ZScpIHtcbiAgICAgICAgaGVpZ2h0UHJvcCA9ICdzY3JvbGxIZWlnaHQnO1xuICAgICAgICB3aWR0aFByb3AgPSAnc2Nyb2xsV2lkdGgnO1xuICAgICAgfVxuICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FzdF06IGZvcmNlIHR5cGUgcmVmaW5lbWVudCwgd2UgY29tcGFyZSBvZmZzZXRQYXJlbnQgd2l0aCB3aW5kb3cgYWJvdmUsIGJ1dCBGbG93IGRvZXNuJ3QgZGV0ZWN0IGl0XG5cblxuICAgIG9mZnNldFBhcmVudCA9IG9mZnNldFBhcmVudDtcblxuICAgIGlmIChwbGFjZW1lbnQgPT09IHRvcCB8fCAocGxhY2VtZW50ID09PSBsZWZ0IHx8IHBsYWNlbWVudCA9PT0gcmlnaHQpICYmIHZhcmlhdGlvbiA9PT0gZW5kKSB7XG4gICAgICBzaWRlWSA9IGJvdHRvbTtcbiAgICAgIHZhciBvZmZzZXRZID0gaXNGaXhlZCAmJiBvZmZzZXRQYXJlbnQgPT09IHdpbiAmJiB3aW4udmlzdWFsVmlld3BvcnQgPyB3aW4udmlzdWFsVmlld3BvcnQuaGVpZ2h0IDogLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgICBvZmZzZXRQYXJlbnRbaGVpZ2h0UHJvcF07XG4gICAgICB5IC09IG9mZnNldFkgLSBwb3BwZXJSZWN0LmhlaWdodDtcbiAgICAgIHkgKj0gZ3B1QWNjZWxlcmF0aW9uID8gMSA6IC0xO1xuICAgIH1cblxuICAgIGlmIChwbGFjZW1lbnQgPT09IGxlZnQgfHwgKHBsYWNlbWVudCA9PT0gdG9wIHx8IHBsYWNlbWVudCA9PT0gYm90dG9tKSAmJiB2YXJpYXRpb24gPT09IGVuZCkge1xuICAgICAgc2lkZVggPSByaWdodDtcbiAgICAgIHZhciBvZmZzZXRYID0gaXNGaXhlZCAmJiBvZmZzZXRQYXJlbnQgPT09IHdpbiAmJiB3aW4udmlzdWFsVmlld3BvcnQgPyB3aW4udmlzdWFsVmlld3BvcnQud2lkdGggOiAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICAgIG9mZnNldFBhcmVudFt3aWR0aFByb3BdO1xuICAgICAgeCAtPSBvZmZzZXRYIC0gcG9wcGVyUmVjdC53aWR0aDtcbiAgICAgIHggKj0gZ3B1QWNjZWxlcmF0aW9uID8gMSA6IC0xO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb21tb25TdHlsZXMgPSBPYmplY3QuYXNzaWduKHtcbiAgICBwb3NpdGlvbjogcG9zaXRpb25cbiAgfSwgYWRhcHRpdmUgJiYgdW5zZXRTaWRlcyk7XG5cbiAgdmFyIF9yZWY0ID0gcm91bmRPZmZzZXRzID09PSB0cnVlID8gcm91bmRPZmZzZXRzQnlEUFIoe1xuICAgIHg6IHgsXG4gICAgeTogeVxuICB9LCBnZXRXaW5kb3cocG9wcGVyKSkgOiB7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG5cbiAgeCA9IF9yZWY0Lng7XG4gIHkgPSBfcmVmNC55O1xuXG4gIGlmIChncHVBY2NlbGVyYXRpb24pIHtcbiAgICB2YXIgX09iamVjdCRhc3NpZ247XG5cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCAoX09iamVjdCRhc3NpZ24gPSB7fSwgX09iamVjdCRhc3NpZ25bc2lkZVldID0gaGFzWSA/ICcwJyA6ICcnLCBfT2JqZWN0JGFzc2lnbltzaWRlWF0gPSBoYXNYID8gJzAnIDogJycsIF9PYmplY3QkYXNzaWduLnRyYW5zZm9ybSA9ICh3aW4uZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSA8PSAxID8gXCJ0cmFuc2xhdGUoXCIgKyB4ICsgXCJweCwgXCIgKyB5ICsgXCJweClcIiA6IFwidHJhbnNsYXRlM2QoXCIgKyB4ICsgXCJweCwgXCIgKyB5ICsgXCJweCwgMClcIiwgX09iamVjdCRhc3NpZ24pKTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIChfT2JqZWN0JGFzc2lnbjIgPSB7fSwgX09iamVjdCRhc3NpZ24yW3NpZGVZXSA9IGhhc1kgPyB5ICsgXCJweFwiIDogJycsIF9PYmplY3QkYXNzaWduMltzaWRlWF0gPSBoYXNYID8geCArIFwicHhcIiA6ICcnLCBfT2JqZWN0JGFzc2lnbjIudHJhbnNmb3JtID0gJycsIF9PYmplY3QkYXNzaWduMikpO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlU3R5bGVzKF9yZWY1KSB7XG4gIHZhciBzdGF0ZSA9IF9yZWY1LnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWY1Lm9wdGlvbnM7XG4gIHZhciBfb3B0aW9ucyRncHVBY2NlbGVyYXQgPSBvcHRpb25zLmdwdUFjY2VsZXJhdGlvbixcbiAgICAgIGdwdUFjY2VsZXJhdGlvbiA9IF9vcHRpb25zJGdwdUFjY2VsZXJhdCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGdwdUFjY2VsZXJhdCxcbiAgICAgIF9vcHRpb25zJGFkYXB0aXZlID0gb3B0aW9ucy5hZGFwdGl2ZSxcbiAgICAgIGFkYXB0aXZlID0gX29wdGlvbnMkYWRhcHRpdmUgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRhZGFwdGl2ZSxcbiAgICAgIF9vcHRpb25zJHJvdW5kT2Zmc2V0cyA9IG9wdGlvbnMucm91bmRPZmZzZXRzLFxuICAgICAgcm91bmRPZmZzZXRzID0gX29wdGlvbnMkcm91bmRPZmZzZXRzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkcm91bmRPZmZzZXRzO1xuICB2YXIgY29tbW9uU3R5bGVzID0ge1xuICAgIHBsYWNlbWVudDogZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpLFxuICAgIHZhcmlhdGlvbjogZ2V0VmFyaWF0aW9uKHN0YXRlLnBsYWNlbWVudCksXG4gICAgcG9wcGVyOiBzdGF0ZS5lbGVtZW50cy5wb3BwZXIsXG4gICAgcG9wcGVyUmVjdDogc3RhdGUucmVjdHMucG9wcGVyLFxuICAgIGdwdUFjY2VsZXJhdGlvbjogZ3B1QWNjZWxlcmF0aW9uLFxuICAgIGlzRml4ZWQ6IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3kgPT09ICdmaXhlZCdcbiAgfTtcblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzICE9IG51bGwpIHtcbiAgICBzdGF0ZS5zdHlsZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuc3R5bGVzLnBvcHBlciwgbWFwVG9TdHlsZXMoT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCB7XG4gICAgICBvZmZzZXRzOiBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMsXG4gICAgICBwb3NpdGlvbjogc3RhdGUub3B0aW9ucy5zdHJhdGVneSxcbiAgICAgIGFkYXB0aXZlOiBhZGFwdGl2ZSxcbiAgICAgIHJvdW5kT2Zmc2V0czogcm91bmRPZmZzZXRzXG4gICAgfSkpKTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLmFycm93ICE9IG51bGwpIHtcbiAgICBzdGF0ZS5zdHlsZXMuYXJyb3cgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5zdHlsZXMuYXJyb3csIG1hcFRvU3R5bGVzKE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywge1xuICAgICAgb2Zmc2V0czogc3RhdGUubW9kaWZpZXJzRGF0YS5hcnJvdyxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgYWRhcHRpdmU6IGZhbHNlLFxuICAgICAgcm91bmRPZmZzZXRzOiByb3VuZE9mZnNldHNcbiAgICB9KSkpO1xuICB9XG5cbiAgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciwge1xuICAgICdkYXRhLXBvcHBlci1wbGFjZW1lbnQnOiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSk7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdjb21wdXRlU3R5bGVzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdiZWZvcmVXcml0ZScsXG4gIGZuOiBjb21wdXRlU3R5bGVzLFxuICBkYXRhOiB7fVxufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/modifiers/computeStyles.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/modifiers/eventListeners.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/eventListeners.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../dom-utils/getWindow.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getWindow.js\");\n // eslint-disable-next-line import/no-unused-modules\n\nvar passive = {\n  passive: true\n};\n\nfunction effect(_ref) {\n  var state = _ref.state,\n      instance = _ref.instance,\n      options = _ref.options;\n  var _options$scroll = options.scroll,\n      scroll = _options$scroll === void 0 ? true : _options$scroll,\n      _options$resize = options.resize,\n      resize = _options$resize === void 0 ? true : _options$resize;\n  var window = (0,_dom_utils_getWindow_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(state.elements.popper);\n  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);\n\n  if (scroll) {\n    scrollParents.forEach(function (scrollParent) {\n      scrollParent.addEventListener('scroll', instance.update, passive);\n    });\n  }\n\n  if (resize) {\n    window.addEventListener('resize', instance.update, passive);\n  }\n\n  return function () {\n    if (scroll) {\n      scrollParents.forEach(function (scrollParent) {\n        scrollParent.removeEventListener('scroll', instance.update, passive);\n      });\n    }\n\n    if (resize) {\n      window.removeEventListener('resize', instance.update, passive);\n    }\n  };\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: 'eventListeners',\n  enabled: true,\n  phase: 'write',\n  fn: function fn() {},\n  effect: effect,\n  data: {}\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2V2ZW50TGlzdGVuZXJzLmpzIiwibWFwcGluZ3MiOiI7O0FBQWtELENBQUM7O0FBRW5EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtRUFBUztBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0YsK0RBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvZXZlbnRMaXN0ZW5lcnMuanM/YzA1YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgZ2V0V2luZG93IGZyb20gXCIuLi9kb20tdXRpbHMvZ2V0V2luZG93LmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxudmFyIHBhc3NpdmUgPSB7XG4gIHBhc3NpdmU6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGVmZmVjdChfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBpbnN0YW5jZSA9IF9yZWYuaW5zdGFuY2UsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zO1xuICB2YXIgX29wdGlvbnMkc2Nyb2xsID0gb3B0aW9ucy5zY3JvbGwsXG4gICAgICBzY3JvbGwgPSBfb3B0aW9ucyRzY3JvbGwgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRzY3JvbGwsXG4gICAgICBfb3B0aW9ucyRyZXNpemUgPSBvcHRpb25zLnJlc2l6ZSxcbiAgICAgIHJlc2l6ZSA9IF9vcHRpb25zJHJlc2l6ZSA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJHJlc2l6ZTtcbiAgdmFyIHdpbmRvdyA9IGdldFdpbmRvdyhzdGF0ZS5lbGVtZW50cy5wb3BwZXIpO1xuICB2YXIgc2Nyb2xsUGFyZW50cyA9IFtdLmNvbmNhdChzdGF0ZS5zY3JvbGxQYXJlbnRzLnJlZmVyZW5jZSwgc3RhdGUuc2Nyb2xsUGFyZW50cy5wb3BwZXIpO1xuXG4gIGlmIChzY3JvbGwpIHtcbiAgICBzY3JvbGxQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHNjcm9sbFBhcmVudCkge1xuICAgICAgc2Nyb2xsUGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAocmVzaXplKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChzY3JvbGwpIHtcbiAgICAgIHNjcm9sbFBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAoc2Nyb2xsUGFyZW50KSB7XG4gICAgICAgIHNjcm9sbFBhcmVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHJlc2l6ZSkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gICAgfVxuICB9O1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnZXZlbnRMaXN0ZW5lcnMnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ3dyaXRlJyxcbiAgZm46IGZ1bmN0aW9uIGZuKCkge30sXG4gIGVmZmVjdDogZWZmZWN0LFxuICBkYXRhOiB7fVxufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/modifiers/eventListeners.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/modifiers/flip.js":
/*!***********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/flip.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/getOppositePlacement.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js\");\n/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/getBasePlacement.js\");\n/* harmony import */ var _utils_getOppositeVariationPlacement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/getOppositeVariationPlacement.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js\");\n/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/detectOverflow.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/detectOverflow.js\");\n/* harmony import */ var _utils_computeAutoPlacement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/computeAutoPlacement.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js\");\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/enums.js\");\n/* harmony import */ var _utils_getVariation_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/getVariation.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/getVariation.js\");\n\n\n\n\n\n\n // eslint-disable-next-line import/no-unused-modules\n\nfunction getExpandedFallbackPlacements(placement) {\n  if ((0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(placement) === _enums_js__WEBPACK_IMPORTED_MODULE_1__.auto) {\n    return [];\n  }\n\n  var oppositePlacement = (0,_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(placement);\n  return [(0,_utils_getOppositeVariationPlacement_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(placement), oppositePlacement, (0,_utils_getOppositeVariationPlacement_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(oppositePlacement)];\n}\n\nfunction flip(_ref) {\n  var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n\n  if (state.modifiersData[name]._skip) {\n    return;\n  }\n\n  var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,\n      specifiedFallbackPlacements = options.fallbackPlacements,\n      padding = options.padding,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      _options$flipVariatio = options.flipVariations,\n      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,\n      allowedAutoPlacements = options.allowedAutoPlacements;\n  var preferredPlacement = state.options.placement;\n  var basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(preferredPlacement);\n  var isBasePlacement = basePlacement === preferredPlacement;\n  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [(0,_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));\n  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {\n    return acc.concat((0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(placement) === _enums_js__WEBPACK_IMPORTED_MODULE_1__.auto ? (0,_utils_computeAutoPlacement_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      padding: padding,\n      flipVariations: flipVariations,\n      allowedAutoPlacements: allowedAutoPlacements\n    }) : placement);\n  }, []);\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var checksMap = new Map();\n  var makeFallbackChecks = true;\n  var firstFittingPlacement = placements[0];\n\n  for (var i = 0; i < placements.length; i++) {\n    var placement = placements[i];\n\n    var _basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(placement);\n\n    var isStartVariation = (0,_utils_getVariation_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(placement) === _enums_js__WEBPACK_IMPORTED_MODULE_1__.start;\n    var isVertical = [_enums_js__WEBPACK_IMPORTED_MODULE_1__.top, _enums_js__WEBPACK_IMPORTED_MODULE_1__.bottom].indexOf(_basePlacement) >= 0;\n    var len = isVertical ? 'width' : 'height';\n    var overflow = (0,_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      altBoundary: altBoundary,\n      padding: padding\n    });\n    var mainVariationSide = isVertical ? isStartVariation ? _enums_js__WEBPACK_IMPORTED_MODULE_1__.right : _enums_js__WEBPACK_IMPORTED_MODULE_1__.left : isStartVariation ? _enums_js__WEBPACK_IMPORTED_MODULE_1__.bottom : _enums_js__WEBPACK_IMPORTED_MODULE_1__.top;\n\n    if (referenceRect[len] > popperRect[len]) {\n      mainVariationSide = (0,_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(mainVariationSide);\n    }\n\n    var altVariationSide = (0,_utils_getOppositePlacement_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(mainVariationSide);\n    var checks = [];\n\n    if (checkMainAxis) {\n      checks.push(overflow[_basePlacement] <= 0);\n    }\n\n    if (checkAltAxis) {\n      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);\n    }\n\n    if (checks.every(function (check) {\n      return check;\n    })) {\n      firstFittingPlacement = placement;\n      makeFallbackChecks = false;\n      break;\n    }\n\n    checksMap.set(placement, checks);\n  }\n\n  if (makeFallbackChecks) {\n    // `2` may be desired in some cases – research later\n    var numberOfChecks = flipVariations ? 3 : 1;\n\n    var _loop = function _loop(_i) {\n      var fittingPlacement = placements.find(function (placement) {\n        var checks = checksMap.get(placement);\n\n        if (checks) {\n          return checks.slice(0, _i).every(function (check) {\n            return check;\n          });\n        }\n      });\n\n      if (fittingPlacement) {\n        firstFittingPlacement = fittingPlacement;\n        return \"break\";\n      }\n    };\n\n    for (var _i = numberOfChecks; _i > 0; _i--) {\n      var _ret = _loop(_i);\n\n      if (_ret === \"break\") break;\n    }\n  }\n\n  if (state.placement !== firstFittingPlacement) {\n    state.modifiersData[name]._skip = true;\n    state.placement = firstFittingPlacement;\n    state.reset = true;\n  }\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: 'flip',\n  enabled: true,\n  phase: 'main',\n  fn: flip,\n  requiresIfExists: ['offset'],\n  data: {\n    _skip: false\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2ZsaXAuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBb0U7QUFDUjtBQUMwQjtBQUM5QjtBQUNZO0FBQ0E7QUFDaEIsQ0FBQzs7QUFFckQ7QUFDQSxNQUFNLHNFQUFnQixnQkFBZ0IsMkNBQUk7QUFDMUM7QUFDQTs7QUFFQSwwQkFBMEIsMEVBQW9CO0FBQzlDLFVBQVUsbUZBQTZCLGdDQUFnQyxtRkFBNkI7QUFDcEc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNFQUFnQjtBQUN0QztBQUNBLGlHQUFpRywwRUFBb0I7QUFDckg7QUFDQSxzQkFBc0Isc0VBQWdCLGdCQUFnQiwyQ0FBSSxHQUFHLDBFQUFvQjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLHVCQUF1QjtBQUN6Qzs7QUFFQSx5QkFBeUIsc0VBQWdCOztBQUV6QywyQkFBMkIsa0VBQVksZ0JBQWdCLDRDQUFLO0FBQzVELHNCQUFzQiwwQ0FBRyxFQUFFLDZDQUFNO0FBQ2pDO0FBQ0EsbUJBQW1CLG9FQUFjO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsNERBQTRELDRDQUFLLEdBQUcsMkNBQUksc0JBQXNCLDZDQUFNLEdBQUcsMENBQUc7O0FBRTFHO0FBQ0EsMEJBQTBCLDBFQUFvQjtBQUM5Qzs7QUFFQSwyQkFBMkIsMEVBQW9CO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtDQUFrQyxRQUFRO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0YsK0RBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9mbGlwLmpzP2UzNTUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGdldE9wcG9zaXRlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRPcHBvc2l0ZVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi4vdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanNcIjtcbmltcG9ydCBjb21wdXRlQXV0b1BsYWNlbWVudCBmcm9tIFwiLi4vdXRpbHMvY29tcHV0ZUF1dG9QbGFjZW1lbnQuanNcIjtcbmltcG9ydCB7IGJvdHRvbSwgdG9wLCBzdGFydCwgcmlnaHQsIGxlZnQsIGF1dG8gfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBnZXRWYXJpYXRpb24gZnJvbSBcIi4uL3V0aWxzL2dldFZhcmlhdGlvbi5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmZ1bmN0aW9uIGdldEV4cGFuZGVkRmFsbGJhY2tQbGFjZW1lbnRzKHBsYWNlbWVudCkge1xuICBpZiAoZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpID09PSBhdXRvKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIG9wcG9zaXRlUGxhY2VtZW50ID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgcmV0dXJuIFtnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChwbGFjZW1lbnQpLCBvcHBvc2l0ZVBsYWNlbWVudCwgZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQob3Bwb3NpdGVQbGFjZW1lbnQpXTtcbn1cblxuZnVuY3Rpb24gZmxpcChfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXS5fc2tpcCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyRtYWluQXhpcyA9IG9wdGlvbnMubWFpbkF4aXMsXG4gICAgICBjaGVja01haW5BeGlzID0gX29wdGlvbnMkbWFpbkF4aXMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRtYWluQXhpcyxcbiAgICAgIF9vcHRpb25zJGFsdEF4aXMgPSBvcHRpb25zLmFsdEF4aXMsXG4gICAgICBjaGVja0FsdEF4aXMgPSBfb3B0aW9ucyRhbHRBeGlzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkYWx0QXhpcyxcbiAgICAgIHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyA9IG9wdGlvbnMuZmFsbGJhY2tQbGFjZW1lbnRzLFxuICAgICAgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZyxcbiAgICAgIGJvdW5kYXJ5ID0gb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeSA9IG9wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnkgPSBvcHRpb25zLmFsdEJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkZmxpcFZhcmlhdGlvID0gb3B0aW9ucy5mbGlwVmFyaWF0aW9ucyxcbiAgICAgIGZsaXBWYXJpYXRpb25zID0gX29wdGlvbnMkZmxpcFZhcmlhdGlvID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkZmxpcFZhcmlhdGlvLFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzID0gb3B0aW9ucy5hbGxvd2VkQXV0b1BsYWNlbWVudHM7XG4gIHZhciBwcmVmZXJyZWRQbGFjZW1lbnQgPSBzdGF0ZS5vcHRpb25zLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHByZWZlcnJlZFBsYWNlbWVudCk7XG4gIHZhciBpc0Jhc2VQbGFjZW1lbnQgPSBiYXNlUGxhY2VtZW50ID09PSBwcmVmZXJyZWRQbGFjZW1lbnQ7XG4gIHZhciBmYWxsYmFja1BsYWNlbWVudHMgPSBzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMgfHwgKGlzQmFzZVBsYWNlbWVudCB8fCAhZmxpcFZhcmlhdGlvbnMgPyBbZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocHJlZmVycmVkUGxhY2VtZW50KV0gOiBnZXRFeHBhbmRlZEZhbGxiYWNrUGxhY2VtZW50cyhwcmVmZXJyZWRQbGFjZW1lbnQpKTtcbiAgdmFyIHBsYWNlbWVudHMgPSBbcHJlZmVycmVkUGxhY2VtZW50XS5jb25jYXQoZmFsbGJhY2tQbGFjZW1lbnRzKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIGFjYy5jb25jYXQoZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpID09PSBhdXRvID8gY29tcHV0ZUF1dG9QbGFjZW1lbnQoc3RhdGUsIHtcbiAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgICBwYWRkaW5nOiBwYWRkaW5nLFxuICAgICAgZmxpcFZhcmlhdGlvbnM6IGZsaXBWYXJpYXRpb25zLFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzOiBhbGxvd2VkQXV0b1BsYWNlbWVudHNcbiAgICB9KSA6IHBsYWNlbWVudCk7XG4gIH0sIFtdKTtcbiAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgY2hlY2tzTWFwID0gbmV3IE1hcCgpO1xuICB2YXIgbWFrZUZhbGxiYWNrQ2hlY2tzID0gdHJ1ZTtcbiAgdmFyIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudHNbMF07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbGFjZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBsYWNlbWVudCA9IHBsYWNlbWVudHNbaV07XG5cbiAgICB2YXIgX2Jhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCk7XG5cbiAgICB2YXIgaXNTdGFydFZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihwbGFjZW1lbnQpID09PSBzdGFydDtcbiAgICB2YXIgaXNWZXJ0aWNhbCA9IFt0b3AsIGJvdHRvbV0uaW5kZXhPZihfYmFzZVBsYWNlbWVudCkgPj0gMDtcbiAgICB2YXIgbGVuID0gaXNWZXJ0aWNhbCA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcbiAgICB2YXIgb3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5OiBhbHRCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmc6IHBhZGRpbmdcbiAgICB9KTtcbiAgICB2YXIgbWFpblZhcmlhdGlvblNpZGUgPSBpc1ZlcnRpY2FsID8gaXNTdGFydFZhcmlhdGlvbiA/IHJpZ2h0IDogbGVmdCA6IGlzU3RhcnRWYXJpYXRpb24gPyBib3R0b20gOiB0b3A7XG5cbiAgICBpZiAocmVmZXJlbmNlUmVjdFtsZW5dID4gcG9wcGVyUmVjdFtsZW5dKSB7XG4gICAgICBtYWluVmFyaWF0aW9uU2lkZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5WYXJpYXRpb25TaWRlKTtcbiAgICB9XG5cbiAgICB2YXIgYWx0VmFyaWF0aW9uU2lkZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5WYXJpYXRpb25TaWRlKTtcbiAgICB2YXIgY2hlY2tzID0gW107XG5cbiAgICBpZiAoY2hlY2tNYWluQXhpcykge1xuICAgICAgY2hlY2tzLnB1c2gob3ZlcmZsb3dbX2Jhc2VQbGFjZW1lbnRdIDw9IDApO1xuICAgIH1cblxuICAgIGlmIChjaGVja0FsdEF4aXMpIHtcbiAgICAgIGNoZWNrcy5wdXNoKG92ZXJmbG93W21haW5WYXJpYXRpb25TaWRlXSA8PSAwLCBvdmVyZmxvd1thbHRWYXJpYXRpb25TaWRlXSA8PSAwKTtcbiAgICB9XG5cbiAgICBpZiAoY2hlY2tzLmV2ZXJ5KGZ1bmN0aW9uIChjaGVjaykge1xuICAgICAgcmV0dXJuIGNoZWNrO1xuICAgIH0pKSB7XG4gICAgICBmaXJzdEZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnQ7XG4gICAgICBtYWtlRmFsbGJhY2tDaGVja3MgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGNoZWNrc01hcC5zZXQocGxhY2VtZW50LCBjaGVja3MpO1xuICB9XG5cbiAgaWYgKG1ha2VGYWxsYmFja0NoZWNrcykge1xuICAgIC8vIGAyYCBtYXkgYmUgZGVzaXJlZCBpbiBzb21lIGNhc2VzIOKAkyByZXNlYXJjaCBsYXRlclxuICAgIHZhciBudW1iZXJPZkNoZWNrcyA9IGZsaXBWYXJpYXRpb25zID8gMyA6IDE7XG5cbiAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChfaSkge1xuICAgICAgdmFyIGZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnRzLmZpbmQoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgICAgICB2YXIgY2hlY2tzID0gY2hlY2tzTWFwLmdldChwbGFjZW1lbnQpO1xuXG4gICAgICAgIGlmIChjaGVja3MpIHtcbiAgICAgICAgICByZXR1cm4gY2hlY2tzLnNsaWNlKDAsIF9pKS5ldmVyeShmdW5jdGlvbiAoY2hlY2spIHtcbiAgICAgICAgICAgIHJldHVybiBjaGVjaztcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmIChmaXR0aW5nUGxhY2VtZW50KSB7XG4gICAgICAgIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IGZpdHRpbmdQbGFjZW1lbnQ7XG4gICAgICAgIHJldHVybiBcImJyZWFrXCI7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGZvciAodmFyIF9pID0gbnVtYmVyT2ZDaGVja3M7IF9pID4gMDsgX2ktLSkge1xuICAgICAgdmFyIF9yZXQgPSBfbG9vcChfaSk7XG5cbiAgICAgIGlmIChfcmV0ID09PSBcImJyZWFrXCIpIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdGF0ZS5wbGFjZW1lbnQgIT09IGZpcnN0Rml0dGluZ1BsYWNlbWVudCkge1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0uX3NraXAgPSB0cnVlO1xuICAgIHN0YXRlLnBsYWNlbWVudCA9IGZpcnN0Rml0dGluZ1BsYWNlbWVudDtcbiAgICBzdGF0ZS5yZXNldCA9IHRydWU7XG4gIH1cbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2ZsaXAnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICBmbjogZmxpcCxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydvZmZzZXQnXSxcbiAgZGF0YToge1xuICAgIF9za2lwOiBmYWxzZVxuICB9XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/modifiers/flip.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/modifiers/hide.js":
/*!***********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/hide.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/enums.js\");\n/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/detectOverflow.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/detectOverflow.js\");\n\n\n\nfunction getSideOffsets(overflow, rect, preventedOffsets) {\n  if (preventedOffsets === void 0) {\n    preventedOffsets = {\n      x: 0,\n      y: 0\n    };\n  }\n\n  return {\n    top: overflow.top - rect.height - preventedOffsets.y,\n    right: overflow.right - rect.width + preventedOffsets.x,\n    bottom: overflow.bottom - rect.height + preventedOffsets.y,\n    left: overflow.left - rect.width - preventedOffsets.x\n  };\n}\n\nfunction isAnySideFullyClipped(overflow) {\n  return [_enums_js__WEBPACK_IMPORTED_MODULE_0__.top, _enums_js__WEBPACK_IMPORTED_MODULE_0__.right, _enums_js__WEBPACK_IMPORTED_MODULE_0__.bottom, _enums_js__WEBPACK_IMPORTED_MODULE_0__.left].some(function (side) {\n    return overflow[side] >= 0;\n  });\n}\n\nfunction hide(_ref) {\n  var state = _ref.state,\n      name = _ref.name;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var preventedOffsets = state.modifiersData.preventOverflow;\n  var referenceOverflow = (0,_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(state, {\n    elementContext: 'reference'\n  });\n  var popperAltOverflow = (0,_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(state, {\n    altBoundary: true\n  });\n  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);\n  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);\n  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);\n  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);\n  state.modifiersData[name] = {\n    referenceClippingOffsets: referenceClippingOffsets,\n    popperEscapeOffsets: popperEscapeOffsets,\n    isReferenceHidden: isReferenceHidden,\n    hasPopperEscaped: hasPopperEscaped\n  };\n  state.attributes.popper = Object.assign({}, state.attributes.popper, {\n    'data-popper-reference-hidden': isReferenceHidden,\n    'data-popper-escaped': hasPopperEscaped\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: 'hide',\n  enabled: true,\n  phase: 'main',\n  requiresIfExists: ['preventOverflow'],\n  fn: hide\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2hpZGUuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQXVEO0FBQ0M7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVSwwQ0FBRyxFQUFFLDRDQUFLLEVBQUUsNkNBQU0sRUFBRSwyQ0FBSTtBQUNsQztBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsb0VBQWM7QUFDeEM7QUFDQSxHQUFHO0FBQ0gsMEJBQTBCLG9FQUFjO0FBQ3hDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7O0FBR0YsK0RBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL21vZGlmaWVycy9oaWRlLmpzPzQyNzUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdG9wLCBib3R0b20sIGxlZnQsIHJpZ2h0IH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5pbXBvcnQgZGV0ZWN0T3ZlcmZsb3cgZnJvbSBcIi4uL3V0aWxzL2RldGVjdE92ZXJmbG93LmpzXCI7XG5cbmZ1bmN0aW9uIGdldFNpZGVPZmZzZXRzKG92ZXJmbG93LCByZWN0LCBwcmV2ZW50ZWRPZmZzZXRzKSB7XG4gIGlmIChwcmV2ZW50ZWRPZmZzZXRzID09PSB2b2lkIDApIHtcbiAgICBwcmV2ZW50ZWRPZmZzZXRzID0ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0b3A6IG92ZXJmbG93LnRvcCAtIHJlY3QuaGVpZ2h0IC0gcHJldmVudGVkT2Zmc2V0cy55LFxuICAgIHJpZ2h0OiBvdmVyZmxvdy5yaWdodCAtIHJlY3Qud2lkdGggKyBwcmV2ZW50ZWRPZmZzZXRzLngsXG4gICAgYm90dG9tOiBvdmVyZmxvdy5ib3R0b20gLSByZWN0LmhlaWdodCArIHByZXZlbnRlZE9mZnNldHMueSxcbiAgICBsZWZ0OiBvdmVyZmxvdy5sZWZ0IC0gcmVjdC53aWR0aCAtIHByZXZlbnRlZE9mZnNldHMueFxuICB9O1xufVxuXG5mdW5jdGlvbiBpc0FueVNpZGVGdWxseUNsaXBwZWQob3ZlcmZsb3cpIHtcbiAgcmV0dXJuIFt0b3AsIHJpZ2h0LCBib3R0b20sIGxlZnRdLnNvbWUoZnVuY3Rpb24gKHNpZGUpIHtcbiAgICByZXR1cm4gb3ZlcmZsb3dbc2lkZV0gPj0gMDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGhpZGUoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgbmFtZSA9IF9yZWYubmFtZTtcbiAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgcHJldmVudGVkT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucHJldmVudE92ZXJmbG93O1xuICB2YXIgcmVmZXJlbmNlT3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgIGVsZW1lbnRDb250ZXh0OiAncmVmZXJlbmNlJ1xuICB9KTtcbiAgdmFyIHBvcHBlckFsdE92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICBhbHRCb3VuZGFyeTogdHJ1ZVxuICB9KTtcbiAgdmFyIHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKHJlZmVyZW5jZU92ZXJmbG93LCByZWZlcmVuY2VSZWN0KTtcbiAgdmFyIHBvcHBlckVzY2FwZU9mZnNldHMgPSBnZXRTaWRlT2Zmc2V0cyhwb3BwZXJBbHRPdmVyZmxvdywgcG9wcGVyUmVjdCwgcHJldmVudGVkT2Zmc2V0cyk7XG4gIHZhciBpc1JlZmVyZW5jZUhpZGRlbiA9IGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChyZWZlcmVuY2VDbGlwcGluZ09mZnNldHMpO1xuICB2YXIgaGFzUG9wcGVyRXNjYXBlZCA9IGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChwb3BwZXJFc2NhcGVPZmZzZXRzKTtcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IHtcbiAgICByZWZlcmVuY2VDbGlwcGluZ09mZnNldHM6IHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyxcbiAgICBwb3BwZXJFc2NhcGVPZmZzZXRzOiBwb3BwZXJFc2NhcGVPZmZzZXRzLFxuICAgIGlzUmVmZXJlbmNlSGlkZGVuOiBpc1JlZmVyZW5jZUhpZGRlbixcbiAgICBoYXNQb3BwZXJFc2NhcGVkOiBoYXNQb3BwZXJFc2NhcGVkXG4gIH07XG4gIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIsIHtcbiAgICAnZGF0YS1wb3BwZXItcmVmZXJlbmNlLWhpZGRlbic6IGlzUmVmZXJlbmNlSGlkZGVuLFxuICAgICdkYXRhLXBvcHBlci1lc2NhcGVkJzogaGFzUG9wcGVyRXNjYXBlZFxuICB9KTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2hpZGUnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ3ByZXZlbnRPdmVyZmxvdyddLFxuICBmbjogaGlkZVxufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/modifiers/hide.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/modifiers/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/index.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyStyles: function() { return /* reexport safe */ _applyStyles_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; },\n/* harmony export */   arrow: function() { return /* reexport safe */ _arrow_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; },\n/* harmony export */   computeStyles: function() { return /* reexport safe */ _computeStyles_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]; },\n/* harmony export */   eventListeners: function() { return /* reexport safe */ _eventListeners_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]; },\n/* harmony export */   flip: function() { return /* reexport safe */ _flip_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]; },\n/* harmony export */   hide: function() { return /* reexport safe */ _hide_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]; },\n/* harmony export */   offset: function() { return /* reexport safe */ _offset_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]; },\n/* harmony export */   popperOffsets: function() { return /* reexport safe */ _popperOffsets_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"]; },\n/* harmony export */   preventOverflow: function() { return /* reexport safe */ _preventOverflow_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"]; }\n/* harmony export */ });\n/* harmony import */ var _applyStyles_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./applyStyles.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/modifiers/applyStyles.js\");\n/* harmony import */ var _arrow_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./arrow.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/modifiers/arrow.js\");\n/* harmony import */ var _computeStyles_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./computeStyles.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/modifiers/computeStyles.js\");\n/* harmony import */ var _eventListeners_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./eventListeners.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/modifiers/eventListeners.js\");\n/* harmony import */ var _flip_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./flip.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/modifiers/flip.js\");\n/* harmony import */ var _hide_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./hide.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/modifiers/hide.js\");\n/* harmony import */ var _offset_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./offset.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/modifiers/offset.js\");\n/* harmony import */ var _popperOffsets_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./popperOffsets.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js\");\n/* harmony import */ var _preventOverflow_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./preventOverflow.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js\");\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUEwRDtBQUNaO0FBQ2dCO0FBQ0U7QUFDcEI7QUFDQTtBQUNJO0FBQ2MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvaW5kZXguanM/Y2QzOSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBkZWZhdWx0IGFzIGFwcGx5U3R5bGVzIH0gZnJvbSBcIi4vYXBwbHlTdHlsZXMuanNcIjtcbmV4cG9ydCB7IGRlZmF1bHQgYXMgYXJyb3cgfSBmcm9tIFwiLi9hcnJvdy5qc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBjb21wdXRlU3R5bGVzIH0gZnJvbSBcIi4vY29tcHV0ZVN0eWxlcy5qc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBldmVudExpc3RlbmVycyB9IGZyb20gXCIuL2V2ZW50TGlzdGVuZXJzLmpzXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGZsaXAgfSBmcm9tIFwiLi9mbGlwLmpzXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIGhpZGUgfSBmcm9tIFwiLi9oaWRlLmpzXCI7XG5leHBvcnQgeyBkZWZhdWx0IGFzIG9mZnNldCB9IGZyb20gXCIuL29mZnNldC5qc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBwb3BwZXJPZmZzZXRzIH0gZnJvbSBcIi4vcG9wcGVyT2Zmc2V0cy5qc1wiO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBwcmV2ZW50T3ZlcmZsb3cgfSBmcm9tIFwiLi9wcmV2ZW50T3ZlcmZsb3cuanNcIjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/modifiers/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/modifiers/offset.js":
/*!*************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/offset.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   distanceAndSkiddingToXY: function() { return /* binding */ distanceAndSkiddingToXY; }\n/* harmony export */ });\n/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/getBasePlacement.js\");\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/enums.js\");\n\n // eslint-disable-next-line import/no-unused-modules\n\nfunction distanceAndSkiddingToXY(placement, rects, offset) {\n  var basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(placement);\n  var invertDistance = [_enums_js__WEBPACK_IMPORTED_MODULE_1__.left, _enums_js__WEBPACK_IMPORTED_MODULE_1__.top].indexOf(basePlacement) >= 0 ? -1 : 1;\n\n  var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {\n    placement: placement\n  })) : offset,\n      skidding = _ref[0],\n      distance = _ref[1];\n\n  skidding = skidding || 0;\n  distance = (distance || 0) * invertDistance;\n  return [_enums_js__WEBPACK_IMPORTED_MODULE_1__.left, _enums_js__WEBPACK_IMPORTED_MODULE_1__.right].indexOf(basePlacement) >= 0 ? {\n    x: distance,\n    y: skidding\n  } : {\n    x: skidding,\n    y: distance\n  };\n}\n\nfunction offset(_ref2) {\n  var state = _ref2.state,\n      options = _ref2.options,\n      name = _ref2.name;\n  var _options$offset = options.offset,\n      offset = _options$offset === void 0 ? [0, 0] : _options$offset;\n  var data = _enums_js__WEBPACK_IMPORTED_MODULE_1__.placements.reduce(function (acc, placement) {\n    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);\n    return acc;\n  }, {});\n  var _data$state$placement = data[state.placement],\n      x = _data$state$placement.x,\n      y = _data$state$placement.y;\n\n  if (state.modifiersData.popperOffsets != null) {\n    state.modifiersData.popperOffsets.x += x;\n    state.modifiersData.popperOffsets.y += y;\n  }\n\n  state.modifiersData[name] = data;\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: 'offset',\n  enabled: true,\n  phase: 'main',\n  requires: ['popperOffsets'],\n  fn: offset\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL29mZnNldC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBNEQ7QUFDRCxDQUFDOztBQUVyRDtBQUNQLHNCQUFzQixzRUFBZ0I7QUFDdEMsd0JBQXdCLDJDQUFJLEVBQUUsMENBQUc7O0FBRWpDLG1FQUFtRTtBQUNuRTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLDJDQUFJLEVBQUUsNENBQUs7QUFDckI7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlEQUFVO0FBQ3ZCO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOzs7QUFHRiwrREFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL29mZnNldC5qcz84Y2RmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuLi91dGlscy9nZXRCYXNlUGxhY2VtZW50LmpzXCI7XG5pbXBvcnQgeyB0b3AsIGxlZnQsIHJpZ2h0LCBwbGFjZW1lbnRzIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IGZ1bmN0aW9uIGRpc3RhbmNlQW5kU2tpZGRpbmdUb1hZKHBsYWNlbWVudCwgcmVjdHMsIG9mZnNldCkge1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgdmFyIGludmVydERpc3RhbmNlID0gW2xlZnQsIHRvcF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA+PSAwID8gLTEgOiAxO1xuXG4gIHZhciBfcmVmID0gdHlwZW9mIG9mZnNldCA9PT0gJ2Z1bmN0aW9uJyA/IG9mZnNldChPYmplY3QuYXNzaWduKHt9LCByZWN0cywge1xuICAgIHBsYWNlbWVudDogcGxhY2VtZW50XG4gIH0pKSA6IG9mZnNldCxcbiAgICAgIHNraWRkaW5nID0gX3JlZlswXSxcbiAgICAgIGRpc3RhbmNlID0gX3JlZlsxXTtcblxuICBza2lkZGluZyA9IHNraWRkaW5nIHx8IDA7XG4gIGRpc3RhbmNlID0gKGRpc3RhbmNlIHx8IDApICogaW52ZXJ0RGlzdGFuY2U7XG4gIHJldHVybiBbbGVmdCwgcmlnaHRdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMCA/IHtcbiAgICB4OiBkaXN0YW5jZSxcbiAgICB5OiBza2lkZGluZ1xuICB9IDoge1xuICAgIHg6IHNraWRkaW5nLFxuICAgIHk6IGRpc3RhbmNlXG4gIH07XG59XG5cbmZ1bmN0aW9uIG9mZnNldChfcmVmMikge1xuICB2YXIgc3RhdGUgPSBfcmVmMi5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmMi5vcHRpb25zLFxuICAgICAgbmFtZSA9IF9yZWYyLm5hbWU7XG4gIHZhciBfb3B0aW9ucyRvZmZzZXQgPSBvcHRpb25zLm9mZnNldCxcbiAgICAgIG9mZnNldCA9IF9vcHRpb25zJG9mZnNldCA9PT0gdm9pZCAwID8gWzAsIDBdIDogX29wdGlvbnMkb2Zmc2V0O1xuICB2YXIgZGF0YSA9IHBsYWNlbWVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICAgIGFjY1twbGFjZW1lbnRdID0gZGlzdGFuY2VBbmRTa2lkZGluZ1RvWFkocGxhY2VtZW50LCBzdGF0ZS5yZWN0cywgb2Zmc2V0KTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG4gIHZhciBfZGF0YSRzdGF0ZSRwbGFjZW1lbnQgPSBkYXRhW3N0YXRlLnBsYWNlbWVudF0sXG4gICAgICB4ID0gX2RhdGEkc3RhdGUkcGxhY2VtZW50LngsXG4gICAgICB5ID0gX2RhdGEkc3RhdGUkcGxhY2VtZW50Lnk7XG5cbiAgaWYgKHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyAhPSBudWxsKSB7XG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnggKz0geDtcbiAgICBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMueSArPSB5O1xuICB9XG5cbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IGRhdGE7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdvZmZzZXQnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICByZXF1aXJlczogWydwb3BwZXJPZmZzZXRzJ10sXG4gIGZuOiBvZmZzZXRcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/modifiers/offset.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js":
/*!********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_computeOffsets_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/computeOffsets.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/computeOffsets.js\");\n\n\nfunction popperOffsets(_ref) {\n  var state = _ref.state,\n      name = _ref.name;\n  // Offsets are the actual position the popper needs to have to be\n  // properly positioned near its reference element\n  // This is the most basic placement, and will be adjusted by\n  // the modifiers in the next step\n  state.modifiersData[name] = (0,_utils_computeOffsets_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n    reference: state.rects.reference,\n    element: state.rects.popper,\n    strategy: 'absolute',\n    placement: state.placement\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: 'popperOffsets',\n  enabled: true,\n  phase: 'read',\n  fn: popperOffsets,\n  data: {}\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL3BvcHBlck9mZnNldHMuanMiLCJtYXBwaW5ncyI6Ijs7QUFBd0Q7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLG9FQUFjO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7OztBQUdGLCtEQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvcG9wcGVyT2Zmc2V0cy5qcz8yZjU4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjb21wdXRlT2Zmc2V0cyBmcm9tIFwiLi4vdXRpbHMvY29tcHV0ZU9mZnNldHMuanNcIjtcblxuZnVuY3Rpb24gcG9wcGVyT2Zmc2V0cyhfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuICAvLyBPZmZzZXRzIGFyZSB0aGUgYWN0dWFsIHBvc2l0aW9uIHRoZSBwb3BwZXIgbmVlZHMgdG8gaGF2ZSB0byBiZVxuICAvLyBwcm9wZXJseSBwb3NpdGlvbmVkIG5lYXIgaXRzIHJlZmVyZW5jZSBlbGVtZW50XG4gIC8vIFRoaXMgaXMgdGhlIG1vc3QgYmFzaWMgcGxhY2VtZW50LCBhbmQgd2lsbCBiZSBhZGp1c3RlZCBieVxuICAvLyB0aGUgbW9kaWZpZXJzIGluIHRoZSBuZXh0IHN0ZXBcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IGNvbXB1dGVPZmZzZXRzKHtcbiAgICByZWZlcmVuY2U6IHN0YXRlLnJlY3RzLnJlZmVyZW5jZSxcbiAgICBlbGVtZW50OiBzdGF0ZS5yZWN0cy5wb3BwZXIsXG4gICAgc3RyYXRlZ3k6ICdhYnNvbHV0ZScsXG4gICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSk7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdwb3BwZXJPZmZzZXRzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdyZWFkJyxcbiAgZm46IHBvcHBlck9mZnNldHMsXG4gIGRhdGE6IHt9XG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../enums.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/enums.js\");\n/* harmony import */ var _utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/getBasePlacement.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/getBasePlacement.js\");\n/* harmony import */ var _utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/getMainAxisFromPlacement.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js\");\n/* harmony import */ var _utils_getAltAxis_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/getAltAxis.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/getAltAxis.js\");\n/* harmony import */ var _utils_within_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/within.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/within.js\");\n/* harmony import */ var _dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dom-utils/getLayoutRect.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js\");\n/* harmony import */ var _dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../dom-utils/getOffsetParent.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js\");\n/* harmony import */ var _utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/detectOverflow.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/detectOverflow.js\");\n/* harmony import */ var _utils_getVariation_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/getVariation.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/getVariation.js\");\n/* harmony import */ var _utils_getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/getFreshSideObject.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js\");\n/* harmony import */ var _utils_math_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../utils/math.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/math.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nfunction preventOverflow(_ref) {\n  var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n  var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      padding = options.padding,\n      _options$tether = options.tether,\n      tether = _options$tether === void 0 ? true : _options$tether,\n      _options$tetherOffset = options.tetherOffset,\n      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;\n  var overflow = (0,_utils_detectOverflow_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(state, {\n    boundary: boundary,\n    rootBoundary: rootBoundary,\n    padding: padding,\n    altBoundary: altBoundary\n  });\n  var basePlacement = (0,_utils_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(state.placement);\n  var variation = (0,_utils_getVariation_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state.placement);\n  var isBasePlacement = !variation;\n  var mainAxis = (0,_utils_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(basePlacement);\n  var altAxis = (0,_utils_getAltAxis_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(mainAxis);\n  var popperOffsets = state.modifiersData.popperOffsets;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {\n    placement: state.placement\n  })) : tetherOffset;\n  var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {\n    mainAxis: tetherOffsetValue,\n    altAxis: tetherOffsetValue\n  } : Object.assign({\n    mainAxis: 0,\n    altAxis: 0\n  }, tetherOffsetValue);\n  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;\n  var data = {\n    x: 0,\n    y: 0\n  };\n\n  if (!popperOffsets) {\n    return;\n  }\n\n  if (checkMainAxis) {\n    var _offsetModifierState$;\n\n    var mainSide = mainAxis === 'y' ? _enums_js__WEBPACK_IMPORTED_MODULE_5__.top : _enums_js__WEBPACK_IMPORTED_MODULE_5__.left;\n    var altSide = mainAxis === 'y' ? _enums_js__WEBPACK_IMPORTED_MODULE_5__.bottom : _enums_js__WEBPACK_IMPORTED_MODULE_5__.right;\n    var len = mainAxis === 'y' ? 'height' : 'width';\n    var offset = popperOffsets[mainAxis];\n    var min = offset + overflow[mainSide];\n    var max = offset - overflow[altSide];\n    var additive = tether ? -popperRect[len] / 2 : 0;\n    var minLen = variation === _enums_js__WEBPACK_IMPORTED_MODULE_5__.start ? referenceRect[len] : popperRect[len];\n    var maxLen = variation === _enums_js__WEBPACK_IMPORTED_MODULE_5__.start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go\n    // outside the reference bounds\n\n    var arrowElement = state.elements.arrow;\n    var arrowRect = tether && arrowElement ? (0,_dom_utils_getLayoutRect_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(arrowElement) : {\n      width: 0,\n      height: 0\n    };\n    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : (0,_utils_getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"])();\n    var arrowPaddingMin = arrowPaddingObject[mainSide];\n    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want\n    // to include its full size in the calculation. If the reference is small\n    // and near the edge of a boundary, the popper can overflow even if the\n    // reference is not overflowing as well (e.g. virtual elements with no\n    // width or height)\n\n    var arrowLen = (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_8__.within)(0, referenceRect[len], arrowRect[len]);\n    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;\n    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;\n    var arrowOffsetParent = state.elements.arrow && (0,_dom_utils_getOffsetParent_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"])(state.elements.arrow);\n    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;\n    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;\n    var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;\n    var tetherMax = offset + maxOffset - offsetModifierValue;\n    var preventedOffset = (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_8__.within)(tether ? (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_10__.min)(min, tetherMin) : min, offset, tether ? (0,_utils_math_js__WEBPACK_IMPORTED_MODULE_10__.max)(max, tetherMax) : max);\n    popperOffsets[mainAxis] = preventedOffset;\n    data[mainAxis] = preventedOffset - offset;\n  }\n\n  if (checkAltAxis) {\n    var _offsetModifierState$2;\n\n    var _mainSide = mainAxis === 'x' ? _enums_js__WEBPACK_IMPORTED_MODULE_5__.top : _enums_js__WEBPACK_IMPORTED_MODULE_5__.left;\n\n    var _altSide = mainAxis === 'x' ? _enums_js__WEBPACK_IMPORTED_MODULE_5__.bottom : _enums_js__WEBPACK_IMPORTED_MODULE_5__.right;\n\n    var _offset = popperOffsets[altAxis];\n\n    var _len = altAxis === 'y' ? 'height' : 'width';\n\n    var _min = _offset + overflow[_mainSide];\n\n    var _max = _offset - overflow[_altSide];\n\n    var isOriginSide = [_enums_js__WEBPACK_IMPORTED_MODULE_5__.top, _enums_js__WEBPACK_IMPORTED_MODULE_5__.left].indexOf(basePlacement) !== -1;\n\n    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;\n\n    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;\n\n    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;\n\n    var _preventedOffset = tether && isOriginSide ? (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_8__.withinMaxClamp)(_tetherMin, _offset, _tetherMax) : (0,_utils_within_js__WEBPACK_IMPORTED_MODULE_8__.within)(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);\n\n    popperOffsets[altAxis] = _preventedOffset;\n    data[altAxis] = _preventedOffset - _offset;\n  }\n\n  state.modifiersData[name] = data;\n} // eslint-disable-next-line import/no-unused-modules\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  name: 'preventOverflow',\n  enabled: true,\n  phase: 'main',\n  fn: preventOverflow,\n  requiresIfExists: ['offset']\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvbW9kaWZpZXJzL3ByZXZlbnRPdmVyZmxvdy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBOEQ7QUFDRjtBQUNnQjtBQUM1QjtBQUNZO0FBQ0Y7QUFDSTtBQUNOO0FBQ0o7QUFDWTtBQUNFOztBQUVsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixvRUFBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxzQkFBc0Isc0VBQWdCO0FBQ3RDLGtCQUFrQixrRUFBWTtBQUM5QjtBQUNBLGlCQUFpQiw4RUFBd0I7QUFDekMsZ0JBQWdCLGdFQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RjtBQUM1RjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHNDQUFzQywwQ0FBRyxHQUFHLDJDQUFJO0FBQ2hELHFDQUFxQyw2Q0FBTSxHQUFHLDRDQUFLO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsNENBQUs7QUFDcEMsK0JBQStCLDRDQUFLLDJDQUEyQztBQUMvRTs7QUFFQTtBQUNBLDZDQUE2Qyx1RUFBYTtBQUMxRDtBQUNBO0FBQ0E7QUFDQSx5SEFBeUgsd0VBQWtCO0FBQzNJO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQix3REFBTTtBQUN6QjtBQUNBO0FBQ0Esb0RBQW9ELHlFQUFlO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHdEQUFNLFVBQVUsb0RBQU8seUNBQXlDLG9EQUFPO0FBQ2pHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHVDQUF1QywwQ0FBRyxHQUFHLDJDQUFJOztBQUVqRCxzQ0FBc0MsNkNBQU0sR0FBRyw0Q0FBSzs7QUFFcEQ7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUEsd0JBQXdCLDBDQUFHLEVBQUUsMkNBQUk7O0FBRWpDOztBQUVBOztBQUVBOztBQUVBLG9EQUFvRCxnRUFBYyxvQ0FBb0Msd0RBQU07O0FBRTVHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7OztBQUdGLCtEQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9tb2RpZmllcnMvcHJldmVudE92ZXJmbG93LmpzP2U4Y2MiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdG9wLCBsZWZ0LCByaWdodCwgYm90dG9tLCBzdGFydCB9IGZyb20gXCIuLi9lbnVtcy5qc1wiO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQgZnJvbSBcIi4uL3V0aWxzL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IGdldEFsdEF4aXMgZnJvbSBcIi4uL3V0aWxzL2dldEFsdEF4aXMuanNcIjtcbmltcG9ydCB7IHdpdGhpbiwgd2l0aGluTWF4Q2xhbXAgfSBmcm9tIFwiLi4vdXRpbHMvd2l0aGluLmpzXCI7XG5pbXBvcnQgZ2V0TGF5b3V0UmVjdCBmcm9tIFwiLi4vZG9tLXV0aWxzL2dldExheW91dFJlY3QuanNcIjtcbmltcG9ydCBnZXRPZmZzZXRQYXJlbnQgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRPZmZzZXRQYXJlbnQuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi4vdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanNcIjtcbmltcG9ydCBnZXRWYXJpYXRpb24gZnJvbSBcIi4uL3V0aWxzL2dldFZhcmlhdGlvbi5qc1wiO1xuaW1wb3J0IGdldEZyZXNoU2lkZU9iamVjdCBmcm9tIFwiLi4vdXRpbHMvZ2V0RnJlc2hTaWRlT2JqZWN0LmpzXCI7XG5pbXBvcnQgeyBtaW4gYXMgbWF0aE1pbiwgbWF4IGFzIG1hdGhNYXggfSBmcm9tIFwiLi4vdXRpbHMvbWF0aC5qc1wiO1xuXG5mdW5jdGlvbiBwcmV2ZW50T3ZlcmZsb3coX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucyxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWU7XG4gIHZhciBfb3B0aW9ucyRtYWluQXhpcyA9IG9wdGlvbnMubWFpbkF4aXMsXG4gICAgICBjaGVja01haW5BeGlzID0gX29wdGlvbnMkbWFpbkF4aXMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRtYWluQXhpcyxcbiAgICAgIF9vcHRpb25zJGFsdEF4aXMgPSBvcHRpb25zLmFsdEF4aXMsXG4gICAgICBjaGVja0FsdEF4aXMgPSBfb3B0aW9ucyRhbHRBeGlzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGFsdEF4aXMsXG4gICAgICBib3VuZGFyeSA9IG9wdGlvbnMuYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnkgPSBvcHRpb25zLnJvb3RCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5ID0gb3B0aW9ucy5hbHRCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmcgPSBvcHRpb25zLnBhZGRpbmcsXG4gICAgICBfb3B0aW9ucyR0ZXRoZXIgPSBvcHRpb25zLnRldGhlcixcbiAgICAgIHRldGhlciA9IF9vcHRpb25zJHRldGhlciA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJHRldGhlcixcbiAgICAgIF9vcHRpb25zJHRldGhlck9mZnNldCA9IG9wdGlvbnMudGV0aGVyT2Zmc2V0LFxuICAgICAgdGV0aGVyT2Zmc2V0ID0gX29wdGlvbnMkdGV0aGVyT2Zmc2V0ID09PSB2b2lkIDAgPyAwIDogX29wdGlvbnMkdGV0aGVyT2Zmc2V0O1xuICB2YXIgb3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICBwYWRkaW5nOiBwYWRkaW5nLFxuICAgIGFsdEJvdW5kYXJ5OiBhbHRCb3VuZGFyeVxuICB9KTtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHN0YXRlLnBsYWNlbWVudCk7XG4gIHZhciB2YXJpYXRpb24gPSBnZXRWYXJpYXRpb24oc3RhdGUucGxhY2VtZW50KTtcbiAgdmFyIGlzQmFzZVBsYWNlbWVudCA9ICF2YXJpYXRpb247XG4gIHZhciBtYWluQXhpcyA9IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KTtcbiAgdmFyIGFsdEF4aXMgPSBnZXRBbHRBeGlzKG1haW5BeGlzKTtcbiAgdmFyIHBvcHBlck9mZnNldHMgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHM7XG4gIHZhciByZWZlcmVuY2VSZWN0ID0gc3RhdGUucmVjdHMucmVmZXJlbmNlO1xuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgdmFyIHRldGhlck9mZnNldFZhbHVlID0gdHlwZW9mIHRldGhlck9mZnNldCA9PT0gJ2Z1bmN0aW9uJyA/IHRldGhlck9mZnNldChPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5yZWN0cywge1xuICAgIHBsYWNlbWVudDogc3RhdGUucGxhY2VtZW50XG4gIH0pKSA6IHRldGhlck9mZnNldDtcbiAgdmFyIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZSA9IHR5cGVvZiB0ZXRoZXJPZmZzZXRWYWx1ZSA9PT0gJ251bWJlcicgPyB7XG4gICAgbWFpbkF4aXM6IHRldGhlck9mZnNldFZhbHVlLFxuICAgIGFsdEF4aXM6IHRldGhlck9mZnNldFZhbHVlXG4gIH0gOiBPYmplY3QuYXNzaWduKHtcbiAgICBtYWluQXhpczogMCxcbiAgICBhbHRBeGlzOiAwXG4gIH0sIHRldGhlck9mZnNldFZhbHVlKTtcbiAgdmFyIG9mZnNldE1vZGlmaWVyU3RhdGUgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldCA/IHN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0W3N0YXRlLnBsYWNlbWVudF0gOiBudWxsO1xuICB2YXIgZGF0YSA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDBcbiAgfTtcblxuICBpZiAoIXBvcHBlck9mZnNldHMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoY2hlY2tNYWluQXhpcykge1xuICAgIHZhciBfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQ7XG5cbiAgICB2YXIgbWFpblNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gdG9wIDogbGVmdDtcbiAgICB2YXIgYWx0U2lkZSA9IG1haW5BeGlzID09PSAneScgPyBib3R0b20gOiByaWdodDtcbiAgICB2YXIgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICB2YXIgb2Zmc2V0ID0gcG9wcGVyT2Zmc2V0c1ttYWluQXhpc107XG4gICAgdmFyIG1pbiA9IG9mZnNldCArIG92ZXJmbG93W21haW5TaWRlXTtcbiAgICB2YXIgbWF4ID0gb2Zmc2V0IC0gb3ZlcmZsb3dbYWx0U2lkZV07XG4gICAgdmFyIGFkZGl0aXZlID0gdGV0aGVyID8gLXBvcHBlclJlY3RbbGVuXSAvIDIgOiAwO1xuICAgIHZhciBtaW5MZW4gPSB2YXJpYXRpb24gPT09IHN0YXJ0ID8gcmVmZXJlbmNlUmVjdFtsZW5dIDogcG9wcGVyUmVjdFtsZW5dO1xuICAgIHZhciBtYXhMZW4gPSB2YXJpYXRpb24gPT09IHN0YXJ0ID8gLXBvcHBlclJlY3RbbGVuXSA6IC1yZWZlcmVuY2VSZWN0W2xlbl07IC8vIFdlIG5lZWQgdG8gaW5jbHVkZSB0aGUgYXJyb3cgaW4gdGhlIGNhbGN1bGF0aW9uIHNvIHRoZSBhcnJvdyBkb2Vzbid0IGdvXG4gICAgLy8gb3V0c2lkZSB0aGUgcmVmZXJlbmNlIGJvdW5kc1xuXG4gICAgdmFyIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLmFycm93O1xuICAgIHZhciBhcnJvd1JlY3QgPSB0ZXRoZXIgJiYgYXJyb3dFbGVtZW50ID8gZ2V0TGF5b3V0UmVjdChhcnJvd0VsZW1lbnQpIDoge1xuICAgICAgd2lkdGg6IDAsXG4gICAgICBoZWlnaHQ6IDBcbiAgICB9O1xuICAgIHZhciBhcnJvd1BhZGRpbmdPYmplY3QgPSBzdGF0ZS5tb2RpZmllcnNEYXRhWydhcnJvdyNwZXJzaXN0ZW50J10gPyBzdGF0ZS5tb2RpZmllcnNEYXRhWydhcnJvdyNwZXJzaXN0ZW50J10ucGFkZGluZyA6IGdldEZyZXNoU2lkZU9iamVjdCgpO1xuICAgIHZhciBhcnJvd1BhZGRpbmdNaW4gPSBhcnJvd1BhZGRpbmdPYmplY3RbbWFpblNpZGVdO1xuICAgIHZhciBhcnJvd1BhZGRpbmdNYXggPSBhcnJvd1BhZGRpbmdPYmplY3RbYWx0U2lkZV07IC8vIElmIHRoZSByZWZlcmVuY2UgbGVuZ3RoIGlzIHNtYWxsZXIgdGhhbiB0aGUgYXJyb3cgbGVuZ3RoLCB3ZSBkb24ndCB3YW50XG4gICAgLy8gdG8gaW5jbHVkZSBpdHMgZnVsbCBzaXplIGluIHRoZSBjYWxjdWxhdGlvbi4gSWYgdGhlIHJlZmVyZW5jZSBpcyBzbWFsbFxuICAgIC8vIGFuZCBuZWFyIHRoZSBlZGdlIG9mIGEgYm91bmRhcnksIHRoZSBwb3BwZXIgY2FuIG92ZXJmbG93IGV2ZW4gaWYgdGhlXG4gICAgLy8gcmVmZXJlbmNlIGlzIG5vdCBvdmVyZmxvd2luZyBhcyB3ZWxsIChlLmcuIHZpcnR1YWwgZWxlbWVudHMgd2l0aCBub1xuICAgIC8vIHdpZHRoIG9yIGhlaWdodClcblxuICAgIHZhciBhcnJvd0xlbiA9IHdpdGhpbigwLCByZWZlcmVuY2VSZWN0W2xlbl0sIGFycm93UmVjdFtsZW5dKTtcbiAgICB2YXIgbWluT2Zmc2V0ID0gaXNCYXNlUGxhY2VtZW50ID8gcmVmZXJlbmNlUmVjdFtsZW5dIC8gMiAtIGFkZGl0aXZlIC0gYXJyb3dMZW4gLSBhcnJvd1BhZGRpbmdNaW4gLSBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUubWFpbkF4aXMgOiBtaW5MZW4gLSBhcnJvd0xlbiAtIGFycm93UGFkZGluZ01pbiAtIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpcztcbiAgICB2YXIgbWF4T2Zmc2V0ID0gaXNCYXNlUGxhY2VtZW50ID8gLXJlZmVyZW5jZVJlY3RbbGVuXSAvIDIgKyBhZGRpdGl2ZSArIGFycm93TGVuICsgYXJyb3dQYWRkaW5nTWF4ICsgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLm1haW5BeGlzIDogbWF4TGVuICsgYXJyb3dMZW4gKyBhcnJvd1BhZGRpbmdNYXggKyBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUubWFpbkF4aXM7XG4gICAgdmFyIGFycm93T2Zmc2V0UGFyZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3cgJiYgZ2V0T2Zmc2V0UGFyZW50KHN0YXRlLmVsZW1lbnRzLmFycm93KTtcbiAgICB2YXIgY2xpZW50T2Zmc2V0ID0gYXJyb3dPZmZzZXRQYXJlbnQgPyBtYWluQXhpcyA9PT0gJ3knID8gYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50VG9wIHx8IDAgOiBhcnJvd09mZnNldFBhcmVudC5jbGllbnRMZWZ0IHx8IDAgOiAwO1xuICAgIHZhciBvZmZzZXRNb2RpZmllclZhbHVlID0gKF9vZmZzZXRNb2RpZmllclN0YXRlJCA9IG9mZnNldE1vZGlmaWVyU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IG9mZnNldE1vZGlmaWVyU3RhdGVbbWFpbkF4aXNdKSAhPSBudWxsID8gX29mZnNldE1vZGlmaWVyU3RhdGUkIDogMDtcbiAgICB2YXIgdGV0aGVyTWluID0gb2Zmc2V0ICsgbWluT2Zmc2V0IC0gb2Zmc2V0TW9kaWZpZXJWYWx1ZSAtIGNsaWVudE9mZnNldDtcbiAgICB2YXIgdGV0aGVyTWF4ID0gb2Zmc2V0ICsgbWF4T2Zmc2V0IC0gb2Zmc2V0TW9kaWZpZXJWYWx1ZTtcbiAgICB2YXIgcHJldmVudGVkT2Zmc2V0ID0gd2l0aGluKHRldGhlciA/IG1hdGhNaW4obWluLCB0ZXRoZXJNaW4pIDogbWluLCBvZmZzZXQsIHRldGhlciA/IG1hdGhNYXgobWF4LCB0ZXRoZXJNYXgpIDogbWF4KTtcbiAgICBwb3BwZXJPZmZzZXRzW21haW5BeGlzXSA9IHByZXZlbnRlZE9mZnNldDtcbiAgICBkYXRhW21haW5BeGlzXSA9IHByZXZlbnRlZE9mZnNldCAtIG9mZnNldDtcbiAgfVxuXG4gIGlmIChjaGVja0FsdEF4aXMpIHtcbiAgICB2YXIgX29mZnNldE1vZGlmaWVyU3RhdGUkMjtcblxuICAgIHZhciBfbWFpblNpZGUgPSBtYWluQXhpcyA9PT0gJ3gnID8gdG9wIDogbGVmdDtcblxuICAgIHZhciBfYWx0U2lkZSA9IG1haW5BeGlzID09PSAneCcgPyBib3R0b20gOiByaWdodDtcblxuICAgIHZhciBfb2Zmc2V0ID0gcG9wcGVyT2Zmc2V0c1thbHRBeGlzXTtcblxuICAgIHZhciBfbGVuID0gYWx0QXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gICAgdmFyIF9taW4gPSBfb2Zmc2V0ICsgb3ZlcmZsb3dbX21haW5TaWRlXTtcblxuICAgIHZhciBfbWF4ID0gX29mZnNldCAtIG92ZXJmbG93W19hbHRTaWRlXTtcblxuICAgIHZhciBpc09yaWdpblNpZGUgPSBbdG9wLCBsZWZ0XS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcblxuICAgIHZhciBfb2Zmc2V0TW9kaWZpZXJWYWx1ZSA9IChfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQyID0gb2Zmc2V0TW9kaWZpZXJTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogb2Zmc2V0TW9kaWZpZXJTdGF0ZVthbHRBeGlzXSkgIT0gbnVsbCA/IF9vZmZzZXRNb2RpZmllclN0YXRlJDIgOiAwO1xuXG4gICAgdmFyIF90ZXRoZXJNaW4gPSBpc09yaWdpblNpZGUgPyBfbWluIDogX29mZnNldCAtIHJlZmVyZW5jZVJlY3RbX2xlbl0gLSBwb3BwZXJSZWN0W19sZW5dIC0gX29mZnNldE1vZGlmaWVyVmFsdWUgKyBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUuYWx0QXhpcztcblxuICAgIHZhciBfdGV0aGVyTWF4ID0gaXNPcmlnaW5TaWRlID8gX29mZnNldCArIHJlZmVyZW5jZVJlY3RbX2xlbl0gKyBwb3BwZXJSZWN0W19sZW5dIC0gX29mZnNldE1vZGlmaWVyVmFsdWUgLSBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUuYWx0QXhpcyA6IF9tYXg7XG5cbiAgICB2YXIgX3ByZXZlbnRlZE9mZnNldCA9IHRldGhlciAmJiBpc09yaWdpblNpZGUgPyB3aXRoaW5NYXhDbGFtcChfdGV0aGVyTWluLCBfb2Zmc2V0LCBfdGV0aGVyTWF4KSA6IHdpdGhpbih0ZXRoZXIgPyBfdGV0aGVyTWluIDogX21pbiwgX29mZnNldCwgdGV0aGVyID8gX3RldGhlck1heCA6IF9tYXgpO1xuXG4gICAgcG9wcGVyT2Zmc2V0c1thbHRBeGlzXSA9IF9wcmV2ZW50ZWRPZmZzZXQ7XG4gICAgZGF0YVthbHRBeGlzXSA9IF9wcmV2ZW50ZWRPZmZzZXQgLSBfb2Zmc2V0O1xuICB9XG5cbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IGRhdGE7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdwcmV2ZW50T3ZlcmZsb3cnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICBmbjogcHJldmVudE92ZXJmbG93LFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ29mZnNldCddXG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/popper-lite.js":
/*!********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/popper-lite.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createPopper: function() { return /* binding */ createPopper; },\n/* harmony export */   defaultModifiers: function() { return /* binding */ defaultModifiers; },\n/* harmony export */   detectOverflow: function() { return /* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]; },\n/* harmony export */   popperGenerator: function() { return /* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_4__.popperGenerator; }\n/* harmony export */ });\n/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./createPopper.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/createPopper.js\");\n/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./createPopper.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/detectOverflow.js\");\n/* harmony import */ var _modifiers_eventListeners_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modifiers/eventListeners.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/modifiers/eventListeners.js\");\n/* harmony import */ var _modifiers_popperOffsets_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modifiers/popperOffsets.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js\");\n/* harmony import */ var _modifiers_computeStyles_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modifiers/computeStyles.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/modifiers/computeStyles.js\");\n/* harmony import */ var _modifiers_applyStyles_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modifiers/applyStyles.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/modifiers/applyStyles.js\");\n\n\n\n\n\nvar defaultModifiers = [_modifiers_eventListeners_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"], _modifiers_popperOffsets_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"], _modifiers_computeStyles_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"], _modifiers_applyStyles_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]];\nvar createPopper = /*#__PURE__*/(0,_createPopper_js__WEBPACK_IMPORTED_MODULE_4__.popperGenerator)({\n  defaultModifiers: defaultModifiers\n}); // eslint-disable-next-line import/no-unused-modules\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvcG9wcGVyLWxpdGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFvRTtBQUNUO0FBQ0Y7QUFDQTtBQUNKO0FBQ3JELHdCQUF3QixvRUFBYyxFQUFFLG1FQUFhLEVBQUUsbUVBQWEsRUFBRSxpRUFBVztBQUNqRixnQ0FBZ0MsaUVBQWU7QUFDL0M7QUFDQSxDQUFDLEdBQUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9wb3BwZXItbGl0ZS5qcz8yODQxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHBvcHBlckdlbmVyYXRvciwgZGV0ZWN0T3ZlcmZsb3cgfSBmcm9tIFwiLi9jcmVhdGVQb3BwZXIuanNcIjtcbmltcG9ydCBldmVudExpc3RlbmVycyBmcm9tIFwiLi9tb2RpZmllcnMvZXZlbnRMaXN0ZW5lcnMuanNcIjtcbmltcG9ydCBwb3BwZXJPZmZzZXRzIGZyb20gXCIuL21vZGlmaWVycy9wb3BwZXJPZmZzZXRzLmpzXCI7XG5pbXBvcnQgY29tcHV0ZVN0eWxlcyBmcm9tIFwiLi9tb2RpZmllcnMvY29tcHV0ZVN0eWxlcy5qc1wiO1xuaW1wb3J0IGFwcGx5U3R5bGVzIGZyb20gXCIuL21vZGlmaWVycy9hcHBseVN0eWxlcy5qc1wiO1xudmFyIGRlZmF1bHRNb2RpZmllcnMgPSBbZXZlbnRMaXN0ZW5lcnMsIHBvcHBlck9mZnNldHMsIGNvbXB1dGVTdHlsZXMsIGFwcGx5U3R5bGVzXTtcbnZhciBjcmVhdGVQb3BwZXIgPSAvKiNfX1BVUkVfXyovcG9wcGVyR2VuZXJhdG9yKHtcbiAgZGVmYXVsdE1vZGlmaWVyczogZGVmYXVsdE1vZGlmaWVyc1xufSk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IHsgY3JlYXRlUG9wcGVyLCBwb3BwZXJHZW5lcmF0b3IsIGRlZmF1bHRNb2RpZmllcnMsIGRldGVjdE92ZXJmbG93IH07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/popper-lite.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/popper.js":
/*!***************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/popper.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   applyStyles: function() { return /* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.applyStyles; },\n/* harmony export */   arrow: function() { return /* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.arrow; },\n/* harmony export */   computeStyles: function() { return /* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.computeStyles; },\n/* harmony export */   createPopper: function() { return /* binding */ createPopper; },\n/* harmony export */   createPopperLite: function() { return /* reexport safe */ _popper_lite_js__WEBPACK_IMPORTED_MODULE_11__.createPopper; },\n/* harmony export */   defaultModifiers: function() { return /* binding */ defaultModifiers; },\n/* harmony export */   detectOverflow: function() { return /* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_10__[\"default\"]; },\n/* harmony export */   eventListeners: function() { return /* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.eventListeners; },\n/* harmony export */   flip: function() { return /* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.flip; },\n/* harmony export */   hide: function() { return /* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.hide; },\n/* harmony export */   offset: function() { return /* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.offset; },\n/* harmony export */   popperGenerator: function() { return /* reexport safe */ _createPopper_js__WEBPACK_IMPORTED_MODULE_9__.popperGenerator; },\n/* harmony export */   popperOffsets: function() { return /* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.popperOffsets; },\n/* harmony export */   preventOverflow: function() { return /* reexport safe */ _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__.preventOverflow; }\n/* harmony export */ });\n/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./createPopper.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/createPopper.js\");\n/* harmony import */ var _createPopper_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./createPopper.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/detectOverflow.js\");\n/* harmony import */ var _modifiers_eventListeners_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modifiers/eventListeners.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/modifiers/eventListeners.js\");\n/* harmony import */ var _modifiers_popperOffsets_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modifiers/popperOffsets.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/modifiers/popperOffsets.js\");\n/* harmony import */ var _modifiers_computeStyles_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modifiers/computeStyles.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/modifiers/computeStyles.js\");\n/* harmony import */ var _modifiers_applyStyles_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./modifiers/applyStyles.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/modifiers/applyStyles.js\");\n/* harmony import */ var _modifiers_offset_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./modifiers/offset.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/modifiers/offset.js\");\n/* harmony import */ var _modifiers_flip_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./modifiers/flip.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/modifiers/flip.js\");\n/* harmony import */ var _modifiers_preventOverflow_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./modifiers/preventOverflow.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/modifiers/preventOverflow.js\");\n/* harmony import */ var _modifiers_arrow_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./modifiers/arrow.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/modifiers/arrow.js\");\n/* harmony import */ var _modifiers_hide_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./modifiers/hide.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/modifiers/hide.js\");\n/* harmony import */ var _popper_lite_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./popper-lite.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/popper-lite.js\");\n/* harmony import */ var _modifiers_index_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./modifiers/index.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/modifiers/index.js\");\n\n\n\n\n\n\n\n\n\n\nvar defaultModifiers = [_modifiers_eventListeners_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"], _modifiers_popperOffsets_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"], _modifiers_computeStyles_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"], _modifiers_applyStyles_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"], _modifiers_offset_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"], _modifiers_flip_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"], _modifiers_preventOverflow_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"], _modifiers_arrow_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"], _modifiers_hide_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"]];\nvar createPopper = /*#__PURE__*/(0,_createPopper_js__WEBPACK_IMPORTED_MODULE_9__.popperGenerator)({\n  defaultModifiers: defaultModifiers\n}); // eslint-disable-next-line import/no-unused-modules\n\n // eslint-disable-next-line import/no-unused-modules\n\n // eslint-disable-next-line import/no-unused-modules\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvcG9wcGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvRTtBQUNUO0FBQ0Y7QUFDQTtBQUNKO0FBQ1Y7QUFDSjtBQUNzQjtBQUNwQjtBQUNGO0FBQ3ZDLHdCQUF3QixvRUFBYyxFQUFFLG1FQUFhLEVBQUUsbUVBQWEsRUFBRSxpRUFBVyxFQUFFLDREQUFNLEVBQUUsMERBQUksRUFBRSxxRUFBZSxFQUFFLDJEQUFLLEVBQUUsMERBQUk7QUFDN0gsZ0NBQWdDLGlFQUFlO0FBQy9DO0FBQ0EsQ0FBQyxHQUFHOztBQUV1RSxDQUFDOztBQUVSLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi9wb3BwZXIuanM/YzBkNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBwb3BwZXJHZW5lcmF0b3IsIGRldGVjdE92ZXJmbG93IH0gZnJvbSBcIi4vY3JlYXRlUG9wcGVyLmpzXCI7XG5pbXBvcnQgZXZlbnRMaXN0ZW5lcnMgZnJvbSBcIi4vbW9kaWZpZXJzL2V2ZW50TGlzdGVuZXJzLmpzXCI7XG5pbXBvcnQgcG9wcGVyT2Zmc2V0cyBmcm9tIFwiLi9tb2RpZmllcnMvcG9wcGVyT2Zmc2V0cy5qc1wiO1xuaW1wb3J0IGNvbXB1dGVTdHlsZXMgZnJvbSBcIi4vbW9kaWZpZXJzL2NvbXB1dGVTdHlsZXMuanNcIjtcbmltcG9ydCBhcHBseVN0eWxlcyBmcm9tIFwiLi9tb2RpZmllcnMvYXBwbHlTdHlsZXMuanNcIjtcbmltcG9ydCBvZmZzZXQgZnJvbSBcIi4vbW9kaWZpZXJzL29mZnNldC5qc1wiO1xuaW1wb3J0IGZsaXAgZnJvbSBcIi4vbW9kaWZpZXJzL2ZsaXAuanNcIjtcbmltcG9ydCBwcmV2ZW50T3ZlcmZsb3cgZnJvbSBcIi4vbW9kaWZpZXJzL3ByZXZlbnRPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IGFycm93IGZyb20gXCIuL21vZGlmaWVycy9hcnJvdy5qc1wiO1xuaW1wb3J0IGhpZGUgZnJvbSBcIi4vbW9kaWZpZXJzL2hpZGUuanNcIjtcbnZhciBkZWZhdWx0TW9kaWZpZXJzID0gW2V2ZW50TGlzdGVuZXJzLCBwb3BwZXJPZmZzZXRzLCBjb21wdXRlU3R5bGVzLCBhcHBseVN0eWxlcywgb2Zmc2V0LCBmbGlwLCBwcmV2ZW50T3ZlcmZsb3csIGFycm93LCBoaWRlXTtcbnZhciBjcmVhdGVQb3BwZXIgPSAvKiNfX1BVUkVfXyovcG9wcGVyR2VuZXJhdG9yKHtcbiAgZGVmYXVsdE1vZGlmaWVyczogZGVmYXVsdE1vZGlmaWVyc1xufSk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IHsgY3JlYXRlUG9wcGVyLCBwb3BwZXJHZW5lcmF0b3IsIGRlZmF1bHRNb2RpZmllcnMsIGRldGVjdE92ZXJmbG93IH07IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IHsgY3JlYXRlUG9wcGVyIGFzIGNyZWF0ZVBvcHBlckxpdGUgfSBmcm9tIFwiLi9wb3BwZXItbGl0ZS5qc1wiOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbmV4cG9ydCAqIGZyb20gXCIuL21vZGlmaWVycy9pbmRleC5qc1wiOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/popper.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ computeAutoPlacement; }\n/* harmony export */ });\n/* harmony import */ var _getVariation_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getVariation.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/getVariation.js\");\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/enums.js\");\n/* harmony import */ var _detectOverflow_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./detectOverflow.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/detectOverflow.js\");\n/* harmony import */ var _getBasePlacement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getBasePlacement.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/getBasePlacement.js\");\n\n\n\n\nfunction computeAutoPlacement(state, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      placement = _options.placement,\n      boundary = _options.boundary,\n      rootBoundary = _options.rootBoundary,\n      padding = _options.padding,\n      flipVariations = _options.flipVariations,\n      _options$allowedAutoP = _options.allowedAutoPlacements,\n      allowedAutoPlacements = _options$allowedAutoP === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.placements : _options$allowedAutoP;\n  var variation = (0,_getVariation_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(placement);\n  var placements = variation ? flipVariations ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.variationPlacements : _enums_js__WEBPACK_IMPORTED_MODULE_0__.variationPlacements.filter(function (placement) {\n    return (0,_getVariation_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(placement) === variation;\n  }) : _enums_js__WEBPACK_IMPORTED_MODULE_0__.basePlacements;\n  var allowedPlacements = placements.filter(function (placement) {\n    return allowedAutoPlacements.indexOf(placement) >= 0;\n  });\n\n  if (allowedPlacements.length === 0) {\n    allowedPlacements = placements;\n  } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...\n\n\n  var overflows = allowedPlacements.reduce(function (acc, placement) {\n    acc[placement] = (0,_detectOverflow_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      padding: padding\n    })[(0,_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(placement)];\n    return acc;\n  }, {});\n  return Object.keys(overflows).sort(function (a, b) {\n    return overflows[a] - overflows[b];\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvY29tcHV0ZUF1dG9QbGFjZW1lbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBNkM7QUFDa0Q7QUFDOUM7QUFDSTtBQUN0QztBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxpREFBYTtBQUM5RSxrQkFBa0IsNERBQVk7QUFDOUIsZ0RBQWdELDBEQUFtQixHQUFHLDBEQUFtQjtBQUN6RixXQUFXLDREQUFZO0FBQ3ZCLEdBQUcsSUFBSSxxREFBYztBQUNyQjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQSxxQkFBcUIsOERBQWM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLEVBQUUsZ0VBQWdCO0FBQ3ZCO0FBQ0EsR0FBRyxJQUFJO0FBQ1A7QUFDQTtBQUNBLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2NvbXB1dGVBdXRvUGxhY2VtZW50LmpzPzVlZGMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGdldFZhcmlhdGlvbiBmcm9tIFwiLi9nZXRWYXJpYXRpb24uanNcIjtcbmltcG9ydCB7IHZhcmlhdGlvblBsYWNlbWVudHMsIGJhc2VQbGFjZW1lbnRzLCBwbGFjZW1lbnRzIGFzIGFsbFBsYWNlbWVudHMgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCBkZXRlY3RPdmVyZmxvdyBmcm9tIFwiLi9kZXRlY3RPdmVyZmxvdy5qc1wiO1xuaW1wb3J0IGdldEJhc2VQbGFjZW1lbnQgZnJvbSBcIi4vZ2V0QmFzZVBsYWNlbWVudC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY29tcHV0ZUF1dG9QbGFjZW1lbnQoc3RhdGUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICBwbGFjZW1lbnQgPSBfb3B0aW9ucy5wbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeSA9IF9vcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZyA9IF9vcHRpb25zLnBhZGRpbmcsXG4gICAgICBmbGlwVmFyaWF0aW9ucyA9IF9vcHRpb25zLmZsaXBWYXJpYXRpb25zLFxuICAgICAgX29wdGlvbnMkYWxsb3dlZEF1dG9QID0gX29wdGlvbnMuYWxsb3dlZEF1dG9QbGFjZW1lbnRzLFxuICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzID0gX29wdGlvbnMkYWxsb3dlZEF1dG9QID09PSB2b2lkIDAgPyBhbGxQbGFjZW1lbnRzIDogX29wdGlvbnMkYWxsb3dlZEF1dG9QO1xuICB2YXIgdmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCk7XG4gIHZhciBwbGFjZW1lbnRzID0gdmFyaWF0aW9uID8gZmxpcFZhcmlhdGlvbnMgPyB2YXJpYXRpb25QbGFjZW1lbnRzIDogdmFyaWF0aW9uUGxhY2VtZW50cy5maWx0ZXIoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgIHJldHVybiBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSA9PT0gdmFyaWF0aW9uO1xuICB9KSA6IGJhc2VQbGFjZW1lbnRzO1xuICB2YXIgYWxsb3dlZFBsYWNlbWVudHMgPSBwbGFjZW1lbnRzLmZpbHRlcihmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIGFsbG93ZWRBdXRvUGxhY2VtZW50cy5pbmRleE9mKHBsYWNlbWVudCkgPj0gMDtcbiAgfSk7XG5cbiAgaWYgKGFsbG93ZWRQbGFjZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGFsbG93ZWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cztcbiAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXTogRmxvdyBzZWVtcyB0byBoYXZlIHByb2JsZW1zIHdpdGggdHdvIGFycmF5IHVuaW9ucy4uLlxuXG5cbiAgdmFyIG92ZXJmbG93cyA9IGFsbG93ZWRQbGFjZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgICBhY2NbcGxhY2VtZW50XSA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZzogcGFkZGluZ1xuICAgIH0pW2dldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KV07XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuICByZXR1cm4gT2JqZWN0LmtleXMob3ZlcmZsb3dzKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIG92ZXJmbG93c1thXSAtIG92ZXJmbG93c1tiXTtcbiAgfSk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/computeOffsets.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/computeOffsets.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ computeOffsets; }\n/* harmony export */ });\n/* harmony import */ var _getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getBasePlacement.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/getBasePlacement.js\");\n/* harmony import */ var _getVariation_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./getVariation.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/getVariation.js\");\n/* harmony import */ var _getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./getMainAxisFromPlacement.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js\");\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../enums.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/enums.js\");\n\n\n\n\nfunction computeOffsets(_ref) {\n  var reference = _ref.reference,\n      element = _ref.element,\n      placement = _ref.placement;\n  var basePlacement = placement ? (0,_getBasePlacement_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(placement) : null;\n  var variation = placement ? (0,_getVariation_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(placement) : null;\n  var commonX = reference.x + reference.width / 2 - element.width / 2;\n  var commonY = reference.y + reference.height / 2 - element.height / 2;\n  var offsets;\n\n  switch (basePlacement) {\n    case _enums_js__WEBPACK_IMPORTED_MODULE_2__.top:\n      offsets = {\n        x: commonX,\n        y: reference.y - element.height\n      };\n      break;\n\n    case _enums_js__WEBPACK_IMPORTED_MODULE_2__.bottom:\n      offsets = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n\n    case _enums_js__WEBPACK_IMPORTED_MODULE_2__.right:\n      offsets = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n\n    case _enums_js__WEBPACK_IMPORTED_MODULE_2__.left:\n      offsets = {\n        x: reference.x - element.width,\n        y: commonY\n      };\n      break;\n\n    default:\n      offsets = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n\n  var mainAxis = basePlacement ? (0,_getMainAxisFromPlacement_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(basePlacement) : null;\n\n  if (mainAxis != null) {\n    var len = mainAxis === 'y' ? 'height' : 'width';\n\n    switch (variation) {\n      case _enums_js__WEBPACK_IMPORTED_MODULE_2__.start:\n        offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);\n        break;\n\n      case _enums_js__WEBPACK_IMPORTED_MODULE_2__.end:\n        offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);\n        break;\n\n      default:\n    }\n  }\n\n  return offsets;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvY29tcHV0ZU9mZnNldHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBcUQ7QUFDUjtBQUN3QjtBQUNGO0FBQ3BEO0FBQ2Y7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGdFQUFnQjtBQUNsRCw4QkFBOEIsNERBQVk7QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUywwQ0FBRztBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyw2Q0FBTTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyw0Q0FBSztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUywyQ0FBSTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyx3RUFBd0I7O0FBRXpEO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLDRDQUFLO0FBQ2hCO0FBQ0E7O0FBRUEsV0FBVywwQ0FBRztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9jb21wdXRlT2Zmc2V0cy5qcz8zMDUzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBnZXRCYXNlUGxhY2VtZW50IGZyb20gXCIuL2dldEJhc2VQbGFjZW1lbnQuanNcIjtcbmltcG9ydCBnZXRWYXJpYXRpb24gZnJvbSBcIi4vZ2V0VmFyaWF0aW9uLmpzXCI7XG5pbXBvcnQgZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50IGZyb20gXCIuL2dldE1haW5BeGlzRnJvbVBsYWNlbWVudC5qc1wiO1xuaW1wb3J0IHsgdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0LCBzdGFydCwgZW5kIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb21wdXRlT2Zmc2V0cyhfcmVmKSB7XG4gIHZhciByZWZlcmVuY2UgPSBfcmVmLnJlZmVyZW5jZSxcbiAgICAgIGVsZW1lbnQgPSBfcmVmLmVsZW1lbnQsXG4gICAgICBwbGFjZW1lbnQgPSBfcmVmLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQgPyBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgOiBudWxsO1xuICB2YXIgdmFyaWF0aW9uID0gcGxhY2VtZW50ID8gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgOiBudWxsO1xuICB2YXIgY29tbW9uWCA9IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoIC8gMiAtIGVsZW1lbnQud2lkdGggLyAyO1xuICB2YXIgY29tbW9uWSA9IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodCAvIDIgLSBlbGVtZW50LmhlaWdodCAvIDI7XG4gIHZhciBvZmZzZXRzO1xuXG4gIHN3aXRjaCAoYmFzZVBsYWNlbWVudCkge1xuICAgIGNhc2UgdG9wOlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgLSBlbGVtZW50LmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBib3R0b206XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICB5OiByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcmlnaHQ6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCxcbiAgICAgICAgeTogY29tbW9uWVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBsZWZ0OlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLnggLSBlbGVtZW50LndpZHRoLFxuICAgICAgICB5OiBjb21tb25ZXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLngsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55XG4gICAgICB9O1xuICB9XG5cbiAgdmFyIG1haW5BeGlzID0gYmFzZVBsYWNlbWVudCA/IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KSA6IG51bGw7XG5cbiAgaWYgKG1haW5BeGlzICE9IG51bGwpIHtcbiAgICB2YXIgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICAgIHN3aXRjaCAodmFyaWF0aW9uKSB7XG4gICAgICBjYXNlIHN0YXJ0OlxuICAgICAgICBvZmZzZXRzW21haW5BeGlzXSA9IG9mZnNldHNbbWFpbkF4aXNdIC0gKHJlZmVyZW5jZVtsZW5dIC8gMiAtIGVsZW1lbnRbbGVuXSAvIDIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBlbmQ6XG4gICAgICAgIG9mZnNldHNbbWFpbkF4aXNdID0gb2Zmc2V0c1ttYWluQXhpc10gKyAocmVmZXJlbmNlW2xlbl0gLyAyIC0gZWxlbWVudFtsZW5dIC8gMik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvZmZzZXRzO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/computeOffsets.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/debounce.js":
/*!***********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/debounce.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ debounce; }\n/* harmony export */ });\nfunction debounce(fn) {\n  var pending;\n  return function () {\n    if (!pending) {\n      pending = new Promise(function (resolve) {\n        Promise.resolve().then(function () {\n          pending = undefined;\n          resolve(fn());\n        });\n      });\n    }\n\n    return pending;\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZGVib3VuY2UuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2RlYm91bmNlLmpzPzUwNmIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGVib3VuY2UoZm4pIHtcbiAgdmFyIHBlbmRpbmc7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFwZW5kaW5nKSB7XG4gICAgICBwZW5kaW5nID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcGVuZGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICByZXNvbHZlKGZuKCkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBwZW5kaW5nO1xuICB9O1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/debounce.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/detectOverflow.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/detectOverflow.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ detectOverflow; }\n/* harmony export */ });\n/* harmony import */ var _dom_utils_getClippingRect_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../dom-utils/getClippingRect.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js\");\n/* harmony import */ var _dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../dom-utils/getDocumentElement.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js\");\n/* harmony import */ var _dom_utils_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../dom-utils/getBoundingClientRect.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js\");\n/* harmony import */ var _computeOffsets_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./computeOffsets.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/computeOffsets.js\");\n/* harmony import */ var _rectToClientRect_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./rectToClientRect.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/rectToClientRect.js\");\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/enums.js\");\n/* harmony import */ var _dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../dom-utils/instanceOf.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/dom-utils/instanceOf.js\");\n/* harmony import */ var _mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mergePaddingObject.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js\");\n/* harmony import */ var _expandToHashMap_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./expandToHashMap.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/expandToHashMap.js\");\n\n\n\n\n\n\n\n\n // eslint-disable-next-line import/no-unused-modules\n\nfunction detectOverflow(state, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      _options$placement = _options.placement,\n      placement = _options$placement === void 0 ? state.placement : _options$placement,\n      _options$strategy = _options.strategy,\n      strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,\n      _options$boundary = _options.boundary,\n      boundary = _options$boundary === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.clippingParents : _options$boundary,\n      _options$rootBoundary = _options.rootBoundary,\n      rootBoundary = _options$rootBoundary === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.viewport : _options$rootBoundary,\n      _options$elementConte = _options.elementContext,\n      elementContext = _options$elementConte === void 0 ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper : _options$elementConte,\n      _options$altBoundary = _options.altBoundary,\n      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,\n      _options$padding = _options.padding,\n      padding = _options$padding === void 0 ? 0 : _options$padding;\n  var paddingObject = (0,_mergePaddingObject_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(typeof padding !== 'number' ? padding : (0,_expandToHashMap_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(padding, _enums_js__WEBPACK_IMPORTED_MODULE_0__.basePlacements));\n  var altContext = elementContext === _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper ? _enums_js__WEBPACK_IMPORTED_MODULE_0__.reference : _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper;\n  var popperRect = state.rects.popper;\n  var element = state.elements[altBoundary ? altContext : elementContext];\n  var clippingClientRect = (0,_dom_utils_getClippingRect_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])((0,_dom_utils_instanceOf_js__WEBPACK_IMPORTED_MODULE_4__.isElement)(element) ? element : element.contextElement || (0,_dom_utils_getDocumentElement_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(state.elements.popper), boundary, rootBoundary, strategy);\n  var referenceClientRect = (0,_dom_utils_getBoundingClientRect_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(state.elements.reference);\n  var popperOffsets = (0,_computeOffsets_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"])({\n    reference: referenceClientRect,\n    element: popperRect,\n    strategy: 'absolute',\n    placement: placement\n  });\n  var popperClientRect = (0,_rectToClientRect_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(Object.assign({}, popperRect, popperOffsets));\n  var elementClientRect = elementContext === _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect\n  // 0 or negative = within the clipping rect\n\n  var overflowOffsets = {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element\n\n  if (elementContext === _enums_js__WEBPACK_IMPORTED_MODULE_0__.popper && offsetData) {\n    var offset = offsetData[placement];\n    Object.keys(overflowOffsets).forEach(function (key) {\n      var multiply = [_enums_js__WEBPACK_IMPORTED_MODULE_0__.right, _enums_js__WEBPACK_IMPORTED_MODULE_0__.bottom].indexOf(key) >= 0 ? 1 : -1;\n      var axis = [_enums_js__WEBPACK_IMPORTED_MODULE_0__.top, _enums_js__WEBPACK_IMPORTED_MODULE_0__.bottom].indexOf(key) >= 0 ? 'y' : 'x';\n      overflowOffsets[key] += offset[axis] * multiply;\n    });\n  }\n\n  return overflowOffsets;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZGV0ZWN0T3ZlcmZsb3cuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUE4RDtBQUNNO0FBQ007QUFDekI7QUFDSTtBQUMwRDtBQUN4RDtBQUNFO0FBQ04sQ0FBQzs7QUFFckM7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELHNEQUFlO0FBQy9EO0FBQ0Esd0RBQXdELCtDQUFRO0FBQ2hFO0FBQ0EsMERBQTBELDZDQUFNO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtFQUFrQix5Q0FBeUMsK0RBQWUsVUFBVSxxREFBYztBQUN4SCxzQ0FBc0MsNkNBQU0sR0FBRyxnREFBUyxHQUFHLDZDQUFNO0FBQ2pFO0FBQ0E7QUFDQSwyQkFBMkIseUVBQWUsQ0FBQyxtRUFBUyxnREFBZ0QsNEVBQWtCO0FBQ3RILDRCQUE0QiwrRUFBcUI7QUFDakQsc0JBQXNCLDhEQUFjO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILHlCQUF5QixnRUFBZ0IsaUJBQWlCO0FBQzFELDZDQUE2Qyw2Q0FBTSwyQ0FBMkM7QUFDOUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDOztBQUUvQyx5QkFBeUIsNkNBQU07QUFDL0I7QUFDQTtBQUNBLHNCQUFzQiw0Q0FBSyxFQUFFLDZDQUFNO0FBQ25DLGtCQUFrQiwwQ0FBRyxFQUFFLDZDQUFNO0FBQzdCO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9kZXRlY3RPdmVyZmxvdy5qcz9lZDczIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBnZXRDbGlwcGluZ1JlY3QgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRDbGlwcGluZ1JlY3QuanNcIjtcbmltcG9ydCBnZXREb2N1bWVudEVsZW1lbnQgZnJvbSBcIi4uL2RvbS11dGlscy9nZXREb2N1bWVudEVsZW1lbnQuanNcIjtcbmltcG9ydCBnZXRCb3VuZGluZ0NsaWVudFJlY3QgZnJvbSBcIi4uL2RvbS11dGlscy9nZXRCb3VuZGluZ0NsaWVudFJlY3QuanNcIjtcbmltcG9ydCBjb21wdXRlT2Zmc2V0cyBmcm9tIFwiLi9jb21wdXRlT2Zmc2V0cy5qc1wiO1xuaW1wb3J0IHJlY3RUb0NsaWVudFJlY3QgZnJvbSBcIi4vcmVjdFRvQ2xpZW50UmVjdC5qc1wiO1xuaW1wb3J0IHsgY2xpcHBpbmdQYXJlbnRzLCByZWZlcmVuY2UsIHBvcHBlciwgYm90dG9tLCB0b3AsIHJpZ2h0LCBiYXNlUGxhY2VtZW50cywgdmlld3BvcnQgfSBmcm9tIFwiLi4vZW51bXMuanNcIjtcbmltcG9ydCB7IGlzRWxlbWVudCB9IGZyb20gXCIuLi9kb20tdXRpbHMvaW5zdGFuY2VPZi5qc1wiO1xuaW1wb3J0IG1lcmdlUGFkZGluZ09iamVjdCBmcm9tIFwiLi9tZXJnZVBhZGRpbmdPYmplY3QuanNcIjtcbmltcG9ydCBleHBhbmRUb0hhc2hNYXAgZnJvbSBcIi4vZXhwYW5kVG9IYXNoTWFwLmpzXCI7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHZhciBfb3B0aW9ucyA9IG9wdGlvbnMsXG4gICAgICBfb3B0aW9ucyRwbGFjZW1lbnQgPSBfb3B0aW9ucy5wbGFjZW1lbnQsXG4gICAgICBwbGFjZW1lbnQgPSBfb3B0aW9ucyRwbGFjZW1lbnQgPT09IHZvaWQgMCA/IHN0YXRlLnBsYWNlbWVudCA6IF9vcHRpb25zJHBsYWNlbWVudCxcbiAgICAgIF9vcHRpb25zJHN0cmF0ZWd5ID0gX29wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICBzdHJhdGVneSA9IF9vcHRpb25zJHN0cmF0ZWd5ID09PSB2b2lkIDAgPyBzdGF0ZS5zdHJhdGVneSA6IF9vcHRpb25zJHN0cmF0ZWd5LFxuICAgICAgX29wdGlvbnMkYm91bmRhcnkgPSBfb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgIGJvdW5kYXJ5ID0gX29wdGlvbnMkYm91bmRhcnkgPT09IHZvaWQgMCA/IGNsaXBwaW5nUGFyZW50cyA6IF9vcHRpb25zJGJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMucm9vdEJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMkcm9vdEJvdW5kYXJ5ID09PSB2b2lkIDAgPyB2aWV3cG9ydCA6IF9vcHRpb25zJHJvb3RCb3VuZGFyeSxcbiAgICAgIF9vcHRpb25zJGVsZW1lbnRDb250ZSA9IF9vcHRpb25zLmVsZW1lbnRDb250ZXh0LFxuICAgICAgZWxlbWVudENvbnRleHQgPSBfb3B0aW9ucyRlbGVtZW50Q29udGUgPT09IHZvaWQgMCA/IHBvcHBlciA6IF9vcHRpb25zJGVsZW1lbnRDb250ZSxcbiAgICAgIF9vcHRpb25zJGFsdEJvdW5kYXJ5ID0gX29wdGlvbnMuYWx0Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeSA9IF9vcHRpb25zJGFsdEJvdW5kYXJ5ID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGFsdEJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkcGFkZGluZyA9IF9vcHRpb25zLnBhZGRpbmcsXG4gICAgICBwYWRkaW5nID0gX29wdGlvbnMkcGFkZGluZyA9PT0gdm9pZCAwID8gMCA6IF9vcHRpb25zJHBhZGRpbmc7XG4gIHZhciBwYWRkaW5nT2JqZWN0ID0gbWVyZ2VQYWRkaW5nT2JqZWN0KHR5cGVvZiBwYWRkaW5nICE9PSAnbnVtYmVyJyA/IHBhZGRpbmcgOiBleHBhbmRUb0hhc2hNYXAocGFkZGluZywgYmFzZVBsYWNlbWVudHMpKTtcbiAgdmFyIGFsdENvbnRleHQgPSBlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyID8gcmVmZXJlbmNlIDogcG9wcGVyO1xuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgdmFyIGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1thbHRCb3VuZGFyeSA/IGFsdENvbnRleHQgOiBlbGVtZW50Q29udGV4dF07XG4gIHZhciBjbGlwcGluZ0NsaWVudFJlY3QgPSBnZXRDbGlwcGluZ1JlY3QoaXNFbGVtZW50KGVsZW1lbnQpID8gZWxlbWVudCA6IGVsZW1lbnQuY29udGV4dEVsZW1lbnQgfHwgZ2V0RG9jdW1lbnRFbGVtZW50KHN0YXRlLmVsZW1lbnRzLnBvcHBlciksIGJvdW5kYXJ5LCByb290Qm91bmRhcnksIHN0cmF0ZWd5KTtcbiAgdmFyIHJlZmVyZW5jZUNsaWVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qoc3RhdGUuZWxlbWVudHMucmVmZXJlbmNlKTtcbiAgdmFyIHBvcHBlck9mZnNldHMgPSBjb21wdXRlT2Zmc2V0cyh7XG4gICAgcmVmZXJlbmNlOiByZWZlcmVuY2VDbGllbnRSZWN0LFxuICAgIGVsZW1lbnQ6IHBvcHBlclJlY3QsXG4gICAgc3RyYXRlZ3k6ICdhYnNvbHV0ZScsXG4gICAgcGxhY2VtZW50OiBwbGFjZW1lbnRcbiAgfSk7XG4gIHZhciBwb3BwZXJDbGllbnRSZWN0ID0gcmVjdFRvQ2xpZW50UmVjdChPYmplY3QuYXNzaWduKHt9LCBwb3BwZXJSZWN0LCBwb3BwZXJPZmZzZXRzKSk7XG4gIHZhciBlbGVtZW50Q2xpZW50UmVjdCA9IGVsZW1lbnRDb250ZXh0ID09PSBwb3BwZXIgPyBwb3BwZXJDbGllbnRSZWN0IDogcmVmZXJlbmNlQ2xpZW50UmVjdDsgLy8gcG9zaXRpdmUgPSBvdmVyZmxvd2luZyB0aGUgY2xpcHBpbmcgcmVjdFxuICAvLyAwIG9yIG5lZ2F0aXZlID0gd2l0aGluIHRoZSBjbGlwcGluZyByZWN0XG5cbiAgdmFyIG92ZXJmbG93T2Zmc2V0cyA9IHtcbiAgICB0b3A6IGNsaXBwaW5nQ2xpZW50UmVjdC50b3AgLSBlbGVtZW50Q2xpZW50UmVjdC50b3AgKyBwYWRkaW5nT2JqZWN0LnRvcCxcbiAgICBib3R0b206IGVsZW1lbnRDbGllbnRSZWN0LmJvdHRvbSAtIGNsaXBwaW5nQ2xpZW50UmVjdC5ib3R0b20gKyBwYWRkaW5nT2JqZWN0LmJvdHRvbSxcbiAgICBsZWZ0OiBjbGlwcGluZ0NsaWVudFJlY3QubGVmdCAtIGVsZW1lbnRDbGllbnRSZWN0LmxlZnQgKyBwYWRkaW5nT2JqZWN0LmxlZnQsXG4gICAgcmlnaHQ6IGVsZW1lbnRDbGllbnRSZWN0LnJpZ2h0IC0gY2xpcHBpbmdDbGllbnRSZWN0LnJpZ2h0ICsgcGFkZGluZ09iamVjdC5yaWdodFxuICB9O1xuICB2YXIgb2Zmc2V0RGF0YSA9IHN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0OyAvLyBPZmZzZXRzIGNhbiBiZSBhcHBsaWVkIG9ubHkgdG8gdGhlIHBvcHBlciBlbGVtZW50XG5cbiAgaWYgKGVsZW1lbnRDb250ZXh0ID09PSBwb3BwZXIgJiYgb2Zmc2V0RGF0YSkge1xuICAgIHZhciBvZmZzZXQgPSBvZmZzZXREYXRhW3BsYWNlbWVudF07XG4gICAgT2JqZWN0LmtleXMob3ZlcmZsb3dPZmZzZXRzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciBtdWx0aXBseSA9IFtyaWdodCwgYm90dG9tXS5pbmRleE9mKGtleSkgPj0gMCA/IDEgOiAtMTtcbiAgICAgIHZhciBheGlzID0gW3RvcCwgYm90dG9tXS5pbmRleE9mKGtleSkgPj0gMCA/ICd5JyA6ICd4JztcbiAgICAgIG92ZXJmbG93T2Zmc2V0c1trZXldICs9IG9mZnNldFtheGlzXSAqIG11bHRpcGx5O1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIG92ZXJmbG93T2Zmc2V0cztcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/detectOverflow.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/expandToHashMap.js":
/*!******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/expandToHashMap.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ expandToHashMap; }\n/* harmony export */ });\nfunction expandToHashMap(value, keys) {\n  return keys.reduce(function (hashMap, key) {\n    hashMap[key] = value;\n    return hashMap;\n  }, {});\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZXhwYW5kVG9IYXNoTWFwLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLEdBQUcsSUFBSTtBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZXhwYW5kVG9IYXNoTWFwLmpzPzAzZGMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZXhwYW5kVG9IYXNoTWFwKHZhbHVlLCBrZXlzKSB7XG4gIHJldHVybiBrZXlzLnJlZHVjZShmdW5jdGlvbiAoaGFzaE1hcCwga2V5KSB7XG4gICAgaGFzaE1hcFtrZXldID0gdmFsdWU7XG4gICAgcmV0dXJuIGhhc2hNYXA7XG4gIH0sIHt9KTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/expandToHashMap.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/getAltAxis.js":
/*!*************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getAltAxis.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ getAltAxis; }\n/* harmony export */ });\nfunction getAltAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0QWx0QXhpcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWU7QUFDZjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0QWx0QXhpcy5qcz81OWU0Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEFsdEF4aXMoYXhpcykge1xuICByZXR1cm4gYXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/getAltAxis.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/getBasePlacement.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getBasePlacement.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ getBasePlacement; }\n/* harmony export */ });\n\nfunction getBasePlacement(placement) {\n  return placement.split('-')[0];\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0QmFzZVBsYWNlbWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQW1DO0FBQ3BCO0FBQ2Y7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldEJhc2VQbGFjZW1lbnQuanM/YmRhZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhdXRvIH0gZnJvbSBcIi4uL2VudW1zLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/getBasePlacement.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ getFreshSideObject; }\n/* harmony export */ });\nfunction getFreshSideObject() {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0RnJlc2hTaWRlT2JqZWN0LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0RnJlc2hTaWRlT2JqZWN0LmpzP2VlODgiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0RnJlc2hTaWRlT2JqZWN0KCkge1xuICByZXR1cm4ge1xuICAgIHRvcDogMCxcbiAgICByaWdodDogMCxcbiAgICBib3R0b206IDAsXG4gICAgbGVmdDogMFxuICB9O1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ getMainAxisFromPlacement; }\n/* harmony export */ });\nfunction getMainAxisFromPlacement(placement) {\n  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBZTtBQUNmO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQuanM/MzBmNSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBbJ3RvcCcsICdib3R0b20nXS5pbmRleE9mKHBsYWNlbWVudCkgPj0gMCA/ICd4JyA6ICd5Jztcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ getOppositePlacement; }\n/* harmony export */ });\nvar hash = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, function (matched) {\n    return hash[matched];\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0T3Bwb3NpdGVQbGFjZW1lbnQuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBLEdBQUc7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHBvcHBlcmpzL2NvcmUvbGliL3V0aWxzL2dldE9wcG9zaXRlUGxhY2VtZW50LmpzPzQxY2MiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGhhc2ggPSB7XG4gIGxlZnQ6ICdyaWdodCcsXG4gIHJpZ2h0OiAnbGVmdCcsXG4gIGJvdHRvbTogJ3RvcCcsXG4gIHRvcDogJ2JvdHRvbSdcbn07XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZywgZnVuY3Rpb24gKG1hdGNoZWQpIHtcbiAgICByZXR1cm4gaGFzaFttYXRjaGVkXTtcbiAgfSk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/getOppositePlacement.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ getOppositeVariationPlacement; }\n/* harmony export */ });\nvar hash = {\n  start: 'end',\n  end: 'start'\n};\nfunction getOppositeVariationPlacement(placement) {\n  return placement.replace(/start|end/g, function (matched) {\n    return hash[matched];\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBO0FBQ0EsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQuanM/ZjA3YiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgaGFzaCA9IHtcbiAgc3RhcnQ6ICdlbmQnLFxuICBlbmQ6ICdzdGFydCdcbn07XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9zdGFydHxlbmQvZywgZnVuY3Rpb24gKG1hdGNoZWQpIHtcbiAgICByZXR1cm4gaGFzaFttYXRjaGVkXTtcbiAgfSk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/getVariation.js":
/*!***************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/getVariation.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ getVariation; }\n/* harmony export */ });\nfunction getVariation(placement) {\n  return placement.split('-')[1];\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvZ2V0VmFyaWF0aW9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBZTtBQUNmO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9nZXRWYXJpYXRpb24uanM/NTc2YSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/getVariation.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/math.js":
/*!*******************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/math.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   max: function() { return /* binding */ max; },\n/* harmony export */   min: function() { return /* binding */ min; },\n/* harmony export */   round: function() { return /* binding */ round; }\n/* harmony export */ });\nvar max = Math.max;\nvar min = Math.min;\nvar round = Math.round;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvbWF0aC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBTztBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9tYXRoLmpzPzIzYjgiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHZhciBtYXggPSBNYXRoLm1heDtcbmV4cG9ydCB2YXIgbWluID0gTWF0aC5taW47XG5leHBvcnQgdmFyIHJvdW5kID0gTWF0aC5yb3VuZDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/math.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/mergeByName.js":
/*!**************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/mergeByName.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ mergeByName; }\n/* harmony export */ });\nfunction mergeByName(modifiers) {\n  var merged = modifiers.reduce(function (merged, current) {\n    var existing = merged[current.name];\n    merged[current.name] = existing ? Object.assign({}, existing, current, {\n      options: Object.assign({}, existing.options, current.options),\n      data: Object.assign({}, existing.data, current.data)\n    }) : current;\n    return merged;\n  }, {}); // IE11 does not support Object.values\n\n  return Object.keys(merged).map(function (key) {\n    return merged[key];\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvbWVyZ2VCeU5hbWUuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFlO0FBQ2Y7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RCwrQkFBK0I7QUFDL0IsNEJBQTRCO0FBQzVCLEtBQUs7QUFDTDtBQUNBLEdBQUcsSUFBSSxHQUFHOztBQUVWO0FBQ0E7QUFDQSxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9tZXJnZUJ5TmFtZS5qcz9iMDE1Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1lcmdlQnlOYW1lKG1vZGlmaWVycykge1xuICB2YXIgbWVyZ2VkID0gbW9kaWZpZXJzLnJlZHVjZShmdW5jdGlvbiAobWVyZ2VkLCBjdXJyZW50KSB7XG4gICAgdmFyIGV4aXN0aW5nID0gbWVyZ2VkW2N1cnJlbnQubmFtZV07XG4gICAgbWVyZ2VkW2N1cnJlbnQubmFtZV0gPSBleGlzdGluZyA/IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nLCBjdXJyZW50LCB7XG4gICAgICBvcHRpb25zOiBPYmplY3QuYXNzaWduKHt9LCBleGlzdGluZy5vcHRpb25zLCBjdXJyZW50Lm9wdGlvbnMpLFxuICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7fSwgZXhpc3RpbmcuZGF0YSwgY3VycmVudC5kYXRhKVxuICAgIH0pIDogY3VycmVudDtcbiAgICByZXR1cm4gbWVyZ2VkO1xuICB9LCB7fSk7IC8vIElFMTEgZG9lcyBub3Qgc3VwcG9ydCBPYmplY3QudmFsdWVzXG5cbiAgcmV0dXJuIE9iamVjdC5rZXlzKG1lcmdlZCkubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gbWVyZ2VkW2tleV07XG4gIH0pO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/mergeByName.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ mergePaddingObject; }\n/* harmony export */ });\n/* harmony import */ var _getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getFreshSideObject.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/getFreshSideObject.js\");\n\nfunction mergePaddingObject(paddingObject) {\n  return Object.assign({}, (0,_getFreshSideObject_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(), paddingObject);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvbWVyZ2VQYWRkaW5nT2JqZWN0LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQXlEO0FBQzFDO0FBQ2YseUJBQXlCLEVBQUUsa0VBQWtCO0FBQzdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvbWVyZ2VQYWRkaW5nT2JqZWN0LmpzP2Q2ZjMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGdldEZyZXNoU2lkZU9iamVjdCBmcm9tIFwiLi9nZXRGcmVzaFNpZGVPYmplY3QuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG1lcmdlUGFkZGluZ09iamVjdChwYWRkaW5nT2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBnZXRGcmVzaFNpZGVPYmplY3QoKSwgcGFkZGluZ09iamVjdCk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/mergePaddingObject.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/orderModifiers.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/orderModifiers.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ orderModifiers; }\n/* harmony export */ });\n/* harmony import */ var _enums_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/enums.js\");\n // source: https://stackoverflow.com/questions/49875255\n\nfunction order(modifiers) {\n  var map = new Map();\n  var visited = new Set();\n  var result = [];\n  modifiers.forEach(function (modifier) {\n    map.set(modifier.name, modifier);\n  }); // On visiting object, check for its dependencies and visit them recursively\n\n  function sort(modifier) {\n    visited.add(modifier.name);\n    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);\n    requires.forEach(function (dep) {\n      if (!visited.has(dep)) {\n        var depModifier = map.get(dep);\n\n        if (depModifier) {\n          sort(depModifier);\n        }\n      }\n    });\n    result.push(modifier);\n  }\n\n  modifiers.forEach(function (modifier) {\n    if (!visited.has(modifier.name)) {\n      // check for visited object\n      sort(modifier);\n    }\n  });\n  return result;\n}\n\nfunction orderModifiers(modifiers) {\n  // order based on dependencies\n  var orderedModifiers = order(modifiers); // order based on phase\n\n  return _enums_js__WEBPACK_IMPORTED_MODULE_0__.modifierPhases.reduce(function (acc, phase) {\n    return acc.concat(orderedModifiers.filter(function (modifier) {\n      return modifier.phase === phase;\n    }));\n  }, []);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvb3JkZXJNb2RpZmllcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBNkMsQ0FBQzs7QUFFOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxHQUFHOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFZTtBQUNmO0FBQ0EsMkNBQTJDOztBQUUzQyxTQUFTLHFEQUFjO0FBQ3ZCO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvb3JkZXJNb2RpZmllcnMuanM/N2M1YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBtb2RpZmllclBoYXNlcyB9IGZyb20gXCIuLi9lbnVtcy5qc1wiOyAvLyBzb3VyY2U6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ5ODc1MjU1XG5cbmZ1bmN0aW9uIG9yZGVyKG1vZGlmaWVycykge1xuICB2YXIgbWFwID0gbmV3IE1hcCgpO1xuICB2YXIgdmlzaXRlZCA9IG5ldyBTZXQoKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBtb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICBtYXAuc2V0KG1vZGlmaWVyLm5hbWUsIG1vZGlmaWVyKTtcbiAgfSk7IC8vIE9uIHZpc2l0aW5nIG9iamVjdCwgY2hlY2sgZm9yIGl0cyBkZXBlbmRlbmNpZXMgYW5kIHZpc2l0IHRoZW0gcmVjdXJzaXZlbHlcblxuICBmdW5jdGlvbiBzb3J0KG1vZGlmaWVyKSB7XG4gICAgdmlzaXRlZC5hZGQobW9kaWZpZXIubmFtZSk7XG4gICAgdmFyIHJlcXVpcmVzID0gW10uY29uY2F0KG1vZGlmaWVyLnJlcXVpcmVzIHx8IFtdLCBtb2RpZmllci5yZXF1aXJlc0lmRXhpc3RzIHx8IFtdKTtcbiAgICByZXF1aXJlcy5mb3JFYWNoKGZ1bmN0aW9uIChkZXApIHtcbiAgICAgIGlmICghdmlzaXRlZC5oYXMoZGVwKSkge1xuICAgICAgICB2YXIgZGVwTW9kaWZpZXIgPSBtYXAuZ2V0KGRlcCk7XG5cbiAgICAgICAgaWYgKGRlcE1vZGlmaWVyKSB7XG4gICAgICAgICAgc29ydChkZXBNb2RpZmllcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXN1bHQucHVzaChtb2RpZmllcik7XG4gIH1cblxuICBtb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICBpZiAoIXZpc2l0ZWQuaGFzKG1vZGlmaWVyLm5hbWUpKSB7XG4gICAgICAvLyBjaGVjayBmb3IgdmlzaXRlZCBvYmplY3RcbiAgICAgIHNvcnQobW9kaWZpZXIpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG9yZGVyTW9kaWZpZXJzKG1vZGlmaWVycykge1xuICAvLyBvcmRlciBiYXNlZCBvbiBkZXBlbmRlbmNpZXNcbiAgdmFyIG9yZGVyZWRNb2RpZmllcnMgPSBvcmRlcihtb2RpZmllcnMpOyAvLyBvcmRlciBiYXNlZCBvbiBwaGFzZVxuXG4gIHJldHVybiBtb2RpZmllclBoYXNlcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGhhc2UpIHtcbiAgICByZXR1cm4gYWNjLmNvbmNhdChvcmRlcmVkTW9kaWZpZXJzLmZpbHRlcihmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICAgIHJldHVybiBtb2RpZmllci5waGFzZSA9PT0gcGhhc2U7XG4gICAgfSkpO1xuICB9LCBbXSk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/orderModifiers.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/rectToClientRect.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/rectToClientRect.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ rectToClientRect; }\n/* harmony export */ });\nfunction rectToClientRect(rect) {\n  return Object.assign({}, rect, {\n    left: rect.x,\n    top: rect.y,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  });\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvcmVjdFRvQ2xpZW50UmVjdC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWU7QUFDZix5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bwb3BwZXJqcy9jb3JlL2xpYi91dGlscy9yZWN0VG9DbGllbnRSZWN0LmpzPzliY2EiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVjdFRvQ2xpZW50UmVjdChyZWN0KSB7XG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCByZWN0LCB7XG4gICAgbGVmdDogcmVjdC54LFxuICAgIHRvcDogcmVjdC55LFxuICAgIHJpZ2h0OiByZWN0LnggKyByZWN0LndpZHRoLFxuICAgIGJvdHRvbTogcmVjdC55ICsgcmVjdC5oZWlnaHRcbiAgfSk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/rectToClientRect.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/userAgent.js":
/*!************************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/userAgent.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ getUAString; }\n/* harmony export */ });\nfunction getUAString() {\n  var uaData = navigator.userAgentData;\n\n  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {\n    return uaData.brands.map(function (item) {\n      return item.brand + \"/\" + item.version;\n    }).join(' ');\n  }\n\n  return navigator.userAgent;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvdXNlckFnZW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvdXNlckFnZW50LmpzP2JmZjAiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0VUFTdHJpbmcoKSB7XG4gIHZhciB1YURhdGEgPSBuYXZpZ2F0b3IudXNlckFnZW50RGF0YTtcblxuICBpZiAodWFEYXRhICE9IG51bGwgJiYgdWFEYXRhLmJyYW5kcyAmJiBBcnJheS5pc0FycmF5KHVhRGF0YS5icmFuZHMpKSB7XG4gICAgcmV0dXJuIHVhRGF0YS5icmFuZHMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gaXRlbS5icmFuZCArIFwiL1wiICsgaXRlbS52ZXJzaW9uO1xuICAgIH0pLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHJldHVybiBuYXZpZ2F0b3IudXNlckFnZW50O1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/userAgent.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/within.js":
/*!*********************************************************!*\
  !*** ./node_modules/@popperjs/core/lib/utils/within.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   within: function() { return /* binding */ within; },\n/* harmony export */   withinMaxClamp: function() { return /* binding */ withinMaxClamp; }\n/* harmony export */ });\n/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/math.js\");\n\nfunction within(min, value, max) {\n  return (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.max)(min, (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.min)(value, max));\n}\nfunction withinMaxClamp(min, value, max) {\n  var v = within(min, value, max);\n  return v > max ? max : v;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvd2l0aGluLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUEyRDtBQUNwRDtBQUNQLFNBQVMsNkNBQU8sTUFBTSw2Q0FBTztBQUM3QjtBQUNPO0FBQ1A7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AcG9wcGVyanMvY29yZS9saWIvdXRpbHMvd2l0aGluLmpzP2E0ZjgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbWF4IGFzIG1hdGhNYXgsIG1pbiBhcyBtYXRoTWluIH0gZnJvbSBcIi4vbWF0aC5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHdpdGhpbihtaW4sIHZhbHVlLCBtYXgpIHtcbiAgcmV0dXJuIG1hdGhNYXgobWluLCBtYXRoTWluKHZhbHVlLCBtYXgpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3aXRoaW5NYXhDbGFtcChtaW4sIHZhbHVlLCBtYXgpIHtcbiAgdmFyIHYgPSB3aXRoaW4obWluLCB2YWx1ZSwgbWF4KTtcbiAgcmV0dXJuIHYgPiBtYXggPyBtYXggOiB2O1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@popperjs/core/lib/utils/within.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js":
/*!****************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/createLucideIcon.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ createLucideIcon; },\n/* harmony export */   toKebabCase: function() { return /* binding */ toKebabCase; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _defaultAttributes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./defaultAttributes.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/defaultAttributes.js\");\n/**\n * @license lucide-react v0.294.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \n\nconst toKebabCase = (string)=>string.replace(/([a-z0-9])([A-Z])/g, \"$1-$2\").toLowerCase().trim();\nconst createLucideIcon = (iconName, iconNode)=>{\n    const Component = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((param, ref)=>{\n        let { color = \"currentColor\", size = 24, strokeWidth = 2, absoluteStrokeWidth, className = \"\", children, ...rest } = param;\n        return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"svg\", {\n            ref,\n            ..._defaultAttributes_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n            width: size,\n            height: size,\n            stroke: color,\n            strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size) : strokeWidth,\n            className: [\n                \"lucide\",\n                \"lucide-\".concat(toKebabCase(iconName)),\n                className\n            ].join(\" \"),\n            ...rest\n        }, [\n            ...iconNode.map((param)=>{\n                let [tag, attrs] = param;\n                return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(tag, attrs);\n            }),\n            ...Array.isArray(children) ? children : [\n                children\n            ]\n        ]);\n    });\n    Component.displayName = \"\".concat(iconName);\n    return Component;\n};\n //# sourceMappingURL=createLucideIcon.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vY3JlYXRlTHVjaWRlSWNvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUE2QmEsTUFBQUEsY0FBYyxDQUFDQyxTQUMxQkEsT0FDR0MsT0FBQSxDQUFRLHNCQUFzQixTQUM5QkMsV0FBWSxHQUNaQyxJQUFLO0FBRUosTUFBQUMsbUJBQW1CLENBQUNDLFVBQWtCQztJQUMxQyxNQUFNQywwQkFBWUMsaURBQVVBLENBQzFCLFFBQWlIQztZQUFoSCxFQUFFQyxRQUFRLGdCQUFnQkMsT0FBTyxFQUFJLEVBQUFDLGNBQWMsQ0FBRyxFQUFBQyxtQkFBQSxFQUFxQkMsWUFBWSxJQUFJQyxRQUFhLEtBQUFDLE1BQUE7NkJBQ3ZHQyxvREFBYUEsQ0FDWCxPQUNBO1lBQ0VSO1lBQ0EsR0FBR1MsNkRBQUE7WUFDSEMsT0FBT1I7WUFDUFMsUUFBUVQ7WUFDUlUsUUFBUVg7WUFDUkUsYUFBYUMsc0JBQXNCUyxPQUFPVixlQUFlLEtBQUtVLE9BQU9YLFFBQVFDO1lBQzdFRSxXQUFXO2dCQUFDO2dCQUFvQixVQUF5QixPQUF6QmYsWUFBWU07Z0JBQWFTO2FBQVcsQ0FBQVMsSUFBQSxDQUFLO1lBQ3pFLEdBQUdQLElBQUE7UUFDTCxHQUNBO2VBQ0tWLFNBQVNrQixHQUFBLENBQUk7b0JBQUMsQ0FBQ0MsS0FBS0MsTUFBVztxQ0FBQVQsb0RBQWFBLENBQUNRLEtBQUtDOztlQUNqREMsTUFBTUMsT0FBQSxDQUFRYixZQUFZQSxXQUFXO2dCQUFDQTthQUFRO1NBQ3BEOztJQUlOUixVQUFVc0IsV0FBQSxHQUFjLEdBQUcsT0FBQXhCO0lBRXBCLE9BQUFFO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL3NyYy9jcmVhdGVMdWNpZGVJY29uLnRzPzA0ODgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgZm9yd2FyZFJlZixcbiAgY3JlYXRlRWxlbWVudCxcbiAgUmVhY3RTVkcsXG4gIFNWR1Byb3BzLFxuICBGb3J3YXJkUmVmRXhvdGljQ29tcG9uZW50LFxuICBSZWZBdHRyaWJ1dGVzLFxufSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgZGVmYXVsdEF0dHJpYnV0ZXMgZnJvbSAnLi9kZWZhdWx0QXR0cmlidXRlcyc7XG5cbmV4cG9ydCB0eXBlIEljb25Ob2RlID0gW2VsZW1lbnROYW1lOiBrZXlvZiBSZWFjdFNWRywgYXR0cnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz5dW107XG5cbmV4cG9ydCB0eXBlIFNWR0F0dHJpYnV0ZXMgPSBQYXJ0aWFsPFNWR1Byb3BzPFNWR1NWR0VsZW1lbnQ+PjtcbnR5cGUgQ29tcG9uZW50QXR0cmlidXRlcyA9IFJlZkF0dHJpYnV0ZXM8U1ZHU1ZHRWxlbWVudD4gJiBTVkdBdHRyaWJ1dGVzO1xuXG5leHBvcnQgaW50ZXJmYWNlIEx1Y2lkZVByb3BzIGV4dGVuZHMgQ29tcG9uZW50QXR0cmlidXRlcyB7XG4gIHNpemU/OiBzdHJpbmcgfCBudW1iZXI7XG4gIGFic29sdXRlU3Ryb2tlV2lkdGg/OiBib29sZWFuO1xufVxuXG5leHBvcnQgdHlwZSBMdWNpZGVJY29uID0gRm9yd2FyZFJlZkV4b3RpY0NvbXBvbmVudDxMdWNpZGVQcm9wcz47XG4vKipcbiAqIENvbnZlcnRzIHN0cmluZyB0byBLZWJhYkNhc2VcbiAqIENvcGllZCBmcm9tIHNjcmlwdHMvaGVscGVyLiBJZiBhbnlvbmUga25vd3MgaG93IHRvIHByb3Blcmx5IGltcG9ydCBpdCBoZXJlXG4gKiB0aGVuIHBsZWFzZSBmaXggaXQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybnMge3N0cmluZ30gQSBrZWJhYml6ZWQgc3RyaW5nXG4gKi9cbmV4cG9ydCBjb25zdCB0b0tlYmFiQ2FzZSA9IChzdHJpbmc6IHN0cmluZykgPT5cbiAgc3RyaW5nXG4gICAgLnJlcGxhY2UoLyhbYS16MC05XSkoW0EtWl0pL2csICckMS0kMicpXG4gICAgLnRvTG93ZXJDYXNlKClcbiAgICAudHJpbSgpO1xuXG5jb25zdCBjcmVhdGVMdWNpZGVJY29uID0gKGljb25OYW1lOiBzdHJpbmcsIGljb25Ob2RlOiBJY29uTm9kZSk6IEx1Y2lkZUljb24gPT4ge1xuICBjb25zdCBDb21wb25lbnQgPSBmb3J3YXJkUmVmPFNWR1NWR0VsZW1lbnQsIEx1Y2lkZVByb3BzPihcbiAgICAoeyBjb2xvciA9ICdjdXJyZW50Q29sb3InLCBzaXplID0gMjQsIHN0cm9rZVdpZHRoID0gMiwgYWJzb2x1dGVTdHJva2VXaWR0aCwgY2xhc3NOYW1lID0gJycsIGNoaWxkcmVuLCAuLi5yZXN0IH0sIHJlZikgPT5cbiAgICAgIGNyZWF0ZUVsZW1lbnQoXG4gICAgICAgICdzdmcnLFxuICAgICAgICB7XG4gICAgICAgICAgcmVmLFxuICAgICAgICAgIC4uLmRlZmF1bHRBdHRyaWJ1dGVzLFxuICAgICAgICAgIHdpZHRoOiBzaXplLFxuICAgICAgICAgIGhlaWdodDogc2l6ZSxcbiAgICAgICAgICBzdHJva2U6IGNvbG9yLFxuICAgICAgICAgIHN0cm9rZVdpZHRoOiBhYnNvbHV0ZVN0cm9rZVdpZHRoID8gTnVtYmVyKHN0cm9rZVdpZHRoKSAqIDI0IC8gTnVtYmVyKHNpemUpIDogc3Ryb2tlV2lkdGgsXG4gICAgICAgICAgY2xhc3NOYW1lOiBbJ2x1Y2lkZScsIGBsdWNpZGUtJHt0b0tlYmFiQ2FzZShpY29uTmFtZSl9YCwgY2xhc3NOYW1lXS5qb2luKCcgJyksXG4gICAgICAgICAgLi4ucmVzdCxcbiAgICAgICAgfSxcbiAgICAgICAgW1xuICAgICAgICAgIC4uLmljb25Ob2RlLm1hcCgoW3RhZywgYXR0cnNdKSA9PiBjcmVhdGVFbGVtZW50KHRhZywgYXR0cnMpKSxcbiAgICAgICAgICAuLi4oQXJyYXkuaXNBcnJheShjaGlsZHJlbikgPyBjaGlsZHJlbiA6IFtjaGlsZHJlbl0pLFxuICAgICAgICBdXG4gICAgICApXG4gICk7XG5cbiAgQ29tcG9uZW50LmRpc3BsYXlOYW1lID0gYCR7aWNvbk5hbWV9YDtcblxuICByZXR1cm4gQ29tcG9uZW50O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgY3JlYXRlTHVjaWRlSWNvbjtcbiJdLCJuYW1lcyI6WyJ0b0tlYmFiQ2FzZSIsInN0cmluZyIsInJlcGxhY2UiLCJ0b0xvd2VyQ2FzZSIsInRyaW0iLCJjcmVhdGVMdWNpZGVJY29uIiwiaWNvbk5hbWUiLCJpY29uTm9kZSIsIkNvbXBvbmVudCIsImZvcndhcmRSZWYiLCJyZWYiLCJjb2xvciIsInNpemUiLCJzdHJva2VXaWR0aCIsImFic29sdXRlU3Ryb2tlV2lkdGgiLCJjbGFzc05hbWUiLCJjaGlsZHJlbiIsInJlc3QiLCJjcmVhdGVFbGVtZW50IiwiZGVmYXVsdEF0dHJpYnV0ZXMiLCJ3aWR0aCIsImhlaWdodCIsInN0cm9rZSIsIk51bWJlciIsImpvaW4iLCJtYXAiLCJ0YWciLCJhdHRycyIsIkFycmF5IiwiaXNBcnJheSIsImRpc3BsYXlOYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/defaultAttributes.js":
/*!*****************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/defaultAttributes.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ defaultAttributes; }\n/* harmony export */ });\n/**\n * @license lucide-react v0.294.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ var defaultAttributes = {\n    xmlns: \"http://www.w3.org/2000/svg\",\n    width: 24,\n    height: 24,\n    viewBox: \"0 0 24 24\",\n    fill: \"none\",\n    stroke: \"currentColor\",\n    strokeWidth: 2,\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\"\n};\n //# sourceMappingURL=defaultAttributes.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vZGVmYXVsdEF0dHJpYnV0ZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0lBQUEsSUFBZUEsb0JBQUE7SUFDYkMsT0FBTztJQUNQQyxPQUFPO0lBQ1BDLFFBQVE7SUFDUkMsU0FBUztJQUNUQyxNQUFNO0lBQ05DLFFBQVE7SUFDUkMsYUFBYTtJQUNiQyxlQUFlO0lBQ2ZDLGdCQUFnQjtBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vc3JjL2RlZmF1bHRBdHRyaWJ1dGVzLnRzPzM3MGMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQge1xuICB4bWxuczogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgd2lkdGg6IDI0LFxuICBoZWlnaHQ6IDI0LFxuICB2aWV3Qm94OiAnMCAwIDI0IDI0JyxcbiAgZmlsbDogJ25vbmUnLFxuICBzdHJva2U6ICdjdXJyZW50Q29sb3InLFxuICBzdHJva2VXaWR0aDogMixcbiAgc3Ryb2tlTGluZWNhcDogJ3JvdW5kJyxcbiAgc3Ryb2tlTGluZWpvaW46ICdyb3VuZCcsXG59O1xuIl0sIm5hbWVzIjpbImRlZmF1bHRBdHRyaWJ1dGVzIiwieG1sbnMiLCJ3aWR0aCIsImhlaWdodCIsInZpZXdCb3giLCJmaWxsIiwic3Ryb2tlIiwic3Ryb2tlV2lkdGgiLCJzdHJva2VMaW5lY2FwIiwic3Ryb2tlTGluZWpvaW4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/defaultAttributes.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/alert-circle.js":
/*!******************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/alert-circle.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ AlertCircle; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.294.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst AlertCircle = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"AlertCircle\", [\n    [\n        \"circle\",\n        {\n            cx: \"12\",\n            cy: \"12\",\n            r: \"10\",\n            key: \"1mglay\"\n        }\n    ],\n    [\n        \"line\",\n        {\n            x1: \"12\",\n            x2: \"12\",\n            y1: \"8\",\n            y2: \"12\",\n            key: \"1pkeuh\"\n        }\n    ],\n    [\n        \"line\",\n        {\n            x1: \"12\",\n            x2: \"12.01\",\n            y1: \"16\",\n            y2: \"16\",\n            key: \"4dfq90\"\n        }\n    ]\n]);\n //# sourceMappingURL=alert-circle.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvYWxlcnQtY2lyY2xlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBYU0sTUFBQUEsY0FBY0MsZ0VBQWdCQSxDQUFDLGVBQWU7SUFDbEQ7UUFBQztRQUFVO1lBQUVDLElBQUk7WUFBTUMsSUFBSTtZQUFNQyxHQUFHO1lBQU1DLEtBQUs7UUFBQTtLQUFVO0lBQ3pEO1FBQUM7UUFBUTtZQUFFQyxJQUFJO1lBQU1DLElBQUk7WUFBTUMsSUFBSTtZQUFLQyxJQUFJO1lBQU1KLEtBQUs7UUFBQTtLQUFVO0lBQ2pFO1FBQUM7UUFBUTtZQUFFQyxJQUFJO1lBQU1DLElBQUk7WUFBU0MsSUFBSTtZQUFNQyxJQUFJO1lBQU1KLEtBQUs7UUFBQTtLQUFVO0NBQ3RFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvaWNvbnMvYWxlcnQtY2lyY2xlLnRzPzg2MDUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNyZWF0ZUx1Y2lkZUljb24gZnJvbSAnLi4vY3JlYXRlTHVjaWRlSWNvbic7XG5cbi8qKlxuICogQGNvbXBvbmVudCBAbmFtZSBBbGVydENpcmNsZVxuICogQGRlc2NyaXB0aW9uIEx1Y2lkZSBTVkcgaWNvbiBjb21wb25lbnQsIHJlbmRlcnMgU1ZHIEVsZW1lbnQgd2l0aCBjaGlsZHJlbi5cbiAqXG4gKiBAcHJldmlldyAhW2ltZ10oZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlBZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWdvZ0lIZHBaSFJvUFNJeU5DSUtJQ0JvWldsbmFIUTlJakkwSWdvZ0lIWnBaWGRDYjNnOUlqQWdNQ0F5TkNBeU5DSUtJQ0JtYVd4c1BTSnViMjVsSWdvZ0lITjBjbTlyWlQwaUl6QXdNQ0lnYzNSNWJHVTlJbUpoWTJ0bmNtOTFibVF0WTI5c2IzSTZJQ05tWm1ZN0lHSnZjbVJsY2kxeVlXUnBkWE02SURKd2VDSUtJQ0J6ZEhKdmEyVXRkMmxrZEdnOUlqSWlDaUFnYzNSeWIydGxMV3hwYm1WallYQTlJbkp2ZFc1a0lnb2dJSE4wY205clpTMXNhVzVsYW05cGJqMGljbTkxYm1RaUNqNEtJQ0E4WTJseVkyeGxJR040UFNJeE1pSWdZM2s5SWpFeUlpQnlQU0l4TUNJZ0x6NEtJQ0E4YkdsdVpTQjRNVDBpTVRJaUlIZ3lQU0l4TWlJZ2VURTlJamdpSUhreVBTSXhNaUlnTHo0S0lDQThiR2x1WlNCNE1UMGlNVElpSUhneVBTSXhNaTR3TVNJZ2VURTlJakUySWlCNU1qMGlNVFlpSUM4K0Nqd3ZjM1puUGdvPSkgLSBodHRwczovL2x1Y2lkZS5kZXYvaWNvbnMvYWxlcnQtY2lyY2xlXG4gKiBAc2VlIGh0dHBzOi8vbHVjaWRlLmRldi9ndWlkZS9wYWNrYWdlcy9sdWNpZGUtcmVhY3QgLSBEb2N1bWVudGF0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIC0gTHVjaWRlIGljb25zIHByb3BzIGFuZCBhbnkgdmFsaWQgU1ZHIGF0dHJpYnV0ZVxuICogQHJldHVybnMge0pTWC5FbGVtZW50fSBKU1ggRWxlbWVudFxuICpcbiAqL1xuY29uc3QgQWxlcnRDaXJjbGUgPSBjcmVhdGVMdWNpZGVJY29uKCdBbGVydENpcmNsZScsIFtcbiAgWydjaXJjbGUnLCB7IGN4OiAnMTInLCBjeTogJzEyJywgcjogJzEwJywga2V5OiAnMW1nbGF5JyB9XSxcbiAgWydsaW5lJywgeyB4MTogJzEyJywgeDI6ICcxMicsIHkxOiAnOCcsIHkyOiAnMTInLCBrZXk6ICcxcGtldWgnIH1dLFxuICBbJ2xpbmUnLCB7IHgxOiAnMTInLCB4MjogJzEyLjAxJywgeTE6ICcxNicsIHkyOiAnMTYnLCBrZXk6ICc0ZGZxOTAnIH1dLFxuXSk7XG5cbmV4cG9ydCBkZWZhdWx0IEFsZXJ0Q2lyY2xlO1xuIl0sIm5hbWVzIjpbIkFsZXJ0Q2lyY2xlIiwiY3JlYXRlTHVjaWRlSWNvbiIsImN4IiwiY3kiLCJyIiwia2V5IiwieDEiLCJ4MiIsInkxIiwieTIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/alert-circle.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/calendar.js":
/*!**************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/calendar.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Calendar; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.294.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst Calendar = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"Calendar\", [\n    [\n        \"rect\",\n        {\n            width: \"18\",\n            height: \"18\",\n            x: \"3\",\n            y: \"4\",\n            rx: \"2\",\n            ry: \"2\",\n            key: \"eu3xkr\"\n        }\n    ],\n    [\n        \"line\",\n        {\n            x1: \"16\",\n            x2: \"16\",\n            y1: \"2\",\n            y2: \"6\",\n            key: \"m3sa8f\"\n        }\n    ],\n    [\n        \"line\",\n        {\n            x1: \"8\",\n            x2: \"8\",\n            y1: \"2\",\n            y2: \"6\",\n            key: \"18kwsl\"\n        }\n    ],\n    [\n        \"line\",\n        {\n            x1: \"3\",\n            x2: \"21\",\n            y1: \"10\",\n            y2: \"10\",\n            key: \"xt86sb\"\n        }\n    ]\n]);\n //# sourceMappingURL=calendar.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvY2FsZW5kYXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFhTSxNQUFBQSxXQUFXQyxnRUFBZ0JBLENBQUMsWUFBWTtJQUM1QztRQUFDO1FBQVE7WUFBRUMsT0FBTztZQUFNQyxRQUFRO1lBQU1DLEdBQUc7WUFBS0MsR0FBRztZQUFLQyxJQUFJO1lBQUtDLElBQUk7WUFBS0MsS0FBSztRQUFBO0tBQVU7SUFDdkY7UUFBQztRQUFRO1lBQUVDLElBQUk7WUFBTUMsSUFBSTtZQUFNQyxJQUFJO1lBQUtDLElBQUk7WUFBS0osS0FBSztRQUFBO0tBQVU7SUFDaEU7UUFBQztRQUFRO1lBQUVDLElBQUk7WUFBS0MsSUFBSTtZQUFLQyxJQUFJO1lBQUtDLElBQUk7WUFBS0osS0FBSztRQUFBO0tBQVU7SUFDOUQ7UUFBQztRQUFRO1lBQUVDLElBQUk7WUFBS0MsSUFBSTtZQUFNQyxJQUFJO1lBQU1DLElBQUk7WUFBTUosS0FBSztRQUFBO0tBQVU7Q0FDbEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uLy4uL3NyYy9pY29ucy9jYWxlbmRhci50cz9mMzdmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcmVhdGVMdWNpZGVJY29uIGZyb20gJy4uL2NyZWF0ZUx1Y2lkZUljb24nO1xuXG4vKipcbiAqIEBjb21wb25lbnQgQG5hbWUgQ2FsZW5kYXJcbiAqIEBkZXNjcmlwdGlvbiBMdWNpZGUgU1ZHIGljb24gY29tcG9uZW50LCByZW5kZXJzIFNWRyBFbGVtZW50IHdpdGggY2hpbGRyZW4uXG4gKlxuICogQHByZXZpZXcgIVtpbWddKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QWdlRzFzYm5NOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6SXdNREF2YzNabklnb2dJSGRwWkhSb1BTSXlOQ0lLSUNCb1pXbG5hSFE5SWpJMElnb2dJSFpwWlhkQ2IzZzlJakFnTUNBeU5DQXlOQ0lLSUNCbWFXeHNQU0p1YjI1bElnb2dJSE4wY205clpUMGlJekF3TUNJZ2MzUjViR1U5SW1KaFkydG5jbTkxYm1RdFkyOXNiM0k2SUNObVptWTdJR0p2Y21SbGNpMXlZV1JwZFhNNklESndlQ0lLSUNCemRISnZhMlV0ZDJsa2RHZzlJaklpQ2lBZ2MzUnliMnRsTFd4cGJtVmpZWEE5SW5KdmRXNWtJZ29nSUhOMGNtOXJaUzFzYVc1bGFtOXBiajBpY205MWJtUWlDajRLSUNBOGNtVmpkQ0IzYVdSMGFEMGlNVGdpSUdobGFXZG9kRDBpTVRnaUlIZzlJak1pSUhrOUlqUWlJSEo0UFNJeUlpQnllVDBpTWlJZ0x6NEtJQ0E4YkdsdVpTQjRNVDBpTVRZaUlIZ3lQU0l4TmlJZ2VURTlJaklpSUhreVBTSTJJaUF2UGdvZ0lEeHNhVzVsSUhneFBTSTRJaUI0TWowaU9DSWdlVEU5SWpJaUlIa3lQU0kySWlBdlBnb2dJRHhzYVc1bElIZ3hQU0l6SWlCNE1qMGlNakVpSUhreFBTSXhNQ0lnZVRJOUlqRXdJaUF2UGdvOEwzTjJaejRLKSAtIGh0dHBzOi8vbHVjaWRlLmRldi9pY29ucy9jYWxlbmRhclxuICogQHNlZSBodHRwczovL2x1Y2lkZS5kZXYvZ3VpZGUvcGFja2FnZXMvbHVjaWRlLXJlYWN0IC0gRG9jdW1lbnRhdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyAtIEx1Y2lkZSBpY29ucyBwcm9wcyBhbmQgYW55IHZhbGlkIFNWRyBhdHRyaWJ1dGVcbiAqIEByZXR1cm5zIHtKU1guRWxlbWVudH0gSlNYIEVsZW1lbnRcbiAqXG4gKi9cbmNvbnN0IENhbGVuZGFyID0gY3JlYXRlTHVjaWRlSWNvbignQ2FsZW5kYXInLCBbXG4gIFsncmVjdCcsIHsgd2lkdGg6ICcxOCcsIGhlaWdodDogJzE4JywgeDogJzMnLCB5OiAnNCcsIHJ4OiAnMicsIHJ5OiAnMicsIGtleTogJ2V1M3hrcicgfV0sXG4gIFsnbGluZScsIHsgeDE6ICcxNicsIHgyOiAnMTYnLCB5MTogJzInLCB5MjogJzYnLCBrZXk6ICdtM3NhOGYnIH1dLFxuICBbJ2xpbmUnLCB7IHgxOiAnOCcsIHgyOiAnOCcsIHkxOiAnMicsIHkyOiAnNicsIGtleTogJzE4a3dzbCcgfV0sXG4gIFsnbGluZScsIHsgeDE6ICczJywgeDI6ICcyMScsIHkxOiAnMTAnLCB5MjogJzEwJywga2V5OiAneHQ4NnNiJyB9XSxcbl0pO1xuXG5leHBvcnQgZGVmYXVsdCBDYWxlbmRhcjtcbiJdLCJuYW1lcyI6WyJDYWxlbmRhciIsImNyZWF0ZUx1Y2lkZUljb24iLCJ3aWR0aCIsImhlaWdodCIsIngiLCJ5IiwicngiLCJyeSIsImtleSIsIngxIiwieDIiLCJ5MSIsInkyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/calendar.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/check-circle.js":
/*!******************************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/check-circle.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ CheckCircle; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.294.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst CheckCircle = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"CheckCircle\", [\n    [\n        \"path\",\n        {\n            d: \"M22 11.08V12a10 10 0 1 1-5.93-9.14\",\n            key: \"g774vq\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"m9 11 3 3L22 4\",\n            key: \"1pflzl\"\n        }\n    ]\n]);\n //# sourceMappingURL=check-circle.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvY2hlY2stY2lyY2xlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBYU0sTUFBQUEsY0FBY0MsZ0VBQWdCQSxDQUFDLGVBQWU7SUFDbEQ7UUFBQztRQUFRO1lBQUVDLEdBQUc7WUFBc0NDLEtBQUs7UUFBQTtLQUFVO0lBQ25FO1FBQUM7UUFBUTtZQUFFRCxHQUFHO1lBQWtCQyxLQUFLO1FBQUE7S0FBVTtDQUNoRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL2ljb25zL2NoZWNrLWNpcmNsZS50cz8zM2QyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcmVhdGVMdWNpZGVJY29uIGZyb20gJy4uL2NyZWF0ZUx1Y2lkZUljb24nO1xuXG4vKipcbiAqIEBjb21wb25lbnQgQG5hbWUgQ2hlY2tDaXJjbGVcbiAqIEBkZXNjcmlwdGlvbiBMdWNpZGUgU1ZHIGljb24gY29tcG9uZW50LCByZW5kZXJzIFNWRyBFbGVtZW50IHdpdGggY2hpbGRyZW4uXG4gKlxuICogQHByZXZpZXcgIVtpbWddKGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5QWdlRzFzYm5NOUltaDBkSEE2THk5M2QzY3Vkek11YjNKbkx6SXdNREF2YzNabklnb2dJSGRwWkhSb1BTSXlOQ0lLSUNCb1pXbG5hSFE5SWpJMElnb2dJSFpwWlhkQ2IzZzlJakFnTUNBeU5DQXlOQ0lLSUNCbWFXeHNQU0p1YjI1bElnb2dJSE4wY205clpUMGlJekF3TUNJZ2MzUjViR1U5SW1KaFkydG5jbTkxYm1RdFkyOXNiM0k2SUNObVptWTdJR0p2Y21SbGNpMXlZV1JwZFhNNklESndlQ0lLSUNCemRISnZhMlV0ZDJsa2RHZzlJaklpQ2lBZ2MzUnliMnRsTFd4cGJtVmpZWEE5SW5KdmRXNWtJZ29nSUhOMGNtOXJaUzFzYVc1bGFtOXBiajBpY205MWJtUWlDajRLSUNBOGNHRjBhQ0JrUFNKTk1qSWdNVEV1TURoV01USmhNVEFnTVRBZ01DQXhJREV0TlM0NU15MDVMakUwSWlBdlBnb2dJRHh3WVhSb0lHUTlJbTA1SURFeElETWdNMHd5TWlBMElpQXZQZ284TDNOMlp6NEspIC0gaHR0cHM6Ly9sdWNpZGUuZGV2L2ljb25zL2NoZWNrLWNpcmNsZVxuICogQHNlZSBodHRwczovL2x1Y2lkZS5kZXYvZ3VpZGUvcGFja2FnZXMvbHVjaWRlLXJlYWN0IC0gRG9jdW1lbnRhdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyAtIEx1Y2lkZSBpY29ucyBwcm9wcyBhbmQgYW55IHZhbGlkIFNWRyBhdHRyaWJ1dGVcbiAqIEByZXR1cm5zIHtKU1guRWxlbWVudH0gSlNYIEVsZW1lbnRcbiAqXG4gKi9cbmNvbnN0IENoZWNrQ2lyY2xlID0gY3JlYXRlTHVjaWRlSWNvbignQ2hlY2tDaXJjbGUnLCBbXG4gIFsncGF0aCcsIHsgZDogJ00yMiAxMS4wOFYxMmExMCAxMCAwIDEgMS01LjkzLTkuMTQnLCBrZXk6ICdnNzc0dnEnIH1dLFxuICBbJ3BhdGgnLCB7IGQ6ICdtOSAxMSAzIDNMMjIgNCcsIGtleTogJzFwZmx6bCcgfV0sXG5dKTtcblxuZXhwb3J0IGRlZmF1bHQgQ2hlY2tDaXJjbGU7XG4iXSwibmFtZXMiOlsiQ2hlY2tDaXJjbGUiLCJjcmVhdGVMdWNpZGVJY29uIiwiZCIsImtleSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/check-circle.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/eye.js":
/*!*********************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/eye.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Eye; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.294.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst Eye = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"Eye\", [\n    [\n        \"path\",\n        {\n            d: \"M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z\",\n            key: \"rwhkz3\"\n        }\n    ],\n    [\n        \"circle\",\n        {\n            cx: \"12\",\n            cy: \"12\",\n            r: \"3\",\n            key: \"1v7zrd\"\n        }\n    ]\n]);\n //# sourceMappingURL=eye.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvZXllLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBYU0sTUFBQUEsTUFBTUMsZ0VBQWdCQSxDQUFDLE9BQU87SUFDbEM7UUFBQztRQUFRO1lBQUVDLEdBQUc7WUFBZ0RDLEtBQUs7UUFBQTtLQUFVO0lBQzdFO1FBQUM7UUFBVTtZQUFFQyxJQUFJO1lBQU1DLElBQUk7WUFBTUMsR0FBRztZQUFLSCxLQUFLO1FBQUE7S0FBVTtDQUN6RCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL2ljb25zL2V5ZS50cz84Y2I4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcmVhdGVMdWNpZGVJY29uIGZyb20gJy4uL2NyZWF0ZUx1Y2lkZUljb24nO1xuXG4vKipcbiAqIEBjb21wb25lbnQgQG5hbWUgRXllXG4gKiBAZGVzY3JpcHRpb24gTHVjaWRlIFNWRyBpY29uIGNvbXBvbmVudCwgcmVuZGVycyBTVkcgRWxlbWVudCB3aXRoIGNoaWxkcmVuLlxuICpcbiAqIEBwcmV2aWV3ICFbaW1nXShkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUFnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JZ29nSUhkcFpIUm9QU0l5TkNJS0lDQm9aV2xuYUhROUlqSTBJZ29nSUhacFpYZENiM2c5SWpBZ01DQXlOQ0F5TkNJS0lDQm1hV3hzUFNKdWIyNWxJZ29nSUhOMGNtOXJaVDBpSXpBd01DSWdjM1I1YkdVOUltSmhZMnRuY205MWJtUXRZMjlzYjNJNklDTm1abVk3SUdKdmNtUmxjaTF5WVdScGRYTTZJREp3ZUNJS0lDQnpkSEp2YTJVdGQybGtkR2c5SWpJaUNpQWdjM1J5YjJ0bExXeHBibVZqWVhBOUluSnZkVzVrSWdvZ0lITjBjbTlyWlMxc2FXNWxhbTlwYmowaWNtOTFibVFpQ2o0S0lDQThjR0YwYUNCa1BTSk5NaUF4TW5NekxUY2dNVEF0TnlBeE1DQTNJREV3SURjdE15QTNMVEV3SURjdE1UQXROeTB4TUMwM1dpSWdMejRLSUNBOFkybHlZMnhsSUdONFBTSXhNaUlnWTNrOUlqRXlJaUJ5UFNJeklpQXZQZ284TDNOMlp6NEspIC0gaHR0cHM6Ly9sdWNpZGUuZGV2L2ljb25zL2V5ZVxuICogQHNlZSBodHRwczovL2x1Y2lkZS5kZXYvZ3VpZGUvcGFja2FnZXMvbHVjaWRlLXJlYWN0IC0gRG9jdW1lbnRhdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyAtIEx1Y2lkZSBpY29ucyBwcm9wcyBhbmQgYW55IHZhbGlkIFNWRyBhdHRyaWJ1dGVcbiAqIEByZXR1cm5zIHtKU1guRWxlbWVudH0gSlNYIEVsZW1lbnRcbiAqXG4gKi9cbmNvbnN0IEV5ZSA9IGNyZWF0ZUx1Y2lkZUljb24oJ0V5ZScsIFtcbiAgWydwYXRoJywgeyBkOiAnTTIgMTJzMy03IDEwLTcgMTAgNyAxMCA3LTMgNy0xMCA3LTEwLTctMTAtN1onLCBrZXk6ICdyd2hrejMnIH1dLFxuICBbJ2NpcmNsZScsIHsgY3g6ICcxMicsIGN5OiAnMTInLCByOiAnMycsIGtleTogJzF2N3pyZCcgfV0sXG5dKTtcblxuZXhwb3J0IGRlZmF1bHQgRXllO1xuIl0sIm5hbWVzIjpbIkV5ZSIsImNyZWF0ZUx1Y2lkZUljb24iLCJkIiwia2V5IiwiY3giLCJjeSIsInIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/eye.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/image.js":
/*!***********************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/image.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Image; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.294.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst Image = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"Image\", [\n    [\n        \"rect\",\n        {\n            width: \"18\",\n            height: \"18\",\n            x: \"3\",\n            y: \"3\",\n            rx: \"2\",\n            ry: \"2\",\n            key: \"1m3agn\"\n        }\n    ],\n    [\n        \"circle\",\n        {\n            cx: \"9\",\n            cy: \"9\",\n            r: \"2\",\n            key: \"af1f0g\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21\",\n            key: \"1xmnt7\"\n        }\n    ]\n]);\n //# sourceMappingURL=image.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvaW1hZ2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFhTSxNQUFBQSxRQUFRQyxnRUFBZ0JBLENBQUMsU0FBUztJQUN0QztRQUFDO1FBQVE7WUFBRUMsT0FBTztZQUFNQyxRQUFRO1lBQU1DLEdBQUc7WUFBS0MsR0FBRztZQUFLQyxJQUFJO1lBQUtDLElBQUk7WUFBS0MsS0FBSztRQUFBO0tBQVU7SUFDdkY7UUFBQztRQUFVO1lBQUVDLElBQUk7WUFBS0MsSUFBSTtZQUFLQyxHQUFHO1lBQUtILEtBQUs7UUFBQTtLQUFVO0lBQ3REO1FBQUM7UUFBUTtZQUFFSSxHQUFHO1lBQTZDSixLQUFLO1FBQUE7S0FBVTtDQUMzRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL2ljb25zL2ltYWdlLnRzP2UwZjYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNyZWF0ZUx1Y2lkZUljb24gZnJvbSAnLi4vY3JlYXRlTHVjaWRlSWNvbic7XG5cbi8qKlxuICogQGNvbXBvbmVudCBAbmFtZSBJbWFnZVxuICogQGRlc2NyaXB0aW9uIEx1Y2lkZSBTVkcgaWNvbiBjb21wb25lbnQsIHJlbmRlcnMgU1ZHIEVsZW1lbnQgd2l0aCBjaGlsZHJlbi5cbiAqXG4gKiBAcHJldmlldyAhW2ltZ10oZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlBZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWdvZ0lIZHBaSFJvUFNJeU5DSUtJQ0JvWldsbmFIUTlJakkwSWdvZ0lIWnBaWGRDYjNnOUlqQWdNQ0F5TkNBeU5DSUtJQ0JtYVd4c1BTSnViMjVsSWdvZ0lITjBjbTlyWlQwaUl6QXdNQ0lnYzNSNWJHVTlJbUpoWTJ0bmNtOTFibVF0WTI5c2IzSTZJQ05tWm1ZN0lHSnZjbVJsY2kxeVlXUnBkWE02SURKd2VDSUtJQ0J6ZEhKdmEyVXRkMmxrZEdnOUlqSWlDaUFnYzNSeWIydGxMV3hwYm1WallYQTlJbkp2ZFc1a0lnb2dJSE4wY205clpTMXNhVzVsYW05cGJqMGljbTkxYm1RaUNqNEtJQ0E4Y21WamRDQjNhV1IwYUQwaU1UZ2lJR2hsYVdkb2REMGlNVGdpSUhnOUlqTWlJSGs5SWpNaUlISjRQU0l5SWlCeWVUMGlNaUlnTHo0S0lDQThZMmx5WTJ4bElHTjRQU0k1SWlCamVUMGlPU0lnY2owaU1pSWdMejRLSUNBOGNHRjBhQ0JrUFNKdE1qRWdNVFV0TXk0d09EWXRNeTR3T0RaaE1pQXlJREFnTUNBd0xUSXVPREk0SURCTU5pQXlNU0lnTHo0S1BDOXpkbWMrQ2c9PSkgLSBodHRwczovL2x1Y2lkZS5kZXYvaWNvbnMvaW1hZ2VcbiAqIEBzZWUgaHR0cHM6Ly9sdWNpZGUuZGV2L2d1aWRlL3BhY2thZ2VzL2x1Y2lkZS1yZWFjdCAtIERvY3VtZW50YXRpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgLSBMdWNpZGUgaWNvbnMgcHJvcHMgYW5kIGFueSB2YWxpZCBTVkcgYXR0cmlidXRlXG4gKiBAcmV0dXJucyB7SlNYLkVsZW1lbnR9IEpTWCBFbGVtZW50XG4gKlxuICovXG5jb25zdCBJbWFnZSA9IGNyZWF0ZUx1Y2lkZUljb24oJ0ltYWdlJywgW1xuICBbJ3JlY3QnLCB7IHdpZHRoOiAnMTgnLCBoZWlnaHQ6ICcxOCcsIHg6ICczJywgeTogJzMnLCByeDogJzInLCByeTogJzInLCBrZXk6ICcxbTNhZ24nIH1dLFxuICBbJ2NpcmNsZScsIHsgY3g6ICc5JywgY3k6ICc5JywgcjogJzInLCBrZXk6ICdhZjFmMGcnIH1dLFxuICBbJ3BhdGgnLCB7IGQ6ICdtMjEgMTUtMy4wODYtMy4wODZhMiAyIDAgMCAwLTIuODI4IDBMNiAyMScsIGtleTogJzF4bW50NycgfV0sXG5dKTtcblxuZXhwb3J0IGRlZmF1bHQgSW1hZ2U7XG4iXSwibmFtZXMiOlsiSW1hZ2UiLCJjcmVhdGVMdWNpZGVJY29uIiwid2lkdGgiLCJoZWlnaHQiLCJ4IiwieSIsInJ4IiwicnkiLCJrZXkiLCJjeCIsImN5IiwiciIsImQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/image.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/save.js":
/*!**********************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/save.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Save; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.294.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst Save = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"Save\", [\n    [\n        \"path\",\n        {\n            d: \"M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z\",\n            key: \"1owoqh\"\n        }\n    ],\n    [\n        \"polyline\",\n        {\n            points: \"17 21 17 13 7 13 7 21\",\n            key: \"1md35c\"\n        }\n    ],\n    [\n        \"polyline\",\n        {\n            points: \"7 3 7 8 15 8\",\n            key: \"8nz8an\"\n        }\n    ]\n]);\n //# sourceMappingURL=save.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvc2F2ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQWFNLE1BQUFBLE9BQU9DLGdFQUFnQkEsQ0FBQyxRQUFRO0lBQ3BDO1FBQUM7UUFBUTtZQUFFQyxHQUFHO1lBQW1FQyxLQUFLO1FBQUE7S0FBVTtJQUNoRztRQUFDO1FBQVk7WUFBRUMsUUFBUTtZQUF5QkQsS0FBSztRQUFBO0tBQVU7SUFDL0Q7UUFBQztRQUFZO1lBQUVDLFFBQVE7WUFBZ0JELEtBQUs7UUFBQTtLQUFVO0NBQ3ZEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi8uLi9zcmMvaWNvbnMvc2F2ZS50cz9kMGViIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcmVhdGVMdWNpZGVJY29uIGZyb20gJy4uL2NyZWF0ZUx1Y2lkZUljb24nO1xuXG4vKipcbiAqIEBjb21wb25lbnQgQG5hbWUgU2F2ZVxuICogQGRlc2NyaXB0aW9uIEx1Y2lkZSBTVkcgaWNvbiBjb21wb25lbnQsIHJlbmRlcnMgU1ZHIEVsZW1lbnQgd2l0aCBjaGlsZHJlbi5cbiAqXG4gKiBAcHJldmlldyAhW2ltZ10oZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlBZ2VHMXNibk05SW1oMGRIQTZMeTkzZDNjdWR6TXViM0puTHpJd01EQXZjM1puSWdvZ0lIZHBaSFJvUFNJeU5DSUtJQ0JvWldsbmFIUTlJakkwSWdvZ0lIWnBaWGRDYjNnOUlqQWdNQ0F5TkNBeU5DSUtJQ0JtYVd4c1BTSnViMjVsSWdvZ0lITjBjbTlyWlQwaUl6QXdNQ0lnYzNSNWJHVTlJbUpoWTJ0bmNtOTFibVF0WTI5c2IzSTZJQ05tWm1ZN0lHSnZjbVJsY2kxeVlXUnBkWE02SURKd2VDSUtJQ0J6ZEhKdmEyVXRkMmxrZEdnOUlqSWlDaUFnYzNSeWIydGxMV3hwYm1WallYQTlJbkp2ZFc1a0lnb2dJSE4wY205clpTMXNhVzVsYW05cGJqMGljbTkxYm1RaUNqNEtJQ0E4Y0dGMGFDQmtQU0pOTVRrZ01qRklOV0V5SURJZ01DQXdJREV0TWkweVZqVmhNaUF5SURBZ01DQXhJREl0TW1neE1XdzFJRFYyTVRGaE1pQXlJREFnTUNBeExUSWdNbm9pSUM4K0NpQWdQSEJ2Ykhsc2FXNWxJSEJ2YVc1MGN6MGlNVGNnTWpFZ01UY2dNVE1nTnlBeE15QTNJREl4SWlBdlBnb2dJRHh3YjJ4NWJHbHVaU0J3YjJsdWRITTlJamNnTXlBM0lEZ2dNVFVnT0NJZ0x6NEtQQzl6ZG1jK0NnPT0pIC0gaHR0cHM6Ly9sdWNpZGUuZGV2L2ljb25zL3NhdmVcbiAqIEBzZWUgaHR0cHM6Ly9sdWNpZGUuZGV2L2d1aWRlL3BhY2thZ2VzL2x1Y2lkZS1yZWFjdCAtIERvY3VtZW50YXRpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgLSBMdWNpZGUgaWNvbnMgcHJvcHMgYW5kIGFueSB2YWxpZCBTVkcgYXR0cmlidXRlXG4gKiBAcmV0dXJucyB7SlNYLkVsZW1lbnR9IEpTWCBFbGVtZW50XG4gKlxuICovXG5jb25zdCBTYXZlID0gY3JlYXRlTHVjaWRlSWNvbignU2F2ZScsIFtcbiAgWydwYXRoJywgeyBkOiAnTTE5IDIxSDVhMiAyIDAgMCAxLTItMlY1YTIgMiAwIDAgMSAyLTJoMTFsNSA1djExYTIgMiAwIDAgMS0yIDJ6Jywga2V5OiAnMW93b3FoJyB9XSxcbiAgWydwb2x5bGluZScsIHsgcG9pbnRzOiAnMTcgMjEgMTcgMTMgNyAxMyA3IDIxJywga2V5OiAnMW1kMzVjJyB9XSxcbiAgWydwb2x5bGluZScsIHsgcG9pbnRzOiAnNyAzIDcgOCAxNSA4Jywga2V5OiAnOG56OGFuJyB9XSxcbl0pO1xuXG5leHBvcnQgZGVmYXVsdCBTYXZlO1xuIl0sIm5hbWVzIjpbIlNhdmUiLCJjcmVhdGVMdWNpZGVJY29uIiwiZCIsImtleSIsInBvaW50cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/save.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/tag.js":
/*!*********************************************************!*\
  !*** ./node_modules/lucide-react/dist/esm/icons/tag.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Tag; }\n/* harmony export */ });\n/* harmony import */ var _createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../createLucideIcon.js */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/createLucideIcon.js\");\n/**\n * @license lucide-react v0.294.0 - ISC\n *\n * This source code is licensed under the ISC license.\n * See the LICENSE file in the root directory of this source tree.\n */ \nconst Tag = (0,_createLucideIcon_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\"Tag\", [\n    [\n        \"path\",\n        {\n            d: \"M12 2H2v10l9.29 9.29c.94.94 2.48.94 3.42 0l6.58-6.58c.94-.94.94-2.48 0-3.42L12 2Z\",\n            key: \"14b2ls\"\n        }\n    ],\n    [\n        \"path\",\n        {\n            d: \"M7 7h.01\",\n            key: \"7u93v4\"\n        }\n    ]\n]);\n //# sourceMappingURL=tag.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sdWNpZGUtcmVhY3QvZGlzdC9lc20vaWNvbnMvdGFnLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBYU0sTUFBQUEsTUFBTUMsZ0VBQWdCQSxDQUFDLE9BQU87SUFDbEM7UUFDRTtRQUNBO1lBQ0VDLEdBQUc7WUFDSEMsS0FBSztRQUNQO0tBQ0Y7SUFDQTtRQUFDO1FBQVE7WUFBRUQsR0FBRztZQUFZQyxLQUFLO1FBQUE7S0FBVTtDQUMxQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vLi4vLi4vc3JjL2ljb25zL3RhZy50cz9jNzc0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBjcmVhdGVMdWNpZGVJY29uIGZyb20gJy4uL2NyZWF0ZUx1Y2lkZUljb24nO1xuXG4vKipcbiAqIEBjb21wb25lbnQgQG5hbWUgVGFnXG4gKiBAZGVzY3JpcHRpb24gTHVjaWRlIFNWRyBpY29uIGNvbXBvbmVudCwgcmVuZGVycyBTVkcgRWxlbWVudCB3aXRoIGNoaWxkcmVuLlxuICpcbiAqIEBwcmV2aWV3ICFbaW1nXShkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFBITjJaeUFnZUcxc2JuTTlJbWgwZEhBNkx5OTNkM2N1ZHpNdWIzSm5Mekl3TURBdmMzWm5JZ29nSUhkcFpIUm9QU0l5TkNJS0lDQm9aV2xuYUhROUlqSTBJZ29nSUhacFpYZENiM2c5SWpBZ01DQXlOQ0F5TkNJS0lDQm1hV3hzUFNKdWIyNWxJZ29nSUhOMGNtOXJaVDBpSXpBd01DSWdjM1I1YkdVOUltSmhZMnRuY205MWJtUXRZMjlzYjNJNklDTm1abVk3SUdKdmNtUmxjaTF5WVdScGRYTTZJREp3ZUNJS0lDQnpkSEp2YTJVdGQybGtkR2c5SWpJaUNpQWdjM1J5YjJ0bExXeHBibVZqWVhBOUluSnZkVzVrSWdvZ0lITjBjbTlyWlMxc2FXNWxhbTlwYmowaWNtOTFibVFpQ2o0S0lDQThjR0YwYUNCa1BTSk5NVElnTWtneWRqRXdiRGt1TWprZ09TNHlPV011T1RRdU9UUWdNaTQwT0M0NU5DQXpMalF5SURCc05pNDFPQzAyTGpVNFl5NDVOQzB1T1RRdU9UUXRNaTQwT0NBd0xUTXVOREpNTVRJZ01sb2lJQzgrQ2lBZ1BIQmhkR2dnWkQwaVRUY2dOMmd1TURFaUlDOCtDand2YzNablBnbz0pIC0gaHR0cHM6Ly9sdWNpZGUuZGV2L2ljb25zL3RhZ1xuICogQHNlZSBodHRwczovL2x1Y2lkZS5kZXYvZ3VpZGUvcGFja2FnZXMvbHVjaWRlLXJlYWN0IC0gRG9jdW1lbnRhdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyAtIEx1Y2lkZSBpY29ucyBwcm9wcyBhbmQgYW55IHZhbGlkIFNWRyBhdHRyaWJ1dGVcbiAqIEByZXR1cm5zIHtKU1guRWxlbWVudH0gSlNYIEVsZW1lbnRcbiAqXG4gKi9cbmNvbnN0IFRhZyA9IGNyZWF0ZUx1Y2lkZUljb24oJ1RhZycsIFtcbiAgW1xuICAgICdwYXRoJyxcbiAgICB7XG4gICAgICBkOiAnTTEyIDJIMnYxMGw5LjI5IDkuMjljLjk0Ljk0IDIuNDguOTQgMy40MiAwbDYuNTgtNi41OGMuOTQtLjk0Ljk0LTIuNDggMC0zLjQyTDEyIDJaJyxcbiAgICAgIGtleTogJzE0YjJscycsXG4gICAgfSxcbiAgXSxcbiAgWydwYXRoJywgeyBkOiAnTTcgN2guMDEnLCBrZXk6ICc3dTkzdjQnIH1dLFxuXSk7XG5cbmV4cG9ydCBkZWZhdWx0IFRhZztcbiJdLCJuYW1lcyI6WyJUYWciLCJjcmVhdGVMdWNpZGVJY29uIiwiZCIsImtleSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/tag.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/api/navigation.js":
/*!**************************************************!*\
  !*** ./node_modules/next/dist/api/navigation.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../client/components/navigation */ \"(app-pages-browser)/./node_modules/next/dist/client/components/navigation.js\");\n/* harmony import */ var _client_components_navigation__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_client_components_navigation__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n//# sourceMappingURL=navigation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL25hdmlnYXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWdEOztBQUVoRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2FwaS9uYXZpZ2F0aW9uLmpzPzUwMjkiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSBcIi4uL2NsaWVudC9jb21wb25lbnRzL25hdmlnYXRpb25cIjtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmF2aWdhdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/api/navigation.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tippy.js/dist/tippy.esm.js":
/*!*************************************************!*\
  !*** ./node_modules/tippy.js/dist/tippy.esm.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   animateFill: function() { return /* binding */ animateFill; },\n/* harmony export */   createSingleton: function() { return /* binding */ createSingleton; },\n/* harmony export */   delegate: function() { return /* binding */ delegate; },\n/* harmony export */   followCursor: function() { return /* binding */ followCursor; },\n/* harmony export */   hideAll: function() { return /* binding */ hideAll; },\n/* harmony export */   inlinePositioning: function() { return /* binding */ inlinePositioning; },\n/* harmony export */   roundArrow: function() { return /* binding */ ROUND_ARROW; },\n/* harmony export */   sticky: function() { return /* binding */ sticky; }\n/* harmony export */ });\n/* harmony import */ var _popperjs_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @popperjs/core */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/popper.js\");\n/* harmony import */ var _popperjs_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @popperjs/core */ \"(app-pages-browser)/./node_modules/@popperjs/core/lib/modifiers/applyStyles.js\");\n/**!\n* tippy.js v6.3.7\n* (c) 2017-2021 atomiks\n* MIT License\n*/\n\n\nvar ROUND_ARROW = '<svg width=\"16\" height=\"6\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M0 6s1.796-.013 4.67-3.615C5.851.9 6.93.006 8 0c1.07-.006 2.148.887 3.343 2.385C14.233 6.005 16 6 16 6H0z\"></svg>';\nvar BOX_CLASS = \"tippy-box\";\nvar CONTENT_CLASS = \"tippy-content\";\nvar BACKDROP_CLASS = \"tippy-backdrop\";\nvar ARROW_CLASS = \"tippy-arrow\";\nvar SVG_ARROW_CLASS = \"tippy-svg-arrow\";\nvar TOUCH_OPTIONS = {\n  passive: true,\n  capture: true\n};\nvar TIPPY_DEFAULT_APPEND_TO = function TIPPY_DEFAULT_APPEND_TO() {\n  return document.body;\n};\n\nfunction hasOwnProperty(obj, key) {\n  return {}.hasOwnProperty.call(obj, key);\n}\nfunction getValueAtIndexOrReturn(value, index, defaultValue) {\n  if (Array.isArray(value)) {\n    var v = value[index];\n    return v == null ? Array.isArray(defaultValue) ? defaultValue[index] : defaultValue : v;\n  }\n\n  return value;\n}\nfunction isType(value, type) {\n  var str = {}.toString.call(value);\n  return str.indexOf('[object') === 0 && str.indexOf(type + \"]\") > -1;\n}\nfunction invokeWithArgsOrReturn(value, args) {\n  return typeof value === 'function' ? value.apply(void 0, args) : value;\n}\nfunction debounce(fn, ms) {\n  // Avoid wrapping in `setTimeout` if ms is 0 anyway\n  if (ms === 0) {\n    return fn;\n  }\n\n  var timeout;\n  return function (arg) {\n    clearTimeout(timeout);\n    timeout = setTimeout(function () {\n      fn(arg);\n    }, ms);\n  };\n}\nfunction removeProperties(obj, keys) {\n  var clone = Object.assign({}, obj);\n  keys.forEach(function (key) {\n    delete clone[key];\n  });\n  return clone;\n}\nfunction splitBySpaces(value) {\n  return value.split(/\\s+/).filter(Boolean);\n}\nfunction normalizeToArray(value) {\n  return [].concat(value);\n}\nfunction pushIfUnique(arr, value) {\n  if (arr.indexOf(value) === -1) {\n    arr.push(value);\n  }\n}\nfunction unique(arr) {\n  return arr.filter(function (item, index) {\n    return arr.indexOf(item) === index;\n  });\n}\nfunction getBasePlacement(placement) {\n  return placement.split('-')[0];\n}\nfunction arrayFrom(value) {\n  return [].slice.call(value);\n}\nfunction removeUndefinedProps(obj) {\n  return Object.keys(obj).reduce(function (acc, key) {\n    if (obj[key] !== undefined) {\n      acc[key] = obj[key];\n    }\n\n    return acc;\n  }, {});\n}\n\nfunction div() {\n  return document.createElement('div');\n}\nfunction isElement(value) {\n  return ['Element', 'Fragment'].some(function (type) {\n    return isType(value, type);\n  });\n}\nfunction isNodeList(value) {\n  return isType(value, 'NodeList');\n}\nfunction isMouseEvent(value) {\n  return isType(value, 'MouseEvent');\n}\nfunction isReferenceElement(value) {\n  return !!(value && value._tippy && value._tippy.reference === value);\n}\nfunction getArrayOfElements(value) {\n  if (isElement(value)) {\n    return [value];\n  }\n\n  if (isNodeList(value)) {\n    return arrayFrom(value);\n  }\n\n  if (Array.isArray(value)) {\n    return value;\n  }\n\n  return arrayFrom(document.querySelectorAll(value));\n}\nfunction setTransitionDuration(els, value) {\n  els.forEach(function (el) {\n    if (el) {\n      el.style.transitionDuration = value + \"ms\";\n    }\n  });\n}\nfunction setVisibilityState(els, state) {\n  els.forEach(function (el) {\n    if (el) {\n      el.setAttribute('data-state', state);\n    }\n  });\n}\nfunction getOwnerDocument(elementOrElements) {\n  var _element$ownerDocumen;\n\n  var _normalizeToArray = normalizeToArray(elementOrElements),\n      element = _normalizeToArray[0]; // Elements created via a <template> have an ownerDocument with no reference to the body\n\n\n  return element != null && (_element$ownerDocumen = element.ownerDocument) != null && _element$ownerDocumen.body ? element.ownerDocument : document;\n}\nfunction isCursorOutsideInteractiveBorder(popperTreeData, event) {\n  var clientX = event.clientX,\n      clientY = event.clientY;\n  return popperTreeData.every(function (_ref) {\n    var popperRect = _ref.popperRect,\n        popperState = _ref.popperState,\n        props = _ref.props;\n    var interactiveBorder = props.interactiveBorder;\n    var basePlacement = getBasePlacement(popperState.placement);\n    var offsetData = popperState.modifiersData.offset;\n\n    if (!offsetData) {\n      return true;\n    }\n\n    var topDistance = basePlacement === 'bottom' ? offsetData.top.y : 0;\n    var bottomDistance = basePlacement === 'top' ? offsetData.bottom.y : 0;\n    var leftDistance = basePlacement === 'right' ? offsetData.left.x : 0;\n    var rightDistance = basePlacement === 'left' ? offsetData.right.x : 0;\n    var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;\n    var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;\n    var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;\n    var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;\n    return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;\n  });\n}\nfunction updateTransitionEndListener(box, action, listener) {\n  var method = action + \"EventListener\"; // some browsers apparently support `transition` (unprefixed) but only fire\n  // `webkitTransitionEnd`...\n\n  ['transitionend', 'webkitTransitionEnd'].forEach(function (event) {\n    box[method](event, listener);\n  });\n}\n/**\n * Compared to xxx.contains, this function works for dom structures with shadow\n * dom\n */\n\nfunction actualContains(parent, child) {\n  var target = child;\n\n  while (target) {\n    var _target$getRootNode;\n\n    if (parent.contains(target)) {\n      return true;\n    }\n\n    target = target.getRootNode == null ? void 0 : (_target$getRootNode = target.getRootNode()) == null ? void 0 : _target$getRootNode.host;\n  }\n\n  return false;\n}\n\nvar currentInput = {\n  isTouch: false\n};\nvar lastMouseMoveTime = 0;\n/**\n * When a `touchstart` event is fired, it's assumed the user is using touch\n * input. We'll bind a `mousemove` event listener to listen for mouse input in\n * the future. This way, the `isTouch` property is fully dynamic and will handle\n * hybrid devices that use a mix of touch + mouse input.\n */\n\nfunction onDocumentTouchStart() {\n  if (currentInput.isTouch) {\n    return;\n  }\n\n  currentInput.isTouch = true;\n\n  if (window.performance) {\n    document.addEventListener('mousemove', onDocumentMouseMove);\n  }\n}\n/**\n * When two `mousemove` event are fired consecutively within 20ms, it's assumed\n * the user is using mouse input again. `mousemove` can fire on touch devices as\n * well, but very rarely that quickly.\n */\n\nfunction onDocumentMouseMove() {\n  var now = performance.now();\n\n  if (now - lastMouseMoveTime < 20) {\n    currentInput.isTouch = false;\n    document.removeEventListener('mousemove', onDocumentMouseMove);\n  }\n\n  lastMouseMoveTime = now;\n}\n/**\n * When an element is in focus and has a tippy, leaving the tab/window and\n * returning causes it to show again. For mouse users this is unexpected, but\n * for keyboard use it makes sense.\n * TODO: find a better technique to solve this problem\n */\n\nfunction onWindowBlur() {\n  var activeElement = document.activeElement;\n\n  if (isReferenceElement(activeElement)) {\n    var instance = activeElement._tippy;\n\n    if (activeElement.blur && !instance.state.isVisible) {\n      activeElement.blur();\n    }\n  }\n}\nfunction bindGlobalEventListeners() {\n  document.addEventListener('touchstart', onDocumentTouchStart, TOUCH_OPTIONS);\n  window.addEventListener('blur', onWindowBlur);\n}\n\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';\nvar isIE11 = isBrowser ? // @ts-ignore\n!!window.msCrypto : false;\n\nfunction createMemoryLeakWarning(method) {\n  var txt = method === 'destroy' ? 'n already-' : ' ';\n  return [method + \"() was called on a\" + txt + \"destroyed instance. This is a no-op but\", 'indicates a potential memory leak.'].join(' ');\n}\nfunction clean(value) {\n  var spacesAndTabs = /[ \\t]{2,}/g;\n  var lineStartWithSpaces = /^[ \\t]*/gm;\n  return value.replace(spacesAndTabs, ' ').replace(lineStartWithSpaces, '').trim();\n}\n\nfunction getDevMessage(message) {\n  return clean(\"\\n  %ctippy.js\\n\\n  %c\" + clean(message) + \"\\n\\n  %c\\uD83D\\uDC77\\u200D This is a development-only message. It will be removed in production.\\n  \");\n}\n\nfunction getFormattedMessage(message) {\n  return [getDevMessage(message), // title\n  'color: #00C584; font-size: 1.3em; font-weight: bold;', // message\n  'line-height: 1.5', // footer\n  'color: #a6a095;'];\n} // Assume warnings and errors never have the same message\n\nvar visitedMessages;\n\nif (true) {\n  resetVisitedMessages();\n}\n\nfunction resetVisitedMessages() {\n  visitedMessages = new Set();\n}\nfunction warnWhen(condition, message) {\n  if (condition && !visitedMessages.has(message)) {\n    var _console;\n\n    visitedMessages.add(message);\n\n    (_console = console).warn.apply(_console, getFormattedMessage(message));\n  }\n}\nfunction errorWhen(condition, message) {\n  if (condition && !visitedMessages.has(message)) {\n    var _console2;\n\n    visitedMessages.add(message);\n\n    (_console2 = console).error.apply(_console2, getFormattedMessage(message));\n  }\n}\nfunction validateTargets(targets) {\n  var didPassFalsyValue = !targets;\n  var didPassPlainObject = Object.prototype.toString.call(targets) === '[object Object]' && !targets.addEventListener;\n  errorWhen(didPassFalsyValue, ['tippy() was passed', '`' + String(targets) + '`', 'as its targets (first) argument. Valid types are: String, Element,', 'Element[], or NodeList.'].join(' '));\n  errorWhen(didPassPlainObject, ['tippy() was passed a plain object which is not supported as an argument', 'for virtual positioning. Use props.getReferenceClientRect instead.'].join(' '));\n}\n\nvar pluginProps = {\n  animateFill: false,\n  followCursor: false,\n  inlinePositioning: false,\n  sticky: false\n};\nvar renderProps = {\n  allowHTML: false,\n  animation: 'fade',\n  arrow: true,\n  content: '',\n  inertia: false,\n  maxWidth: 350,\n  role: 'tooltip',\n  theme: '',\n  zIndex: 9999\n};\nvar defaultProps = Object.assign({\n  appendTo: TIPPY_DEFAULT_APPEND_TO,\n  aria: {\n    content: 'auto',\n    expanded: 'auto'\n  },\n  delay: 0,\n  duration: [300, 250],\n  getReferenceClientRect: null,\n  hideOnClick: true,\n  ignoreAttributes: false,\n  interactive: false,\n  interactiveBorder: 2,\n  interactiveDebounce: 0,\n  moveTransition: '',\n  offset: [0, 10],\n  onAfterUpdate: function onAfterUpdate() {},\n  onBeforeUpdate: function onBeforeUpdate() {},\n  onCreate: function onCreate() {},\n  onDestroy: function onDestroy() {},\n  onHidden: function onHidden() {},\n  onHide: function onHide() {},\n  onMount: function onMount() {},\n  onShow: function onShow() {},\n  onShown: function onShown() {},\n  onTrigger: function onTrigger() {},\n  onUntrigger: function onUntrigger() {},\n  onClickOutside: function onClickOutside() {},\n  placement: 'top',\n  plugins: [],\n  popperOptions: {},\n  render: null,\n  showOnCreate: false,\n  touch: true,\n  trigger: 'mouseenter focus',\n  triggerTarget: null\n}, pluginProps, renderProps);\nvar defaultKeys = Object.keys(defaultProps);\nvar setDefaultProps = function setDefaultProps(partialProps) {\n  /* istanbul ignore else */\n  if (true) {\n    validateProps(partialProps, []);\n  }\n\n  var keys = Object.keys(partialProps);\n  keys.forEach(function (key) {\n    defaultProps[key] = partialProps[key];\n  });\n};\nfunction getExtendedPassedProps(passedProps) {\n  var plugins = passedProps.plugins || [];\n  var pluginProps = plugins.reduce(function (acc, plugin) {\n    var name = plugin.name,\n        defaultValue = plugin.defaultValue;\n\n    if (name) {\n      var _name;\n\n      acc[name] = passedProps[name] !== undefined ? passedProps[name] : (_name = defaultProps[name]) != null ? _name : defaultValue;\n    }\n\n    return acc;\n  }, {});\n  return Object.assign({}, passedProps, pluginProps);\n}\nfunction getDataAttributeProps(reference, plugins) {\n  var propKeys = plugins ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {\n    plugins: plugins\n  }))) : defaultKeys;\n  var props = propKeys.reduce(function (acc, key) {\n    var valueAsString = (reference.getAttribute(\"data-tippy-\" + key) || '').trim();\n\n    if (!valueAsString) {\n      return acc;\n    }\n\n    if (key === 'content') {\n      acc[key] = valueAsString;\n    } else {\n      try {\n        acc[key] = JSON.parse(valueAsString);\n      } catch (e) {\n        acc[key] = valueAsString;\n      }\n    }\n\n    return acc;\n  }, {});\n  return props;\n}\nfunction evaluateProps(reference, props) {\n  var out = Object.assign({}, props, {\n    content: invokeWithArgsOrReturn(props.content, [reference])\n  }, props.ignoreAttributes ? {} : getDataAttributeProps(reference, props.plugins));\n  out.aria = Object.assign({}, defaultProps.aria, out.aria);\n  out.aria = {\n    expanded: out.aria.expanded === 'auto' ? props.interactive : out.aria.expanded,\n    content: out.aria.content === 'auto' ? props.interactive ? null : 'describedby' : out.aria.content\n  };\n  return out;\n}\nfunction validateProps(partialProps, plugins) {\n  if (partialProps === void 0) {\n    partialProps = {};\n  }\n\n  if (plugins === void 0) {\n    plugins = [];\n  }\n\n  var keys = Object.keys(partialProps);\n  keys.forEach(function (prop) {\n    var nonPluginProps = removeProperties(defaultProps, Object.keys(pluginProps));\n    var didPassUnknownProp = !hasOwnProperty(nonPluginProps, prop); // Check if the prop exists in `plugins`\n\n    if (didPassUnknownProp) {\n      didPassUnknownProp = plugins.filter(function (plugin) {\n        return plugin.name === prop;\n      }).length === 0;\n    }\n\n    warnWhen(didPassUnknownProp, [\"`\" + prop + \"`\", \"is not a valid prop. You may have spelled it incorrectly, or if it's\", 'a plugin, forgot to pass it in an array as props.plugins.', '\\n\\n', 'All props: https://atomiks.github.io/tippyjs/v6/all-props/\\n', 'Plugins: https://atomiks.github.io/tippyjs/v6/plugins/'].join(' '));\n  });\n}\n\nvar innerHTML = function innerHTML() {\n  return 'innerHTML';\n};\n\nfunction dangerouslySetInnerHTML(element, html) {\n  element[innerHTML()] = html;\n}\n\nfunction createArrowElement(value) {\n  var arrow = div();\n\n  if (value === true) {\n    arrow.className = ARROW_CLASS;\n  } else {\n    arrow.className = SVG_ARROW_CLASS;\n\n    if (isElement(value)) {\n      arrow.appendChild(value);\n    } else {\n      dangerouslySetInnerHTML(arrow, value);\n    }\n  }\n\n  return arrow;\n}\n\nfunction setContent(content, props) {\n  if (isElement(props.content)) {\n    dangerouslySetInnerHTML(content, '');\n    content.appendChild(props.content);\n  } else if (typeof props.content !== 'function') {\n    if (props.allowHTML) {\n      dangerouslySetInnerHTML(content, props.content);\n    } else {\n      content.textContent = props.content;\n    }\n  }\n}\nfunction getChildren(popper) {\n  var box = popper.firstElementChild;\n  var boxChildren = arrayFrom(box.children);\n  return {\n    box: box,\n    content: boxChildren.find(function (node) {\n      return node.classList.contains(CONTENT_CLASS);\n    }),\n    arrow: boxChildren.find(function (node) {\n      return node.classList.contains(ARROW_CLASS) || node.classList.contains(SVG_ARROW_CLASS);\n    }),\n    backdrop: boxChildren.find(function (node) {\n      return node.classList.contains(BACKDROP_CLASS);\n    })\n  };\n}\nfunction render(instance) {\n  var popper = div();\n  var box = div();\n  box.className = BOX_CLASS;\n  box.setAttribute('data-state', 'hidden');\n  box.setAttribute('tabindex', '-1');\n  var content = div();\n  content.className = CONTENT_CLASS;\n  content.setAttribute('data-state', 'hidden');\n  setContent(content, instance.props);\n  popper.appendChild(box);\n  box.appendChild(content);\n  onUpdate(instance.props, instance.props);\n\n  function onUpdate(prevProps, nextProps) {\n    var _getChildren = getChildren(popper),\n        box = _getChildren.box,\n        content = _getChildren.content,\n        arrow = _getChildren.arrow;\n\n    if (nextProps.theme) {\n      box.setAttribute('data-theme', nextProps.theme);\n    } else {\n      box.removeAttribute('data-theme');\n    }\n\n    if (typeof nextProps.animation === 'string') {\n      box.setAttribute('data-animation', nextProps.animation);\n    } else {\n      box.removeAttribute('data-animation');\n    }\n\n    if (nextProps.inertia) {\n      box.setAttribute('data-inertia', '');\n    } else {\n      box.removeAttribute('data-inertia');\n    }\n\n    box.style.maxWidth = typeof nextProps.maxWidth === 'number' ? nextProps.maxWidth + \"px\" : nextProps.maxWidth;\n\n    if (nextProps.role) {\n      box.setAttribute('role', nextProps.role);\n    } else {\n      box.removeAttribute('role');\n    }\n\n    if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) {\n      setContent(content, instance.props);\n    }\n\n    if (nextProps.arrow) {\n      if (!arrow) {\n        box.appendChild(createArrowElement(nextProps.arrow));\n      } else if (prevProps.arrow !== nextProps.arrow) {\n        box.removeChild(arrow);\n        box.appendChild(createArrowElement(nextProps.arrow));\n      }\n    } else if (arrow) {\n      box.removeChild(arrow);\n    }\n  }\n\n  return {\n    popper: popper,\n    onUpdate: onUpdate\n  };\n} // Runtime check to identify if the render function is the default one; this\n// way we can apply default CSS transitions logic and it can be tree-shaken away\n\nrender.$$tippy = true;\n\nvar idCounter = 1;\nvar mouseMoveListeners = []; // Used by `hideAll()`\n\nvar mountedInstances = [];\nfunction createTippy(reference, passedProps) {\n  var props = evaluateProps(reference, Object.assign({}, defaultProps, getExtendedPassedProps(removeUndefinedProps(passedProps)))); // ===========================================================================\n  // 🔒 Private members\n  // ===========================================================================\n\n  var showTimeout;\n  var hideTimeout;\n  var scheduleHideAnimationFrame;\n  var isVisibleFromClick = false;\n  var didHideDueToDocumentMouseDown = false;\n  var didTouchMove = false;\n  var ignoreOnFirstUpdate = false;\n  var lastTriggerEvent;\n  var currentTransitionEndListener;\n  var onFirstUpdate;\n  var listeners = [];\n  var debouncedOnMouseMove = debounce(onMouseMove, props.interactiveDebounce);\n  var currentTarget; // ===========================================================================\n  // 🔑 Public members\n  // ===========================================================================\n\n  var id = idCounter++;\n  var popperInstance = null;\n  var plugins = unique(props.plugins);\n  var state = {\n    // Is the instance currently enabled?\n    isEnabled: true,\n    // Is the tippy currently showing and not transitioning out?\n    isVisible: false,\n    // Has the instance been destroyed?\n    isDestroyed: false,\n    // Is the tippy currently mounted to the DOM?\n    isMounted: false,\n    // Has the tippy finished transitioning in?\n    isShown: false\n  };\n  var instance = {\n    // properties\n    id: id,\n    reference: reference,\n    popper: div(),\n    popperInstance: popperInstance,\n    props: props,\n    state: state,\n    plugins: plugins,\n    // methods\n    clearDelayTimeouts: clearDelayTimeouts,\n    setProps: setProps,\n    setContent: setContent,\n    show: show,\n    hide: hide,\n    hideWithInteractivity: hideWithInteractivity,\n    enable: enable,\n    disable: disable,\n    unmount: unmount,\n    destroy: destroy\n  }; // TODO: Investigate why this early return causes a TDZ error in the tests —\n  // it doesn't seem to happen in the browser\n\n  /* istanbul ignore if */\n\n  if (!props.render) {\n    if (true) {\n      errorWhen(true, 'render() function has not been supplied.');\n    }\n\n    return instance;\n  } // ===========================================================================\n  // Initial mutations\n  // ===========================================================================\n\n\n  var _props$render = props.render(instance),\n      popper = _props$render.popper,\n      onUpdate = _props$render.onUpdate;\n\n  popper.setAttribute('data-tippy-root', '');\n  popper.id = \"tippy-\" + instance.id;\n  instance.popper = popper;\n  reference._tippy = instance;\n  popper._tippy = instance;\n  var pluginsHooks = plugins.map(function (plugin) {\n    return plugin.fn(instance);\n  });\n  var hasAriaExpanded = reference.hasAttribute('aria-expanded');\n  addListeners();\n  handleAriaExpandedAttribute();\n  handleStyles();\n  invokeHook('onCreate', [instance]);\n\n  if (props.showOnCreate) {\n    scheduleShow();\n  } // Prevent a tippy with a delay from hiding if the cursor left then returned\n  // before it started hiding\n\n\n  popper.addEventListener('mouseenter', function () {\n    if (instance.props.interactive && instance.state.isVisible) {\n      instance.clearDelayTimeouts();\n    }\n  });\n  popper.addEventListener('mouseleave', function () {\n    if (instance.props.interactive && instance.props.trigger.indexOf('mouseenter') >= 0) {\n      getDocument().addEventListener('mousemove', debouncedOnMouseMove);\n    }\n  });\n  return instance; // ===========================================================================\n  // 🔒 Private methods\n  // ===========================================================================\n\n  function getNormalizedTouchSettings() {\n    var touch = instance.props.touch;\n    return Array.isArray(touch) ? touch : [touch, 0];\n  }\n\n  function getIsCustomTouchBehavior() {\n    return getNormalizedTouchSettings()[0] === 'hold';\n  }\n\n  function getIsDefaultRenderFn() {\n    var _instance$props$rende;\n\n    // @ts-ignore\n    return !!((_instance$props$rende = instance.props.render) != null && _instance$props$rende.$$tippy);\n  }\n\n  function getCurrentTarget() {\n    return currentTarget || reference;\n  }\n\n  function getDocument() {\n    var parent = getCurrentTarget().parentNode;\n    return parent ? getOwnerDocument(parent) : document;\n  }\n\n  function getDefaultTemplateChildren() {\n    return getChildren(popper);\n  }\n\n  function getDelay(isShow) {\n    // For touch or keyboard input, force `0` delay for UX reasons\n    // Also if the instance is mounted but not visible (transitioning out),\n    // ignore delay\n    if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === 'focus') {\n      return 0;\n    }\n\n    return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);\n  }\n\n  function handleStyles(fromHide) {\n    if (fromHide === void 0) {\n      fromHide = false;\n    }\n\n    popper.style.pointerEvents = instance.props.interactive && !fromHide ? '' : 'none';\n    popper.style.zIndex = \"\" + instance.props.zIndex;\n  }\n\n  function invokeHook(hook, args, shouldInvokePropsHook) {\n    if (shouldInvokePropsHook === void 0) {\n      shouldInvokePropsHook = true;\n    }\n\n    pluginsHooks.forEach(function (pluginHooks) {\n      if (pluginHooks[hook]) {\n        pluginHooks[hook].apply(pluginHooks, args);\n      }\n    });\n\n    if (shouldInvokePropsHook) {\n      var _instance$props;\n\n      (_instance$props = instance.props)[hook].apply(_instance$props, args);\n    }\n  }\n\n  function handleAriaContentAttribute() {\n    var aria = instance.props.aria;\n\n    if (!aria.content) {\n      return;\n    }\n\n    var attr = \"aria-\" + aria.content;\n    var id = popper.id;\n    var nodes = normalizeToArray(instance.props.triggerTarget || reference);\n    nodes.forEach(function (node) {\n      var currentValue = node.getAttribute(attr);\n\n      if (instance.state.isVisible) {\n        node.setAttribute(attr, currentValue ? currentValue + \" \" + id : id);\n      } else {\n        var nextValue = currentValue && currentValue.replace(id, '').trim();\n\n        if (nextValue) {\n          node.setAttribute(attr, nextValue);\n        } else {\n          node.removeAttribute(attr);\n        }\n      }\n    });\n  }\n\n  function handleAriaExpandedAttribute() {\n    if (hasAriaExpanded || !instance.props.aria.expanded) {\n      return;\n    }\n\n    var nodes = normalizeToArray(instance.props.triggerTarget || reference);\n    nodes.forEach(function (node) {\n      if (instance.props.interactive) {\n        node.setAttribute('aria-expanded', instance.state.isVisible && node === getCurrentTarget() ? 'true' : 'false');\n      } else {\n        node.removeAttribute('aria-expanded');\n      }\n    });\n  }\n\n  function cleanupInteractiveMouseListeners() {\n    getDocument().removeEventListener('mousemove', debouncedOnMouseMove);\n    mouseMoveListeners = mouseMoveListeners.filter(function (listener) {\n      return listener !== debouncedOnMouseMove;\n    });\n  }\n\n  function onDocumentPress(event) {\n    // Moved finger to scroll instead of an intentional tap outside\n    if (currentInput.isTouch) {\n      if (didTouchMove || event.type === 'mousedown') {\n        return;\n      }\n    }\n\n    var actualTarget = event.composedPath && event.composedPath()[0] || event.target; // Clicked on interactive popper\n\n    if (instance.props.interactive && actualContains(popper, actualTarget)) {\n      return;\n    } // Clicked on the event listeners target\n\n\n    if (normalizeToArray(instance.props.triggerTarget || reference).some(function (el) {\n      return actualContains(el, actualTarget);\n    })) {\n      if (currentInput.isTouch) {\n        return;\n      }\n\n      if (instance.state.isVisible && instance.props.trigger.indexOf('click') >= 0) {\n        return;\n      }\n    } else {\n      invokeHook('onClickOutside', [instance, event]);\n    }\n\n    if (instance.props.hideOnClick === true) {\n      instance.clearDelayTimeouts();\n      instance.hide(); // `mousedown` event is fired right before `focus` if pressing the\n      // currentTarget. This lets a tippy with `focus` trigger know that it\n      // should not show\n\n      didHideDueToDocumentMouseDown = true;\n      setTimeout(function () {\n        didHideDueToDocumentMouseDown = false;\n      }); // The listener gets added in `scheduleShow()`, but this may be hiding it\n      // before it shows, and hide()'s early bail-out behavior can prevent it\n      // from being cleaned up\n\n      if (!instance.state.isMounted) {\n        removeDocumentPress();\n      }\n    }\n  }\n\n  function onTouchMove() {\n    didTouchMove = true;\n  }\n\n  function onTouchStart() {\n    didTouchMove = false;\n  }\n\n  function addDocumentPress() {\n    var doc = getDocument();\n    doc.addEventListener('mousedown', onDocumentPress, true);\n    doc.addEventListener('touchend', onDocumentPress, TOUCH_OPTIONS);\n    doc.addEventListener('touchstart', onTouchStart, TOUCH_OPTIONS);\n    doc.addEventListener('touchmove', onTouchMove, TOUCH_OPTIONS);\n  }\n\n  function removeDocumentPress() {\n    var doc = getDocument();\n    doc.removeEventListener('mousedown', onDocumentPress, true);\n    doc.removeEventListener('touchend', onDocumentPress, TOUCH_OPTIONS);\n    doc.removeEventListener('touchstart', onTouchStart, TOUCH_OPTIONS);\n    doc.removeEventListener('touchmove', onTouchMove, TOUCH_OPTIONS);\n  }\n\n  function onTransitionedOut(duration, callback) {\n    onTransitionEnd(duration, function () {\n      if (!instance.state.isVisible && popper.parentNode && popper.parentNode.contains(popper)) {\n        callback();\n      }\n    });\n  }\n\n  function onTransitionedIn(duration, callback) {\n    onTransitionEnd(duration, callback);\n  }\n\n  function onTransitionEnd(duration, callback) {\n    var box = getDefaultTemplateChildren().box;\n\n    function listener(event) {\n      if (event.target === box) {\n        updateTransitionEndListener(box, 'remove', listener);\n        callback();\n      }\n    } // Make callback synchronous if duration is 0\n    // `transitionend` won't fire otherwise\n\n\n    if (duration === 0) {\n      return callback();\n    }\n\n    updateTransitionEndListener(box, 'remove', currentTransitionEndListener);\n    updateTransitionEndListener(box, 'add', listener);\n    currentTransitionEndListener = listener;\n  }\n\n  function on(eventType, handler, options) {\n    if (options === void 0) {\n      options = false;\n    }\n\n    var nodes = normalizeToArray(instance.props.triggerTarget || reference);\n    nodes.forEach(function (node) {\n      node.addEventListener(eventType, handler, options);\n      listeners.push({\n        node: node,\n        eventType: eventType,\n        handler: handler,\n        options: options\n      });\n    });\n  }\n\n  function addListeners() {\n    if (getIsCustomTouchBehavior()) {\n      on('touchstart', onTrigger, {\n        passive: true\n      });\n      on('touchend', onMouseLeave, {\n        passive: true\n      });\n    }\n\n    splitBySpaces(instance.props.trigger).forEach(function (eventType) {\n      if (eventType === 'manual') {\n        return;\n      }\n\n      on(eventType, onTrigger);\n\n      switch (eventType) {\n        case 'mouseenter':\n          on('mouseleave', onMouseLeave);\n          break;\n\n        case 'focus':\n          on(isIE11 ? 'focusout' : 'blur', onBlurOrFocusOut);\n          break;\n\n        case 'focusin':\n          on('focusout', onBlurOrFocusOut);\n          break;\n      }\n    });\n  }\n\n  function removeListeners() {\n    listeners.forEach(function (_ref) {\n      var node = _ref.node,\n          eventType = _ref.eventType,\n          handler = _ref.handler,\n          options = _ref.options;\n      node.removeEventListener(eventType, handler, options);\n    });\n    listeners = [];\n  }\n\n  function onTrigger(event) {\n    var _lastTriggerEvent;\n\n    var shouldScheduleClickHide = false;\n\n    if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {\n      return;\n    }\n\n    var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === 'focus';\n    lastTriggerEvent = event;\n    currentTarget = event.currentTarget;\n    handleAriaExpandedAttribute();\n\n    if (!instance.state.isVisible && isMouseEvent(event)) {\n      // If scrolling, `mouseenter` events can be fired if the cursor lands\n      // over a new target, but `mousemove` events don't get fired. This\n      // causes interactive tooltips to get stuck open until the cursor is\n      // moved\n      mouseMoveListeners.forEach(function (listener) {\n        return listener(event);\n      });\n    } // Toggle show/hide when clicking click-triggered tooltips\n\n\n    if (event.type === 'click' && (instance.props.trigger.indexOf('mouseenter') < 0 || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) {\n      shouldScheduleClickHide = true;\n    } else {\n      scheduleShow(event);\n    }\n\n    if (event.type === 'click') {\n      isVisibleFromClick = !shouldScheduleClickHide;\n    }\n\n    if (shouldScheduleClickHide && !wasFocused) {\n      scheduleHide(event);\n    }\n  }\n\n  function onMouseMove(event) {\n    var target = event.target;\n    var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper.contains(target);\n\n    if (event.type === 'mousemove' && isCursorOverReferenceOrPopper) {\n      return;\n    }\n\n    var popperTreeData = getNestedPopperTree().concat(popper).map(function (popper) {\n      var _instance$popperInsta;\n\n      var instance = popper._tippy;\n      var state = (_instance$popperInsta = instance.popperInstance) == null ? void 0 : _instance$popperInsta.state;\n\n      if (state) {\n        return {\n          popperRect: popper.getBoundingClientRect(),\n          popperState: state,\n          props: props\n        };\n      }\n\n      return null;\n    }).filter(Boolean);\n\n    if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {\n      cleanupInteractiveMouseListeners();\n      scheduleHide(event);\n    }\n  }\n\n  function onMouseLeave(event) {\n    var shouldBail = isEventListenerStopped(event) || instance.props.trigger.indexOf('click') >= 0 && isVisibleFromClick;\n\n    if (shouldBail) {\n      return;\n    }\n\n    if (instance.props.interactive) {\n      instance.hideWithInteractivity(event);\n      return;\n    }\n\n    scheduleHide(event);\n  }\n\n  function onBlurOrFocusOut(event) {\n    if (instance.props.trigger.indexOf('focusin') < 0 && event.target !== getCurrentTarget()) {\n      return;\n    } // If focus was moved to within the popper\n\n\n    if (instance.props.interactive && event.relatedTarget && popper.contains(event.relatedTarget)) {\n      return;\n    }\n\n    scheduleHide(event);\n  }\n\n  function isEventListenerStopped(event) {\n    return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf('touch') >= 0 : false;\n  }\n\n  function createPopperInstance() {\n    destroyPopperInstance();\n    var _instance$props2 = instance.props,\n        popperOptions = _instance$props2.popperOptions,\n        placement = _instance$props2.placement,\n        offset = _instance$props2.offset,\n        getReferenceClientRect = _instance$props2.getReferenceClientRect,\n        moveTransition = _instance$props2.moveTransition;\n    var arrow = getIsDefaultRenderFn() ? getChildren(popper).arrow : null;\n    var computedReference = getReferenceClientRect ? {\n      getBoundingClientRect: getReferenceClientRect,\n      contextElement: getReferenceClientRect.contextElement || getCurrentTarget()\n    } : reference;\n    var tippyModifier = {\n      name: '$$tippy',\n      enabled: true,\n      phase: 'beforeWrite',\n      requires: ['computeStyles'],\n      fn: function fn(_ref2) {\n        var state = _ref2.state;\n\n        if (getIsDefaultRenderFn()) {\n          var _getDefaultTemplateCh = getDefaultTemplateChildren(),\n              box = _getDefaultTemplateCh.box;\n\n          ['placement', 'reference-hidden', 'escaped'].forEach(function (attr) {\n            if (attr === 'placement') {\n              box.setAttribute('data-placement', state.placement);\n            } else {\n              if (state.attributes.popper[\"data-popper-\" + attr]) {\n                box.setAttribute(\"data-\" + attr, '');\n              } else {\n                box.removeAttribute(\"data-\" + attr);\n              }\n            }\n          });\n          state.attributes.popper = {};\n        }\n      }\n    };\n    var modifiers = [{\n      name: 'offset',\n      options: {\n        offset: offset\n      }\n    }, {\n      name: 'preventOverflow',\n      options: {\n        padding: {\n          top: 2,\n          bottom: 2,\n          left: 5,\n          right: 5\n        }\n      }\n    }, {\n      name: 'flip',\n      options: {\n        padding: 5\n      }\n    }, {\n      name: 'computeStyles',\n      options: {\n        adaptive: !moveTransition\n      }\n    }, tippyModifier];\n\n    if (getIsDefaultRenderFn() && arrow) {\n      modifiers.push({\n        name: 'arrow',\n        options: {\n          element: arrow,\n          padding: 3\n        }\n      });\n    }\n\n    modifiers.push.apply(modifiers, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);\n    instance.popperInstance = (0,_popperjs_core__WEBPACK_IMPORTED_MODULE_0__.createPopper)(computedReference, popper, Object.assign({}, popperOptions, {\n      placement: placement,\n      onFirstUpdate: onFirstUpdate,\n      modifiers: modifiers\n    }));\n  }\n\n  function destroyPopperInstance() {\n    if (instance.popperInstance) {\n      instance.popperInstance.destroy();\n      instance.popperInstance = null;\n    }\n  }\n\n  function mount() {\n    var appendTo = instance.props.appendTo;\n    var parentNode; // By default, we'll append the popper to the triggerTargets's parentNode so\n    // it's directly after the reference element so the elements inside the\n    // tippy can be tabbed to\n    // If there are clipping issues, the user can specify a different appendTo\n    // and ensure focus management is handled correctly manually\n\n    var node = getCurrentTarget();\n\n    if (instance.props.interactive && appendTo === TIPPY_DEFAULT_APPEND_TO || appendTo === 'parent') {\n      parentNode = node.parentNode;\n    } else {\n      parentNode = invokeWithArgsOrReturn(appendTo, [node]);\n    } // The popper element needs to exist on the DOM before its position can be\n    // updated as Popper needs to read its dimensions\n\n\n    if (!parentNode.contains(popper)) {\n      parentNode.appendChild(popper);\n    }\n\n    instance.state.isMounted = true;\n    createPopperInstance();\n    /* istanbul ignore else */\n\n    if (true) {\n      // Accessibility check\n      warnWhen(instance.props.interactive && appendTo === defaultProps.appendTo && node.nextElementSibling !== popper, ['Interactive tippy element may not be accessible via keyboard', 'navigation because it is not directly after the reference element', 'in the DOM source order.', '\\n\\n', 'Using a wrapper <div> or <span> tag around the reference element', 'solves this by creating a new parentNode context.', '\\n\\n', 'Specifying `appendTo: document.body` silences this warning, but it', 'assumes you are using a focus management solution to handle', 'keyboard navigation.', '\\n\\n', 'See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity'].join(' '));\n    }\n  }\n\n  function getNestedPopperTree() {\n    return arrayFrom(popper.querySelectorAll('[data-tippy-root]'));\n  }\n\n  function scheduleShow(event) {\n    instance.clearDelayTimeouts();\n\n    if (event) {\n      invokeHook('onTrigger', [instance, event]);\n    }\n\n    addDocumentPress();\n    var delay = getDelay(true);\n\n    var _getNormalizedTouchSe = getNormalizedTouchSettings(),\n        touchValue = _getNormalizedTouchSe[0],\n        touchDelay = _getNormalizedTouchSe[1];\n\n    if (currentInput.isTouch && touchValue === 'hold' && touchDelay) {\n      delay = touchDelay;\n    }\n\n    if (delay) {\n      showTimeout = setTimeout(function () {\n        instance.show();\n      }, delay);\n    } else {\n      instance.show();\n    }\n  }\n\n  function scheduleHide(event) {\n    instance.clearDelayTimeouts();\n    invokeHook('onUntrigger', [instance, event]);\n\n    if (!instance.state.isVisible) {\n      removeDocumentPress();\n      return;\n    } // For interactive tippies, scheduleHide is added to a document.body handler\n    // from onMouseLeave so must intercept scheduled hides from mousemove/leave\n    // events when trigger contains mouseenter and click, and the tip is\n    // currently shown as a result of a click.\n\n\n    if (instance.props.trigger.indexOf('mouseenter') >= 0 && instance.props.trigger.indexOf('click') >= 0 && ['mouseleave', 'mousemove'].indexOf(event.type) >= 0 && isVisibleFromClick) {\n      return;\n    }\n\n    var delay = getDelay(false);\n\n    if (delay) {\n      hideTimeout = setTimeout(function () {\n        if (instance.state.isVisible) {\n          instance.hide();\n        }\n      }, delay);\n    } else {\n      // Fixes a `transitionend` problem when it fires 1 frame too\n      // late sometimes, we don't want hide() to be called.\n      scheduleHideAnimationFrame = requestAnimationFrame(function () {\n        instance.hide();\n      });\n    }\n  } // ===========================================================================\n  // 🔑 Public methods\n  // ===========================================================================\n\n\n  function enable() {\n    instance.state.isEnabled = true;\n  }\n\n  function disable() {\n    // Disabling the instance should also hide it\n    // https://github.com/atomiks/tippy.js-react/issues/106\n    instance.hide();\n    instance.state.isEnabled = false;\n  }\n\n  function clearDelayTimeouts() {\n    clearTimeout(showTimeout);\n    clearTimeout(hideTimeout);\n    cancelAnimationFrame(scheduleHideAnimationFrame);\n  }\n\n  function setProps(partialProps) {\n    /* istanbul ignore else */\n    if (true) {\n      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('setProps'));\n    }\n\n    if (instance.state.isDestroyed) {\n      return;\n    }\n\n    invokeHook('onBeforeUpdate', [instance, partialProps]);\n    removeListeners();\n    var prevProps = instance.props;\n    var nextProps = evaluateProps(reference, Object.assign({}, prevProps, removeUndefinedProps(partialProps), {\n      ignoreAttributes: true\n    }));\n    instance.props = nextProps;\n    addListeners();\n\n    if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {\n      cleanupInteractiveMouseListeners();\n      debouncedOnMouseMove = debounce(onMouseMove, nextProps.interactiveDebounce);\n    } // Ensure stale aria-expanded attributes are removed\n\n\n    if (prevProps.triggerTarget && !nextProps.triggerTarget) {\n      normalizeToArray(prevProps.triggerTarget).forEach(function (node) {\n        node.removeAttribute('aria-expanded');\n      });\n    } else if (nextProps.triggerTarget) {\n      reference.removeAttribute('aria-expanded');\n    }\n\n    handleAriaExpandedAttribute();\n    handleStyles();\n\n    if (onUpdate) {\n      onUpdate(prevProps, nextProps);\n    }\n\n    if (instance.popperInstance) {\n      createPopperInstance(); // Fixes an issue with nested tippies if they are all getting re-rendered,\n      // and the nested ones get re-rendered first.\n      // https://github.com/atomiks/tippyjs-react/issues/177\n      // TODO: find a cleaner / more efficient solution(!)\n\n      getNestedPopperTree().forEach(function (nestedPopper) {\n        // React (and other UI libs likely) requires a rAF wrapper as it flushes\n        // its work in one\n        requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);\n      });\n    }\n\n    invokeHook('onAfterUpdate', [instance, partialProps]);\n  }\n\n  function setContent(content) {\n    instance.setProps({\n      content: content\n    });\n  }\n\n  function show() {\n    /* istanbul ignore else */\n    if (true) {\n      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('show'));\n    } // Early bail-out\n\n\n    var isAlreadyVisible = instance.state.isVisible;\n    var isDestroyed = instance.state.isDestroyed;\n    var isDisabled = !instance.state.isEnabled;\n    var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;\n    var duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);\n\n    if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {\n      return;\n    } // Normalize `disabled` behavior across browsers.\n    // Firefox allows events on disabled elements, but Chrome doesn't.\n    // Using a wrapper element (i.e. <span>) is recommended.\n\n\n    if (getCurrentTarget().hasAttribute('disabled')) {\n      return;\n    }\n\n    invokeHook('onShow', [instance], false);\n\n    if (instance.props.onShow(instance) === false) {\n      return;\n    }\n\n    instance.state.isVisible = true;\n\n    if (getIsDefaultRenderFn()) {\n      popper.style.visibility = 'visible';\n    }\n\n    handleStyles();\n    addDocumentPress();\n\n    if (!instance.state.isMounted) {\n      popper.style.transition = 'none';\n    } // If flipping to the opposite side after hiding at least once, the\n    // animation will use the wrong placement without resetting the duration\n\n\n    if (getIsDefaultRenderFn()) {\n      var _getDefaultTemplateCh2 = getDefaultTemplateChildren(),\n          box = _getDefaultTemplateCh2.box,\n          content = _getDefaultTemplateCh2.content;\n\n      setTransitionDuration([box, content], 0);\n    }\n\n    onFirstUpdate = function onFirstUpdate() {\n      var _instance$popperInsta2;\n\n      if (!instance.state.isVisible || ignoreOnFirstUpdate) {\n        return;\n      }\n\n      ignoreOnFirstUpdate = true; // reflow\n\n      void popper.offsetHeight;\n      popper.style.transition = instance.props.moveTransition;\n\n      if (getIsDefaultRenderFn() && instance.props.animation) {\n        var _getDefaultTemplateCh3 = getDefaultTemplateChildren(),\n            _box = _getDefaultTemplateCh3.box,\n            _content = _getDefaultTemplateCh3.content;\n\n        setTransitionDuration([_box, _content], duration);\n        setVisibilityState([_box, _content], 'visible');\n      }\n\n      handleAriaContentAttribute();\n      handleAriaExpandedAttribute();\n      pushIfUnique(mountedInstances, instance); // certain modifiers (e.g. `maxSize`) require a second update after the\n      // popper has been positioned for the first time\n\n      (_instance$popperInsta2 = instance.popperInstance) == null ? void 0 : _instance$popperInsta2.forceUpdate();\n      invokeHook('onMount', [instance]);\n\n      if (instance.props.animation && getIsDefaultRenderFn()) {\n        onTransitionedIn(duration, function () {\n          instance.state.isShown = true;\n          invokeHook('onShown', [instance]);\n        });\n      }\n    };\n\n    mount();\n  }\n\n  function hide() {\n    /* istanbul ignore else */\n    if (true) {\n      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('hide'));\n    } // Early bail-out\n\n\n    var isAlreadyHidden = !instance.state.isVisible;\n    var isDestroyed = instance.state.isDestroyed;\n    var isDisabled = !instance.state.isEnabled;\n    var duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);\n\n    if (isAlreadyHidden || isDestroyed || isDisabled) {\n      return;\n    }\n\n    invokeHook('onHide', [instance], false);\n\n    if (instance.props.onHide(instance) === false) {\n      return;\n    }\n\n    instance.state.isVisible = false;\n    instance.state.isShown = false;\n    ignoreOnFirstUpdate = false;\n    isVisibleFromClick = false;\n\n    if (getIsDefaultRenderFn()) {\n      popper.style.visibility = 'hidden';\n    }\n\n    cleanupInteractiveMouseListeners();\n    removeDocumentPress();\n    handleStyles(true);\n\n    if (getIsDefaultRenderFn()) {\n      var _getDefaultTemplateCh4 = getDefaultTemplateChildren(),\n          box = _getDefaultTemplateCh4.box,\n          content = _getDefaultTemplateCh4.content;\n\n      if (instance.props.animation) {\n        setTransitionDuration([box, content], duration);\n        setVisibilityState([box, content], 'hidden');\n      }\n    }\n\n    handleAriaContentAttribute();\n    handleAriaExpandedAttribute();\n\n    if (instance.props.animation) {\n      if (getIsDefaultRenderFn()) {\n        onTransitionedOut(duration, instance.unmount);\n      }\n    } else {\n      instance.unmount();\n    }\n  }\n\n  function hideWithInteractivity(event) {\n    /* istanbul ignore else */\n    if (true) {\n      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('hideWithInteractivity'));\n    }\n\n    getDocument().addEventListener('mousemove', debouncedOnMouseMove);\n    pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);\n    debouncedOnMouseMove(event);\n  }\n\n  function unmount() {\n    /* istanbul ignore else */\n    if (true) {\n      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('unmount'));\n    }\n\n    if (instance.state.isVisible) {\n      instance.hide();\n    }\n\n    if (!instance.state.isMounted) {\n      return;\n    }\n\n    destroyPopperInstance(); // If a popper is not interactive, it will be appended outside the popper\n    // tree by default. This seems mainly for interactive tippies, but we should\n    // find a workaround if possible\n\n    getNestedPopperTree().forEach(function (nestedPopper) {\n      nestedPopper._tippy.unmount();\n    });\n\n    if (popper.parentNode) {\n      popper.parentNode.removeChild(popper);\n    }\n\n    mountedInstances = mountedInstances.filter(function (i) {\n      return i !== instance;\n    });\n    instance.state.isMounted = false;\n    invokeHook('onHidden', [instance]);\n  }\n\n  function destroy() {\n    /* istanbul ignore else */\n    if (true) {\n      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('destroy'));\n    }\n\n    if (instance.state.isDestroyed) {\n      return;\n    }\n\n    instance.clearDelayTimeouts();\n    instance.unmount();\n    removeListeners();\n    delete reference._tippy;\n    instance.state.isDestroyed = true;\n    invokeHook('onDestroy', [instance]);\n  }\n}\n\nfunction tippy(targets, optionalProps) {\n  if (optionalProps === void 0) {\n    optionalProps = {};\n  }\n\n  var plugins = defaultProps.plugins.concat(optionalProps.plugins || []);\n  /* istanbul ignore else */\n\n  if (true) {\n    validateTargets(targets);\n    validateProps(optionalProps, plugins);\n  }\n\n  bindGlobalEventListeners();\n  var passedProps = Object.assign({}, optionalProps, {\n    plugins: plugins\n  });\n  var elements = getArrayOfElements(targets);\n  /* istanbul ignore else */\n\n  if (true) {\n    var isSingleContentElement = isElement(passedProps.content);\n    var isMoreThanOneReferenceElement = elements.length > 1;\n    warnWhen(isSingleContentElement && isMoreThanOneReferenceElement, ['tippy() was passed an Element as the `content` prop, but more than', 'one tippy instance was created by this invocation. This means the', 'content element will only be appended to the last tippy instance.', '\\n\\n', 'Instead, pass the .innerHTML of the element, or use a function that', 'returns a cloned version of the element instead.', '\\n\\n', '1) content: element.innerHTML\\n', '2) content: () => element.cloneNode(true)'].join(' '));\n  }\n\n  var instances = elements.reduce(function (acc, reference) {\n    var instance = reference && createTippy(reference, passedProps);\n\n    if (instance) {\n      acc.push(instance);\n    }\n\n    return acc;\n  }, []);\n  return isElement(targets) ? instances[0] : instances;\n}\n\ntippy.defaultProps = defaultProps;\ntippy.setDefaultProps = setDefaultProps;\ntippy.currentInput = currentInput;\nvar hideAll = function hideAll(_temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n      excludedReferenceOrInstance = _ref.exclude,\n      duration = _ref.duration;\n\n  mountedInstances.forEach(function (instance) {\n    var isExcluded = false;\n\n    if (excludedReferenceOrInstance) {\n      isExcluded = isReferenceElement(excludedReferenceOrInstance) ? instance.reference === excludedReferenceOrInstance : instance.popper === excludedReferenceOrInstance.popper;\n    }\n\n    if (!isExcluded) {\n      var originalDuration = instance.props.duration;\n      instance.setProps({\n        duration: duration\n      });\n      instance.hide();\n\n      if (!instance.state.isDestroyed) {\n        instance.setProps({\n          duration: originalDuration\n        });\n      }\n    }\n  });\n};\n\n// every time the popper is destroyed (i.e. a new target), removing the styles\n// and causing transitions to break for singletons when the console is open, but\n// most notably for non-transform styles being used, `gpuAcceleration: false`.\n\nvar applyStylesModifier = Object.assign({}, _popperjs_core__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n  effect: function effect(_ref) {\n    var state = _ref.state;\n    var initialStyles = {\n      popper: {\n        position: state.options.strategy,\n        left: '0',\n        top: '0',\n        margin: '0'\n      },\n      arrow: {\n        position: 'absolute'\n      },\n      reference: {}\n    };\n    Object.assign(state.elements.popper.style, initialStyles.popper);\n    state.styles = initialStyles;\n\n    if (state.elements.arrow) {\n      Object.assign(state.elements.arrow.style, initialStyles.arrow);\n    } // intentionally return no cleanup function\n    // return () => { ... }\n\n  }\n});\n\nvar createSingleton = function createSingleton(tippyInstances, optionalProps) {\n  var _optionalProps$popper;\n\n  if (optionalProps === void 0) {\n    optionalProps = {};\n  }\n\n  /* istanbul ignore else */\n  if (true) {\n    errorWhen(!Array.isArray(tippyInstances), ['The first argument passed to createSingleton() must be an array of', 'tippy instances. The passed value was', String(tippyInstances)].join(' '));\n  }\n\n  var individualInstances = tippyInstances;\n  var references = [];\n  var triggerTargets = [];\n  var currentTarget;\n  var overrides = optionalProps.overrides;\n  var interceptSetPropsCleanups = [];\n  var shownOnCreate = false;\n\n  function setTriggerTargets() {\n    triggerTargets = individualInstances.map(function (instance) {\n      return normalizeToArray(instance.props.triggerTarget || instance.reference);\n    }).reduce(function (acc, item) {\n      return acc.concat(item);\n    }, []);\n  }\n\n  function setReferences() {\n    references = individualInstances.map(function (instance) {\n      return instance.reference;\n    });\n  }\n\n  function enableInstances(isEnabled) {\n    individualInstances.forEach(function (instance) {\n      if (isEnabled) {\n        instance.enable();\n      } else {\n        instance.disable();\n      }\n    });\n  }\n\n  function interceptSetProps(singleton) {\n    return individualInstances.map(function (instance) {\n      var originalSetProps = instance.setProps;\n\n      instance.setProps = function (props) {\n        originalSetProps(props);\n\n        if (instance.reference === currentTarget) {\n          singleton.setProps(props);\n        }\n      };\n\n      return function () {\n        instance.setProps = originalSetProps;\n      };\n    });\n  } // have to pass singleton, as it maybe undefined on first call\n\n\n  function prepareInstance(singleton, target) {\n    var index = triggerTargets.indexOf(target); // bail-out\n\n    if (target === currentTarget) {\n      return;\n    }\n\n    currentTarget = target;\n    var overrideProps = (overrides || []).concat('content').reduce(function (acc, prop) {\n      acc[prop] = individualInstances[index].props[prop];\n      return acc;\n    }, {});\n    singleton.setProps(Object.assign({}, overrideProps, {\n      getReferenceClientRect: typeof overrideProps.getReferenceClientRect === 'function' ? overrideProps.getReferenceClientRect : function () {\n        var _references$index;\n\n        return (_references$index = references[index]) == null ? void 0 : _references$index.getBoundingClientRect();\n      }\n    }));\n  }\n\n  enableInstances(false);\n  setReferences();\n  setTriggerTargets();\n  var plugin = {\n    fn: function fn() {\n      return {\n        onDestroy: function onDestroy() {\n          enableInstances(true);\n        },\n        onHidden: function onHidden() {\n          currentTarget = null;\n        },\n        onClickOutside: function onClickOutside(instance) {\n          if (instance.props.showOnCreate && !shownOnCreate) {\n            shownOnCreate = true;\n            currentTarget = null;\n          }\n        },\n        onShow: function onShow(instance) {\n          if (instance.props.showOnCreate && !shownOnCreate) {\n            shownOnCreate = true;\n            prepareInstance(instance, references[0]);\n          }\n        },\n        onTrigger: function onTrigger(instance, event) {\n          prepareInstance(instance, event.currentTarget);\n        }\n      };\n    }\n  };\n  var singleton = tippy(div(), Object.assign({}, removeProperties(optionalProps, ['overrides']), {\n    plugins: [plugin].concat(optionalProps.plugins || []),\n    triggerTarget: triggerTargets,\n    popperOptions: Object.assign({}, optionalProps.popperOptions, {\n      modifiers: [].concat(((_optionalProps$popper = optionalProps.popperOptions) == null ? void 0 : _optionalProps$popper.modifiers) || [], [applyStylesModifier])\n    })\n  }));\n  var originalShow = singleton.show;\n\n  singleton.show = function (target) {\n    originalShow(); // first time, showOnCreate or programmatic call with no params\n    // default to showing first instance\n\n    if (!currentTarget && target == null) {\n      return prepareInstance(singleton, references[0]);\n    } // triggered from event (do nothing as prepareInstance already called by onTrigger)\n    // programmatic call with no params when already visible (do nothing again)\n\n\n    if (currentTarget && target == null) {\n      return;\n    } // target is index of instance\n\n\n    if (typeof target === 'number') {\n      return references[target] && prepareInstance(singleton, references[target]);\n    } // target is a child tippy instance\n\n\n    if (individualInstances.indexOf(target) >= 0) {\n      var ref = target.reference;\n      return prepareInstance(singleton, ref);\n    } // target is a ReferenceElement\n\n\n    if (references.indexOf(target) >= 0) {\n      return prepareInstance(singleton, target);\n    }\n  };\n\n  singleton.showNext = function () {\n    var first = references[0];\n\n    if (!currentTarget) {\n      return singleton.show(0);\n    }\n\n    var index = references.indexOf(currentTarget);\n    singleton.show(references[index + 1] || first);\n  };\n\n  singleton.showPrevious = function () {\n    var last = references[references.length - 1];\n\n    if (!currentTarget) {\n      return singleton.show(last);\n    }\n\n    var index = references.indexOf(currentTarget);\n    var target = references[index - 1] || last;\n    singleton.show(target);\n  };\n\n  var originalSetProps = singleton.setProps;\n\n  singleton.setProps = function (props) {\n    overrides = props.overrides || overrides;\n    originalSetProps(props);\n  };\n\n  singleton.setInstances = function (nextInstances) {\n    enableInstances(true);\n    interceptSetPropsCleanups.forEach(function (fn) {\n      return fn();\n    });\n    individualInstances = nextInstances;\n    enableInstances(false);\n    setReferences();\n    setTriggerTargets();\n    interceptSetPropsCleanups = interceptSetProps(singleton);\n    singleton.setProps({\n      triggerTarget: triggerTargets\n    });\n  };\n\n  interceptSetPropsCleanups = interceptSetProps(singleton);\n  return singleton;\n};\n\nvar BUBBLING_EVENTS_MAP = {\n  mouseover: 'mouseenter',\n  focusin: 'focus',\n  click: 'click'\n};\n/**\n * Creates a delegate instance that controls the creation of tippy instances\n * for child elements (`target` CSS selector).\n */\n\nfunction delegate(targets, props) {\n  /* istanbul ignore else */\n  if (true) {\n    errorWhen(!(props && props.target), ['You must specity a `target` prop indicating a CSS selector string matching', 'the target elements that should receive a tippy.'].join(' '));\n  }\n\n  var listeners = [];\n  var childTippyInstances = [];\n  var disabled = false;\n  var target = props.target;\n  var nativeProps = removeProperties(props, ['target']);\n  var parentProps = Object.assign({}, nativeProps, {\n    trigger: 'manual',\n    touch: false\n  });\n  var childProps = Object.assign({\n    touch: defaultProps.touch\n  }, nativeProps, {\n    showOnCreate: true\n  });\n  var returnValue = tippy(targets, parentProps);\n  var normalizedReturnValue = normalizeToArray(returnValue);\n\n  function onTrigger(event) {\n    if (!event.target || disabled) {\n      return;\n    }\n\n    var targetNode = event.target.closest(target);\n\n    if (!targetNode) {\n      return;\n    } // Get relevant trigger with fallbacks:\n    // 1. Check `data-tippy-trigger` attribute on target node\n    // 2. Fallback to `trigger` passed to `delegate()`\n    // 3. Fallback to `defaultProps.trigger`\n\n\n    var trigger = targetNode.getAttribute('data-tippy-trigger') || props.trigger || defaultProps.trigger; // @ts-ignore\n\n    if (targetNode._tippy) {\n      return;\n    }\n\n    if (event.type === 'touchstart' && typeof childProps.touch === 'boolean') {\n      return;\n    }\n\n    if (event.type !== 'touchstart' && trigger.indexOf(BUBBLING_EVENTS_MAP[event.type]) < 0) {\n      return;\n    }\n\n    var instance = tippy(targetNode, childProps);\n\n    if (instance) {\n      childTippyInstances = childTippyInstances.concat(instance);\n    }\n  }\n\n  function on(node, eventType, handler, options) {\n    if (options === void 0) {\n      options = false;\n    }\n\n    node.addEventListener(eventType, handler, options);\n    listeners.push({\n      node: node,\n      eventType: eventType,\n      handler: handler,\n      options: options\n    });\n  }\n\n  function addEventListeners(instance) {\n    var reference = instance.reference;\n    on(reference, 'touchstart', onTrigger, TOUCH_OPTIONS);\n    on(reference, 'mouseover', onTrigger);\n    on(reference, 'focusin', onTrigger);\n    on(reference, 'click', onTrigger);\n  }\n\n  function removeEventListeners() {\n    listeners.forEach(function (_ref) {\n      var node = _ref.node,\n          eventType = _ref.eventType,\n          handler = _ref.handler,\n          options = _ref.options;\n      node.removeEventListener(eventType, handler, options);\n    });\n    listeners = [];\n  }\n\n  function applyMutations(instance) {\n    var originalDestroy = instance.destroy;\n    var originalEnable = instance.enable;\n    var originalDisable = instance.disable;\n\n    instance.destroy = function (shouldDestroyChildInstances) {\n      if (shouldDestroyChildInstances === void 0) {\n        shouldDestroyChildInstances = true;\n      }\n\n      if (shouldDestroyChildInstances) {\n        childTippyInstances.forEach(function (instance) {\n          instance.destroy();\n        });\n      }\n\n      childTippyInstances = [];\n      removeEventListeners();\n      originalDestroy();\n    };\n\n    instance.enable = function () {\n      originalEnable();\n      childTippyInstances.forEach(function (instance) {\n        return instance.enable();\n      });\n      disabled = false;\n    };\n\n    instance.disable = function () {\n      originalDisable();\n      childTippyInstances.forEach(function (instance) {\n        return instance.disable();\n      });\n      disabled = true;\n    };\n\n    addEventListeners(instance);\n  }\n\n  normalizedReturnValue.forEach(applyMutations);\n  return returnValue;\n}\n\nvar animateFill = {\n  name: 'animateFill',\n  defaultValue: false,\n  fn: function fn(instance) {\n    var _instance$props$rende;\n\n    // @ts-ignore\n    if (!((_instance$props$rende = instance.props.render) != null && _instance$props$rende.$$tippy)) {\n      if (true) {\n        errorWhen(instance.props.animateFill, 'The `animateFill` plugin requires the default render function.');\n      }\n\n      return {};\n    }\n\n    var _getChildren = getChildren(instance.popper),\n        box = _getChildren.box,\n        content = _getChildren.content;\n\n    var backdrop = instance.props.animateFill ? createBackdropElement() : null;\n    return {\n      onCreate: function onCreate() {\n        if (backdrop) {\n          box.insertBefore(backdrop, box.firstElementChild);\n          box.setAttribute('data-animatefill', '');\n          box.style.overflow = 'hidden';\n          instance.setProps({\n            arrow: false,\n            animation: 'shift-away'\n          });\n        }\n      },\n      onMount: function onMount() {\n        if (backdrop) {\n          var transitionDuration = box.style.transitionDuration;\n          var duration = Number(transitionDuration.replace('ms', '')); // The content should fade in after the backdrop has mostly filled the\n          // tooltip element. `clip-path` is the other alternative but is not\n          // well-supported and is buggy on some devices.\n\n          content.style.transitionDelay = Math.round(duration / 10) + \"ms\";\n          backdrop.style.transitionDuration = transitionDuration;\n          setVisibilityState([backdrop], 'visible');\n        }\n      },\n      onShow: function onShow() {\n        if (backdrop) {\n          backdrop.style.transitionDuration = '0ms';\n        }\n      },\n      onHide: function onHide() {\n        if (backdrop) {\n          setVisibilityState([backdrop], 'hidden');\n        }\n      }\n    };\n  }\n};\n\nfunction createBackdropElement() {\n  var backdrop = div();\n  backdrop.className = BACKDROP_CLASS;\n  setVisibilityState([backdrop], 'hidden');\n  return backdrop;\n}\n\nvar mouseCoords = {\n  clientX: 0,\n  clientY: 0\n};\nvar activeInstances = [];\n\nfunction storeMouseCoords(_ref) {\n  var clientX = _ref.clientX,\n      clientY = _ref.clientY;\n  mouseCoords = {\n    clientX: clientX,\n    clientY: clientY\n  };\n}\n\nfunction addMouseCoordsListener(doc) {\n  doc.addEventListener('mousemove', storeMouseCoords);\n}\n\nfunction removeMouseCoordsListener(doc) {\n  doc.removeEventListener('mousemove', storeMouseCoords);\n}\n\nvar followCursor = {\n  name: 'followCursor',\n  defaultValue: false,\n  fn: function fn(instance) {\n    var reference = instance.reference;\n    var doc = getOwnerDocument(instance.props.triggerTarget || reference);\n    var isInternalUpdate = false;\n    var wasFocusEvent = false;\n    var isUnmounted = true;\n    var prevProps = instance.props;\n\n    function getIsInitialBehavior() {\n      return instance.props.followCursor === 'initial' && instance.state.isVisible;\n    }\n\n    function addListener() {\n      doc.addEventListener('mousemove', onMouseMove);\n    }\n\n    function removeListener() {\n      doc.removeEventListener('mousemove', onMouseMove);\n    }\n\n    function unsetGetReferenceClientRect() {\n      isInternalUpdate = true;\n      instance.setProps({\n        getReferenceClientRect: null\n      });\n      isInternalUpdate = false;\n    }\n\n    function onMouseMove(event) {\n      // If the instance is interactive, avoid updating the position unless it's\n      // over the reference element\n      var isCursorOverReference = event.target ? reference.contains(event.target) : true;\n      var followCursor = instance.props.followCursor;\n      var clientX = event.clientX,\n          clientY = event.clientY;\n      var rect = reference.getBoundingClientRect();\n      var relativeX = clientX - rect.left;\n      var relativeY = clientY - rect.top;\n\n      if (isCursorOverReference || !instance.props.interactive) {\n        instance.setProps({\n          // @ts-ignore - unneeded DOMRect properties\n          getReferenceClientRect: function getReferenceClientRect() {\n            var rect = reference.getBoundingClientRect();\n            var x = clientX;\n            var y = clientY;\n\n            if (followCursor === 'initial') {\n              x = rect.left + relativeX;\n              y = rect.top + relativeY;\n            }\n\n            var top = followCursor === 'horizontal' ? rect.top : y;\n            var right = followCursor === 'vertical' ? rect.right : x;\n            var bottom = followCursor === 'horizontal' ? rect.bottom : y;\n            var left = followCursor === 'vertical' ? rect.left : x;\n            return {\n              width: right - left,\n              height: bottom - top,\n              top: top,\n              right: right,\n              bottom: bottom,\n              left: left\n            };\n          }\n        });\n      }\n    }\n\n    function create() {\n      if (instance.props.followCursor) {\n        activeInstances.push({\n          instance: instance,\n          doc: doc\n        });\n        addMouseCoordsListener(doc);\n      }\n    }\n\n    function destroy() {\n      activeInstances = activeInstances.filter(function (data) {\n        return data.instance !== instance;\n      });\n\n      if (activeInstances.filter(function (data) {\n        return data.doc === doc;\n      }).length === 0) {\n        removeMouseCoordsListener(doc);\n      }\n    }\n\n    return {\n      onCreate: create,\n      onDestroy: destroy,\n      onBeforeUpdate: function onBeforeUpdate() {\n        prevProps = instance.props;\n      },\n      onAfterUpdate: function onAfterUpdate(_, _ref2) {\n        var followCursor = _ref2.followCursor;\n\n        if (isInternalUpdate) {\n          return;\n        }\n\n        if (followCursor !== undefined && prevProps.followCursor !== followCursor) {\n          destroy();\n\n          if (followCursor) {\n            create();\n\n            if (instance.state.isMounted && !wasFocusEvent && !getIsInitialBehavior()) {\n              addListener();\n            }\n          } else {\n            removeListener();\n            unsetGetReferenceClientRect();\n          }\n        }\n      },\n      onMount: function onMount() {\n        if (instance.props.followCursor && !wasFocusEvent) {\n          if (isUnmounted) {\n            onMouseMove(mouseCoords);\n            isUnmounted = false;\n          }\n\n          if (!getIsInitialBehavior()) {\n            addListener();\n          }\n        }\n      },\n      onTrigger: function onTrigger(_, event) {\n        if (isMouseEvent(event)) {\n          mouseCoords = {\n            clientX: event.clientX,\n            clientY: event.clientY\n          };\n        }\n\n        wasFocusEvent = event.type === 'focus';\n      },\n      onHidden: function onHidden() {\n        if (instance.props.followCursor) {\n          unsetGetReferenceClientRect();\n          removeListener();\n          isUnmounted = true;\n        }\n      }\n    };\n  }\n};\n\nfunction getProps(props, modifier) {\n  var _props$popperOptions;\n\n  return {\n    popperOptions: Object.assign({}, props.popperOptions, {\n      modifiers: [].concat((((_props$popperOptions = props.popperOptions) == null ? void 0 : _props$popperOptions.modifiers) || []).filter(function (_ref) {\n        var name = _ref.name;\n        return name !== modifier.name;\n      }), [modifier])\n    })\n  };\n}\n\nvar inlinePositioning = {\n  name: 'inlinePositioning',\n  defaultValue: false,\n  fn: function fn(instance) {\n    var reference = instance.reference;\n\n    function isEnabled() {\n      return !!instance.props.inlinePositioning;\n    }\n\n    var placement;\n    var cursorRectIndex = -1;\n    var isInternalUpdate = false;\n    var triedPlacements = [];\n    var modifier = {\n      name: 'tippyInlinePositioning',\n      enabled: true,\n      phase: 'afterWrite',\n      fn: function fn(_ref2) {\n        var state = _ref2.state;\n\n        if (isEnabled()) {\n          if (triedPlacements.indexOf(state.placement) !== -1) {\n            triedPlacements = [];\n          }\n\n          if (placement !== state.placement && triedPlacements.indexOf(state.placement) === -1) {\n            triedPlacements.push(state.placement);\n            instance.setProps({\n              // @ts-ignore - unneeded DOMRect properties\n              getReferenceClientRect: function getReferenceClientRect() {\n                return _getReferenceClientRect(state.placement);\n              }\n            });\n          }\n\n          placement = state.placement;\n        }\n      }\n    };\n\n    function _getReferenceClientRect(placement) {\n      return getInlineBoundingClientRect(getBasePlacement(placement), reference.getBoundingClientRect(), arrayFrom(reference.getClientRects()), cursorRectIndex);\n    }\n\n    function setInternalProps(partialProps) {\n      isInternalUpdate = true;\n      instance.setProps(partialProps);\n      isInternalUpdate = false;\n    }\n\n    function addModifier() {\n      if (!isInternalUpdate) {\n        setInternalProps(getProps(instance.props, modifier));\n      }\n    }\n\n    return {\n      onCreate: addModifier,\n      onAfterUpdate: addModifier,\n      onTrigger: function onTrigger(_, event) {\n        if (isMouseEvent(event)) {\n          var rects = arrayFrom(instance.reference.getClientRects());\n          var cursorRect = rects.find(function (rect) {\n            return rect.left - 2 <= event.clientX && rect.right + 2 >= event.clientX && rect.top - 2 <= event.clientY && rect.bottom + 2 >= event.clientY;\n          });\n          var index = rects.indexOf(cursorRect);\n          cursorRectIndex = index > -1 ? index : cursorRectIndex;\n        }\n      },\n      onHidden: function onHidden() {\n        cursorRectIndex = -1;\n      }\n    };\n  }\n};\nfunction getInlineBoundingClientRect(currentBasePlacement, boundingRect, clientRects, cursorRectIndex) {\n  // Not an inline element, or placement is not yet known\n  if (clientRects.length < 2 || currentBasePlacement === null) {\n    return boundingRect;\n  } // There are two rects and they are disjoined\n\n\n  if (clientRects.length === 2 && cursorRectIndex >= 0 && clientRects[0].left > clientRects[1].right) {\n    return clientRects[cursorRectIndex] || boundingRect;\n  }\n\n  switch (currentBasePlacement) {\n    case 'top':\n    case 'bottom':\n      {\n        var firstRect = clientRects[0];\n        var lastRect = clientRects[clientRects.length - 1];\n        var isTop = currentBasePlacement === 'top';\n        var top = firstRect.top;\n        var bottom = lastRect.bottom;\n        var left = isTop ? firstRect.left : lastRect.left;\n        var right = isTop ? firstRect.right : lastRect.right;\n        var width = right - left;\n        var height = bottom - top;\n        return {\n          top: top,\n          bottom: bottom,\n          left: left,\n          right: right,\n          width: width,\n          height: height\n        };\n      }\n\n    case 'left':\n    case 'right':\n      {\n        var minLeft = Math.min.apply(Math, clientRects.map(function (rects) {\n          return rects.left;\n        }));\n        var maxRight = Math.max.apply(Math, clientRects.map(function (rects) {\n          return rects.right;\n        }));\n        var measureRects = clientRects.filter(function (rect) {\n          return currentBasePlacement === 'left' ? rect.left === minLeft : rect.right === maxRight;\n        });\n        var _top = measureRects[0].top;\n        var _bottom = measureRects[measureRects.length - 1].bottom;\n        var _left = minLeft;\n        var _right = maxRight;\n\n        var _width = _right - _left;\n\n        var _height = _bottom - _top;\n\n        return {\n          top: _top,\n          bottom: _bottom,\n          left: _left,\n          right: _right,\n          width: _width,\n          height: _height\n        };\n      }\n\n    default:\n      {\n        return boundingRect;\n      }\n  }\n}\n\nvar sticky = {\n  name: 'sticky',\n  defaultValue: false,\n  fn: function fn(instance) {\n    var reference = instance.reference,\n        popper = instance.popper;\n\n    function getReference() {\n      return instance.popperInstance ? instance.popperInstance.state.elements.reference : reference;\n    }\n\n    function shouldCheck(value) {\n      return instance.props.sticky === true || instance.props.sticky === value;\n    }\n\n    var prevRefRect = null;\n    var prevPopRect = null;\n\n    function updatePosition() {\n      var currentRefRect = shouldCheck('reference') ? getReference().getBoundingClientRect() : null;\n      var currentPopRect = shouldCheck('popper') ? popper.getBoundingClientRect() : null;\n\n      if (currentRefRect && areRectsDifferent(prevRefRect, currentRefRect) || currentPopRect && areRectsDifferent(prevPopRect, currentPopRect)) {\n        if (instance.popperInstance) {\n          instance.popperInstance.update();\n        }\n      }\n\n      prevRefRect = currentRefRect;\n      prevPopRect = currentPopRect;\n\n      if (instance.state.isMounted) {\n        requestAnimationFrame(updatePosition);\n      }\n    }\n\n    return {\n      onMount: function onMount() {\n        if (instance.props.sticky) {\n          updatePosition();\n        }\n      }\n    };\n  }\n};\n\nfunction areRectsDifferent(rectA, rectB) {\n  if (rectA && rectB) {\n    return rectA.top !== rectB.top || rectA.right !== rectB.right || rectA.bottom !== rectB.bottom || rectA.left !== rectB.left;\n  }\n\n  return true;\n}\n\ntippy.setDefaultProps({\n  render: render\n});\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (tippy);\n\n//# sourceMappingURL=tippy.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aXBweS5qcy9kaXN0L3RpcHB5LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUMyRDs7QUFFM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUcsSUFBSTtBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQzs7O0FBR3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSx3RUFBd0U7QUFDMUU7O0FBRUE7O0FBRUE7QUFDQSw2QkFBNkI7O0FBRTdCO0FBQ0E7QUFDQSx1REFBdUQsNkVBQTZFO0FBQ3BJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxtQkFBbUI7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0ZBQXNGOztBQUV0RjtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU8sR0FBRztBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTs7O0FBR047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLDhCQUE4Qiw0REFBWSw0Q0FBNEM7QUFDdEY7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxJQUFxQztBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtDQUFrQzs7QUFFbEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUSxJQUFxQztBQUM3QztBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRLElBQXFDO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVEsSUFBcUM7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUSxJQUFxQztBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsTUFBTSxJQUFxQztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDLEVBQUUsc0RBQVc7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sc0JBQXNCOztBQUV0QjtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJOzs7QUFHSjtBQUNBLGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1QsdUNBQXVDO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBLG9CQUFvQjtBQUNwQjs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOzs7QUFHQTtBQUNBO0FBQ0EsTUFBTTs7O0FBR047QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7O0FBR0EsMEdBQTBHOztBQUUxRztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsSUFBcUM7QUFDL0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQsK0RBQWUsS0FBSyxFQUFDO0FBQzBHO0FBQy9IIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90aXBweS5qcy9kaXN0L3RpcHB5LmVzbS5qcz9kYTRkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiFcbiogdGlwcHkuanMgdjYuMy43XG4qIChjKSAyMDE3LTIwMjEgYXRvbWlrc1xuKiBNSVQgTGljZW5zZVxuKi9cbmltcG9ydCB7IGNyZWF0ZVBvcHBlciwgYXBwbHlTdHlsZXMgfSBmcm9tICdAcG9wcGVyanMvY29yZSc7XG5cbnZhciBST1VORF9BUlJPVyA9ICc8c3ZnIHdpZHRoPVwiMTZcIiBoZWlnaHQ9XCI2XCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxwYXRoIGQ9XCJNMCA2czEuNzk2LS4wMTMgNC42Ny0zLjYxNUM1Ljg1MS45IDYuOTMuMDA2IDggMGMxLjA3LS4wMDYgMi4xNDguODg3IDMuMzQzIDIuMzg1QzE0LjIzMyA2LjAwNSAxNiA2IDE2IDZIMHpcIj48L3N2Zz4nO1xudmFyIEJPWF9DTEFTUyA9IFwidGlwcHktYm94XCI7XG52YXIgQ09OVEVOVF9DTEFTUyA9IFwidGlwcHktY29udGVudFwiO1xudmFyIEJBQ0tEUk9QX0NMQVNTID0gXCJ0aXBweS1iYWNrZHJvcFwiO1xudmFyIEFSUk9XX0NMQVNTID0gXCJ0aXBweS1hcnJvd1wiO1xudmFyIFNWR19BUlJPV19DTEFTUyA9IFwidGlwcHktc3ZnLWFycm93XCI7XG52YXIgVE9VQ0hfT1BUSU9OUyA9IHtcbiAgcGFzc2l2ZTogdHJ1ZSxcbiAgY2FwdHVyZTogdHJ1ZVxufTtcbnZhciBUSVBQWV9ERUZBVUxUX0FQUEVORF9UTyA9IGZ1bmN0aW9uIFRJUFBZX0RFRkFVTFRfQVBQRU5EX1RPKCkge1xuICByZXR1cm4gZG9jdW1lbnQuYm9keTtcbn07XG5cbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwga2V5KSB7XG4gIHJldHVybiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbn1cbmZ1bmN0aW9uIGdldFZhbHVlQXRJbmRleE9yUmV0dXJuKHZhbHVlLCBpbmRleCwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHZhciB2ID0gdmFsdWVbaW5kZXhdO1xuICAgIHJldHVybiB2ID09IG51bGwgPyBBcnJheS5pc0FycmF5KGRlZmF1bHRWYWx1ZSkgPyBkZWZhdWx0VmFsdWVbaW5kZXhdIDogZGVmYXVsdFZhbHVlIDogdjtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGlzVHlwZSh2YWx1ZSwgdHlwZSkge1xuICB2YXIgc3RyID0ge30udG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gIHJldHVybiBzdHIuaW5kZXhPZignW29iamVjdCcpID09PSAwICYmIHN0ci5pbmRleE9mKHR5cGUgKyBcIl1cIikgPiAtMTtcbn1cbmZ1bmN0aW9uIGludm9rZVdpdGhBcmdzT3JSZXR1cm4odmFsdWUsIGFyZ3MpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IHZhbHVlLmFwcGx5KHZvaWQgMCwgYXJncykgOiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGRlYm91bmNlKGZuLCBtcykge1xuICAvLyBBdm9pZCB3cmFwcGluZyBpbiBgc2V0VGltZW91dGAgaWYgbXMgaXMgMCBhbnl3YXlcbiAgaWYgKG1zID09PSAwKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHRpbWVvdXQ7XG4gIHJldHVybiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGZuKGFyZyk7XG4gICAgfSwgbXMpO1xuICB9O1xufVxuZnVuY3Rpb24gcmVtb3ZlUHJvcGVydGllcyhvYmosIGtleXMpIHtcbiAgdmFyIGNsb25lID0gT2JqZWN0LmFzc2lnbih7fSwgb2JqKTtcbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICBkZWxldGUgY2xvbmVba2V5XTtcbiAgfSk7XG4gIHJldHVybiBjbG9uZTtcbn1cbmZ1bmN0aW9uIHNwbGl0QnlTcGFjZXModmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLnNwbGl0KC9cXHMrLykuZmlsdGVyKEJvb2xlYW4pO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplVG9BcnJheSh2YWx1ZSkge1xuICByZXR1cm4gW10uY29uY2F0KHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHB1c2hJZlVuaXF1ZShhcnIsIHZhbHVlKSB7XG4gIGlmIChhcnIuaW5kZXhPZih2YWx1ZSkgPT09IC0xKSB7XG4gICAgYXJyLnB1c2godmFsdWUpO1xuICB9XG59XG5mdW5jdGlvbiB1bmlxdWUoYXJyKSB7XG4gIHJldHVybiBhcnIuZmlsdGVyKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgIHJldHVybiBhcnIuaW5kZXhPZihpdGVtKSA9PT0gaW5kZXg7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xufVxuZnVuY3Rpb24gYXJyYXlGcm9tKHZhbHVlKSB7XG4gIHJldHVybiBbXS5zbGljZS5jYWxsKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZVVuZGVmaW5lZFByb3BzKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5KSB7XG4gICAgaWYgKG9ialtrZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGFjY1trZXldID0gb2JqW2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xufVxuXG5mdW5jdGlvbiBkaXYoKSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbn1cbmZ1bmN0aW9uIGlzRWxlbWVudCh2YWx1ZSkge1xuICByZXR1cm4gWydFbGVtZW50JywgJ0ZyYWdtZW50J10uc29tZShmdW5jdGlvbiAodHlwZSkge1xuICAgIHJldHVybiBpc1R5cGUodmFsdWUsIHR5cGUpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGlzTm9kZUxpc3QodmFsdWUpIHtcbiAgcmV0dXJuIGlzVHlwZSh2YWx1ZSwgJ05vZGVMaXN0Jyk7XG59XG5mdW5jdGlvbiBpc01vdXNlRXZlbnQodmFsdWUpIHtcbiAgcmV0dXJuIGlzVHlwZSh2YWx1ZSwgJ01vdXNlRXZlbnQnKTtcbn1cbmZ1bmN0aW9uIGlzUmVmZXJlbmNlRWxlbWVudCh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX3RpcHB5ICYmIHZhbHVlLl90aXBweS5yZWZlcmVuY2UgPT09IHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGdldEFycmF5T2ZFbGVtZW50cyh2YWx1ZSkge1xuICBpZiAoaXNFbGVtZW50KHZhbHVlKSkge1xuICAgIHJldHVybiBbdmFsdWVdO1xuICB9XG5cbiAgaWYgKGlzTm9kZUxpc3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIGFycmF5RnJvbSh2YWx1ZSk7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gYXJyYXlGcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodmFsdWUpKTtcbn1cbmZ1bmN0aW9uIHNldFRyYW5zaXRpb25EdXJhdGlvbihlbHMsIHZhbHVlKSB7XG4gIGVscy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgIGlmIChlbCkge1xuICAgICAgZWwuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gdmFsdWUgKyBcIm1zXCI7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHNldFZpc2liaWxpdHlTdGF0ZShlbHMsIHN0YXRlKSB7XG4gIGVscy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgIGlmIChlbCkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdkYXRhLXN0YXRlJywgc3RhdGUpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRPd25lckRvY3VtZW50KGVsZW1lbnRPckVsZW1lbnRzKSB7XG4gIHZhciBfZWxlbWVudCRvd25lckRvY3VtZW47XG5cbiAgdmFyIF9ub3JtYWxpemVUb0FycmF5ID0gbm9ybWFsaXplVG9BcnJheShlbGVtZW50T3JFbGVtZW50cyksXG4gICAgICBlbGVtZW50ID0gX25vcm1hbGl6ZVRvQXJyYXlbMF07IC8vIEVsZW1lbnRzIGNyZWF0ZWQgdmlhIGEgPHRlbXBsYXRlPiBoYXZlIGFuIG93bmVyRG9jdW1lbnQgd2l0aCBubyByZWZlcmVuY2UgdG8gdGhlIGJvZHlcblxuXG4gIHJldHVybiBlbGVtZW50ICE9IG51bGwgJiYgKF9lbGVtZW50JG93bmVyRG9jdW1lbiA9IGVsZW1lbnQub3duZXJEb2N1bWVudCkgIT0gbnVsbCAmJiBfZWxlbWVudCRvd25lckRvY3VtZW4uYm9keSA/IGVsZW1lbnQub3duZXJEb2N1bWVudCA6IGRvY3VtZW50O1xufVxuZnVuY3Rpb24gaXNDdXJzb3JPdXRzaWRlSW50ZXJhY3RpdmVCb3JkZXIocG9wcGVyVHJlZURhdGEsIGV2ZW50KSB7XG4gIHZhciBjbGllbnRYID0gZXZlbnQuY2xpZW50WCxcbiAgICAgIGNsaWVudFkgPSBldmVudC5jbGllbnRZO1xuICByZXR1cm4gcG9wcGVyVHJlZURhdGEuZXZlcnkoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICB2YXIgcG9wcGVyUmVjdCA9IF9yZWYucG9wcGVyUmVjdCxcbiAgICAgICAgcG9wcGVyU3RhdGUgPSBfcmVmLnBvcHBlclN0YXRlLFxuICAgICAgICBwcm9wcyA9IF9yZWYucHJvcHM7XG4gICAgdmFyIGludGVyYWN0aXZlQm9yZGVyID0gcHJvcHMuaW50ZXJhY3RpdmVCb3JkZXI7XG4gICAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHBvcHBlclN0YXRlLnBsYWNlbWVudCk7XG4gICAgdmFyIG9mZnNldERhdGEgPSBwb3BwZXJTdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldDtcblxuICAgIGlmICghb2Zmc2V0RGF0YSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHRvcERpc3RhbmNlID0gYmFzZVBsYWNlbWVudCA9PT0gJ2JvdHRvbScgPyBvZmZzZXREYXRhLnRvcC55IDogMDtcbiAgICB2YXIgYm90dG9tRGlzdGFuY2UgPSBiYXNlUGxhY2VtZW50ID09PSAndG9wJyA/IG9mZnNldERhdGEuYm90dG9tLnkgOiAwO1xuICAgIHZhciBsZWZ0RGlzdGFuY2UgPSBiYXNlUGxhY2VtZW50ID09PSAncmlnaHQnID8gb2Zmc2V0RGF0YS5sZWZ0LnggOiAwO1xuICAgIHZhciByaWdodERpc3RhbmNlID0gYmFzZVBsYWNlbWVudCA9PT0gJ2xlZnQnID8gb2Zmc2V0RGF0YS5yaWdodC54IDogMDtcbiAgICB2YXIgZXhjZWVkc1RvcCA9IHBvcHBlclJlY3QudG9wIC0gY2xpZW50WSArIHRvcERpc3RhbmNlID4gaW50ZXJhY3RpdmVCb3JkZXI7XG4gICAgdmFyIGV4Y2VlZHNCb3R0b20gPSBjbGllbnRZIC0gcG9wcGVyUmVjdC5ib3R0b20gLSBib3R0b21EaXN0YW5jZSA+IGludGVyYWN0aXZlQm9yZGVyO1xuICAgIHZhciBleGNlZWRzTGVmdCA9IHBvcHBlclJlY3QubGVmdCAtIGNsaWVudFggKyBsZWZ0RGlzdGFuY2UgPiBpbnRlcmFjdGl2ZUJvcmRlcjtcbiAgICB2YXIgZXhjZWVkc1JpZ2h0ID0gY2xpZW50WCAtIHBvcHBlclJlY3QucmlnaHQgLSByaWdodERpc3RhbmNlID4gaW50ZXJhY3RpdmVCb3JkZXI7XG4gICAgcmV0dXJuIGV4Y2VlZHNUb3AgfHwgZXhjZWVkc0JvdHRvbSB8fCBleGNlZWRzTGVmdCB8fCBleGNlZWRzUmlnaHQ7XG4gIH0pO1xufVxuZnVuY3Rpb24gdXBkYXRlVHJhbnNpdGlvbkVuZExpc3RlbmVyKGJveCwgYWN0aW9uLCBsaXN0ZW5lcikge1xuICB2YXIgbWV0aG9kID0gYWN0aW9uICsgXCJFdmVudExpc3RlbmVyXCI7IC8vIHNvbWUgYnJvd3NlcnMgYXBwYXJlbnRseSBzdXBwb3J0IGB0cmFuc2l0aW9uYCAodW5wcmVmaXhlZCkgYnV0IG9ubHkgZmlyZVxuICAvLyBgd2Via2l0VHJhbnNpdGlvbkVuZGAuLi5cblxuICBbJ3RyYW5zaXRpb25lbmQnLCAnd2Via2l0VHJhbnNpdGlvbkVuZCddLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgYm94W21ldGhvZF0oZXZlbnQsIGxpc3RlbmVyKTtcbiAgfSk7XG59XG4vKipcbiAqIENvbXBhcmVkIHRvIHh4eC5jb250YWlucywgdGhpcyBmdW5jdGlvbiB3b3JrcyBmb3IgZG9tIHN0cnVjdHVyZXMgd2l0aCBzaGFkb3dcbiAqIGRvbVxuICovXG5cbmZ1bmN0aW9uIGFjdHVhbENvbnRhaW5zKHBhcmVudCwgY2hpbGQpIHtcbiAgdmFyIHRhcmdldCA9IGNoaWxkO1xuXG4gIHdoaWxlICh0YXJnZXQpIHtcbiAgICB2YXIgX3RhcmdldCRnZXRSb290Tm9kZTtcblxuICAgIGlmIChwYXJlbnQuY29udGFpbnModGFyZ2V0KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdGFyZ2V0ID0gdGFyZ2V0LmdldFJvb3ROb2RlID09IG51bGwgPyB2b2lkIDAgOiAoX3RhcmdldCRnZXRSb290Tm9kZSA9IHRhcmdldC5nZXRSb290Tm9kZSgpKSA9PSBudWxsID8gdm9pZCAwIDogX3RhcmdldCRnZXRSb290Tm9kZS5ob3N0O1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgY3VycmVudElucHV0ID0ge1xuICBpc1RvdWNoOiBmYWxzZVxufTtcbnZhciBsYXN0TW91c2VNb3ZlVGltZSA9IDA7XG4vKipcbiAqIFdoZW4gYSBgdG91Y2hzdGFydGAgZXZlbnQgaXMgZmlyZWQsIGl0J3MgYXNzdW1lZCB0aGUgdXNlciBpcyB1c2luZyB0b3VjaFxuICogaW5wdXQuIFdlJ2xsIGJpbmQgYSBgbW91c2Vtb3ZlYCBldmVudCBsaXN0ZW5lciB0byBsaXN0ZW4gZm9yIG1vdXNlIGlucHV0IGluXG4gKiB0aGUgZnV0dXJlLiBUaGlzIHdheSwgdGhlIGBpc1RvdWNoYCBwcm9wZXJ0eSBpcyBmdWxseSBkeW5hbWljIGFuZCB3aWxsIGhhbmRsZVxuICogaHlicmlkIGRldmljZXMgdGhhdCB1c2UgYSBtaXggb2YgdG91Y2ggKyBtb3VzZSBpbnB1dC5cbiAqL1xuXG5mdW5jdGlvbiBvbkRvY3VtZW50VG91Y2hTdGFydCgpIHtcbiAgaWYgKGN1cnJlbnRJbnB1dC5pc1RvdWNoKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY3VycmVudElucHV0LmlzVG91Y2ggPSB0cnVlO1xuXG4gIGlmICh3aW5kb3cucGVyZm9ybWFuY2UpIHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbkRvY3VtZW50TW91c2VNb3ZlKTtcbiAgfVxufVxuLyoqXG4gKiBXaGVuIHR3byBgbW91c2Vtb3ZlYCBldmVudCBhcmUgZmlyZWQgY29uc2VjdXRpdmVseSB3aXRoaW4gMjBtcywgaXQncyBhc3N1bWVkXG4gKiB0aGUgdXNlciBpcyB1c2luZyBtb3VzZSBpbnB1dCBhZ2Fpbi4gYG1vdXNlbW92ZWAgY2FuIGZpcmUgb24gdG91Y2ggZGV2aWNlcyBhc1xuICogd2VsbCwgYnV0IHZlcnkgcmFyZWx5IHRoYXQgcXVpY2tseS5cbiAqL1xuXG5mdW5jdGlvbiBvbkRvY3VtZW50TW91c2VNb3ZlKCkge1xuICB2YXIgbm93ID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgaWYgKG5vdyAtIGxhc3RNb3VzZU1vdmVUaW1lIDwgMjApIHtcbiAgICBjdXJyZW50SW5wdXQuaXNUb3VjaCA9IGZhbHNlO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uRG9jdW1lbnRNb3VzZU1vdmUpO1xuICB9XG5cbiAgbGFzdE1vdXNlTW92ZVRpbWUgPSBub3c7XG59XG4vKipcbiAqIFdoZW4gYW4gZWxlbWVudCBpcyBpbiBmb2N1cyBhbmQgaGFzIGEgdGlwcHksIGxlYXZpbmcgdGhlIHRhYi93aW5kb3cgYW5kXG4gKiByZXR1cm5pbmcgY2F1c2VzIGl0IHRvIHNob3cgYWdhaW4uIEZvciBtb3VzZSB1c2VycyB0aGlzIGlzIHVuZXhwZWN0ZWQsIGJ1dFxuICogZm9yIGtleWJvYXJkIHVzZSBpdCBtYWtlcyBzZW5zZS5cbiAqIFRPRE86IGZpbmQgYSBiZXR0ZXIgdGVjaG5pcXVlIHRvIHNvbHZlIHRoaXMgcHJvYmxlbVxuICovXG5cbmZ1bmN0aW9uIG9uV2luZG93Qmx1cigpIHtcbiAgdmFyIGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXG4gIGlmIChpc1JlZmVyZW5jZUVsZW1lbnQoYWN0aXZlRWxlbWVudCkpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBhY3RpdmVFbGVtZW50Ll90aXBweTtcblxuICAgIGlmIChhY3RpdmVFbGVtZW50LmJsdXIgJiYgIWluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSkge1xuICAgICAgYWN0aXZlRWxlbWVudC5ibHVyKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBiaW5kR2xvYmFsRXZlbnRMaXN0ZW5lcnMoKSB7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBvbkRvY3VtZW50VG91Y2hTdGFydCwgVE9VQ0hfT1BUSU9OUyk7XG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgb25XaW5kb3dCbHVyKTtcbn1cblxudmFyIGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgaXNJRTExID0gaXNCcm93c2VyID8gLy8gQHRzLWlnbm9yZVxuISF3aW5kb3cubXNDcnlwdG8gOiBmYWxzZTtcblxuZnVuY3Rpb24gY3JlYXRlTWVtb3J5TGVha1dhcm5pbmcobWV0aG9kKSB7XG4gIHZhciB0eHQgPSBtZXRob2QgPT09ICdkZXN0cm95JyA/ICduIGFscmVhZHktJyA6ICcgJztcbiAgcmV0dXJuIFttZXRob2QgKyBcIigpIHdhcyBjYWxsZWQgb24gYVwiICsgdHh0ICsgXCJkZXN0cm95ZWQgaW5zdGFuY2UuIFRoaXMgaXMgYSBuby1vcCBidXRcIiwgJ2luZGljYXRlcyBhIHBvdGVudGlhbCBtZW1vcnkgbGVhay4nXS5qb2luKCcgJyk7XG59XG5mdW5jdGlvbiBjbGVhbih2YWx1ZSkge1xuICB2YXIgc3BhY2VzQW5kVGFicyA9IC9bIFxcdF17Mix9L2c7XG4gIHZhciBsaW5lU3RhcnRXaXRoU3BhY2VzID0gL15bIFxcdF0qL2dtO1xuICByZXR1cm4gdmFsdWUucmVwbGFjZShzcGFjZXNBbmRUYWJzLCAnICcpLnJlcGxhY2UobGluZVN0YXJ0V2l0aFNwYWNlcywgJycpLnRyaW0oKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGV2TWVzc2FnZShtZXNzYWdlKSB7XG4gIHJldHVybiBjbGVhbihcIlxcbiAgJWN0aXBweS5qc1xcblxcbiAgJWNcIiArIGNsZWFuKG1lc3NhZ2UpICsgXCJcXG5cXG4gICVjXFx1RDgzRFxcdURDNzdcXHUyMDBEIFRoaXMgaXMgYSBkZXZlbG9wbWVudC1vbmx5IG1lc3NhZ2UuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiBwcm9kdWN0aW9uLlxcbiAgXCIpO1xufVxuXG5mdW5jdGlvbiBnZXRGb3JtYXR0ZWRNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIFtnZXREZXZNZXNzYWdlKG1lc3NhZ2UpLCAvLyB0aXRsZVxuICAnY29sb3I6ICMwMEM1ODQ7IGZvbnQtc2l6ZTogMS4zZW07IGZvbnQtd2VpZ2h0OiBib2xkOycsIC8vIG1lc3NhZ2VcbiAgJ2xpbmUtaGVpZ2h0OiAxLjUnLCAvLyBmb290ZXJcbiAgJ2NvbG9yOiAjYTZhMDk1OyddO1xufSAvLyBBc3N1bWUgd2FybmluZ3MgYW5kIGVycm9ycyBuZXZlciBoYXZlIHRoZSBzYW1lIG1lc3NhZ2VcblxudmFyIHZpc2l0ZWRNZXNzYWdlcztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICByZXNldFZpc2l0ZWRNZXNzYWdlcygpO1xufVxuXG5mdW5jdGlvbiByZXNldFZpc2l0ZWRNZXNzYWdlcygpIHtcbiAgdmlzaXRlZE1lc3NhZ2VzID0gbmV3IFNldCgpO1xufVxuZnVuY3Rpb24gd2FybldoZW4oY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmIChjb25kaXRpb24gJiYgIXZpc2l0ZWRNZXNzYWdlcy5oYXMobWVzc2FnZSkpIHtcbiAgICB2YXIgX2NvbnNvbGU7XG5cbiAgICB2aXNpdGVkTWVzc2FnZXMuYWRkKG1lc3NhZ2UpO1xuXG4gICAgKF9jb25zb2xlID0gY29uc29sZSkud2Fybi5hcHBseShfY29uc29sZSwgZ2V0Rm9ybWF0dGVkTWVzc2FnZShtZXNzYWdlKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVycm9yV2hlbihjb25kaXRpb24sIG1lc3NhZ2UpIHtcbiAgaWYgKGNvbmRpdGlvbiAmJiAhdmlzaXRlZE1lc3NhZ2VzLmhhcyhtZXNzYWdlKSkge1xuICAgIHZhciBfY29uc29sZTI7XG5cbiAgICB2aXNpdGVkTWVzc2FnZXMuYWRkKG1lc3NhZ2UpO1xuXG4gICAgKF9jb25zb2xlMiA9IGNvbnNvbGUpLmVycm9yLmFwcGx5KF9jb25zb2xlMiwgZ2V0Rm9ybWF0dGVkTWVzc2FnZShtZXNzYWdlKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlVGFyZ2V0cyh0YXJnZXRzKSB7XG4gIHZhciBkaWRQYXNzRmFsc3lWYWx1ZSA9ICF0YXJnZXRzO1xuICB2YXIgZGlkUGFzc1BsYWluT2JqZWN0ID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHRhcmdldHMpID09PSAnW29iamVjdCBPYmplY3RdJyAmJiAhdGFyZ2V0cy5hZGRFdmVudExpc3RlbmVyO1xuICBlcnJvcldoZW4oZGlkUGFzc0ZhbHN5VmFsdWUsIFsndGlwcHkoKSB3YXMgcGFzc2VkJywgJ2AnICsgU3RyaW5nKHRhcmdldHMpICsgJ2AnLCAnYXMgaXRzIHRhcmdldHMgKGZpcnN0KSBhcmd1bWVudC4gVmFsaWQgdHlwZXMgYXJlOiBTdHJpbmcsIEVsZW1lbnQsJywgJ0VsZW1lbnRbXSwgb3IgTm9kZUxpc3QuJ10uam9pbignICcpKTtcbiAgZXJyb3JXaGVuKGRpZFBhc3NQbGFpbk9iamVjdCwgWyd0aXBweSgpIHdhcyBwYXNzZWQgYSBwbGFpbiBvYmplY3Qgd2hpY2ggaXMgbm90IHN1cHBvcnRlZCBhcyBhbiBhcmd1bWVudCcsICdmb3IgdmlydHVhbCBwb3NpdGlvbmluZy4gVXNlIHByb3BzLmdldFJlZmVyZW5jZUNsaWVudFJlY3QgaW5zdGVhZC4nXS5qb2luKCcgJykpO1xufVxuXG52YXIgcGx1Z2luUHJvcHMgPSB7XG4gIGFuaW1hdGVGaWxsOiBmYWxzZSxcbiAgZm9sbG93Q3Vyc29yOiBmYWxzZSxcbiAgaW5saW5lUG9zaXRpb25pbmc6IGZhbHNlLFxuICBzdGlja3k6IGZhbHNlXG59O1xudmFyIHJlbmRlclByb3BzID0ge1xuICBhbGxvd0hUTUw6IGZhbHNlLFxuICBhbmltYXRpb246ICdmYWRlJyxcbiAgYXJyb3c6IHRydWUsXG4gIGNvbnRlbnQ6ICcnLFxuICBpbmVydGlhOiBmYWxzZSxcbiAgbWF4V2lkdGg6IDM1MCxcbiAgcm9sZTogJ3Rvb2x0aXAnLFxuICB0aGVtZTogJycsXG4gIHpJbmRleDogOTk5OVxufTtcbnZhciBkZWZhdWx0UHJvcHMgPSBPYmplY3QuYXNzaWduKHtcbiAgYXBwZW5kVG86IFRJUFBZX0RFRkFVTFRfQVBQRU5EX1RPLFxuICBhcmlhOiB7XG4gICAgY29udGVudDogJ2F1dG8nLFxuICAgIGV4cGFuZGVkOiAnYXV0bydcbiAgfSxcbiAgZGVsYXk6IDAsXG4gIGR1cmF0aW9uOiBbMzAwLCAyNTBdLFxuICBnZXRSZWZlcmVuY2VDbGllbnRSZWN0OiBudWxsLFxuICBoaWRlT25DbGljazogdHJ1ZSxcbiAgaWdub3JlQXR0cmlidXRlczogZmFsc2UsXG4gIGludGVyYWN0aXZlOiBmYWxzZSxcbiAgaW50ZXJhY3RpdmVCb3JkZXI6IDIsXG4gIGludGVyYWN0aXZlRGVib3VuY2U6IDAsXG4gIG1vdmVUcmFuc2l0aW9uOiAnJyxcbiAgb2Zmc2V0OiBbMCwgMTBdLFxuICBvbkFmdGVyVXBkYXRlOiBmdW5jdGlvbiBvbkFmdGVyVXBkYXRlKCkge30sXG4gIG9uQmVmb3JlVXBkYXRlOiBmdW5jdGlvbiBvbkJlZm9yZVVwZGF0ZSgpIHt9LFxuICBvbkNyZWF0ZTogZnVuY3Rpb24gb25DcmVhdGUoKSB7fSxcbiAgb25EZXN0cm95OiBmdW5jdGlvbiBvbkRlc3Ryb3koKSB7fSxcbiAgb25IaWRkZW46IGZ1bmN0aW9uIG9uSGlkZGVuKCkge30sXG4gIG9uSGlkZTogZnVuY3Rpb24gb25IaWRlKCkge30sXG4gIG9uTW91bnQ6IGZ1bmN0aW9uIG9uTW91bnQoKSB7fSxcbiAgb25TaG93OiBmdW5jdGlvbiBvblNob3coKSB7fSxcbiAgb25TaG93bjogZnVuY3Rpb24gb25TaG93bigpIHt9LFxuICBvblRyaWdnZXI6IGZ1bmN0aW9uIG9uVHJpZ2dlcigpIHt9LFxuICBvblVudHJpZ2dlcjogZnVuY3Rpb24gb25VbnRyaWdnZXIoKSB7fSxcbiAgb25DbGlja091dHNpZGU6IGZ1bmN0aW9uIG9uQ2xpY2tPdXRzaWRlKCkge30sXG4gIHBsYWNlbWVudDogJ3RvcCcsXG4gIHBsdWdpbnM6IFtdLFxuICBwb3BwZXJPcHRpb25zOiB7fSxcbiAgcmVuZGVyOiBudWxsLFxuICBzaG93T25DcmVhdGU6IGZhbHNlLFxuICB0b3VjaDogdHJ1ZSxcbiAgdHJpZ2dlcjogJ21vdXNlZW50ZXIgZm9jdXMnLFxuICB0cmlnZ2VyVGFyZ2V0OiBudWxsXG59LCBwbHVnaW5Qcm9wcywgcmVuZGVyUHJvcHMpO1xudmFyIGRlZmF1bHRLZXlzID0gT2JqZWN0LmtleXMoZGVmYXVsdFByb3BzKTtcbnZhciBzZXREZWZhdWx0UHJvcHMgPSBmdW5jdGlvbiBzZXREZWZhdWx0UHJvcHMocGFydGlhbFByb3BzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB2YWxpZGF0ZVByb3BzKHBhcnRpYWxQcm9wcywgW10pO1xuICB9XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwYXJ0aWFsUHJvcHMpO1xuICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIGRlZmF1bHRQcm9wc1trZXldID0gcGFydGlhbFByb3BzW2tleV07XG4gIH0pO1xufTtcbmZ1bmN0aW9uIGdldEV4dGVuZGVkUGFzc2VkUHJvcHMocGFzc2VkUHJvcHMpIHtcbiAgdmFyIHBsdWdpbnMgPSBwYXNzZWRQcm9wcy5wbHVnaW5zIHx8IFtdO1xuICB2YXIgcGx1Z2luUHJvcHMgPSBwbHVnaW5zLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbHVnaW4pIHtcbiAgICB2YXIgbmFtZSA9IHBsdWdpbi5uYW1lLFxuICAgICAgICBkZWZhdWx0VmFsdWUgPSBwbHVnaW4uZGVmYXVsdFZhbHVlO1xuXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHZhciBfbmFtZTtcblxuICAgICAgYWNjW25hbWVdID0gcGFzc2VkUHJvcHNbbmFtZV0gIT09IHVuZGVmaW5lZCA/IHBhc3NlZFByb3BzW25hbWVdIDogKF9uYW1lID0gZGVmYXVsdFByb3BzW25hbWVdKSAhPSBudWxsID8gX25hbWUgOiBkZWZhdWx0VmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgcGFzc2VkUHJvcHMsIHBsdWdpblByb3BzKTtcbn1cbmZ1bmN0aW9uIGdldERhdGFBdHRyaWJ1dGVQcm9wcyhyZWZlcmVuY2UsIHBsdWdpbnMpIHtcbiAgdmFyIHByb3BLZXlzID0gcGx1Z2lucyA/IE9iamVjdC5rZXlzKGdldEV4dGVuZGVkUGFzc2VkUHJvcHMoT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFByb3BzLCB7XG4gICAgcGx1Z2luczogcGx1Z2luc1xuICB9KSkpIDogZGVmYXVsdEtleXM7XG4gIHZhciBwcm9wcyA9IHByb3BLZXlzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcbiAgICB2YXIgdmFsdWVBc1N0cmluZyA9IChyZWZlcmVuY2UuZ2V0QXR0cmlidXRlKFwiZGF0YS10aXBweS1cIiArIGtleSkgfHwgJycpLnRyaW0oKTtcblxuICAgIGlmICghdmFsdWVBc1N0cmluZykge1xuICAgICAgcmV0dXJuIGFjYztcbiAgICB9XG5cbiAgICBpZiAoa2V5ID09PSAnY29udGVudCcpIHtcbiAgICAgIGFjY1trZXldID0gdmFsdWVBc1N0cmluZztcbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYWNjW2tleV0gPSBKU09OLnBhcnNlKHZhbHVlQXNTdHJpbmcpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBhY2Nba2V5XSA9IHZhbHVlQXNTdHJpbmc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuICByZXR1cm4gcHJvcHM7XG59XG5mdW5jdGlvbiBldmFsdWF0ZVByb3BzKHJlZmVyZW5jZSwgcHJvcHMpIHtcbiAgdmFyIG91dCA9IE9iamVjdC5hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgY29udGVudDogaW52b2tlV2l0aEFyZ3NPclJldHVybihwcm9wcy5jb250ZW50LCBbcmVmZXJlbmNlXSlcbiAgfSwgcHJvcHMuaWdub3JlQXR0cmlidXRlcyA/IHt9IDogZ2V0RGF0YUF0dHJpYnV0ZVByb3BzKHJlZmVyZW5jZSwgcHJvcHMucGx1Z2lucykpO1xuICBvdXQuYXJpYSA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRQcm9wcy5hcmlhLCBvdXQuYXJpYSk7XG4gIG91dC5hcmlhID0ge1xuICAgIGV4cGFuZGVkOiBvdXQuYXJpYS5leHBhbmRlZCA9PT0gJ2F1dG8nID8gcHJvcHMuaW50ZXJhY3RpdmUgOiBvdXQuYXJpYS5leHBhbmRlZCxcbiAgICBjb250ZW50OiBvdXQuYXJpYS5jb250ZW50ID09PSAnYXV0bycgPyBwcm9wcy5pbnRlcmFjdGl2ZSA/IG51bGwgOiAnZGVzY3JpYmVkYnknIDogb3V0LmFyaWEuY29udGVudFxuICB9O1xuICByZXR1cm4gb3V0O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wcyhwYXJ0aWFsUHJvcHMsIHBsdWdpbnMpIHtcbiAgaWYgKHBhcnRpYWxQcm9wcyA9PT0gdm9pZCAwKSB7XG4gICAgcGFydGlhbFByb3BzID0ge307XG4gIH1cblxuICBpZiAocGx1Z2lucyA9PT0gdm9pZCAwKSB7XG4gICAgcGx1Z2lucyA9IFtdO1xuICB9XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwYXJ0aWFsUHJvcHMpO1xuICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICB2YXIgbm9uUGx1Z2luUHJvcHMgPSByZW1vdmVQcm9wZXJ0aWVzKGRlZmF1bHRQcm9wcywgT2JqZWN0LmtleXMocGx1Z2luUHJvcHMpKTtcbiAgICB2YXIgZGlkUGFzc1Vua25vd25Qcm9wID0gIWhhc093blByb3BlcnR5KG5vblBsdWdpblByb3BzLCBwcm9wKTsgLy8gQ2hlY2sgaWYgdGhlIHByb3AgZXhpc3RzIGluIGBwbHVnaW5zYFxuXG4gICAgaWYgKGRpZFBhc3NVbmtub3duUHJvcCkge1xuICAgICAgZGlkUGFzc1Vua25vd25Qcm9wID0gcGx1Z2lucy5maWx0ZXIoZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgICByZXR1cm4gcGx1Z2luLm5hbWUgPT09IHByb3A7XG4gICAgICB9KS5sZW5ndGggPT09IDA7XG4gICAgfVxuXG4gICAgd2FybldoZW4oZGlkUGFzc1Vua25vd25Qcm9wLCBbXCJgXCIgKyBwcm9wICsgXCJgXCIsIFwiaXMgbm90IGEgdmFsaWQgcHJvcC4gWW91IG1heSBoYXZlIHNwZWxsZWQgaXQgaW5jb3JyZWN0bHksIG9yIGlmIGl0J3NcIiwgJ2EgcGx1Z2luLCBmb3Jnb3QgdG8gcGFzcyBpdCBpbiBhbiBhcnJheSBhcyBwcm9wcy5wbHVnaW5zLicsICdcXG5cXG4nLCAnQWxsIHByb3BzOiBodHRwczovL2F0b21pa3MuZ2l0aHViLmlvL3RpcHB5anMvdjYvYWxsLXByb3BzL1xcbicsICdQbHVnaW5zOiBodHRwczovL2F0b21pa3MuZ2l0aHViLmlvL3RpcHB5anMvdjYvcGx1Z2lucy8nXS5qb2luKCcgJykpO1xuICB9KTtcbn1cblxudmFyIGlubmVySFRNTCA9IGZ1bmN0aW9uIGlubmVySFRNTCgpIHtcbiAgcmV0dXJuICdpbm5lckhUTUwnO1xufTtcblxuZnVuY3Rpb24gZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwoZWxlbWVudCwgaHRtbCkge1xuICBlbGVtZW50W2lubmVySFRNTCgpXSA9IGh0bWw7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFycm93RWxlbWVudCh2YWx1ZSkge1xuICB2YXIgYXJyb3cgPSBkaXYoKTtcblxuICBpZiAodmFsdWUgPT09IHRydWUpIHtcbiAgICBhcnJvdy5jbGFzc05hbWUgPSBBUlJPV19DTEFTUztcbiAgfSBlbHNlIHtcbiAgICBhcnJvdy5jbGFzc05hbWUgPSBTVkdfQVJST1dfQ0xBU1M7XG5cbiAgICBpZiAoaXNFbGVtZW50KHZhbHVlKSkge1xuICAgICAgYXJyb3cuYXBwZW5kQ2hpbGQodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTChhcnJvdywgdmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBhcnJvdztcbn1cblxuZnVuY3Rpb24gc2V0Q29udGVudChjb250ZW50LCBwcm9wcykge1xuICBpZiAoaXNFbGVtZW50KHByb3BzLmNvbnRlbnQpKSB7XG4gICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwoY29udGVudCwgJycpO1xuICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQocHJvcHMuY29udGVudCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHByb3BzLmNvbnRlbnQgIT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAocHJvcHMuYWxsb3dIVE1MKSB7XG4gICAgICBkYW5nZXJvdXNseVNldElubmVySFRNTChjb250ZW50LCBwcm9wcy5jb250ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudC50ZXh0Q29udGVudCA9IHByb3BzLmNvbnRlbnQ7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXRDaGlsZHJlbihwb3BwZXIpIHtcbiAgdmFyIGJveCA9IHBvcHBlci5maXJzdEVsZW1lbnRDaGlsZDtcbiAgdmFyIGJveENoaWxkcmVuID0gYXJyYXlGcm9tKGJveC5jaGlsZHJlbik7XG4gIHJldHVybiB7XG4gICAgYm94OiBib3gsXG4gICAgY29udGVudDogYm94Q2hpbGRyZW4uZmluZChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKENPTlRFTlRfQ0xBU1MpO1xuICAgIH0pLFxuICAgIGFycm93OiBib3hDaGlsZHJlbi5maW5kKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICByZXR1cm4gbm9kZS5jbGFzc0xpc3QuY29udGFpbnMoQVJST1dfQ0xBU1MpIHx8IG5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKFNWR19BUlJPV19DTEFTUyk7XG4gICAgfSksXG4gICAgYmFja2Ryb3A6IGJveENoaWxkcmVuLmZpbmQoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLmNsYXNzTGlzdC5jb250YWlucyhCQUNLRFJPUF9DTEFTUyk7XG4gICAgfSlcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlbmRlcihpbnN0YW5jZSkge1xuICB2YXIgcG9wcGVyID0gZGl2KCk7XG4gIHZhciBib3ggPSBkaXYoKTtcbiAgYm94LmNsYXNzTmFtZSA9IEJPWF9DTEFTUztcbiAgYm94LnNldEF0dHJpYnV0ZSgnZGF0YS1zdGF0ZScsICdoaWRkZW4nKTtcbiAgYm94LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcbiAgdmFyIGNvbnRlbnQgPSBkaXYoKTtcbiAgY29udGVudC5jbGFzc05hbWUgPSBDT05URU5UX0NMQVNTO1xuICBjb250ZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1zdGF0ZScsICdoaWRkZW4nKTtcbiAgc2V0Q29udGVudChjb250ZW50LCBpbnN0YW5jZS5wcm9wcyk7XG4gIHBvcHBlci5hcHBlbmRDaGlsZChib3gpO1xuICBib3guYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gIG9uVXBkYXRlKGluc3RhbmNlLnByb3BzLCBpbnN0YW5jZS5wcm9wcyk7XG5cbiAgZnVuY3Rpb24gb25VcGRhdGUocHJldlByb3BzLCBuZXh0UHJvcHMpIHtcbiAgICB2YXIgX2dldENoaWxkcmVuID0gZ2V0Q2hpbGRyZW4ocG9wcGVyKSxcbiAgICAgICAgYm94ID0gX2dldENoaWxkcmVuLmJveCxcbiAgICAgICAgY29udGVudCA9IF9nZXRDaGlsZHJlbi5jb250ZW50LFxuICAgICAgICBhcnJvdyA9IF9nZXRDaGlsZHJlbi5hcnJvdztcblxuICAgIGlmIChuZXh0UHJvcHMudGhlbWUpIHtcbiAgICAgIGJveC5zZXRBdHRyaWJ1dGUoJ2RhdGEtdGhlbWUnLCBuZXh0UHJvcHMudGhlbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBib3gucmVtb3ZlQXR0cmlidXRlKCdkYXRhLXRoZW1lJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuZXh0UHJvcHMuYW5pbWF0aW9uID09PSAnc3RyaW5nJykge1xuICAgICAgYm94LnNldEF0dHJpYnV0ZSgnZGF0YS1hbmltYXRpb24nLCBuZXh0UHJvcHMuYW5pbWF0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYm94LnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1hbmltYXRpb24nKTtcbiAgICB9XG5cbiAgICBpZiAobmV4dFByb3BzLmluZXJ0aWEpIHtcbiAgICAgIGJveC5zZXRBdHRyaWJ1dGUoJ2RhdGEtaW5lcnRpYScsICcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYm94LnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1pbmVydGlhJyk7XG4gICAgfVxuXG4gICAgYm94LnN0eWxlLm1heFdpZHRoID0gdHlwZW9mIG5leHRQcm9wcy5tYXhXaWR0aCA9PT0gJ251bWJlcicgPyBuZXh0UHJvcHMubWF4V2lkdGggKyBcInB4XCIgOiBuZXh0UHJvcHMubWF4V2lkdGg7XG5cbiAgICBpZiAobmV4dFByb3BzLnJvbGUpIHtcbiAgICAgIGJveC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCBuZXh0UHJvcHMucm9sZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJveC5yZW1vdmVBdHRyaWJ1dGUoJ3JvbGUnKTtcbiAgICB9XG5cbiAgICBpZiAocHJldlByb3BzLmNvbnRlbnQgIT09IG5leHRQcm9wcy5jb250ZW50IHx8IHByZXZQcm9wcy5hbGxvd0hUTUwgIT09IG5leHRQcm9wcy5hbGxvd0hUTUwpIHtcbiAgICAgIHNldENvbnRlbnQoY29udGVudCwgaW5zdGFuY2UucHJvcHMpO1xuICAgIH1cblxuICAgIGlmIChuZXh0UHJvcHMuYXJyb3cpIHtcbiAgICAgIGlmICghYXJyb3cpIHtcbiAgICAgICAgYm94LmFwcGVuZENoaWxkKGNyZWF0ZUFycm93RWxlbWVudChuZXh0UHJvcHMuYXJyb3cpKTtcbiAgICAgIH0gZWxzZSBpZiAocHJldlByb3BzLmFycm93ICE9PSBuZXh0UHJvcHMuYXJyb3cpIHtcbiAgICAgICAgYm94LnJlbW92ZUNoaWxkKGFycm93KTtcbiAgICAgICAgYm94LmFwcGVuZENoaWxkKGNyZWF0ZUFycm93RWxlbWVudChuZXh0UHJvcHMuYXJyb3cpKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFycm93KSB7XG4gICAgICBib3gucmVtb3ZlQ2hpbGQoYXJyb3cpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcG9wcGVyOiBwb3BwZXIsXG4gICAgb25VcGRhdGU6IG9uVXBkYXRlXG4gIH07XG59IC8vIFJ1bnRpbWUgY2hlY2sgdG8gaWRlbnRpZnkgaWYgdGhlIHJlbmRlciBmdW5jdGlvbiBpcyB0aGUgZGVmYXVsdCBvbmU7IHRoaXNcbi8vIHdheSB3ZSBjYW4gYXBwbHkgZGVmYXVsdCBDU1MgdHJhbnNpdGlvbnMgbG9naWMgYW5kIGl0IGNhbiBiZSB0cmVlLXNoYWtlbiBhd2F5XG5cbnJlbmRlci4kJHRpcHB5ID0gdHJ1ZTtcblxudmFyIGlkQ291bnRlciA9IDE7XG52YXIgbW91c2VNb3ZlTGlzdGVuZXJzID0gW107IC8vIFVzZWQgYnkgYGhpZGVBbGwoKWBcblxudmFyIG1vdW50ZWRJbnN0YW5jZXMgPSBbXTtcbmZ1bmN0aW9uIGNyZWF0ZVRpcHB5KHJlZmVyZW5jZSwgcGFzc2VkUHJvcHMpIHtcbiAgdmFyIHByb3BzID0gZXZhbHVhdGVQcm9wcyhyZWZlcmVuY2UsIE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRQcm9wcywgZ2V0RXh0ZW5kZWRQYXNzZWRQcm9wcyhyZW1vdmVVbmRlZmluZWRQcm9wcyhwYXNzZWRQcm9wcykpKSk7IC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyDwn5SSIFByaXZhdGUgbWVtYmVyc1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICB2YXIgc2hvd1RpbWVvdXQ7XG4gIHZhciBoaWRlVGltZW91dDtcbiAgdmFyIHNjaGVkdWxlSGlkZUFuaW1hdGlvbkZyYW1lO1xuICB2YXIgaXNWaXNpYmxlRnJvbUNsaWNrID0gZmFsc2U7XG4gIHZhciBkaWRIaWRlRHVlVG9Eb2N1bWVudE1vdXNlRG93biA9IGZhbHNlO1xuICB2YXIgZGlkVG91Y2hNb3ZlID0gZmFsc2U7XG4gIHZhciBpZ25vcmVPbkZpcnN0VXBkYXRlID0gZmFsc2U7XG4gIHZhciBsYXN0VHJpZ2dlckV2ZW50O1xuICB2YXIgY3VycmVudFRyYW5zaXRpb25FbmRMaXN0ZW5lcjtcbiAgdmFyIG9uRmlyc3RVcGRhdGU7XG4gIHZhciBsaXN0ZW5lcnMgPSBbXTtcbiAgdmFyIGRlYm91bmNlZE9uTW91c2VNb3ZlID0gZGVib3VuY2Uob25Nb3VzZU1vdmUsIHByb3BzLmludGVyYWN0aXZlRGVib3VuY2UpO1xuICB2YXIgY3VycmVudFRhcmdldDsgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIPCflJEgUHVibGljIG1lbWJlcnNcbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgdmFyIGlkID0gaWRDb3VudGVyKys7XG4gIHZhciBwb3BwZXJJbnN0YW5jZSA9IG51bGw7XG4gIHZhciBwbHVnaW5zID0gdW5pcXVlKHByb3BzLnBsdWdpbnMpO1xuICB2YXIgc3RhdGUgPSB7XG4gICAgLy8gSXMgdGhlIGluc3RhbmNlIGN1cnJlbnRseSBlbmFibGVkP1xuICAgIGlzRW5hYmxlZDogdHJ1ZSxcbiAgICAvLyBJcyB0aGUgdGlwcHkgY3VycmVudGx5IHNob3dpbmcgYW5kIG5vdCB0cmFuc2l0aW9uaW5nIG91dD9cbiAgICBpc1Zpc2libGU6IGZhbHNlLFxuICAgIC8vIEhhcyB0aGUgaW5zdGFuY2UgYmVlbiBkZXN0cm95ZWQ/XG4gICAgaXNEZXN0cm95ZWQ6IGZhbHNlLFxuICAgIC8vIElzIHRoZSB0aXBweSBjdXJyZW50bHkgbW91bnRlZCB0byB0aGUgRE9NP1xuICAgIGlzTW91bnRlZDogZmFsc2UsXG4gICAgLy8gSGFzIHRoZSB0aXBweSBmaW5pc2hlZCB0cmFuc2l0aW9uaW5nIGluP1xuICAgIGlzU2hvd246IGZhbHNlXG4gIH07XG4gIHZhciBpbnN0YW5jZSA9IHtcbiAgICAvLyBwcm9wZXJ0aWVzXG4gICAgaWQ6IGlkLFxuICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlLFxuICAgIHBvcHBlcjogZGl2KCksXG4gICAgcG9wcGVySW5zdGFuY2U6IHBvcHBlckluc3RhbmNlLFxuICAgIHByb3BzOiBwcm9wcyxcbiAgICBzdGF0ZTogc3RhdGUsXG4gICAgcGx1Z2luczogcGx1Z2lucyxcbiAgICAvLyBtZXRob2RzXG4gICAgY2xlYXJEZWxheVRpbWVvdXRzOiBjbGVhckRlbGF5VGltZW91dHMsXG4gICAgc2V0UHJvcHM6IHNldFByb3BzLFxuICAgIHNldENvbnRlbnQ6IHNldENvbnRlbnQsXG4gICAgc2hvdzogc2hvdyxcbiAgICBoaWRlOiBoaWRlLFxuICAgIGhpZGVXaXRoSW50ZXJhY3Rpdml0eTogaGlkZVdpdGhJbnRlcmFjdGl2aXR5LFxuICAgIGVuYWJsZTogZW5hYmxlLFxuICAgIGRpc2FibGU6IGRpc2FibGUsXG4gICAgdW5tb3VudDogdW5tb3VudCxcbiAgICBkZXN0cm95OiBkZXN0cm95XG4gIH07IC8vIFRPRE86IEludmVzdGlnYXRlIHdoeSB0aGlzIGVhcmx5IHJldHVybiBjYXVzZXMgYSBURFogZXJyb3IgaW4gdGhlIHRlc3RzIOKAlFxuICAvLyBpdCBkb2Vzbid0IHNlZW0gdG8gaGFwcGVuIGluIHRoZSBicm93c2VyXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5cbiAgaWYgKCFwcm9wcy5yZW5kZXIpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBlcnJvcldoZW4odHJ1ZSwgJ3JlbmRlcigpIGZ1bmN0aW9uIGhhcyBub3QgYmVlbiBzdXBwbGllZC4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIEluaXRpYWwgbXV0YXRpb25zXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG5cbiAgdmFyIF9wcm9wcyRyZW5kZXIgPSBwcm9wcy5yZW5kZXIoaW5zdGFuY2UpLFxuICAgICAgcG9wcGVyID0gX3Byb3BzJHJlbmRlci5wb3BwZXIsXG4gICAgICBvblVwZGF0ZSA9IF9wcm9wcyRyZW5kZXIub25VcGRhdGU7XG5cbiAgcG9wcGVyLnNldEF0dHJpYnV0ZSgnZGF0YS10aXBweS1yb290JywgJycpO1xuICBwb3BwZXIuaWQgPSBcInRpcHB5LVwiICsgaW5zdGFuY2UuaWQ7XG4gIGluc3RhbmNlLnBvcHBlciA9IHBvcHBlcjtcbiAgcmVmZXJlbmNlLl90aXBweSA9IGluc3RhbmNlO1xuICBwb3BwZXIuX3RpcHB5ID0gaW5zdGFuY2U7XG4gIHZhciBwbHVnaW5zSG9va3MgPSBwbHVnaW5zLm1hcChmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgcmV0dXJuIHBsdWdpbi5mbihpbnN0YW5jZSk7XG4gIH0pO1xuICB2YXIgaGFzQXJpYUV4cGFuZGVkID0gcmVmZXJlbmNlLmhhc0F0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcpO1xuICBhZGRMaXN0ZW5lcnMoKTtcbiAgaGFuZGxlQXJpYUV4cGFuZGVkQXR0cmlidXRlKCk7XG4gIGhhbmRsZVN0eWxlcygpO1xuICBpbnZva2VIb29rKCdvbkNyZWF0ZScsIFtpbnN0YW5jZV0pO1xuXG4gIGlmIChwcm9wcy5zaG93T25DcmVhdGUpIHtcbiAgICBzY2hlZHVsZVNob3coKTtcbiAgfSAvLyBQcmV2ZW50IGEgdGlwcHkgd2l0aCBhIGRlbGF5IGZyb20gaGlkaW5nIGlmIHRoZSBjdXJzb3IgbGVmdCB0aGVuIHJldHVybmVkXG4gIC8vIGJlZm9yZSBpdCBzdGFydGVkIGhpZGluZ1xuXG5cbiAgcG9wcGVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZW50ZXInLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGluc3RhbmNlLnByb3BzLmludGVyYWN0aXZlICYmIGluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSkge1xuICAgICAgaW5zdGFuY2UuY2xlYXJEZWxheVRpbWVvdXRzKCk7XG4gICAgfVxuICB9KTtcbiAgcG9wcGVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGluc3RhbmNlLnByb3BzLmludGVyYWN0aXZlICYmIGluc3RhbmNlLnByb3BzLnRyaWdnZXIuaW5kZXhPZignbW91c2VlbnRlcicpID49IDApIHtcbiAgICAgIGdldERvY3VtZW50KCkuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgZGVib3VuY2VkT25Nb3VzZU1vdmUpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBpbnN0YW5jZTsgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIPCflJIgUHJpdmF0ZSBtZXRob2RzXG4gIC8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4gIGZ1bmN0aW9uIGdldE5vcm1hbGl6ZWRUb3VjaFNldHRpbmdzKCkge1xuICAgIHZhciB0b3VjaCA9IGluc3RhbmNlLnByb3BzLnRvdWNoO1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHRvdWNoKSA/IHRvdWNoIDogW3RvdWNoLCAwXTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldElzQ3VzdG9tVG91Y2hCZWhhdmlvcigpIHtcbiAgICByZXR1cm4gZ2V0Tm9ybWFsaXplZFRvdWNoU2V0dGluZ3MoKVswXSA9PT0gJ2hvbGQnO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SXNEZWZhdWx0UmVuZGVyRm4oKSB7XG4gICAgdmFyIF9pbnN0YW5jZSRwcm9wcyRyZW5kZTtcblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gISEoKF9pbnN0YW5jZSRwcm9wcyRyZW5kZSA9IGluc3RhbmNlLnByb3BzLnJlbmRlcikgIT0gbnVsbCAmJiBfaW5zdGFuY2UkcHJvcHMkcmVuZGUuJCR0aXBweSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRDdXJyZW50VGFyZ2V0KCkge1xuICAgIHJldHVybiBjdXJyZW50VGFyZ2V0IHx8IHJlZmVyZW5jZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldERvY3VtZW50KCkge1xuICAgIHZhciBwYXJlbnQgPSBnZXRDdXJyZW50VGFyZ2V0KCkucGFyZW50Tm9kZTtcbiAgICByZXR1cm4gcGFyZW50ID8gZ2V0T3duZXJEb2N1bWVudChwYXJlbnQpIDogZG9jdW1lbnQ7XG4gIH1cblxuICBmdW5jdGlvbiBnZXREZWZhdWx0VGVtcGxhdGVDaGlsZHJlbigpIHtcbiAgICByZXR1cm4gZ2V0Q2hpbGRyZW4ocG9wcGVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldERlbGF5KGlzU2hvdykge1xuICAgIC8vIEZvciB0b3VjaCBvciBrZXlib2FyZCBpbnB1dCwgZm9yY2UgYDBgIGRlbGF5IGZvciBVWCByZWFzb25zXG4gICAgLy8gQWxzbyBpZiB0aGUgaW5zdGFuY2UgaXMgbW91bnRlZCBidXQgbm90IHZpc2libGUgKHRyYW5zaXRpb25pbmcgb3V0KSxcbiAgICAvLyBpZ25vcmUgZGVsYXlcbiAgICBpZiAoaW5zdGFuY2Uuc3RhdGUuaXNNb3VudGVkICYmICFpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUgfHwgY3VycmVudElucHV0LmlzVG91Y2ggfHwgbGFzdFRyaWdnZXJFdmVudCAmJiBsYXN0VHJpZ2dlckV2ZW50LnR5cGUgPT09ICdmb2N1cycpIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cblxuICAgIHJldHVybiBnZXRWYWx1ZUF0SW5kZXhPclJldHVybihpbnN0YW5jZS5wcm9wcy5kZWxheSwgaXNTaG93ID8gMCA6IDEsIGRlZmF1bHRQcm9wcy5kZWxheSk7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVTdHlsZXMoZnJvbUhpZGUpIHtcbiAgICBpZiAoZnJvbUhpZGUgPT09IHZvaWQgMCkge1xuICAgICAgZnJvbUhpZGUgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBwb3BwZXIuc3R5bGUucG9pbnRlckV2ZW50cyA9IGluc3RhbmNlLnByb3BzLmludGVyYWN0aXZlICYmICFmcm9tSGlkZSA/ICcnIDogJ25vbmUnO1xuICAgIHBvcHBlci5zdHlsZS56SW5kZXggPSBcIlwiICsgaW5zdGFuY2UucHJvcHMuekluZGV4O1xuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlSG9vayhob29rLCBhcmdzLCBzaG91bGRJbnZva2VQcm9wc0hvb2spIHtcbiAgICBpZiAoc2hvdWxkSW52b2tlUHJvcHNIb29rID09PSB2b2lkIDApIHtcbiAgICAgIHNob3VsZEludm9rZVByb3BzSG9vayA9IHRydWU7XG4gICAgfVxuXG4gICAgcGx1Z2luc0hvb2tzLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbkhvb2tzKSB7XG4gICAgICBpZiAocGx1Z2luSG9va3NbaG9va10pIHtcbiAgICAgICAgcGx1Z2luSG9va3NbaG9va10uYXBwbHkocGx1Z2luSG9va3MsIGFyZ3MpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaWYgKHNob3VsZEludm9rZVByb3BzSG9vaykge1xuICAgICAgdmFyIF9pbnN0YW5jZSRwcm9wcztcblxuICAgICAgKF9pbnN0YW5jZSRwcm9wcyA9IGluc3RhbmNlLnByb3BzKVtob29rXS5hcHBseShfaW5zdGFuY2UkcHJvcHMsIGFyZ3MpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZUFyaWFDb250ZW50QXR0cmlidXRlKCkge1xuICAgIHZhciBhcmlhID0gaW5zdGFuY2UucHJvcHMuYXJpYTtcblxuICAgIGlmICghYXJpYS5jb250ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGF0dHIgPSBcImFyaWEtXCIgKyBhcmlhLmNvbnRlbnQ7XG4gICAgdmFyIGlkID0gcG9wcGVyLmlkO1xuICAgIHZhciBub2RlcyA9IG5vcm1hbGl6ZVRvQXJyYXkoaW5zdGFuY2UucHJvcHMudHJpZ2dlclRhcmdldCB8fCByZWZlcmVuY2UpO1xuICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgIHZhciBjdXJyZW50VmFsdWUgPSBub2RlLmdldEF0dHJpYnV0ZShhdHRyKTtcblxuICAgICAgaWYgKGluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSkge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyLCBjdXJyZW50VmFsdWUgPyBjdXJyZW50VmFsdWUgKyBcIiBcIiArIGlkIDogaWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG5leHRWYWx1ZSA9IGN1cnJlbnRWYWx1ZSAmJiBjdXJyZW50VmFsdWUucmVwbGFjZShpZCwgJycpLnRyaW0oKTtcblxuICAgICAgICBpZiAobmV4dFZhbHVlKSB7XG4gICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0ciwgbmV4dFZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlQXJpYUV4cGFuZGVkQXR0cmlidXRlKCkge1xuICAgIGlmIChoYXNBcmlhRXhwYW5kZWQgfHwgIWluc3RhbmNlLnByb3BzLmFyaWEuZXhwYW5kZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbm9kZXMgPSBub3JtYWxpemVUb0FycmF5KGluc3RhbmNlLnByb3BzLnRyaWdnZXJUYXJnZXQgfHwgcmVmZXJlbmNlKTtcbiAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICBpZiAoaW5zdGFuY2UucHJvcHMuaW50ZXJhY3RpdmUpIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCBpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUgJiYgbm9kZSA9PT0gZ2V0Q3VycmVudFRhcmdldCgpID8gJ3RydWUnIDogJ2ZhbHNlJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYW51cEludGVyYWN0aXZlTW91c2VMaXN0ZW5lcnMoKSB7XG4gICAgZ2V0RG9jdW1lbnQoKS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBkZWJvdW5jZWRPbk1vdXNlTW92ZSk7XG4gICAgbW91c2VNb3ZlTGlzdGVuZXJzID0gbW91c2VNb3ZlTGlzdGVuZXJzLmZpbHRlcihmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBsaXN0ZW5lciAhPT0gZGVib3VuY2VkT25Nb3VzZU1vdmU7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBvbkRvY3VtZW50UHJlc3MoZXZlbnQpIHtcbiAgICAvLyBNb3ZlZCBmaW5nZXIgdG8gc2Nyb2xsIGluc3RlYWQgb2YgYW4gaW50ZW50aW9uYWwgdGFwIG91dHNpZGVcbiAgICBpZiAoY3VycmVudElucHV0LmlzVG91Y2gpIHtcbiAgICAgIGlmIChkaWRUb3VjaE1vdmUgfHwgZXZlbnQudHlwZSA9PT0gJ21vdXNlZG93bicpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBhY3R1YWxUYXJnZXQgPSBldmVudC5jb21wb3NlZFBhdGggJiYgZXZlbnQuY29tcG9zZWRQYXRoKClbMF0gfHwgZXZlbnQudGFyZ2V0OyAvLyBDbGlja2VkIG9uIGludGVyYWN0aXZlIHBvcHBlclxuXG4gICAgaWYgKGluc3RhbmNlLnByb3BzLmludGVyYWN0aXZlICYmIGFjdHVhbENvbnRhaW5zKHBvcHBlciwgYWN0dWFsVGFyZ2V0KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gQ2xpY2tlZCBvbiB0aGUgZXZlbnQgbGlzdGVuZXJzIHRhcmdldFxuXG5cbiAgICBpZiAobm9ybWFsaXplVG9BcnJheShpbnN0YW5jZS5wcm9wcy50cmlnZ2VyVGFyZ2V0IHx8IHJlZmVyZW5jZSkuc29tZShmdW5jdGlvbiAoZWwpIHtcbiAgICAgIHJldHVybiBhY3R1YWxDb250YWlucyhlbCwgYWN0dWFsVGFyZ2V0KTtcbiAgICB9KSkge1xuICAgICAgaWYgKGN1cnJlbnRJbnB1dC5pc1RvdWNoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSAmJiBpbnN0YW5jZS5wcm9wcy50cmlnZ2VyLmluZGV4T2YoJ2NsaWNrJykgPj0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGludm9rZUhvb2soJ29uQ2xpY2tPdXRzaWRlJywgW2luc3RhbmNlLCBldmVudF0pO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5wcm9wcy5oaWRlT25DbGljayA9PT0gdHJ1ZSkge1xuICAgICAgaW5zdGFuY2UuY2xlYXJEZWxheVRpbWVvdXRzKCk7XG4gICAgICBpbnN0YW5jZS5oaWRlKCk7IC8vIGBtb3VzZWRvd25gIGV2ZW50IGlzIGZpcmVkIHJpZ2h0IGJlZm9yZSBgZm9jdXNgIGlmIHByZXNzaW5nIHRoZVxuICAgICAgLy8gY3VycmVudFRhcmdldC4gVGhpcyBsZXRzIGEgdGlwcHkgd2l0aCBgZm9jdXNgIHRyaWdnZXIga25vdyB0aGF0IGl0XG4gICAgICAvLyBzaG91bGQgbm90IHNob3dcblxuICAgICAgZGlkSGlkZUR1ZVRvRG9jdW1lbnRNb3VzZURvd24gPSB0cnVlO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRpZEhpZGVEdWVUb0RvY3VtZW50TW91c2VEb3duID0gZmFsc2U7XG4gICAgICB9KTsgLy8gVGhlIGxpc3RlbmVyIGdldHMgYWRkZWQgaW4gYHNjaGVkdWxlU2hvdygpYCwgYnV0IHRoaXMgbWF5IGJlIGhpZGluZyBpdFxuICAgICAgLy8gYmVmb3JlIGl0IHNob3dzLCBhbmQgaGlkZSgpJ3MgZWFybHkgYmFpbC1vdXQgYmVoYXZpb3IgY2FuIHByZXZlbnQgaXRcbiAgICAgIC8vIGZyb20gYmVpbmcgY2xlYW5lZCB1cFxuXG4gICAgICBpZiAoIWluc3RhbmNlLnN0YXRlLmlzTW91bnRlZCkge1xuICAgICAgICByZW1vdmVEb2N1bWVudFByZXNzKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25Ub3VjaE1vdmUoKSB7XG4gICAgZGlkVG91Y2hNb3ZlID0gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVG91Y2hTdGFydCgpIHtcbiAgICBkaWRUb3VjaE1vdmUgPSBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZERvY3VtZW50UHJlc3MoKSB7XG4gICAgdmFyIGRvYyA9IGdldERvY3VtZW50KCk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG9uRG9jdW1lbnRQcmVzcywgdHJ1ZSk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgb25Eb2N1bWVudFByZXNzLCBUT1VDSF9PUFRJT05TKTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIG9uVG91Y2hTdGFydCwgVE9VQ0hfT1BUSU9OUyk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG9uVG91Y2hNb3ZlLCBUT1VDSF9PUFRJT05TKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZURvY3VtZW50UHJlc3MoKSB7XG4gICAgdmFyIGRvYyA9IGdldERvY3VtZW50KCk7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIG9uRG9jdW1lbnRQcmVzcywgdHJ1ZSk7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgb25Eb2N1bWVudFByZXNzLCBUT1VDSF9PUFRJT05TKTtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIG9uVG91Y2hTdGFydCwgVE9VQ0hfT1BUSU9OUyk7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG9uVG91Y2hNb3ZlLCBUT1VDSF9PUFRJT05TKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVHJhbnNpdGlvbmVkT3V0KGR1cmF0aW9uLCBjYWxsYmFjaykge1xuICAgIG9uVHJhbnNpdGlvbkVuZChkdXJhdGlvbiwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUgJiYgcG9wcGVyLnBhcmVudE5vZGUgJiYgcG9wcGVyLnBhcmVudE5vZGUuY29udGFpbnMocG9wcGVyKSkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gb25UcmFuc2l0aW9uZWRJbihkdXJhdGlvbiwgY2FsbGJhY2spIHtcbiAgICBvblRyYW5zaXRpb25FbmQoZHVyYXRpb24sIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVHJhbnNpdGlvbkVuZChkdXJhdGlvbiwgY2FsbGJhY2spIHtcbiAgICB2YXIgYm94ID0gZ2V0RGVmYXVsdFRlbXBsYXRlQ2hpbGRyZW4oKS5ib3g7XG5cbiAgICBmdW5jdGlvbiBsaXN0ZW5lcihldmVudCkge1xuICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gYm94KSB7XG4gICAgICAgIHVwZGF0ZVRyYW5zaXRpb25FbmRMaXN0ZW5lcihib3gsICdyZW1vdmUnLCBsaXN0ZW5lcik7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfSAvLyBNYWtlIGNhbGxiYWNrIHN5bmNocm9ub3VzIGlmIGR1cmF0aW9uIGlzIDBcbiAgICAvLyBgdHJhbnNpdGlvbmVuZGAgd29uJ3QgZmlyZSBvdGhlcndpc2VcblxuXG4gICAgaWYgKGR1cmF0aW9uID09PSAwKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICB1cGRhdGVUcmFuc2l0aW9uRW5kTGlzdGVuZXIoYm94LCAncmVtb3ZlJywgY3VycmVudFRyYW5zaXRpb25FbmRMaXN0ZW5lcik7XG4gICAgdXBkYXRlVHJhbnNpdGlvbkVuZExpc3RlbmVyKGJveCwgJ2FkZCcsIGxpc3RlbmVyKTtcbiAgICBjdXJyZW50VHJhbnNpdGlvbkVuZExpc3RlbmVyID0gbGlzdGVuZXI7XG4gIH1cblxuICBmdW5jdGlvbiBvbihldmVudFR5cGUsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIG5vZGVzID0gbm9ybWFsaXplVG9BcnJheShpbnN0YW5jZS5wcm9wcy50cmlnZ2VyVGFyZ2V0IHx8IHJlZmVyZW5jZSk7XG4gICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgICBsaXN0ZW5lcnMucHVzaCh7XG4gICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgIGV2ZW50VHlwZTogZXZlbnRUeXBlLFxuICAgICAgICBoYW5kbGVyOiBoYW5kbGVyLFxuICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZExpc3RlbmVycygpIHtcbiAgICBpZiAoZ2V0SXNDdXN0b21Ub3VjaEJlaGF2aW9yKCkpIHtcbiAgICAgIG9uKCd0b3VjaHN0YXJ0Jywgb25UcmlnZ2VyLCB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH0pO1xuICAgICAgb24oJ3RvdWNoZW5kJywgb25Nb3VzZUxlYXZlLCB7XG4gICAgICAgIHBhc3NpdmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHNwbGl0QnlTcGFjZXMoaW5zdGFuY2UucHJvcHMudHJpZ2dlcikuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnRUeXBlKSB7XG4gICAgICBpZiAoZXZlbnRUeXBlID09PSAnbWFudWFsJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG9uKGV2ZW50VHlwZSwgb25UcmlnZ2VyKTtcblxuICAgICAgc3dpdGNoIChldmVudFR5cGUpIHtcbiAgICAgICAgY2FzZSAnbW91c2VlbnRlcic6XG4gICAgICAgICAgb24oJ21vdXNlbGVhdmUnLCBvbk1vdXNlTGVhdmUpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2ZvY3VzJzpcbiAgICAgICAgICBvbihpc0lFMTEgPyAnZm9jdXNvdXQnIDogJ2JsdXInLCBvbkJsdXJPckZvY3VzT3V0KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdmb2N1c2luJzpcbiAgICAgICAgICBvbignZm9jdXNvdXQnLCBvbkJsdXJPckZvY3VzT3V0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVycygpIHtcbiAgICBsaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgdmFyIG5vZGUgPSBfcmVmLm5vZGUsXG4gICAgICAgICAgZXZlbnRUeXBlID0gX3JlZi5ldmVudFR5cGUsXG4gICAgICAgICAgaGFuZGxlciA9IF9yZWYuaGFuZGxlcixcbiAgICAgICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zO1xuICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgaGFuZGxlciwgb3B0aW9ucyk7XG4gICAgfSk7XG4gICAgbGlzdGVuZXJzID0gW107XG4gIH1cblxuICBmdW5jdGlvbiBvblRyaWdnZXIoZXZlbnQpIHtcbiAgICB2YXIgX2xhc3RUcmlnZ2VyRXZlbnQ7XG5cbiAgICB2YXIgc2hvdWxkU2NoZWR1bGVDbGlja0hpZGUgPSBmYWxzZTtcblxuICAgIGlmICghaW5zdGFuY2Uuc3RhdGUuaXNFbmFibGVkIHx8IGlzRXZlbnRMaXN0ZW5lclN0b3BwZWQoZXZlbnQpIHx8IGRpZEhpZGVEdWVUb0RvY3VtZW50TW91c2VEb3duKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHdhc0ZvY3VzZWQgPSAoKF9sYXN0VHJpZ2dlckV2ZW50ID0gbGFzdFRyaWdnZXJFdmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9sYXN0VHJpZ2dlckV2ZW50LnR5cGUpID09PSAnZm9jdXMnO1xuICAgIGxhc3RUcmlnZ2VyRXZlbnQgPSBldmVudDtcbiAgICBjdXJyZW50VGFyZ2V0ID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICBoYW5kbGVBcmlhRXhwYW5kZWRBdHRyaWJ1dGUoKTtcblxuICAgIGlmICghaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlICYmIGlzTW91c2VFdmVudChldmVudCkpIHtcbiAgICAgIC8vIElmIHNjcm9sbGluZywgYG1vdXNlZW50ZXJgIGV2ZW50cyBjYW4gYmUgZmlyZWQgaWYgdGhlIGN1cnNvciBsYW5kc1xuICAgICAgLy8gb3ZlciBhIG5ldyB0YXJnZXQsIGJ1dCBgbW91c2Vtb3ZlYCBldmVudHMgZG9uJ3QgZ2V0IGZpcmVkLiBUaGlzXG4gICAgICAvLyBjYXVzZXMgaW50ZXJhY3RpdmUgdG9vbHRpcHMgdG8gZ2V0IHN0dWNrIG9wZW4gdW50aWwgdGhlIGN1cnNvciBpc1xuICAgICAgLy8gbW92ZWRcbiAgICAgIG1vdXNlTW92ZUxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gbGlzdGVuZXIoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgfSAvLyBUb2dnbGUgc2hvdy9oaWRlIHdoZW4gY2xpY2tpbmcgY2xpY2stdHJpZ2dlcmVkIHRvb2x0aXBzXG5cblxuICAgIGlmIChldmVudC50eXBlID09PSAnY2xpY2snICYmIChpbnN0YW5jZS5wcm9wcy50cmlnZ2VyLmluZGV4T2YoJ21vdXNlZW50ZXInKSA8IDAgfHwgaXNWaXNpYmxlRnJvbUNsaWNrKSAmJiBpbnN0YW5jZS5wcm9wcy5oaWRlT25DbGljayAhPT0gZmFsc2UgJiYgaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlKSB7XG4gICAgICBzaG91bGRTY2hlZHVsZUNsaWNrSGlkZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjaGVkdWxlU2hvdyhldmVudCk7XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdjbGljaycpIHtcbiAgICAgIGlzVmlzaWJsZUZyb21DbGljayA9ICFzaG91bGRTY2hlZHVsZUNsaWNrSGlkZTtcbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkU2NoZWR1bGVDbGlja0hpZGUgJiYgIXdhc0ZvY3VzZWQpIHtcbiAgICAgIHNjaGVkdWxlSGlkZShldmVudCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25Nb3VzZU1vdmUoZXZlbnQpIHtcbiAgICB2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgIHZhciBpc0N1cnNvck92ZXJSZWZlcmVuY2VPclBvcHBlciA9IGdldEN1cnJlbnRUYXJnZXQoKS5jb250YWlucyh0YXJnZXQpIHx8IHBvcHBlci5jb250YWlucyh0YXJnZXQpO1xuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdtb3VzZW1vdmUnICYmIGlzQ3Vyc29yT3ZlclJlZmVyZW5jZU9yUG9wcGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBvcHBlclRyZWVEYXRhID0gZ2V0TmVzdGVkUG9wcGVyVHJlZSgpLmNvbmNhdChwb3BwZXIpLm1hcChmdW5jdGlvbiAocG9wcGVyKSB7XG4gICAgICB2YXIgX2luc3RhbmNlJHBvcHBlckluc3RhO1xuXG4gICAgICB2YXIgaW5zdGFuY2UgPSBwb3BwZXIuX3RpcHB5O1xuICAgICAgdmFyIHN0YXRlID0gKF9pbnN0YW5jZSRwb3BwZXJJbnN0YSA9IGluc3RhbmNlLnBvcHBlckluc3RhbmNlKSA9PSBudWxsID8gdm9pZCAwIDogX2luc3RhbmNlJHBvcHBlckluc3RhLnN0YXRlO1xuXG4gICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwb3BwZXJSZWN0OiBwb3BwZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgcG9wcGVyU3RhdGU6IHN0YXRlLFxuICAgICAgICAgIHByb3BzOiBwcm9wc1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9KS5maWx0ZXIoQm9vbGVhbik7XG5cbiAgICBpZiAoaXNDdXJzb3JPdXRzaWRlSW50ZXJhY3RpdmVCb3JkZXIocG9wcGVyVHJlZURhdGEsIGV2ZW50KSkge1xuICAgICAgY2xlYW51cEludGVyYWN0aXZlTW91c2VMaXN0ZW5lcnMoKTtcbiAgICAgIHNjaGVkdWxlSGlkZShldmVudCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25Nb3VzZUxlYXZlKGV2ZW50KSB7XG4gICAgdmFyIHNob3VsZEJhaWwgPSBpc0V2ZW50TGlzdGVuZXJTdG9wcGVkKGV2ZW50KSB8fCBpbnN0YW5jZS5wcm9wcy50cmlnZ2VyLmluZGV4T2YoJ2NsaWNrJykgPj0gMCAmJiBpc1Zpc2libGVGcm9tQ2xpY2s7XG5cbiAgICBpZiAoc2hvdWxkQmFpbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5wcm9wcy5pbnRlcmFjdGl2ZSkge1xuICAgICAgaW5zdGFuY2UuaGlkZVdpdGhJbnRlcmFjdGl2aXR5KGV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzY2hlZHVsZUhpZGUoZXZlbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25CbHVyT3JGb2N1c091dChldmVudCkge1xuICAgIGlmIChpbnN0YW5jZS5wcm9wcy50cmlnZ2VyLmluZGV4T2YoJ2ZvY3VzaW4nKSA8IDAgJiYgZXZlbnQudGFyZ2V0ICE9PSBnZXRDdXJyZW50VGFyZ2V0KCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIElmIGZvY3VzIHdhcyBtb3ZlZCB0byB3aXRoaW4gdGhlIHBvcHBlclxuXG5cbiAgICBpZiAoaW5zdGFuY2UucHJvcHMuaW50ZXJhY3RpdmUgJiYgZXZlbnQucmVsYXRlZFRhcmdldCAmJiBwb3BwZXIuY29udGFpbnMoZXZlbnQucmVsYXRlZFRhcmdldCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzY2hlZHVsZUhpZGUoZXZlbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNFdmVudExpc3RlbmVyU3RvcHBlZChldmVudCkge1xuICAgIHJldHVybiBjdXJyZW50SW5wdXQuaXNUb3VjaCA/IGdldElzQ3VzdG9tVG91Y2hCZWhhdmlvcigpICE9PSBldmVudC50eXBlLmluZGV4T2YoJ3RvdWNoJykgPj0gMCA6IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUG9wcGVySW5zdGFuY2UoKSB7XG4gICAgZGVzdHJveVBvcHBlckluc3RhbmNlKCk7XG4gICAgdmFyIF9pbnN0YW5jZSRwcm9wczIgPSBpbnN0YW5jZS5wcm9wcyxcbiAgICAgICAgcG9wcGVyT3B0aW9ucyA9IF9pbnN0YW5jZSRwcm9wczIucG9wcGVyT3B0aW9ucyxcbiAgICAgICAgcGxhY2VtZW50ID0gX2luc3RhbmNlJHByb3BzMi5wbGFjZW1lbnQsXG4gICAgICAgIG9mZnNldCA9IF9pbnN0YW5jZSRwcm9wczIub2Zmc2V0LFxuICAgICAgICBnZXRSZWZlcmVuY2VDbGllbnRSZWN0ID0gX2luc3RhbmNlJHByb3BzMi5nZXRSZWZlcmVuY2VDbGllbnRSZWN0LFxuICAgICAgICBtb3ZlVHJhbnNpdGlvbiA9IF9pbnN0YW5jZSRwcm9wczIubW92ZVRyYW5zaXRpb247XG4gICAgdmFyIGFycm93ID0gZ2V0SXNEZWZhdWx0UmVuZGVyRm4oKSA/IGdldENoaWxkcmVuKHBvcHBlcikuYXJyb3cgOiBudWxsO1xuICAgIHZhciBjb21wdXRlZFJlZmVyZW5jZSA9IGdldFJlZmVyZW5jZUNsaWVudFJlY3QgPyB7XG4gICAgICBnZXRCb3VuZGluZ0NsaWVudFJlY3Q6IGdldFJlZmVyZW5jZUNsaWVudFJlY3QsXG4gICAgICBjb250ZXh0RWxlbWVudDogZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdC5jb250ZXh0RWxlbWVudCB8fCBnZXRDdXJyZW50VGFyZ2V0KClcbiAgICB9IDogcmVmZXJlbmNlO1xuICAgIHZhciB0aXBweU1vZGlmaWVyID0ge1xuICAgICAgbmFtZTogJyQkdGlwcHknLFxuICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgIHBoYXNlOiAnYmVmb3JlV3JpdGUnLFxuICAgICAgcmVxdWlyZXM6IFsnY29tcHV0ZVN0eWxlcyddLFxuICAgICAgZm46IGZ1bmN0aW9uIGZuKF9yZWYyKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlO1xuXG4gICAgICAgIGlmIChnZXRJc0RlZmF1bHRSZW5kZXJGbigpKSB7XG4gICAgICAgICAgdmFyIF9nZXREZWZhdWx0VGVtcGxhdGVDaCA9IGdldERlZmF1bHRUZW1wbGF0ZUNoaWxkcmVuKCksXG4gICAgICAgICAgICAgIGJveCA9IF9nZXREZWZhdWx0VGVtcGxhdGVDaC5ib3g7XG5cbiAgICAgICAgICBbJ3BsYWNlbWVudCcsICdyZWZlcmVuY2UtaGlkZGVuJywgJ2VzY2FwZWQnXS5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgICBpZiAoYXR0ciA9PT0gJ3BsYWNlbWVudCcpIHtcbiAgICAgICAgICAgICAgYm94LnNldEF0dHJpYnV0ZSgnZGF0YS1wbGFjZW1lbnQnLCBzdGF0ZS5wbGFjZW1lbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyW1wiZGF0YS1wb3BwZXItXCIgKyBhdHRyXSkge1xuICAgICAgICAgICAgICAgIGJveC5zZXRBdHRyaWJ1dGUoXCJkYXRhLVwiICsgYXR0ciwgJycpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJveC5yZW1vdmVBdHRyaWJ1dGUoXCJkYXRhLVwiICsgYXR0cik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciA9IHt9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgbW9kaWZpZXJzID0gW3tcbiAgICAgIG5hbWU6ICdvZmZzZXQnLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBvZmZzZXQ6IG9mZnNldFxuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIG5hbWU6ICdwcmV2ZW50T3ZlcmZsb3cnLFxuICAgICAgb3B0aW9uczoge1xuICAgICAgICBwYWRkaW5nOiB7XG4gICAgICAgICAgdG9wOiAyLFxuICAgICAgICAgIGJvdHRvbTogMixcbiAgICAgICAgICBsZWZ0OiA1LFxuICAgICAgICAgIHJpZ2h0OiA1XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBuYW1lOiAnZmxpcCcsXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIHBhZGRpbmc6IDVcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBuYW1lOiAnY29tcHV0ZVN0eWxlcycsXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIGFkYXB0aXZlOiAhbW92ZVRyYW5zaXRpb25cbiAgICAgIH1cbiAgICB9LCB0aXBweU1vZGlmaWVyXTtcblxuICAgIGlmIChnZXRJc0RlZmF1bHRSZW5kZXJGbigpICYmIGFycm93KSB7XG4gICAgICBtb2RpZmllcnMucHVzaCh7XG4gICAgICAgIG5hbWU6ICdhcnJvdycsXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICBlbGVtZW50OiBhcnJvdyxcbiAgICAgICAgICBwYWRkaW5nOiAzXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIG1vZGlmaWVycy5wdXNoLmFwcGx5KG1vZGlmaWVycywgKHBvcHBlck9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IHBvcHBlck9wdGlvbnMubW9kaWZpZXJzKSB8fCBbXSk7XG4gICAgaW5zdGFuY2UucG9wcGVySW5zdGFuY2UgPSBjcmVhdGVQb3BwZXIoY29tcHV0ZWRSZWZlcmVuY2UsIHBvcHBlciwgT2JqZWN0LmFzc2lnbih7fSwgcG9wcGVyT3B0aW9ucywge1xuICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICBvbkZpcnN0VXBkYXRlOiBvbkZpcnN0VXBkYXRlLFxuICAgICAgbW9kaWZpZXJzOiBtb2RpZmllcnNcbiAgICB9KSk7XG4gIH1cblxuICBmdW5jdGlvbiBkZXN0cm95UG9wcGVySW5zdGFuY2UoKSB7XG4gICAgaWYgKGluc3RhbmNlLnBvcHBlckluc3RhbmNlKSB7XG4gICAgICBpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZS5kZXN0cm95KCk7XG4gICAgICBpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbW91bnQoKSB7XG4gICAgdmFyIGFwcGVuZFRvID0gaW5zdGFuY2UucHJvcHMuYXBwZW5kVG87XG4gICAgdmFyIHBhcmVudE5vZGU7IC8vIEJ5IGRlZmF1bHQsIHdlJ2xsIGFwcGVuZCB0aGUgcG9wcGVyIHRvIHRoZSB0cmlnZ2VyVGFyZ2V0cydzIHBhcmVudE5vZGUgc29cbiAgICAvLyBpdCdzIGRpcmVjdGx5IGFmdGVyIHRoZSByZWZlcmVuY2UgZWxlbWVudCBzbyB0aGUgZWxlbWVudHMgaW5zaWRlIHRoZVxuICAgIC8vIHRpcHB5IGNhbiBiZSB0YWJiZWQgdG9cbiAgICAvLyBJZiB0aGVyZSBhcmUgY2xpcHBpbmcgaXNzdWVzLCB0aGUgdXNlciBjYW4gc3BlY2lmeSBhIGRpZmZlcmVudCBhcHBlbmRUb1xuICAgIC8vIGFuZCBlbnN1cmUgZm9jdXMgbWFuYWdlbWVudCBpcyBoYW5kbGVkIGNvcnJlY3RseSBtYW51YWxseVxuXG4gICAgdmFyIG5vZGUgPSBnZXRDdXJyZW50VGFyZ2V0KCk7XG5cbiAgICBpZiAoaW5zdGFuY2UucHJvcHMuaW50ZXJhY3RpdmUgJiYgYXBwZW5kVG8gPT09IFRJUFBZX0RFRkFVTFRfQVBQRU5EX1RPIHx8IGFwcGVuZFRvID09PSAncGFyZW50Jykge1xuICAgICAgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyZW50Tm9kZSA9IGludm9rZVdpdGhBcmdzT3JSZXR1cm4oYXBwZW5kVG8sIFtub2RlXSk7XG4gICAgfSAvLyBUaGUgcG9wcGVyIGVsZW1lbnQgbmVlZHMgdG8gZXhpc3Qgb24gdGhlIERPTSBiZWZvcmUgaXRzIHBvc2l0aW9uIGNhbiBiZVxuICAgIC8vIHVwZGF0ZWQgYXMgUG9wcGVyIG5lZWRzIHRvIHJlYWQgaXRzIGRpbWVuc2lvbnNcblxuXG4gICAgaWYgKCFwYXJlbnROb2RlLmNvbnRhaW5zKHBvcHBlcikpIHtcbiAgICAgIHBhcmVudE5vZGUuYXBwZW5kQ2hpbGQocG9wcGVyKTtcbiAgICB9XG5cbiAgICBpbnN0YW5jZS5zdGF0ZS5pc01vdW50ZWQgPSB0cnVlO1xuICAgIGNyZWF0ZVBvcHBlckluc3RhbmNlKCk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIC8vIEFjY2Vzc2liaWxpdHkgY2hlY2tcbiAgICAgIHdhcm5XaGVuKGluc3RhbmNlLnByb3BzLmludGVyYWN0aXZlICYmIGFwcGVuZFRvID09PSBkZWZhdWx0UHJvcHMuYXBwZW5kVG8gJiYgbm9kZS5uZXh0RWxlbWVudFNpYmxpbmcgIT09IHBvcHBlciwgWydJbnRlcmFjdGl2ZSB0aXBweSBlbGVtZW50IG1heSBub3QgYmUgYWNjZXNzaWJsZSB2aWEga2V5Ym9hcmQnLCAnbmF2aWdhdGlvbiBiZWNhdXNlIGl0IGlzIG5vdCBkaXJlY3RseSBhZnRlciB0aGUgcmVmZXJlbmNlIGVsZW1lbnQnLCAnaW4gdGhlIERPTSBzb3VyY2Ugb3JkZXIuJywgJ1xcblxcbicsICdVc2luZyBhIHdyYXBwZXIgPGRpdj4gb3IgPHNwYW4+IHRhZyBhcm91bmQgdGhlIHJlZmVyZW5jZSBlbGVtZW50JywgJ3NvbHZlcyB0aGlzIGJ5IGNyZWF0aW5nIGEgbmV3IHBhcmVudE5vZGUgY29udGV4dC4nLCAnXFxuXFxuJywgJ1NwZWNpZnlpbmcgYGFwcGVuZFRvOiBkb2N1bWVudC5ib2R5YCBzaWxlbmNlcyB0aGlzIHdhcm5pbmcsIGJ1dCBpdCcsICdhc3N1bWVzIHlvdSBhcmUgdXNpbmcgYSBmb2N1cyBtYW5hZ2VtZW50IHNvbHV0aW9uIHRvIGhhbmRsZScsICdrZXlib2FyZCBuYXZpZ2F0aW9uLicsICdcXG5cXG4nLCAnU2VlOiBodHRwczovL2F0b21pa3MuZ2l0aHViLmlvL3RpcHB5anMvdjYvYWNjZXNzaWJpbGl0eS8jaW50ZXJhY3Rpdml0eSddLmpvaW4oJyAnKSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0TmVzdGVkUG9wcGVyVHJlZSgpIHtcbiAgICByZXR1cm4gYXJyYXlGcm9tKHBvcHBlci5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS10aXBweS1yb290XScpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlU2hvdyhldmVudCkge1xuICAgIGluc3RhbmNlLmNsZWFyRGVsYXlUaW1lb3V0cygpO1xuXG4gICAgaWYgKGV2ZW50KSB7XG4gICAgICBpbnZva2VIb29rKCdvblRyaWdnZXInLCBbaW5zdGFuY2UsIGV2ZW50XSk7XG4gICAgfVxuXG4gICAgYWRkRG9jdW1lbnRQcmVzcygpO1xuICAgIHZhciBkZWxheSA9IGdldERlbGF5KHRydWUpO1xuXG4gICAgdmFyIF9nZXROb3JtYWxpemVkVG91Y2hTZSA9IGdldE5vcm1hbGl6ZWRUb3VjaFNldHRpbmdzKCksXG4gICAgICAgIHRvdWNoVmFsdWUgPSBfZ2V0Tm9ybWFsaXplZFRvdWNoU2VbMF0sXG4gICAgICAgIHRvdWNoRGVsYXkgPSBfZ2V0Tm9ybWFsaXplZFRvdWNoU2VbMV07XG5cbiAgICBpZiAoY3VycmVudElucHV0LmlzVG91Y2ggJiYgdG91Y2hWYWx1ZSA9PT0gJ2hvbGQnICYmIHRvdWNoRGVsYXkpIHtcbiAgICAgIGRlbGF5ID0gdG91Y2hEZWxheTtcbiAgICB9XG5cbiAgICBpZiAoZGVsYXkpIHtcbiAgICAgIHNob3dUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGluc3RhbmNlLnNob3coKTtcbiAgICAgIH0sIGRlbGF5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5zdGFuY2Uuc2hvdygpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlSGlkZShldmVudCkge1xuICAgIGluc3RhbmNlLmNsZWFyRGVsYXlUaW1lb3V0cygpO1xuICAgIGludm9rZUhvb2soJ29uVW50cmlnZ2VyJywgW2luc3RhbmNlLCBldmVudF0pO1xuXG4gICAgaWYgKCFpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUpIHtcbiAgICAgIHJlbW92ZURvY3VtZW50UHJlc3MoKTtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEZvciBpbnRlcmFjdGl2ZSB0aXBwaWVzLCBzY2hlZHVsZUhpZGUgaXMgYWRkZWQgdG8gYSBkb2N1bWVudC5ib2R5IGhhbmRsZXJcbiAgICAvLyBmcm9tIG9uTW91c2VMZWF2ZSBzbyBtdXN0IGludGVyY2VwdCBzY2hlZHVsZWQgaGlkZXMgZnJvbSBtb3VzZW1vdmUvbGVhdmVcbiAgICAvLyBldmVudHMgd2hlbiB0cmlnZ2VyIGNvbnRhaW5zIG1vdXNlZW50ZXIgYW5kIGNsaWNrLCBhbmQgdGhlIHRpcCBpc1xuICAgIC8vIGN1cnJlbnRseSBzaG93biBhcyBhIHJlc3VsdCBvZiBhIGNsaWNrLlxuXG5cbiAgICBpZiAoaW5zdGFuY2UucHJvcHMudHJpZ2dlci5pbmRleE9mKCdtb3VzZWVudGVyJykgPj0gMCAmJiBpbnN0YW5jZS5wcm9wcy50cmlnZ2VyLmluZGV4T2YoJ2NsaWNrJykgPj0gMCAmJiBbJ21vdXNlbGVhdmUnLCAnbW91c2Vtb3ZlJ10uaW5kZXhPZihldmVudC50eXBlKSA+PSAwICYmIGlzVmlzaWJsZUZyb21DbGljaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBkZWxheSA9IGdldERlbGF5KGZhbHNlKTtcblxuICAgIGlmIChkZWxheSkge1xuICAgICAgaGlkZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSkge1xuICAgICAgICAgIGluc3RhbmNlLmhpZGUoKTtcbiAgICAgICAgfVxuICAgICAgfSwgZGVsYXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGaXhlcyBhIGB0cmFuc2l0aW9uZW5kYCBwcm9ibGVtIHdoZW4gaXQgZmlyZXMgMSBmcmFtZSB0b29cbiAgICAgIC8vIGxhdGUgc29tZXRpbWVzLCB3ZSBkb24ndCB3YW50IGhpZGUoKSB0byBiZSBjYWxsZWQuXG4gICAgICBzY2hlZHVsZUhpZGVBbmltYXRpb25GcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGluc3RhbmNlLmhpZGUoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8g8J+UkSBQdWJsaWMgbWV0aG9kc1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuXG4gIGZ1bmN0aW9uIGVuYWJsZSgpIHtcbiAgICBpbnN0YW5jZS5zdGF0ZS5pc0VuYWJsZWQgPSB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICAvLyBEaXNhYmxpbmcgdGhlIGluc3RhbmNlIHNob3VsZCBhbHNvIGhpZGUgaXRcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYXRvbWlrcy90aXBweS5qcy1yZWFjdC9pc3N1ZXMvMTA2XG4gICAgaW5zdGFuY2UuaGlkZSgpO1xuICAgIGluc3RhbmNlLnN0YXRlLmlzRW5hYmxlZCA9IGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXJEZWxheVRpbWVvdXRzKCkge1xuICAgIGNsZWFyVGltZW91dChzaG93VGltZW91dCk7XG4gICAgY2xlYXJUaW1lb3V0KGhpZGVUaW1lb3V0KTtcbiAgICBjYW5jZWxBbmltYXRpb25GcmFtZShzY2hlZHVsZUhpZGVBbmltYXRpb25GcmFtZSk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRQcm9wcyhwYXJ0aWFsUHJvcHMpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIHdhcm5XaGVuKGluc3RhbmNlLnN0YXRlLmlzRGVzdHJveWVkLCBjcmVhdGVNZW1vcnlMZWFrV2FybmluZygnc2V0UHJvcHMnKSk7XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLnN0YXRlLmlzRGVzdHJveWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW52b2tlSG9vaygnb25CZWZvcmVVcGRhdGUnLCBbaW5zdGFuY2UsIHBhcnRpYWxQcm9wc10pO1xuICAgIHJlbW92ZUxpc3RlbmVycygpO1xuICAgIHZhciBwcmV2UHJvcHMgPSBpbnN0YW5jZS5wcm9wcztcbiAgICB2YXIgbmV4dFByb3BzID0gZXZhbHVhdGVQcm9wcyhyZWZlcmVuY2UsIE9iamVjdC5hc3NpZ24oe30sIHByZXZQcm9wcywgcmVtb3ZlVW5kZWZpbmVkUHJvcHMocGFydGlhbFByb3BzKSwge1xuICAgICAgaWdub3JlQXR0cmlidXRlczogdHJ1ZVxuICAgIH0pKTtcbiAgICBpbnN0YW5jZS5wcm9wcyA9IG5leHRQcm9wcztcbiAgICBhZGRMaXN0ZW5lcnMoKTtcblxuICAgIGlmIChwcmV2UHJvcHMuaW50ZXJhY3RpdmVEZWJvdW5jZSAhPT0gbmV4dFByb3BzLmludGVyYWN0aXZlRGVib3VuY2UpIHtcbiAgICAgIGNsZWFudXBJbnRlcmFjdGl2ZU1vdXNlTGlzdGVuZXJzKCk7XG4gICAgICBkZWJvdW5jZWRPbk1vdXNlTW92ZSA9IGRlYm91bmNlKG9uTW91c2VNb3ZlLCBuZXh0UHJvcHMuaW50ZXJhY3RpdmVEZWJvdW5jZSk7XG4gICAgfSAvLyBFbnN1cmUgc3RhbGUgYXJpYS1leHBhbmRlZCBhdHRyaWJ1dGVzIGFyZSByZW1vdmVkXG5cblxuICAgIGlmIChwcmV2UHJvcHMudHJpZ2dlclRhcmdldCAmJiAhbmV4dFByb3BzLnRyaWdnZXJUYXJnZXQpIHtcbiAgICAgIG5vcm1hbGl6ZVRvQXJyYXkocHJldlByb3BzLnRyaWdnZXJUYXJnZXQpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAobmV4dFByb3BzLnRyaWdnZXJUYXJnZXQpIHtcbiAgICAgIHJlZmVyZW5jZS5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnKTtcbiAgICB9XG5cbiAgICBoYW5kbGVBcmlhRXhwYW5kZWRBdHRyaWJ1dGUoKTtcbiAgICBoYW5kbGVTdHlsZXMoKTtcblxuICAgIGlmIChvblVwZGF0ZSkge1xuICAgICAgb25VcGRhdGUocHJldlByb3BzLCBuZXh0UHJvcHMpO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZSkge1xuICAgICAgY3JlYXRlUG9wcGVySW5zdGFuY2UoKTsgLy8gRml4ZXMgYW4gaXNzdWUgd2l0aCBuZXN0ZWQgdGlwcGllcyBpZiB0aGV5IGFyZSBhbGwgZ2V0dGluZyByZS1yZW5kZXJlZCxcbiAgICAgIC8vIGFuZCB0aGUgbmVzdGVkIG9uZXMgZ2V0IHJlLXJlbmRlcmVkIGZpcnN0LlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2F0b21pa3MvdGlwcHlqcy1yZWFjdC9pc3N1ZXMvMTc3XG4gICAgICAvLyBUT0RPOiBmaW5kIGEgY2xlYW5lciAvIG1vcmUgZWZmaWNpZW50IHNvbHV0aW9uKCEpXG5cbiAgICAgIGdldE5lc3RlZFBvcHBlclRyZWUoKS5mb3JFYWNoKGZ1bmN0aW9uIChuZXN0ZWRQb3BwZXIpIHtcbiAgICAgICAgLy8gUmVhY3QgKGFuZCBvdGhlciBVSSBsaWJzIGxpa2VseSkgcmVxdWlyZXMgYSByQUYgd3JhcHBlciBhcyBpdCBmbHVzaGVzXG4gICAgICAgIC8vIGl0cyB3b3JrIGluIG9uZVxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobmVzdGVkUG9wcGVyLl90aXBweS5wb3BwZXJJbnN0YW5jZS5mb3JjZVVwZGF0ZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpbnZva2VIb29rKCdvbkFmdGVyVXBkYXRlJywgW2luc3RhbmNlLCBwYXJ0aWFsUHJvcHNdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldENvbnRlbnQoY29udGVudCkge1xuICAgIGluc3RhbmNlLnNldFByb3BzKHtcbiAgICAgIGNvbnRlbnQ6IGNvbnRlbnRcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNob3coKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICB3YXJuV2hlbihpbnN0YW5jZS5zdGF0ZS5pc0Rlc3Ryb3llZCwgY3JlYXRlTWVtb3J5TGVha1dhcm5pbmcoJ3Nob3cnKSk7XG4gICAgfSAvLyBFYXJseSBiYWlsLW91dFxuXG5cbiAgICB2YXIgaXNBbHJlYWR5VmlzaWJsZSA9IGluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZTtcbiAgICB2YXIgaXNEZXN0cm95ZWQgPSBpbnN0YW5jZS5zdGF0ZS5pc0Rlc3Ryb3llZDtcbiAgICB2YXIgaXNEaXNhYmxlZCA9ICFpbnN0YW5jZS5zdGF0ZS5pc0VuYWJsZWQ7XG4gICAgdmFyIGlzVG91Y2hBbmRUb3VjaERpc2FibGVkID0gY3VycmVudElucHV0LmlzVG91Y2ggJiYgIWluc3RhbmNlLnByb3BzLnRvdWNoO1xuICAgIHZhciBkdXJhdGlvbiA9IGdldFZhbHVlQXRJbmRleE9yUmV0dXJuKGluc3RhbmNlLnByb3BzLmR1cmF0aW9uLCAwLCBkZWZhdWx0UHJvcHMuZHVyYXRpb24pO1xuXG4gICAgaWYgKGlzQWxyZWFkeVZpc2libGUgfHwgaXNEZXN0cm95ZWQgfHwgaXNEaXNhYmxlZCB8fCBpc1RvdWNoQW5kVG91Y2hEaXNhYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gTm9ybWFsaXplIGBkaXNhYmxlZGAgYmVoYXZpb3IgYWNyb3NzIGJyb3dzZXJzLlxuICAgIC8vIEZpcmVmb3ggYWxsb3dzIGV2ZW50cyBvbiBkaXNhYmxlZCBlbGVtZW50cywgYnV0IENocm9tZSBkb2Vzbid0LlxuICAgIC8vIFVzaW5nIGEgd3JhcHBlciBlbGVtZW50IChpLmUuIDxzcGFuPikgaXMgcmVjb21tZW5kZWQuXG5cblxuICAgIGlmIChnZXRDdXJyZW50VGFyZ2V0KCkuaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW52b2tlSG9vaygnb25TaG93JywgW2luc3RhbmNlXSwgZmFsc2UpO1xuXG4gICAgaWYgKGluc3RhbmNlLnByb3BzLm9uU2hvdyhpbnN0YW5jZSkgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlID0gdHJ1ZTtcblxuICAgIGlmIChnZXRJc0RlZmF1bHRSZW5kZXJGbigpKSB7XG4gICAgICBwb3BwZXIuc3R5bGUudmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcbiAgICB9XG5cbiAgICBoYW5kbGVTdHlsZXMoKTtcbiAgICBhZGREb2N1bWVudFByZXNzKCk7XG5cbiAgICBpZiAoIWluc3RhbmNlLnN0YXRlLmlzTW91bnRlZCkge1xuICAgICAgcG9wcGVyLnN0eWxlLnRyYW5zaXRpb24gPSAnbm9uZSc7XG4gICAgfSAvLyBJZiBmbGlwcGluZyB0byB0aGUgb3Bwb3NpdGUgc2lkZSBhZnRlciBoaWRpbmcgYXQgbGVhc3Qgb25jZSwgdGhlXG4gICAgLy8gYW5pbWF0aW9uIHdpbGwgdXNlIHRoZSB3cm9uZyBwbGFjZW1lbnQgd2l0aG91dCByZXNldHRpbmcgdGhlIGR1cmF0aW9uXG5cblxuICAgIGlmIChnZXRJc0RlZmF1bHRSZW5kZXJGbigpKSB7XG4gICAgICB2YXIgX2dldERlZmF1bHRUZW1wbGF0ZUNoMiA9IGdldERlZmF1bHRUZW1wbGF0ZUNoaWxkcmVuKCksXG4gICAgICAgICAgYm94ID0gX2dldERlZmF1bHRUZW1wbGF0ZUNoMi5ib3gsXG4gICAgICAgICAgY29udGVudCA9IF9nZXREZWZhdWx0VGVtcGxhdGVDaDIuY29udGVudDtcblxuICAgICAgc2V0VHJhbnNpdGlvbkR1cmF0aW9uKFtib3gsIGNvbnRlbnRdLCAwKTtcbiAgICB9XG5cbiAgICBvbkZpcnN0VXBkYXRlID0gZnVuY3Rpb24gb25GaXJzdFVwZGF0ZSgpIHtcbiAgICAgIHZhciBfaW5zdGFuY2UkcG9wcGVySW5zdGEyO1xuXG4gICAgICBpZiAoIWluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSB8fCBpZ25vcmVPbkZpcnN0VXBkYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWdub3JlT25GaXJzdFVwZGF0ZSA9IHRydWU7IC8vIHJlZmxvd1xuXG4gICAgICB2b2lkIHBvcHBlci5vZmZzZXRIZWlnaHQ7XG4gICAgICBwb3BwZXIuc3R5bGUudHJhbnNpdGlvbiA9IGluc3RhbmNlLnByb3BzLm1vdmVUcmFuc2l0aW9uO1xuXG4gICAgICBpZiAoZ2V0SXNEZWZhdWx0UmVuZGVyRm4oKSAmJiBpbnN0YW5jZS5wcm9wcy5hbmltYXRpb24pIHtcbiAgICAgICAgdmFyIF9nZXREZWZhdWx0VGVtcGxhdGVDaDMgPSBnZXREZWZhdWx0VGVtcGxhdGVDaGlsZHJlbigpLFxuICAgICAgICAgICAgX2JveCA9IF9nZXREZWZhdWx0VGVtcGxhdGVDaDMuYm94LFxuICAgICAgICAgICAgX2NvbnRlbnQgPSBfZ2V0RGVmYXVsdFRlbXBsYXRlQ2gzLmNvbnRlbnQ7XG5cbiAgICAgICAgc2V0VHJhbnNpdGlvbkR1cmF0aW9uKFtfYm94LCBfY29udGVudF0sIGR1cmF0aW9uKTtcbiAgICAgICAgc2V0VmlzaWJpbGl0eVN0YXRlKFtfYm94LCBfY29udGVudF0sICd2aXNpYmxlJyk7XG4gICAgICB9XG5cbiAgICAgIGhhbmRsZUFyaWFDb250ZW50QXR0cmlidXRlKCk7XG4gICAgICBoYW5kbGVBcmlhRXhwYW5kZWRBdHRyaWJ1dGUoKTtcbiAgICAgIHB1c2hJZlVuaXF1ZShtb3VudGVkSW5zdGFuY2VzLCBpbnN0YW5jZSk7IC8vIGNlcnRhaW4gbW9kaWZpZXJzIChlLmcuIGBtYXhTaXplYCkgcmVxdWlyZSBhIHNlY29uZCB1cGRhdGUgYWZ0ZXIgdGhlXG4gICAgICAvLyBwb3BwZXIgaGFzIGJlZW4gcG9zaXRpb25lZCBmb3IgdGhlIGZpcnN0IHRpbWVcblxuICAgICAgKF9pbnN0YW5jZSRwb3BwZXJJbnN0YTIgPSBpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9pbnN0YW5jZSRwb3BwZXJJbnN0YTIuZm9yY2VVcGRhdGUoKTtcbiAgICAgIGludm9rZUhvb2soJ29uTW91bnQnLCBbaW5zdGFuY2VdKTtcblxuICAgICAgaWYgKGluc3RhbmNlLnByb3BzLmFuaW1hdGlvbiAmJiBnZXRJc0RlZmF1bHRSZW5kZXJGbigpKSB7XG4gICAgICAgIG9uVHJhbnNpdGlvbmVkSW4oZHVyYXRpb24sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpbnN0YW5jZS5zdGF0ZS5pc1Nob3duID0gdHJ1ZTtcbiAgICAgICAgICBpbnZva2VIb29rKCdvblNob3duJywgW2luc3RhbmNlXSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBtb3VudCgpO1xuICB9XG5cbiAgZnVuY3Rpb24gaGlkZSgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIHdhcm5XaGVuKGluc3RhbmNlLnN0YXRlLmlzRGVzdHJveWVkLCBjcmVhdGVNZW1vcnlMZWFrV2FybmluZygnaGlkZScpKTtcbiAgICB9IC8vIEVhcmx5IGJhaWwtb3V0XG5cblxuICAgIHZhciBpc0FscmVhZHlIaWRkZW4gPSAhaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlO1xuICAgIHZhciBpc0Rlc3Ryb3llZCA9IGluc3RhbmNlLnN0YXRlLmlzRGVzdHJveWVkO1xuICAgIHZhciBpc0Rpc2FibGVkID0gIWluc3RhbmNlLnN0YXRlLmlzRW5hYmxlZDtcbiAgICB2YXIgZHVyYXRpb24gPSBnZXRWYWx1ZUF0SW5kZXhPclJldHVybihpbnN0YW5jZS5wcm9wcy5kdXJhdGlvbiwgMSwgZGVmYXVsdFByb3BzLmR1cmF0aW9uKTtcblxuICAgIGlmIChpc0FscmVhZHlIaWRkZW4gfHwgaXNEZXN0cm95ZWQgfHwgaXNEaXNhYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGludm9rZUhvb2soJ29uSGlkZScsIFtpbnN0YW5jZV0sIGZhbHNlKTtcblxuICAgIGlmIChpbnN0YW5jZS5wcm9wcy5vbkhpZGUoaW5zdGFuY2UpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGluc3RhbmNlLnN0YXRlLmlzVmlzaWJsZSA9IGZhbHNlO1xuICAgIGluc3RhbmNlLnN0YXRlLmlzU2hvd24gPSBmYWxzZTtcbiAgICBpZ25vcmVPbkZpcnN0VXBkYXRlID0gZmFsc2U7XG4gICAgaXNWaXNpYmxlRnJvbUNsaWNrID0gZmFsc2U7XG5cbiAgICBpZiAoZ2V0SXNEZWZhdWx0UmVuZGVyRm4oKSkge1xuICAgICAgcG9wcGVyLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICB9XG5cbiAgICBjbGVhbnVwSW50ZXJhY3RpdmVNb3VzZUxpc3RlbmVycygpO1xuICAgIHJlbW92ZURvY3VtZW50UHJlc3MoKTtcbiAgICBoYW5kbGVTdHlsZXModHJ1ZSk7XG5cbiAgICBpZiAoZ2V0SXNEZWZhdWx0UmVuZGVyRm4oKSkge1xuICAgICAgdmFyIF9nZXREZWZhdWx0VGVtcGxhdGVDaDQgPSBnZXREZWZhdWx0VGVtcGxhdGVDaGlsZHJlbigpLFxuICAgICAgICAgIGJveCA9IF9nZXREZWZhdWx0VGVtcGxhdGVDaDQuYm94LFxuICAgICAgICAgIGNvbnRlbnQgPSBfZ2V0RGVmYXVsdFRlbXBsYXRlQ2g0LmNvbnRlbnQ7XG5cbiAgICAgIGlmIChpbnN0YW5jZS5wcm9wcy5hbmltYXRpb24pIHtcbiAgICAgICAgc2V0VHJhbnNpdGlvbkR1cmF0aW9uKFtib3gsIGNvbnRlbnRdLCBkdXJhdGlvbik7XG4gICAgICAgIHNldFZpc2liaWxpdHlTdGF0ZShbYm94LCBjb250ZW50XSwgJ2hpZGRlbicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGhhbmRsZUFyaWFDb250ZW50QXR0cmlidXRlKCk7XG4gICAgaGFuZGxlQXJpYUV4cGFuZGVkQXR0cmlidXRlKCk7XG5cbiAgICBpZiAoaW5zdGFuY2UucHJvcHMuYW5pbWF0aW9uKSB7XG4gICAgICBpZiAoZ2V0SXNEZWZhdWx0UmVuZGVyRm4oKSkge1xuICAgICAgICBvblRyYW5zaXRpb25lZE91dChkdXJhdGlvbiwgaW5zdGFuY2UudW5tb3VudCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc3RhbmNlLnVubW91bnQoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoaWRlV2l0aEludGVyYWN0aXZpdHkoZXZlbnQpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIHdhcm5XaGVuKGluc3RhbmNlLnN0YXRlLmlzRGVzdHJveWVkLCBjcmVhdGVNZW1vcnlMZWFrV2FybmluZygnaGlkZVdpdGhJbnRlcmFjdGl2aXR5JykpO1xuICAgIH1cblxuICAgIGdldERvY3VtZW50KCkuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgZGVib3VuY2VkT25Nb3VzZU1vdmUpO1xuICAgIHB1c2hJZlVuaXF1ZShtb3VzZU1vdmVMaXN0ZW5lcnMsIGRlYm91bmNlZE9uTW91c2VNb3ZlKTtcbiAgICBkZWJvdW5jZWRPbk1vdXNlTW92ZShldmVudCk7XG4gIH1cblxuICBmdW5jdGlvbiB1bm1vdW50KCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgd2FybldoZW4oaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQsIGNyZWF0ZU1lbW9yeUxlYWtXYXJuaW5nKCd1bm1vdW50JykpO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5zdGF0ZS5pc1Zpc2libGUpIHtcbiAgICAgIGluc3RhbmNlLmhpZGUoKTtcbiAgICB9XG5cbiAgICBpZiAoIWluc3RhbmNlLnN0YXRlLmlzTW91bnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRlc3Ryb3lQb3BwZXJJbnN0YW5jZSgpOyAvLyBJZiBhIHBvcHBlciBpcyBub3QgaW50ZXJhY3RpdmUsIGl0IHdpbGwgYmUgYXBwZW5kZWQgb3V0c2lkZSB0aGUgcG9wcGVyXG4gICAgLy8gdHJlZSBieSBkZWZhdWx0LiBUaGlzIHNlZW1zIG1haW5seSBmb3IgaW50ZXJhY3RpdmUgdGlwcGllcywgYnV0IHdlIHNob3VsZFxuICAgIC8vIGZpbmQgYSB3b3JrYXJvdW5kIGlmIHBvc3NpYmxlXG5cbiAgICBnZXROZXN0ZWRQb3BwZXJUcmVlKCkuZm9yRWFjaChmdW5jdGlvbiAobmVzdGVkUG9wcGVyKSB7XG4gICAgICBuZXN0ZWRQb3BwZXIuX3RpcHB5LnVubW91bnQoKTtcbiAgICB9KTtcblxuICAgIGlmIChwb3BwZXIucGFyZW50Tm9kZSkge1xuICAgICAgcG9wcGVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocG9wcGVyKTtcbiAgICB9XG5cbiAgICBtb3VudGVkSW5zdGFuY2VzID0gbW91bnRlZEluc3RhbmNlcy5maWx0ZXIoZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBpICE9PSBpbnN0YW5jZTtcbiAgICB9KTtcbiAgICBpbnN0YW5jZS5zdGF0ZS5pc01vdW50ZWQgPSBmYWxzZTtcbiAgICBpbnZva2VIb29rKCdvbkhpZGRlbicsIFtpbnN0YW5jZV0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgIHdhcm5XaGVuKGluc3RhbmNlLnN0YXRlLmlzRGVzdHJveWVkLCBjcmVhdGVNZW1vcnlMZWFrV2FybmluZygnZGVzdHJveScpKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbnN0YW5jZS5jbGVhckRlbGF5VGltZW91dHMoKTtcbiAgICBpbnN0YW5jZS51bm1vdW50KCk7XG4gICAgcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgZGVsZXRlIHJlZmVyZW5jZS5fdGlwcHk7XG4gICAgaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgIGludm9rZUhvb2soJ29uRGVzdHJveScsIFtpbnN0YW5jZV0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRpcHB5KHRhcmdldHMsIG9wdGlvbmFsUHJvcHMpIHtcbiAgaWYgKG9wdGlvbmFsUHJvcHMgPT09IHZvaWQgMCkge1xuICAgIG9wdGlvbmFsUHJvcHMgPSB7fTtcbiAgfVxuXG4gIHZhciBwbHVnaW5zID0gZGVmYXVsdFByb3BzLnBsdWdpbnMuY29uY2F0KG9wdGlvbmFsUHJvcHMucGx1Z2lucyB8fCBbXSk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHZhbGlkYXRlVGFyZ2V0cyh0YXJnZXRzKTtcbiAgICB2YWxpZGF0ZVByb3BzKG9wdGlvbmFsUHJvcHMsIHBsdWdpbnMpO1xuICB9XG5cbiAgYmluZEdsb2JhbEV2ZW50TGlzdGVuZXJzKCk7XG4gIHZhciBwYXNzZWRQcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbmFsUHJvcHMsIHtcbiAgICBwbHVnaW5zOiBwbHVnaW5zXG4gIH0pO1xuICB2YXIgZWxlbWVudHMgPSBnZXRBcnJheU9mRWxlbWVudHModGFyZ2V0cyk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHZhciBpc1NpbmdsZUNvbnRlbnRFbGVtZW50ID0gaXNFbGVtZW50KHBhc3NlZFByb3BzLmNvbnRlbnQpO1xuICAgIHZhciBpc01vcmVUaGFuT25lUmVmZXJlbmNlRWxlbWVudCA9IGVsZW1lbnRzLmxlbmd0aCA+IDE7XG4gICAgd2FybldoZW4oaXNTaW5nbGVDb250ZW50RWxlbWVudCAmJiBpc01vcmVUaGFuT25lUmVmZXJlbmNlRWxlbWVudCwgWyd0aXBweSgpIHdhcyBwYXNzZWQgYW4gRWxlbWVudCBhcyB0aGUgYGNvbnRlbnRgIHByb3AsIGJ1dCBtb3JlIHRoYW4nLCAnb25lIHRpcHB5IGluc3RhbmNlIHdhcyBjcmVhdGVkIGJ5IHRoaXMgaW52b2NhdGlvbi4gVGhpcyBtZWFucyB0aGUnLCAnY29udGVudCBlbGVtZW50IHdpbGwgb25seSBiZSBhcHBlbmRlZCB0byB0aGUgbGFzdCB0aXBweSBpbnN0YW5jZS4nLCAnXFxuXFxuJywgJ0luc3RlYWQsIHBhc3MgdGhlIC5pbm5lckhUTUwgb2YgdGhlIGVsZW1lbnQsIG9yIHVzZSBhIGZ1bmN0aW9uIHRoYXQnLCAncmV0dXJucyBhIGNsb25lZCB2ZXJzaW9uIG9mIHRoZSBlbGVtZW50IGluc3RlYWQuJywgJ1xcblxcbicsICcxKSBjb250ZW50OiBlbGVtZW50LmlubmVySFRNTFxcbicsICcyKSBjb250ZW50OiAoKSA9PiBlbGVtZW50LmNsb25lTm9kZSh0cnVlKSddLmpvaW4oJyAnKSk7XG4gIH1cblxuICB2YXIgaW5zdGFuY2VzID0gZWxlbWVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHJlZmVyZW5jZSkge1xuICAgIHZhciBpbnN0YW5jZSA9IHJlZmVyZW5jZSAmJiBjcmVhdGVUaXBweShyZWZlcmVuY2UsIHBhc3NlZFByb3BzKTtcblxuICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgYWNjLnB1c2goaW5zdGFuY2UpO1xuICAgIH1cblxuICAgIHJldHVybiBhY2M7XG4gIH0sIFtdKTtcbiAgcmV0dXJuIGlzRWxlbWVudCh0YXJnZXRzKSA/IGluc3RhbmNlc1swXSA6IGluc3RhbmNlcztcbn1cblxudGlwcHkuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xudGlwcHkuc2V0RGVmYXVsdFByb3BzID0gc2V0RGVmYXVsdFByb3BzO1xudGlwcHkuY3VycmVudElucHV0ID0gY3VycmVudElucHV0O1xudmFyIGhpZGVBbGwgPSBmdW5jdGlvbiBoaWRlQWxsKF90ZW1wKSB7XG4gIHZhciBfcmVmID0gX3RlbXAgPT09IHZvaWQgMCA/IHt9IDogX3RlbXAsXG4gICAgICBleGNsdWRlZFJlZmVyZW5jZU9ySW5zdGFuY2UgPSBfcmVmLmV4Y2x1ZGUsXG4gICAgICBkdXJhdGlvbiA9IF9yZWYuZHVyYXRpb247XG5cbiAgbW91bnRlZEluc3RhbmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgIHZhciBpc0V4Y2x1ZGVkID0gZmFsc2U7XG5cbiAgICBpZiAoZXhjbHVkZWRSZWZlcmVuY2VPckluc3RhbmNlKSB7XG4gICAgICBpc0V4Y2x1ZGVkID0gaXNSZWZlcmVuY2VFbGVtZW50KGV4Y2x1ZGVkUmVmZXJlbmNlT3JJbnN0YW5jZSkgPyBpbnN0YW5jZS5yZWZlcmVuY2UgPT09IGV4Y2x1ZGVkUmVmZXJlbmNlT3JJbnN0YW5jZSA6IGluc3RhbmNlLnBvcHBlciA9PT0gZXhjbHVkZWRSZWZlcmVuY2VPckluc3RhbmNlLnBvcHBlcjtcbiAgICB9XG5cbiAgICBpZiAoIWlzRXhjbHVkZWQpIHtcbiAgICAgIHZhciBvcmlnaW5hbER1cmF0aW9uID0gaW5zdGFuY2UucHJvcHMuZHVyYXRpb247XG4gICAgICBpbnN0YW5jZS5zZXRQcm9wcyh7XG4gICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvblxuICAgICAgfSk7XG4gICAgICBpbnN0YW5jZS5oaWRlKCk7XG5cbiAgICAgIGlmICghaW5zdGFuY2Uuc3RhdGUuaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgaW5zdGFuY2Uuc2V0UHJvcHMoe1xuICAgICAgICAgIGR1cmF0aW9uOiBvcmlnaW5hbER1cmF0aW9uXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59O1xuXG4vLyBldmVyeSB0aW1lIHRoZSBwb3BwZXIgaXMgZGVzdHJveWVkIChpLmUuIGEgbmV3IHRhcmdldCksIHJlbW92aW5nIHRoZSBzdHlsZXNcbi8vIGFuZCBjYXVzaW5nIHRyYW5zaXRpb25zIHRvIGJyZWFrIGZvciBzaW5nbGV0b25zIHdoZW4gdGhlIGNvbnNvbGUgaXMgb3BlbiwgYnV0XG4vLyBtb3N0IG5vdGFibHkgZm9yIG5vbi10cmFuc2Zvcm0gc3R5bGVzIGJlaW5nIHVzZWQsIGBncHVBY2NlbGVyYXRpb246IGZhbHNlYC5cblxudmFyIGFwcGx5U3R5bGVzTW9kaWZpZXIgPSBPYmplY3QuYXNzaWduKHt9LCBhcHBseVN0eWxlcywge1xuICBlZmZlY3Q6IGZ1bmN0aW9uIGVmZmVjdChfcmVmKSB7XG4gICAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZTtcbiAgICB2YXIgaW5pdGlhbFN0eWxlcyA9IHtcbiAgICAgIHBvcHBlcjoge1xuICAgICAgICBwb3NpdGlvbjogc3RhdGUub3B0aW9ucy5zdHJhdGVneSxcbiAgICAgICAgbGVmdDogJzAnLFxuICAgICAgICB0b3A6ICcwJyxcbiAgICAgICAgbWFyZ2luOiAnMCdcbiAgICAgIH0sXG4gICAgICBhcnJvdzoge1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJ1xuICAgICAgfSxcbiAgICAgIHJlZmVyZW5jZToge31cbiAgICB9O1xuICAgIE9iamVjdC5hc3NpZ24oc3RhdGUuZWxlbWVudHMucG9wcGVyLnN0eWxlLCBpbml0aWFsU3R5bGVzLnBvcHBlcik7XG4gICAgc3RhdGUuc3R5bGVzID0gaW5pdGlhbFN0eWxlcztcblxuICAgIGlmIChzdGF0ZS5lbGVtZW50cy5hcnJvdykge1xuICAgICAgT2JqZWN0LmFzc2lnbihzdGF0ZS5lbGVtZW50cy5hcnJvdy5zdHlsZSwgaW5pdGlhbFN0eWxlcy5hcnJvdyk7XG4gICAgfSAvLyBpbnRlbnRpb25hbGx5IHJldHVybiBubyBjbGVhbnVwIGZ1bmN0aW9uXG4gICAgLy8gcmV0dXJuICgpID0+IHsgLi4uIH1cblxuICB9XG59KTtcblxudmFyIGNyZWF0ZVNpbmdsZXRvbiA9IGZ1bmN0aW9uIGNyZWF0ZVNpbmdsZXRvbih0aXBweUluc3RhbmNlcywgb3B0aW9uYWxQcm9wcykge1xuICB2YXIgX29wdGlvbmFsUHJvcHMkcG9wcGVyO1xuXG4gIGlmIChvcHRpb25hbFByb3BzID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25hbFByb3BzID0ge307XG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgZXJyb3JXaGVuKCFBcnJheS5pc0FycmF5KHRpcHB5SW5zdGFuY2VzKSwgWydUaGUgZmlyc3QgYXJndW1lbnQgcGFzc2VkIHRvIGNyZWF0ZVNpbmdsZXRvbigpIG11c3QgYmUgYW4gYXJyYXkgb2YnLCAndGlwcHkgaW5zdGFuY2VzLiBUaGUgcGFzc2VkIHZhbHVlIHdhcycsIFN0cmluZyh0aXBweUluc3RhbmNlcyldLmpvaW4oJyAnKSk7XG4gIH1cblxuICB2YXIgaW5kaXZpZHVhbEluc3RhbmNlcyA9IHRpcHB5SW5zdGFuY2VzO1xuICB2YXIgcmVmZXJlbmNlcyA9IFtdO1xuICB2YXIgdHJpZ2dlclRhcmdldHMgPSBbXTtcbiAgdmFyIGN1cnJlbnRUYXJnZXQ7XG4gIHZhciBvdmVycmlkZXMgPSBvcHRpb25hbFByb3BzLm92ZXJyaWRlcztcbiAgdmFyIGludGVyY2VwdFNldFByb3BzQ2xlYW51cHMgPSBbXTtcbiAgdmFyIHNob3duT25DcmVhdGUgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBzZXRUcmlnZ2VyVGFyZ2V0cygpIHtcbiAgICB0cmlnZ2VyVGFyZ2V0cyA9IGluZGl2aWR1YWxJbnN0YW5jZXMubWFwKGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZVRvQXJyYXkoaW5zdGFuY2UucHJvcHMudHJpZ2dlclRhcmdldCB8fCBpbnN0YW5jZS5yZWZlcmVuY2UpO1xuICAgIH0pLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBpdGVtKSB7XG4gICAgICByZXR1cm4gYWNjLmNvbmNhdChpdGVtKTtcbiAgICB9LCBbXSk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRSZWZlcmVuY2VzKCkge1xuICAgIHJlZmVyZW5jZXMgPSBpbmRpdmlkdWFsSW5zdGFuY2VzLm1hcChmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAgIHJldHVybiBpbnN0YW5jZS5yZWZlcmVuY2U7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBlbmFibGVJbnN0YW5jZXMoaXNFbmFibGVkKSB7XG4gICAgaW5kaXZpZHVhbEluc3RhbmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgaWYgKGlzRW5hYmxlZCkge1xuICAgICAgICBpbnN0YW5jZS5lbmFibGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluc3RhbmNlLmRpc2FibGUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGludGVyY2VwdFNldFByb3BzKHNpbmdsZXRvbikge1xuICAgIHJldHVybiBpbmRpdmlkdWFsSW5zdGFuY2VzLm1hcChmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAgIHZhciBvcmlnaW5hbFNldFByb3BzID0gaW5zdGFuY2Uuc2V0UHJvcHM7XG5cbiAgICAgIGluc3RhbmNlLnNldFByb3BzID0gZnVuY3Rpb24gKHByb3BzKSB7XG4gICAgICAgIG9yaWdpbmFsU2V0UHJvcHMocHJvcHMpO1xuXG4gICAgICAgIGlmIChpbnN0YW5jZS5yZWZlcmVuY2UgPT09IGN1cnJlbnRUYXJnZXQpIHtcbiAgICAgICAgICBzaW5nbGV0b24uc2V0UHJvcHMocHJvcHMpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpbnN0YW5jZS5zZXRQcm9wcyA9IG9yaWdpbmFsU2V0UHJvcHM7XG4gICAgICB9O1xuICAgIH0pO1xuICB9IC8vIGhhdmUgdG8gcGFzcyBzaW5nbGV0b24sIGFzIGl0IG1heWJlIHVuZGVmaW5lZCBvbiBmaXJzdCBjYWxsXG5cblxuICBmdW5jdGlvbiBwcmVwYXJlSW5zdGFuY2Uoc2luZ2xldG9uLCB0YXJnZXQpIHtcbiAgICB2YXIgaW5kZXggPSB0cmlnZ2VyVGFyZ2V0cy5pbmRleE9mKHRhcmdldCk7IC8vIGJhaWwtb3V0XG5cbiAgICBpZiAodGFyZ2V0ID09PSBjdXJyZW50VGFyZ2V0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY3VycmVudFRhcmdldCA9IHRhcmdldDtcbiAgICB2YXIgb3ZlcnJpZGVQcm9wcyA9IChvdmVycmlkZXMgfHwgW10pLmNvbmNhdCgnY29udGVudCcpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwcm9wKSB7XG4gICAgICBhY2NbcHJvcF0gPSBpbmRpdmlkdWFsSW5zdGFuY2VzW2luZGV4XS5wcm9wc1twcm9wXTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuICAgIHNpbmdsZXRvbi5zZXRQcm9wcyhPYmplY3QuYXNzaWduKHt9LCBvdmVycmlkZVByb3BzLCB7XG4gICAgICBnZXRSZWZlcmVuY2VDbGllbnRSZWN0OiB0eXBlb2Ygb3ZlcnJpZGVQcm9wcy5nZXRSZWZlcmVuY2VDbGllbnRSZWN0ID09PSAnZnVuY3Rpb24nID8gb3ZlcnJpZGVQcm9wcy5nZXRSZWZlcmVuY2VDbGllbnRSZWN0IDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3JlZmVyZW5jZXMkaW5kZXg7XG5cbiAgICAgICAgcmV0dXJuIChfcmVmZXJlbmNlcyRpbmRleCA9IHJlZmVyZW5jZXNbaW5kZXhdKSA9PSBudWxsID8gdm9pZCAwIDogX3JlZmVyZW5jZXMkaW5kZXguZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB9XG4gICAgfSkpO1xuICB9XG5cbiAgZW5hYmxlSW5zdGFuY2VzKGZhbHNlKTtcbiAgc2V0UmVmZXJlbmNlcygpO1xuICBzZXRUcmlnZ2VyVGFyZ2V0cygpO1xuICB2YXIgcGx1Z2luID0ge1xuICAgIGZuOiBmdW5jdGlvbiBmbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG9uRGVzdHJveTogZnVuY3Rpb24gb25EZXN0cm95KCkge1xuICAgICAgICAgIGVuYWJsZUluc3RhbmNlcyh0cnVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25IaWRkZW46IGZ1bmN0aW9uIG9uSGlkZGVuKCkge1xuICAgICAgICAgIGN1cnJlbnRUYXJnZXQgPSBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBvbkNsaWNrT3V0c2lkZTogZnVuY3Rpb24gb25DbGlja091dHNpZGUoaW5zdGFuY2UpIHtcbiAgICAgICAgICBpZiAoaW5zdGFuY2UucHJvcHMuc2hvd09uQ3JlYXRlICYmICFzaG93bk9uQ3JlYXRlKSB7XG4gICAgICAgICAgICBzaG93bk9uQ3JlYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIGN1cnJlbnRUYXJnZXQgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25TaG93OiBmdW5jdGlvbiBvblNob3coaW5zdGFuY2UpIHtcbiAgICAgICAgICBpZiAoaW5zdGFuY2UucHJvcHMuc2hvd09uQ3JlYXRlICYmICFzaG93bk9uQ3JlYXRlKSB7XG4gICAgICAgICAgICBzaG93bk9uQ3JlYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIHByZXBhcmVJbnN0YW5jZShpbnN0YW5jZSwgcmVmZXJlbmNlc1swXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvblRyaWdnZXI6IGZ1bmN0aW9uIG9uVHJpZ2dlcihpbnN0YW5jZSwgZXZlbnQpIHtcbiAgICAgICAgICBwcmVwYXJlSW5zdGFuY2UoaW5zdGFuY2UsIGV2ZW50LmN1cnJlbnRUYXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbiAgdmFyIHNpbmdsZXRvbiA9IHRpcHB5KGRpdigpLCBPYmplY3QuYXNzaWduKHt9LCByZW1vdmVQcm9wZXJ0aWVzKG9wdGlvbmFsUHJvcHMsIFsnb3ZlcnJpZGVzJ10pLCB7XG4gICAgcGx1Z2luczogW3BsdWdpbl0uY29uY2F0KG9wdGlvbmFsUHJvcHMucGx1Z2lucyB8fCBbXSksXG4gICAgdHJpZ2dlclRhcmdldDogdHJpZ2dlclRhcmdldHMsXG4gICAgcG9wcGVyT3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9uYWxQcm9wcy5wb3BwZXJPcHRpb25zLCB7XG4gICAgICBtb2RpZmllcnM6IFtdLmNvbmNhdCgoKF9vcHRpb25hbFByb3BzJHBvcHBlciA9IG9wdGlvbmFsUHJvcHMucG9wcGVyT3B0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9vcHRpb25hbFByb3BzJHBvcHBlci5tb2RpZmllcnMpIHx8IFtdLCBbYXBwbHlTdHlsZXNNb2RpZmllcl0pXG4gICAgfSlcbiAgfSkpO1xuICB2YXIgb3JpZ2luYWxTaG93ID0gc2luZ2xldG9uLnNob3c7XG5cbiAgc2luZ2xldG9uLnNob3cgPSBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgb3JpZ2luYWxTaG93KCk7IC8vIGZpcnN0IHRpbWUsIHNob3dPbkNyZWF0ZSBvciBwcm9ncmFtbWF0aWMgY2FsbCB3aXRoIG5vIHBhcmFtc1xuICAgIC8vIGRlZmF1bHQgdG8gc2hvd2luZyBmaXJzdCBpbnN0YW5jZVxuXG4gICAgaWYgKCFjdXJyZW50VGFyZ2V0ICYmIHRhcmdldCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gcHJlcGFyZUluc3RhbmNlKHNpbmdsZXRvbiwgcmVmZXJlbmNlc1swXSk7XG4gICAgfSAvLyB0cmlnZ2VyZWQgZnJvbSBldmVudCAoZG8gbm90aGluZyBhcyBwcmVwYXJlSW5zdGFuY2UgYWxyZWFkeSBjYWxsZWQgYnkgb25UcmlnZ2VyKVxuICAgIC8vIHByb2dyYW1tYXRpYyBjYWxsIHdpdGggbm8gcGFyYW1zIHdoZW4gYWxyZWFkeSB2aXNpYmxlIChkbyBub3RoaW5nIGFnYWluKVxuXG5cbiAgICBpZiAoY3VycmVudFRhcmdldCAmJiB0YXJnZXQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gdGFyZ2V0IGlzIGluZGV4IG9mIGluc3RhbmNlXG5cblxuICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIHJlZmVyZW5jZXNbdGFyZ2V0XSAmJiBwcmVwYXJlSW5zdGFuY2Uoc2luZ2xldG9uLCByZWZlcmVuY2VzW3RhcmdldF0pO1xuICAgIH0gLy8gdGFyZ2V0IGlzIGEgY2hpbGQgdGlwcHkgaW5zdGFuY2VcblxuXG4gICAgaWYgKGluZGl2aWR1YWxJbnN0YW5jZXMuaW5kZXhPZih0YXJnZXQpID49IDApIHtcbiAgICAgIHZhciByZWYgPSB0YXJnZXQucmVmZXJlbmNlO1xuICAgICAgcmV0dXJuIHByZXBhcmVJbnN0YW5jZShzaW5nbGV0b24sIHJlZik7XG4gICAgfSAvLyB0YXJnZXQgaXMgYSBSZWZlcmVuY2VFbGVtZW50XG5cblxuICAgIGlmIChyZWZlcmVuY2VzLmluZGV4T2YodGFyZ2V0KSA+PSAwKSB7XG4gICAgICByZXR1cm4gcHJlcGFyZUluc3RhbmNlKHNpbmdsZXRvbiwgdGFyZ2V0KTtcbiAgICB9XG4gIH07XG5cbiAgc2luZ2xldG9uLnNob3dOZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBmaXJzdCA9IHJlZmVyZW5jZXNbMF07XG5cbiAgICBpZiAoIWN1cnJlbnRUYXJnZXQpIHtcbiAgICAgIHJldHVybiBzaW5nbGV0b24uc2hvdygwKTtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXggPSByZWZlcmVuY2VzLmluZGV4T2YoY3VycmVudFRhcmdldCk7XG4gICAgc2luZ2xldG9uLnNob3cocmVmZXJlbmNlc1tpbmRleCArIDFdIHx8IGZpcnN0KTtcbiAgfTtcblxuICBzaW5nbGV0b24uc2hvd1ByZXZpb3VzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBsYXN0ID0gcmVmZXJlbmNlc1tyZWZlcmVuY2VzLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKCFjdXJyZW50VGFyZ2V0KSB7XG4gICAgICByZXR1cm4gc2luZ2xldG9uLnNob3cobGFzdCk7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gcmVmZXJlbmNlcy5pbmRleE9mKGN1cnJlbnRUYXJnZXQpO1xuICAgIHZhciB0YXJnZXQgPSByZWZlcmVuY2VzW2luZGV4IC0gMV0gfHwgbGFzdDtcbiAgICBzaW5nbGV0b24uc2hvdyh0YXJnZXQpO1xuICB9O1xuXG4gIHZhciBvcmlnaW5hbFNldFByb3BzID0gc2luZ2xldG9uLnNldFByb3BzO1xuXG4gIHNpbmdsZXRvbi5zZXRQcm9wcyA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgIG92ZXJyaWRlcyA9IHByb3BzLm92ZXJyaWRlcyB8fCBvdmVycmlkZXM7XG4gICAgb3JpZ2luYWxTZXRQcm9wcyhwcm9wcyk7XG4gIH07XG5cbiAgc2luZ2xldG9uLnNldEluc3RhbmNlcyA9IGZ1bmN0aW9uIChuZXh0SW5zdGFuY2VzKSB7XG4gICAgZW5hYmxlSW5zdGFuY2VzKHRydWUpO1xuICAgIGludGVyY2VwdFNldFByb3BzQ2xlYW51cHMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcbiAgICAgIHJldHVybiBmbigpO1xuICAgIH0pO1xuICAgIGluZGl2aWR1YWxJbnN0YW5jZXMgPSBuZXh0SW5zdGFuY2VzO1xuICAgIGVuYWJsZUluc3RhbmNlcyhmYWxzZSk7XG4gICAgc2V0UmVmZXJlbmNlcygpO1xuICAgIHNldFRyaWdnZXJUYXJnZXRzKCk7XG4gICAgaW50ZXJjZXB0U2V0UHJvcHNDbGVhbnVwcyA9IGludGVyY2VwdFNldFByb3BzKHNpbmdsZXRvbik7XG4gICAgc2luZ2xldG9uLnNldFByb3BzKHtcbiAgICAgIHRyaWdnZXJUYXJnZXQ6IHRyaWdnZXJUYXJnZXRzXG4gICAgfSk7XG4gIH07XG5cbiAgaW50ZXJjZXB0U2V0UHJvcHNDbGVhbnVwcyA9IGludGVyY2VwdFNldFByb3BzKHNpbmdsZXRvbik7XG4gIHJldHVybiBzaW5nbGV0b247XG59O1xuXG52YXIgQlVCQkxJTkdfRVZFTlRTX01BUCA9IHtcbiAgbW91c2VvdmVyOiAnbW91c2VlbnRlcicsXG4gIGZvY3VzaW46ICdmb2N1cycsXG4gIGNsaWNrOiAnY2xpY2snXG59O1xuLyoqXG4gKiBDcmVhdGVzIGEgZGVsZWdhdGUgaW5zdGFuY2UgdGhhdCBjb250cm9scyB0aGUgY3JlYXRpb24gb2YgdGlwcHkgaW5zdGFuY2VzXG4gKiBmb3IgY2hpbGQgZWxlbWVudHMgKGB0YXJnZXRgIENTUyBzZWxlY3RvcikuXG4gKi9cblxuZnVuY3Rpb24gZGVsZWdhdGUodGFyZ2V0cywgcHJvcHMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIGVycm9yV2hlbighKHByb3BzICYmIHByb3BzLnRhcmdldCksIFsnWW91IG11c3Qgc3BlY2l0eSBhIGB0YXJnZXRgIHByb3AgaW5kaWNhdGluZyBhIENTUyBzZWxlY3RvciBzdHJpbmcgbWF0Y2hpbmcnLCAndGhlIHRhcmdldCBlbGVtZW50cyB0aGF0IHNob3VsZCByZWNlaXZlIGEgdGlwcHkuJ10uam9pbignICcpKTtcbiAgfVxuXG4gIHZhciBsaXN0ZW5lcnMgPSBbXTtcbiAgdmFyIGNoaWxkVGlwcHlJbnN0YW5jZXMgPSBbXTtcbiAgdmFyIGRpc2FibGVkID0gZmFsc2U7XG4gIHZhciB0YXJnZXQgPSBwcm9wcy50YXJnZXQ7XG4gIHZhciBuYXRpdmVQcm9wcyA9IHJlbW92ZVByb3BlcnRpZXMocHJvcHMsIFsndGFyZ2V0J10pO1xuICB2YXIgcGFyZW50UHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBuYXRpdmVQcm9wcywge1xuICAgIHRyaWdnZXI6ICdtYW51YWwnLFxuICAgIHRvdWNoOiBmYWxzZVxuICB9KTtcbiAgdmFyIGNoaWxkUHJvcHMgPSBPYmplY3QuYXNzaWduKHtcbiAgICB0b3VjaDogZGVmYXVsdFByb3BzLnRvdWNoXG4gIH0sIG5hdGl2ZVByb3BzLCB7XG4gICAgc2hvd09uQ3JlYXRlOiB0cnVlXG4gIH0pO1xuICB2YXIgcmV0dXJuVmFsdWUgPSB0aXBweSh0YXJnZXRzLCBwYXJlbnRQcm9wcyk7XG4gIHZhciBub3JtYWxpemVkUmV0dXJuVmFsdWUgPSBub3JtYWxpemVUb0FycmF5KHJldHVyblZhbHVlKTtcblxuICBmdW5jdGlvbiBvblRyaWdnZXIoZXZlbnQpIHtcbiAgICBpZiAoIWV2ZW50LnRhcmdldCB8fCBkaXNhYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0YXJnZXROb2RlID0gZXZlbnQudGFyZ2V0LmNsb3Nlc3QodGFyZ2V0KTtcblxuICAgIGlmICghdGFyZ2V0Tm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gR2V0IHJlbGV2YW50IHRyaWdnZXIgd2l0aCBmYWxsYmFja3M6XG4gICAgLy8gMS4gQ2hlY2sgYGRhdGEtdGlwcHktdHJpZ2dlcmAgYXR0cmlidXRlIG9uIHRhcmdldCBub2RlXG4gICAgLy8gMi4gRmFsbGJhY2sgdG8gYHRyaWdnZXJgIHBhc3NlZCB0byBgZGVsZWdhdGUoKWBcbiAgICAvLyAzLiBGYWxsYmFjayB0byBgZGVmYXVsdFByb3BzLnRyaWdnZXJgXG5cblxuICAgIHZhciB0cmlnZ2VyID0gdGFyZ2V0Tm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtdGlwcHktdHJpZ2dlcicpIHx8IHByb3BzLnRyaWdnZXIgfHwgZGVmYXVsdFByb3BzLnRyaWdnZXI7IC8vIEB0cy1pZ25vcmVcblxuICAgIGlmICh0YXJnZXROb2RlLl90aXBweSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudC50eXBlID09PSAndG91Y2hzdGFydCcgJiYgdHlwZW9mIGNoaWxkUHJvcHMudG91Y2ggPT09ICdib29sZWFuJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudC50eXBlICE9PSAndG91Y2hzdGFydCcgJiYgdHJpZ2dlci5pbmRleE9mKEJVQkJMSU5HX0VWRU5UU19NQVBbZXZlbnQudHlwZV0pIDwgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpbnN0YW5jZSA9IHRpcHB5KHRhcmdldE5vZGUsIGNoaWxkUHJvcHMpO1xuXG4gICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICBjaGlsZFRpcHB5SW5zdGFuY2VzID0gY2hpbGRUaXBweUluc3RhbmNlcy5jb25jYXQoaW5zdGFuY2UpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uKG5vZGUsIGV2ZW50VHlwZSwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgIG9wdGlvbnMgPSBmYWxzZTtcbiAgICB9XG5cbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICBsaXN0ZW5lcnMucHVzaCh7XG4gICAgICBub2RlOiBub2RlLFxuICAgICAgZXZlbnRUeXBlOiBldmVudFR5cGUsXG4gICAgICBoYW5kbGVyOiBoYW5kbGVyLFxuICAgICAgb3B0aW9uczogb3B0aW9uc1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcnMoaW5zdGFuY2UpIHtcbiAgICB2YXIgcmVmZXJlbmNlID0gaW5zdGFuY2UucmVmZXJlbmNlO1xuICAgIG9uKHJlZmVyZW5jZSwgJ3RvdWNoc3RhcnQnLCBvblRyaWdnZXIsIFRPVUNIX09QVElPTlMpO1xuICAgIG9uKHJlZmVyZW5jZSwgJ21vdXNlb3ZlcicsIG9uVHJpZ2dlcik7XG4gICAgb24ocmVmZXJlbmNlLCAnZm9jdXNpbicsIG9uVHJpZ2dlcik7XG4gICAgb24ocmVmZXJlbmNlLCAnY2xpY2snLCBvblRyaWdnZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgIHZhciBub2RlID0gX3JlZi5ub2RlLFxuICAgICAgICAgIGV2ZW50VHlwZSA9IF9yZWYuZXZlbnRUeXBlLFxuICAgICAgICAgIGhhbmRsZXIgPSBfcmVmLmhhbmRsZXIsXG4gICAgICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucztcbiAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIH0pO1xuICAgIGxpc3RlbmVycyA9IFtdO1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwbHlNdXRhdGlvbnMoaW5zdGFuY2UpIHtcbiAgICB2YXIgb3JpZ2luYWxEZXN0cm95ID0gaW5zdGFuY2UuZGVzdHJveTtcbiAgICB2YXIgb3JpZ2luYWxFbmFibGUgPSBpbnN0YW5jZS5lbmFibGU7XG4gICAgdmFyIG9yaWdpbmFsRGlzYWJsZSA9IGluc3RhbmNlLmRpc2FibGU7XG5cbiAgICBpbnN0YW5jZS5kZXN0cm95ID0gZnVuY3Rpb24gKHNob3VsZERlc3Ryb3lDaGlsZEluc3RhbmNlcykge1xuICAgICAgaWYgKHNob3VsZERlc3Ryb3lDaGlsZEluc3RhbmNlcyA9PT0gdm9pZCAwKSB7XG4gICAgICAgIHNob3VsZERlc3Ryb3lDaGlsZEluc3RhbmNlcyA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaG91bGREZXN0cm95Q2hpbGRJbnN0YW5jZXMpIHtcbiAgICAgICAgY2hpbGRUaXBweUluc3RhbmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgICAgIGluc3RhbmNlLmRlc3Ryb3koKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkVGlwcHlJbnN0YW5jZXMgPSBbXTtcbiAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICBvcmlnaW5hbERlc3Ryb3koKTtcbiAgICB9O1xuXG4gICAgaW5zdGFuY2UuZW5hYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgb3JpZ2luYWxFbmFibGUoKTtcbiAgICAgIGNoaWxkVGlwcHlJbnN0YW5jZXMuZm9yRWFjaChmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlLmVuYWJsZSgpO1xuICAgICAgfSk7XG4gICAgICBkaXNhYmxlZCA9IGZhbHNlO1xuICAgIH07XG5cbiAgICBpbnN0YW5jZS5kaXNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgb3JpZ2luYWxEaXNhYmxlKCk7XG4gICAgICBjaGlsZFRpcHB5SW5zdGFuY2VzLmZvckVhY2goZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZS5kaXNhYmxlKCk7XG4gICAgICB9KTtcbiAgICAgIGRpc2FibGVkID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgYWRkRXZlbnRMaXN0ZW5lcnMoaW5zdGFuY2UpO1xuICB9XG5cbiAgbm9ybWFsaXplZFJldHVyblZhbHVlLmZvckVhY2goYXBwbHlNdXRhdGlvbnMpO1xuICByZXR1cm4gcmV0dXJuVmFsdWU7XG59XG5cbnZhciBhbmltYXRlRmlsbCA9IHtcbiAgbmFtZTogJ2FuaW1hdGVGaWxsJyxcbiAgZGVmYXVsdFZhbHVlOiBmYWxzZSxcbiAgZm46IGZ1bmN0aW9uIGZuKGluc3RhbmNlKSB7XG4gICAgdmFyIF9pbnN0YW5jZSRwcm9wcyRyZW5kZTtcblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAoISgoX2luc3RhbmNlJHByb3BzJHJlbmRlID0gaW5zdGFuY2UucHJvcHMucmVuZGVyKSAhPSBudWxsICYmIF9pbnN0YW5jZSRwcm9wcyRyZW5kZS4kJHRpcHB5KSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBlcnJvcldoZW4oaW5zdGFuY2UucHJvcHMuYW5pbWF0ZUZpbGwsICdUaGUgYGFuaW1hdGVGaWxsYCBwbHVnaW4gcmVxdWlyZXMgdGhlIGRlZmF1bHQgcmVuZGVyIGZ1bmN0aW9uLicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge307XG4gICAgfVxuXG4gICAgdmFyIF9nZXRDaGlsZHJlbiA9IGdldENoaWxkcmVuKGluc3RhbmNlLnBvcHBlciksXG4gICAgICAgIGJveCA9IF9nZXRDaGlsZHJlbi5ib3gsXG4gICAgICAgIGNvbnRlbnQgPSBfZ2V0Q2hpbGRyZW4uY29udGVudDtcblxuICAgIHZhciBiYWNrZHJvcCA9IGluc3RhbmNlLnByb3BzLmFuaW1hdGVGaWxsID8gY3JlYXRlQmFja2Ryb3BFbGVtZW50KCkgOiBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICBvbkNyZWF0ZTogZnVuY3Rpb24gb25DcmVhdGUoKSB7XG4gICAgICAgIGlmIChiYWNrZHJvcCkge1xuICAgICAgICAgIGJveC5pbnNlcnRCZWZvcmUoYmFja2Ryb3AsIGJveC5maXJzdEVsZW1lbnRDaGlsZCk7XG4gICAgICAgICAgYm94LnNldEF0dHJpYnV0ZSgnZGF0YS1hbmltYXRlZmlsbCcsICcnKTtcbiAgICAgICAgICBib3guc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICAgICAgICBpbnN0YW5jZS5zZXRQcm9wcyh7XG4gICAgICAgICAgICBhcnJvdzogZmFsc2UsXG4gICAgICAgICAgICBhbmltYXRpb246ICdzaGlmdC1hd2F5J1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25Nb3VudDogZnVuY3Rpb24gb25Nb3VudCgpIHtcbiAgICAgICAgaWYgKGJhY2tkcm9wKSB7XG4gICAgICAgICAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbiA9IGJveC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb247XG4gICAgICAgICAgdmFyIGR1cmF0aW9uID0gTnVtYmVyKHRyYW5zaXRpb25EdXJhdGlvbi5yZXBsYWNlKCdtcycsICcnKSk7IC8vIFRoZSBjb250ZW50IHNob3VsZCBmYWRlIGluIGFmdGVyIHRoZSBiYWNrZHJvcCBoYXMgbW9zdGx5IGZpbGxlZCB0aGVcbiAgICAgICAgICAvLyB0b29sdGlwIGVsZW1lbnQuIGBjbGlwLXBhdGhgIGlzIHRoZSBvdGhlciBhbHRlcm5hdGl2ZSBidXQgaXMgbm90XG4gICAgICAgICAgLy8gd2VsbC1zdXBwb3J0ZWQgYW5kIGlzIGJ1Z2d5IG9uIHNvbWUgZGV2aWNlcy5cblxuICAgICAgICAgIGNvbnRlbnQuc3R5bGUudHJhbnNpdGlvbkRlbGF5ID0gTWF0aC5yb3VuZChkdXJhdGlvbiAvIDEwKSArIFwibXNcIjtcbiAgICAgICAgICBiYWNrZHJvcC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSB0cmFuc2l0aW9uRHVyYXRpb247XG4gICAgICAgICAgc2V0VmlzaWJpbGl0eVN0YXRlKFtiYWNrZHJvcF0sICd2aXNpYmxlJyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvblNob3c6IGZ1bmN0aW9uIG9uU2hvdygpIHtcbiAgICAgICAgaWYgKGJhY2tkcm9wKSB7XG4gICAgICAgICAgYmFja2Ryb3Auc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBtcyc7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbkhpZGU6IGZ1bmN0aW9uIG9uSGlkZSgpIHtcbiAgICAgICAgaWYgKGJhY2tkcm9wKSB7XG4gICAgICAgICAgc2V0VmlzaWJpbGl0eVN0YXRlKFtiYWNrZHJvcF0sICdoaWRkZW4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUJhY2tkcm9wRWxlbWVudCgpIHtcbiAgdmFyIGJhY2tkcm9wID0gZGl2KCk7XG4gIGJhY2tkcm9wLmNsYXNzTmFtZSA9IEJBQ0tEUk9QX0NMQVNTO1xuICBzZXRWaXNpYmlsaXR5U3RhdGUoW2JhY2tkcm9wXSwgJ2hpZGRlbicpO1xuICByZXR1cm4gYmFja2Ryb3A7XG59XG5cbnZhciBtb3VzZUNvb3JkcyA9IHtcbiAgY2xpZW50WDogMCxcbiAgY2xpZW50WTogMFxufTtcbnZhciBhY3RpdmVJbnN0YW5jZXMgPSBbXTtcblxuZnVuY3Rpb24gc3RvcmVNb3VzZUNvb3JkcyhfcmVmKSB7XG4gIHZhciBjbGllbnRYID0gX3JlZi5jbGllbnRYLFxuICAgICAgY2xpZW50WSA9IF9yZWYuY2xpZW50WTtcbiAgbW91c2VDb29yZHMgPSB7XG4gICAgY2xpZW50WDogY2xpZW50WCxcbiAgICBjbGllbnRZOiBjbGllbnRZXG4gIH07XG59XG5cbmZ1bmN0aW9uIGFkZE1vdXNlQ29vcmRzTGlzdGVuZXIoZG9jKSB7XG4gIGRvYy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBzdG9yZU1vdXNlQ29vcmRzKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlTW91c2VDb29yZHNMaXN0ZW5lcihkb2MpIHtcbiAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHN0b3JlTW91c2VDb29yZHMpO1xufVxuXG52YXIgZm9sbG93Q3Vyc29yID0ge1xuICBuYW1lOiAnZm9sbG93Q3Vyc29yJyxcbiAgZGVmYXVsdFZhbHVlOiBmYWxzZSxcbiAgZm46IGZ1bmN0aW9uIGZuKGluc3RhbmNlKSB7XG4gICAgdmFyIHJlZmVyZW5jZSA9IGluc3RhbmNlLnJlZmVyZW5jZTtcbiAgICB2YXIgZG9jID0gZ2V0T3duZXJEb2N1bWVudChpbnN0YW5jZS5wcm9wcy50cmlnZ2VyVGFyZ2V0IHx8IHJlZmVyZW5jZSk7XG4gICAgdmFyIGlzSW50ZXJuYWxVcGRhdGUgPSBmYWxzZTtcbiAgICB2YXIgd2FzRm9jdXNFdmVudCA9IGZhbHNlO1xuICAgIHZhciBpc1VubW91bnRlZCA9IHRydWU7XG4gICAgdmFyIHByZXZQcm9wcyA9IGluc3RhbmNlLnByb3BzO1xuXG4gICAgZnVuY3Rpb24gZ2V0SXNJbml0aWFsQmVoYXZpb3IoKSB7XG4gICAgICByZXR1cm4gaW5zdGFuY2UucHJvcHMuZm9sbG93Q3Vyc29yID09PSAnaW5pdGlhbCcgJiYgaW5zdGFuY2Uuc3RhdGUuaXNWaXNpYmxlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZExpc3RlbmVyKCkge1xuICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uTW91c2VNb3ZlKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcigpIHtcbiAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvbk1vdXNlTW92ZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdW5zZXRHZXRSZWZlcmVuY2VDbGllbnRSZWN0KCkge1xuICAgICAgaXNJbnRlcm5hbFVwZGF0ZSA9IHRydWU7XG4gICAgICBpbnN0YW5jZS5zZXRQcm9wcyh7XG4gICAgICAgIGdldFJlZmVyZW5jZUNsaWVudFJlY3Q6IG51bGxcbiAgICAgIH0pO1xuICAgICAgaXNJbnRlcm5hbFVwZGF0ZSA9IGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uTW91c2VNb3ZlKGV2ZW50KSB7XG4gICAgICAvLyBJZiB0aGUgaW5zdGFuY2UgaXMgaW50ZXJhY3RpdmUsIGF2b2lkIHVwZGF0aW5nIHRoZSBwb3NpdGlvbiB1bmxlc3MgaXQnc1xuICAgICAgLy8gb3ZlciB0aGUgcmVmZXJlbmNlIGVsZW1lbnRcbiAgICAgIHZhciBpc0N1cnNvck92ZXJSZWZlcmVuY2UgPSBldmVudC50YXJnZXQgPyByZWZlcmVuY2UuY29udGFpbnMoZXZlbnQudGFyZ2V0KSA6IHRydWU7XG4gICAgICB2YXIgZm9sbG93Q3Vyc29yID0gaW5zdGFuY2UucHJvcHMuZm9sbG93Q3Vyc29yO1xuICAgICAgdmFyIGNsaWVudFggPSBldmVudC5jbGllbnRYLFxuICAgICAgICAgIGNsaWVudFkgPSBldmVudC5jbGllbnRZO1xuICAgICAgdmFyIHJlY3QgPSByZWZlcmVuY2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgcmVsYXRpdmVYID0gY2xpZW50WCAtIHJlY3QubGVmdDtcbiAgICAgIHZhciByZWxhdGl2ZVkgPSBjbGllbnRZIC0gcmVjdC50b3A7XG5cbiAgICAgIGlmIChpc0N1cnNvck92ZXJSZWZlcmVuY2UgfHwgIWluc3RhbmNlLnByb3BzLmludGVyYWN0aXZlKSB7XG4gICAgICAgIGluc3RhbmNlLnNldFByb3BzKHtcbiAgICAgICAgICAvLyBAdHMtaWdub3JlIC0gdW5uZWVkZWQgRE9NUmVjdCBwcm9wZXJ0aWVzXG4gICAgICAgICAgZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdDogZnVuY3Rpb24gZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdCgpIHtcbiAgICAgICAgICAgIHZhciByZWN0ID0gcmVmZXJlbmNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgdmFyIHggPSBjbGllbnRYO1xuICAgICAgICAgICAgdmFyIHkgPSBjbGllbnRZO1xuXG4gICAgICAgICAgICBpZiAoZm9sbG93Q3Vyc29yID09PSAnaW5pdGlhbCcpIHtcbiAgICAgICAgICAgICAgeCA9IHJlY3QubGVmdCArIHJlbGF0aXZlWDtcbiAgICAgICAgICAgICAgeSA9IHJlY3QudG9wICsgcmVsYXRpdmVZO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdG9wID0gZm9sbG93Q3Vyc29yID09PSAnaG9yaXpvbnRhbCcgPyByZWN0LnRvcCA6IHk7XG4gICAgICAgICAgICB2YXIgcmlnaHQgPSBmb2xsb3dDdXJzb3IgPT09ICd2ZXJ0aWNhbCcgPyByZWN0LnJpZ2h0IDogeDtcbiAgICAgICAgICAgIHZhciBib3R0b20gPSBmb2xsb3dDdXJzb3IgPT09ICdob3Jpem9udGFsJyA/IHJlY3QuYm90dG9tIDogeTtcbiAgICAgICAgICAgIHZhciBsZWZ0ID0gZm9sbG93Q3Vyc29yID09PSAndmVydGljYWwnID8gcmVjdC5sZWZ0IDogeDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHdpZHRoOiByaWdodCAtIGxlZnQsXG4gICAgICAgICAgICAgIGhlaWdodDogYm90dG9tIC0gdG9wLFxuICAgICAgICAgICAgICB0b3A6IHRvcCxcbiAgICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0LFxuICAgICAgICAgICAgICBib3R0b206IGJvdHRvbSxcbiAgICAgICAgICAgICAgbGVmdDogbGVmdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICAgIGlmIChpbnN0YW5jZS5wcm9wcy5mb2xsb3dDdXJzb3IpIHtcbiAgICAgICAgYWN0aXZlSW5zdGFuY2VzLnB1c2goe1xuICAgICAgICAgIGluc3RhbmNlOiBpbnN0YW5jZSxcbiAgICAgICAgICBkb2M6IGRvY1xuICAgICAgICB9KTtcbiAgICAgICAgYWRkTW91c2VDb29yZHNMaXN0ZW5lcihkb2MpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICBhY3RpdmVJbnN0YW5jZXMgPSBhY3RpdmVJbnN0YW5jZXMuZmlsdGVyKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiBkYXRhLmluc3RhbmNlICE9PSBpbnN0YW5jZTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoYWN0aXZlSW5zdGFuY2VzLmZpbHRlcihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gZGF0YS5kb2MgPT09IGRvYztcbiAgICAgIH0pLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZW1vdmVNb3VzZUNvb3Jkc0xpc3RlbmVyKGRvYyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG9uQ3JlYXRlOiBjcmVhdGUsXG4gICAgICBvbkRlc3Ryb3k6IGRlc3Ryb3ksXG4gICAgICBvbkJlZm9yZVVwZGF0ZTogZnVuY3Rpb24gb25CZWZvcmVVcGRhdGUoKSB7XG4gICAgICAgIHByZXZQcm9wcyA9IGluc3RhbmNlLnByb3BzO1xuICAgICAgfSxcbiAgICAgIG9uQWZ0ZXJVcGRhdGU6IGZ1bmN0aW9uIG9uQWZ0ZXJVcGRhdGUoXywgX3JlZjIpIHtcbiAgICAgICAgdmFyIGZvbGxvd0N1cnNvciA9IF9yZWYyLmZvbGxvd0N1cnNvcjtcblxuICAgICAgICBpZiAoaXNJbnRlcm5hbFVwZGF0ZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmb2xsb3dDdXJzb3IgIT09IHVuZGVmaW5lZCAmJiBwcmV2UHJvcHMuZm9sbG93Q3Vyc29yICE9PSBmb2xsb3dDdXJzb3IpIHtcbiAgICAgICAgICBkZXN0cm95KCk7XG5cbiAgICAgICAgICBpZiAoZm9sbG93Q3Vyc29yKSB7XG4gICAgICAgICAgICBjcmVhdGUoKTtcblxuICAgICAgICAgICAgaWYgKGluc3RhbmNlLnN0YXRlLmlzTW91bnRlZCAmJiAhd2FzRm9jdXNFdmVudCAmJiAhZ2V0SXNJbml0aWFsQmVoYXZpb3IoKSkge1xuICAgICAgICAgICAgICBhZGRMaXN0ZW5lcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW1vdmVMaXN0ZW5lcigpO1xuICAgICAgICAgICAgdW5zZXRHZXRSZWZlcmVuY2VDbGllbnRSZWN0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25Nb3VudDogZnVuY3Rpb24gb25Nb3VudCgpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlLnByb3BzLmZvbGxvd0N1cnNvciAmJiAhd2FzRm9jdXNFdmVudCkge1xuICAgICAgICAgIGlmIChpc1VubW91bnRlZCkge1xuICAgICAgICAgICAgb25Nb3VzZU1vdmUobW91c2VDb29yZHMpO1xuICAgICAgICAgICAgaXNVbm1vdW50ZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWdldElzSW5pdGlhbEJlaGF2aW9yKCkpIHtcbiAgICAgICAgICAgIGFkZExpc3RlbmVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgb25UcmlnZ2VyOiBmdW5jdGlvbiBvblRyaWdnZXIoXywgZXZlbnQpIHtcbiAgICAgICAgaWYgKGlzTW91c2VFdmVudChldmVudCkpIHtcbiAgICAgICAgICBtb3VzZUNvb3JkcyA9IHtcbiAgICAgICAgICAgIGNsaWVudFg6IGV2ZW50LmNsaWVudFgsXG4gICAgICAgICAgICBjbGllbnRZOiBldmVudC5jbGllbnRZXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdhc0ZvY3VzRXZlbnQgPSBldmVudC50eXBlID09PSAnZm9jdXMnO1xuICAgICAgfSxcbiAgICAgIG9uSGlkZGVuOiBmdW5jdGlvbiBvbkhpZGRlbigpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlLnByb3BzLmZvbGxvd0N1cnNvcikge1xuICAgICAgICAgIHVuc2V0R2V0UmVmZXJlbmNlQ2xpZW50UmVjdCgpO1xuICAgICAgICAgIHJlbW92ZUxpc3RlbmVyKCk7XG4gICAgICAgICAgaXNVbm1vdW50ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcblxuZnVuY3Rpb24gZ2V0UHJvcHMocHJvcHMsIG1vZGlmaWVyKSB7XG4gIHZhciBfcHJvcHMkcG9wcGVyT3B0aW9ucztcblxuICByZXR1cm4ge1xuICAgIHBvcHBlck9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIHByb3BzLnBvcHBlck9wdGlvbnMsIHtcbiAgICAgIG1vZGlmaWVyczogW10uY29uY2F0KCgoKF9wcm9wcyRwb3BwZXJPcHRpb25zID0gcHJvcHMucG9wcGVyT3B0aW9ucykgPT0gbnVsbCA/IHZvaWQgMCA6IF9wcm9wcyRwb3BwZXJPcHRpb25zLm1vZGlmaWVycykgfHwgW10pLmZpbHRlcihmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICB2YXIgbmFtZSA9IF9yZWYubmFtZTtcbiAgICAgICAgcmV0dXJuIG5hbWUgIT09IG1vZGlmaWVyLm5hbWU7XG4gICAgICB9KSwgW21vZGlmaWVyXSlcbiAgICB9KVxuICB9O1xufVxuXG52YXIgaW5saW5lUG9zaXRpb25pbmcgPSB7XG4gIG5hbWU6ICdpbmxpbmVQb3NpdGlvbmluZycsXG4gIGRlZmF1bHRWYWx1ZTogZmFsc2UsXG4gIGZuOiBmdW5jdGlvbiBmbihpbnN0YW5jZSkge1xuICAgIHZhciByZWZlcmVuY2UgPSBpbnN0YW5jZS5yZWZlcmVuY2U7XG5cbiAgICBmdW5jdGlvbiBpc0VuYWJsZWQoKSB7XG4gICAgICByZXR1cm4gISFpbnN0YW5jZS5wcm9wcy5pbmxpbmVQb3NpdGlvbmluZztcbiAgICB9XG5cbiAgICB2YXIgcGxhY2VtZW50O1xuICAgIHZhciBjdXJzb3JSZWN0SW5kZXggPSAtMTtcbiAgICB2YXIgaXNJbnRlcm5hbFVwZGF0ZSA9IGZhbHNlO1xuICAgIHZhciB0cmllZFBsYWNlbWVudHMgPSBbXTtcbiAgICB2YXIgbW9kaWZpZXIgPSB7XG4gICAgICBuYW1lOiAndGlwcHlJbmxpbmVQb3NpdGlvbmluZycsXG4gICAgICBlbmFibGVkOiB0cnVlLFxuICAgICAgcGhhc2U6ICdhZnRlcldyaXRlJyxcbiAgICAgIGZuOiBmdW5jdGlvbiBmbihfcmVmMikge1xuICAgICAgICB2YXIgc3RhdGUgPSBfcmVmMi5zdGF0ZTtcblxuICAgICAgICBpZiAoaXNFbmFibGVkKCkpIHtcbiAgICAgICAgICBpZiAodHJpZWRQbGFjZW1lbnRzLmluZGV4T2Yoc3RhdGUucGxhY2VtZW50KSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRyaWVkUGxhY2VtZW50cyA9IFtdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwbGFjZW1lbnQgIT09IHN0YXRlLnBsYWNlbWVudCAmJiB0cmllZFBsYWNlbWVudHMuaW5kZXhPZihzdGF0ZS5wbGFjZW1lbnQpID09PSAtMSkge1xuICAgICAgICAgICAgdHJpZWRQbGFjZW1lbnRzLnB1c2goc3RhdGUucGxhY2VtZW50KTtcbiAgICAgICAgICAgIGluc3RhbmNlLnNldFByb3BzKHtcbiAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSAtIHVubmVlZGVkIERPTVJlY3QgcHJvcGVydGllc1xuICAgICAgICAgICAgICBnZXRSZWZlcmVuY2VDbGllbnRSZWN0OiBmdW5jdGlvbiBnZXRSZWZlcmVuY2VDbGllbnRSZWN0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZ2V0UmVmZXJlbmNlQ2xpZW50UmVjdChzdGF0ZS5wbGFjZW1lbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwbGFjZW1lbnQgPSBzdGF0ZS5wbGFjZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gX2dldFJlZmVyZW5jZUNsaWVudFJlY3QocGxhY2VtZW50KSB7XG4gICAgICByZXR1cm4gZ2V0SW5saW5lQm91bmRpbmdDbGllbnRSZWN0KGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSwgcmVmZXJlbmNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBhcnJheUZyb20ocmVmZXJlbmNlLmdldENsaWVudFJlY3RzKCkpLCBjdXJzb3JSZWN0SW5kZXgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldEludGVybmFsUHJvcHMocGFydGlhbFByb3BzKSB7XG4gICAgICBpc0ludGVybmFsVXBkYXRlID0gdHJ1ZTtcbiAgICAgIGluc3RhbmNlLnNldFByb3BzKHBhcnRpYWxQcm9wcyk7XG4gICAgICBpc0ludGVybmFsVXBkYXRlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkTW9kaWZpZXIoKSB7XG4gICAgICBpZiAoIWlzSW50ZXJuYWxVcGRhdGUpIHtcbiAgICAgICAgc2V0SW50ZXJuYWxQcm9wcyhnZXRQcm9wcyhpbnN0YW5jZS5wcm9wcywgbW9kaWZpZXIpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgb25DcmVhdGU6IGFkZE1vZGlmaWVyLFxuICAgICAgb25BZnRlclVwZGF0ZTogYWRkTW9kaWZpZXIsXG4gICAgICBvblRyaWdnZXI6IGZ1bmN0aW9uIG9uVHJpZ2dlcihfLCBldmVudCkge1xuICAgICAgICBpZiAoaXNNb3VzZUV2ZW50KGV2ZW50KSkge1xuICAgICAgICAgIHZhciByZWN0cyA9IGFycmF5RnJvbShpbnN0YW5jZS5yZWZlcmVuY2UuZ2V0Q2xpZW50UmVjdHMoKSk7XG4gICAgICAgICAgdmFyIGN1cnNvclJlY3QgPSByZWN0cy5maW5kKGZ1bmN0aW9uIChyZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gcmVjdC5sZWZ0IC0gMiA8PSBldmVudC5jbGllbnRYICYmIHJlY3QucmlnaHQgKyAyID49IGV2ZW50LmNsaWVudFggJiYgcmVjdC50b3AgLSAyIDw9IGV2ZW50LmNsaWVudFkgJiYgcmVjdC5ib3R0b20gKyAyID49IGV2ZW50LmNsaWVudFk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIGluZGV4ID0gcmVjdHMuaW5kZXhPZihjdXJzb3JSZWN0KTtcbiAgICAgICAgICBjdXJzb3JSZWN0SW5kZXggPSBpbmRleCA+IC0xID8gaW5kZXggOiBjdXJzb3JSZWN0SW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbkhpZGRlbjogZnVuY3Rpb24gb25IaWRkZW4oKSB7XG4gICAgICAgIGN1cnNvclJlY3RJbmRleCA9IC0xO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG5mdW5jdGlvbiBnZXRJbmxpbmVCb3VuZGluZ0NsaWVudFJlY3QoY3VycmVudEJhc2VQbGFjZW1lbnQsIGJvdW5kaW5nUmVjdCwgY2xpZW50UmVjdHMsIGN1cnNvclJlY3RJbmRleCkge1xuICAvLyBOb3QgYW4gaW5saW5lIGVsZW1lbnQsIG9yIHBsYWNlbWVudCBpcyBub3QgeWV0IGtub3duXG4gIGlmIChjbGllbnRSZWN0cy5sZW5ndGggPCAyIHx8IGN1cnJlbnRCYXNlUGxhY2VtZW50ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGJvdW5kaW5nUmVjdDtcbiAgfSAvLyBUaGVyZSBhcmUgdHdvIHJlY3RzIGFuZCB0aGV5IGFyZSBkaXNqb2luZWRcblxuXG4gIGlmIChjbGllbnRSZWN0cy5sZW5ndGggPT09IDIgJiYgY3Vyc29yUmVjdEluZGV4ID49IDAgJiYgY2xpZW50UmVjdHNbMF0ubGVmdCA+IGNsaWVudFJlY3RzWzFdLnJpZ2h0KSB7XG4gICAgcmV0dXJuIGNsaWVudFJlY3RzW2N1cnNvclJlY3RJbmRleF0gfHwgYm91bmRpbmdSZWN0O1xuICB9XG5cbiAgc3dpdGNoIChjdXJyZW50QmFzZVBsYWNlbWVudCkge1xuICAgIGNhc2UgJ3RvcCc6XG4gICAgY2FzZSAnYm90dG9tJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIGZpcnN0UmVjdCA9IGNsaWVudFJlY3RzWzBdO1xuICAgICAgICB2YXIgbGFzdFJlY3QgPSBjbGllbnRSZWN0c1tjbGllbnRSZWN0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIGlzVG9wID0gY3VycmVudEJhc2VQbGFjZW1lbnQgPT09ICd0b3AnO1xuICAgICAgICB2YXIgdG9wID0gZmlyc3RSZWN0LnRvcDtcbiAgICAgICAgdmFyIGJvdHRvbSA9IGxhc3RSZWN0LmJvdHRvbTtcbiAgICAgICAgdmFyIGxlZnQgPSBpc1RvcCA/IGZpcnN0UmVjdC5sZWZ0IDogbGFzdFJlY3QubGVmdDtcbiAgICAgICAgdmFyIHJpZ2h0ID0gaXNUb3AgPyBmaXJzdFJlY3QucmlnaHQgOiBsYXN0UmVjdC5yaWdodDtcbiAgICAgICAgdmFyIHdpZHRoID0gcmlnaHQgLSBsZWZ0O1xuICAgICAgICB2YXIgaGVpZ2h0ID0gYm90dG9tIC0gdG9wO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHRvcDogdG9wLFxuICAgICAgICAgIGJvdHRvbTogYm90dG9tLFxuICAgICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgICAgcmlnaHQ6IHJpZ2h0LFxuICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgY2FzZSAnbGVmdCc6XG4gICAgY2FzZSAncmlnaHQnOlxuICAgICAge1xuICAgICAgICB2YXIgbWluTGVmdCA9IE1hdGgubWluLmFwcGx5KE1hdGgsIGNsaWVudFJlY3RzLm1hcChmdW5jdGlvbiAocmVjdHMpIHtcbiAgICAgICAgICByZXR1cm4gcmVjdHMubGVmdDtcbiAgICAgICAgfSkpO1xuICAgICAgICB2YXIgbWF4UmlnaHQgPSBNYXRoLm1heC5hcHBseShNYXRoLCBjbGllbnRSZWN0cy5tYXAoZnVuY3Rpb24gKHJlY3RzKSB7XG4gICAgICAgICAgcmV0dXJuIHJlY3RzLnJpZ2h0O1xuICAgICAgICB9KSk7XG4gICAgICAgIHZhciBtZWFzdXJlUmVjdHMgPSBjbGllbnRSZWN0cy5maWx0ZXIoZnVuY3Rpb24gKHJlY3QpIHtcbiAgICAgICAgICByZXR1cm4gY3VycmVudEJhc2VQbGFjZW1lbnQgPT09ICdsZWZ0JyA/IHJlY3QubGVmdCA9PT0gbWluTGVmdCA6IHJlY3QucmlnaHQgPT09IG1heFJpZ2h0O1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIF90b3AgPSBtZWFzdXJlUmVjdHNbMF0udG9wO1xuICAgICAgICB2YXIgX2JvdHRvbSA9IG1lYXN1cmVSZWN0c1ttZWFzdXJlUmVjdHMubGVuZ3RoIC0gMV0uYm90dG9tO1xuICAgICAgICB2YXIgX2xlZnQgPSBtaW5MZWZ0O1xuICAgICAgICB2YXIgX3JpZ2h0ID0gbWF4UmlnaHQ7XG5cbiAgICAgICAgdmFyIF93aWR0aCA9IF9yaWdodCAtIF9sZWZ0O1xuXG4gICAgICAgIHZhciBfaGVpZ2h0ID0gX2JvdHRvbSAtIF90b3A7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB0b3A6IF90b3AsXG4gICAgICAgICAgYm90dG9tOiBfYm90dG9tLFxuICAgICAgICAgIGxlZnQ6IF9sZWZ0LFxuICAgICAgICAgIHJpZ2h0OiBfcmlnaHQsXG4gICAgICAgICAgd2lkdGg6IF93aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IF9oZWlnaHRcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBib3VuZGluZ1JlY3Q7XG4gICAgICB9XG4gIH1cbn1cblxudmFyIHN0aWNreSA9IHtcbiAgbmFtZTogJ3N0aWNreScsXG4gIGRlZmF1bHRWYWx1ZTogZmFsc2UsXG4gIGZuOiBmdW5jdGlvbiBmbihpbnN0YW5jZSkge1xuICAgIHZhciByZWZlcmVuY2UgPSBpbnN0YW5jZS5yZWZlcmVuY2UsXG4gICAgICAgIHBvcHBlciA9IGluc3RhbmNlLnBvcHBlcjtcblxuICAgIGZ1bmN0aW9uIGdldFJlZmVyZW5jZSgpIHtcbiAgICAgIHJldHVybiBpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZSA/IGluc3RhbmNlLnBvcHBlckluc3RhbmNlLnN0YXRlLmVsZW1lbnRzLnJlZmVyZW5jZSA6IHJlZmVyZW5jZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzaG91bGRDaGVjayh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGluc3RhbmNlLnByb3BzLnN0aWNreSA9PT0gdHJ1ZSB8fCBpbnN0YW5jZS5wcm9wcy5zdGlja3kgPT09IHZhbHVlO1xuICAgIH1cblxuICAgIHZhciBwcmV2UmVmUmVjdCA9IG51bGw7XG4gICAgdmFyIHByZXZQb3BSZWN0ID0gbnVsbDtcblxuICAgIGZ1bmN0aW9uIHVwZGF0ZVBvc2l0aW9uKCkge1xuICAgICAgdmFyIGN1cnJlbnRSZWZSZWN0ID0gc2hvdWxkQ2hlY2soJ3JlZmVyZW5jZScpID8gZ2V0UmVmZXJlbmNlKCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOiBudWxsO1xuICAgICAgdmFyIGN1cnJlbnRQb3BSZWN0ID0gc2hvdWxkQ2hlY2soJ3BvcHBlcicpID8gcG9wcGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDogbnVsbDtcblxuICAgICAgaWYgKGN1cnJlbnRSZWZSZWN0ICYmIGFyZVJlY3RzRGlmZmVyZW50KHByZXZSZWZSZWN0LCBjdXJyZW50UmVmUmVjdCkgfHwgY3VycmVudFBvcFJlY3QgJiYgYXJlUmVjdHNEaWZmZXJlbnQocHJldlBvcFJlY3QsIGN1cnJlbnRQb3BSZWN0KSkge1xuICAgICAgICBpZiAoaW5zdGFuY2UucG9wcGVySW5zdGFuY2UpIHtcbiAgICAgICAgICBpbnN0YW5jZS5wb3BwZXJJbnN0YW5jZS51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwcmV2UmVmUmVjdCA9IGN1cnJlbnRSZWZSZWN0O1xuICAgICAgcHJldlBvcFJlY3QgPSBjdXJyZW50UG9wUmVjdDtcblxuICAgICAgaWYgKGluc3RhbmNlLnN0YXRlLmlzTW91bnRlZCkge1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodXBkYXRlUG9zaXRpb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBvbk1vdW50OiBmdW5jdGlvbiBvbk1vdW50KCkge1xuICAgICAgICBpZiAoaW5zdGFuY2UucHJvcHMuc3RpY2t5KSB7XG4gICAgICAgICAgdXBkYXRlUG9zaXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGFyZVJlY3RzRGlmZmVyZW50KHJlY3RBLCByZWN0Qikge1xuICBpZiAocmVjdEEgJiYgcmVjdEIpIHtcbiAgICByZXR1cm4gcmVjdEEudG9wICE9PSByZWN0Qi50b3AgfHwgcmVjdEEucmlnaHQgIT09IHJlY3RCLnJpZ2h0IHx8IHJlY3RBLmJvdHRvbSAhPT0gcmVjdEIuYm90dG9tIHx8IHJlY3RBLmxlZnQgIT09IHJlY3RCLmxlZnQ7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxudGlwcHkuc2V0RGVmYXVsdFByb3BzKHtcbiAgcmVuZGVyOiByZW5kZXJcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCB0aXBweTtcbmV4cG9ydCB7IGFuaW1hdGVGaWxsLCBjcmVhdGVTaW5nbGV0b24sIGRlbGVnYXRlLCBmb2xsb3dDdXJzb3IsIGhpZGVBbGwsIGlubGluZVBvc2l0aW9uaW5nLCBST1VORF9BUlJPVyBhcyByb3VuZEFycm93LCBzdGlja3kgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRpcHB5LmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tippy.js/dist/tippy.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/create/page.tsx":
/*!*********************************!*\
  !*** ./src/app/create/page.tsx ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ CreatePost; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var _barrel_optimize_names_AlertCircle_Calendar_CheckCircle_Eye_Image_Save_Tag_lucide_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! __barrel_optimize__?names=AlertCircle,Calendar,CheckCircle,Eye,Image,Save,Tag!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/eye.js\");\n/* harmony import */ var _barrel_optimize_names_AlertCircle_Calendar_CheckCircle_Eye_Image_Save_Tag_lucide_react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! __barrel_optimize__?names=AlertCircle,Calendar,CheckCircle,Eye,Image,Save,Tag!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/alert-circle.js\");\n/* harmony import */ var _barrel_optimize_names_AlertCircle_Calendar_CheckCircle_Eye_Image_Save_Tag_lucide_react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! __barrel_optimize__?names=AlertCircle,Calendar,CheckCircle,Eye,Image,Save,Tag!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/check-circle.js\");\n/* harmony import */ var _barrel_optimize_names_AlertCircle_Calendar_CheckCircle_Eye_Image_Save_Tag_lucide_react__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! __barrel_optimize__?names=AlertCircle,Calendar,CheckCircle,Eye,Image,Save,Tag!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/calendar.js\");\n/* harmony import */ var _barrel_optimize_names_AlertCircle_Calendar_CheckCircle_Eye_Image_Save_Tag_lucide_react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! __barrel_optimize__?names=AlertCircle,Calendar,CheckCircle,Eye,Image,Save,Tag!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/tag.js\");\n/* harmony import */ var _barrel_optimize_names_AlertCircle_Calendar_CheckCircle_Eye_Image_Save_Tag_lucide_react__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! __barrel_optimize__?names=AlertCircle,Calendar,CheckCircle,Eye,Image,Save,Tag!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/image.js\");\n/* harmony import */ var _barrel_optimize_names_AlertCircle_Calendar_CheckCircle_Eye_Image_Save_Tag_lucide_react__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! __barrel_optimize__?names=AlertCircle,Calendar,CheckCircle,Eye,Image,Save,Tag!=!lucide-react */ \"(app-pages-browser)/./node_modules/lucide-react/dist/esm/icons/save.js\");\n/* harmony import */ var _components_MarkdownEditor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @/components/MarkdownEditor */ \"(app-pages-browser)/./src/components/MarkdownEditor.tsx\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\nfunction CreatePost() {\n    _s();\n    const router = (0,next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter)();\n    const [formData, setFormData] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        title: \"\",\n        content: \"\",\n        tags: \"\",\n        featuredImage: \"\",\n        category: \"\",\n        published: false\n    });\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const [success, setSuccess] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const [showPreview, setShowPreview] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const categories = [\n        \"Technology\",\n        \"Lifestyle\",\n        \"Travel\",\n        \"Food\",\n        \"Business\",\n        \"Health\",\n        \"Education\",\n        \"Entertainment\"\n    ];\n    const handleChange = (e)=>{\n        const { name, value, type } = e.target;\n        setFormData((prev)=>({\n                ...prev,\n                [name]: type === \"checkbox\" ? e.target.checked : value\n            }));\n    };\n    const handleSubmit = async (e)=>{\n        e.preventDefault();\n        setLoading(true);\n        setError(\"\");\n        setSuccess(\"\");\n        try {\n            if (!formData.title.trim()) {\n                throw new Error(\"Title is required\");\n            }\n            if (!formData.content.trim()) {\n                throw new Error(\"Content is required\");\n            }\n            if (!formData.category) {\n                throw new Error(\"Please select a category\");\n            }\n            console.log(\"Creating post:\", formData);\n            const response = await fetch(\"/api/posts\", {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                },\n                body: JSON.stringify({\n                    title: formData.title,\n                    content: formData.content,\n                    tags: formData.tags,\n                    featuredImage: formData.featuredImage,\n                    category: formData.category,\n                    published: formData.published\n                })\n            });\n            if (!response.ok) {\n                const errorData = await response.json();\n                throw new Error(errorData.error || \"Failed to create post\");\n            }\n            const result = await response.json();\n            console.log(\"Post created:\", result);\n            setSuccess(formData.published ? \"Post published successfully!\" : \"Post saved as draft!\");\n            setTimeout(()=>{\n                router.push(\"/dashboard\");\n            }, 1500);\n        } catch (err) {\n            setError(err instanceof Error ? err.message : \"Error creating post\");\n        } finally{\n            setLoading(false);\n        }\n    };\n    const handleSaveDraft = ()=>{\n        setFormData((prev)=>({\n                ...prev,\n                published: false\n            }));\n        handleSubmit(new Event(\"submit\"));\n    };\n    const handlePublish = ()=>{\n        setFormData((prev)=>({\n                ...prev,\n                published: true\n            }));\n        handleSubmit(new Event(\"submit\"));\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"max-w-4xl mx-auto px-4 sm:px-6 lg:px-8 py-8\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n            className: \"card\",\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"flex items-center justify-between mb-8\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                            className: \"text-3xl font-bold text-gray-900\",\n                            children: \"Create New Post\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\app\\\\create\\\\page.tsx\",\n                            lineNumber: 111,\n                            columnNumber: 11\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"flex space-x-2\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                onClick: ()=>setShowPreview(!showPreview),\n                                className: \"btn-secondary flex items-center space-x-2\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_AlertCircle_Calendar_CheckCircle_Eye_Image_Save_Tag_lucide_react__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n                                        size: 16\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\app\\\\create\\\\page.tsx\",\n                                        lineNumber: 117,\n                                        columnNumber: 15\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                        children: showPreview ? \"Edit\" : \"Preview\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\app\\\\create\\\\page.tsx\",\n                                        lineNumber: 118,\n                                        columnNumber: 15\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\app\\\\create\\\\page.tsx\",\n                                lineNumber: 113,\n                                columnNumber: 13\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\app\\\\create\\\\page.tsx\",\n                            lineNumber: 112,\n                            columnNumber: 11\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\app\\\\create\\\\page.tsx\",\n                    lineNumber: 110,\n                    columnNumber: 9\n                }, this),\n                error && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"mb-6 p-4 bg-red-100 border border-red-400 text-red-700 rounded-lg flex items-center\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_AlertCircle_Calendar_CheckCircle_Eye_Image_Save_Tag_lucide_react__WEBPACK_IMPORTED_MODULE_5__[\"default\"], {\n                            size: 20\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\app\\\\create\\\\page.tsx\",\n                            lineNumber: 125,\n                            columnNumber: 13\n                        }, this),\n                        error\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\app\\\\create\\\\page.tsx\",\n                    lineNumber: 124,\n                    columnNumber: 11\n                }, this),\n                success && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"mb-6 p-4 bg-green-100 border border-green-400 text-green-700 rounded-lg flex items-center\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_AlertCircle_Calendar_CheckCircle_Eye_Image_Save_Tag_lucide_react__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {\n                            size: 20\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\app\\\\create\\\\page.tsx\",\n                            lineNumber: 132,\n                            columnNumber: 13\n                        }, this),\n                        success\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\app\\\\create\\\\page.tsx\",\n                    lineNumber: 131,\n                    columnNumber: 11\n                }, this),\n                showPreview ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"space-y-6\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"border-b pb-4\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                                    className: \"text-2xl font-bold text-gray-900 mb-2\",\n                                    children: formData.title || \"Untitled Post\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\app\\\\create\\\\page.tsx\",\n                                    lineNumber: 140,\n                                    columnNumber: 15\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                    className: \"flex items-center space-x-4 text-sm text-gray-500\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                            className: \"flex items-center\",\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_AlertCircle_Calendar_CheckCircle_Eye_Image_Save_Tag_lucide_react__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {\n                                                    size: 16\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\app\\\\create\\\\page.tsx\",\n                                                    lineNumber: 143,\n                                                    columnNumber: 19\n                                                }, this),\n                                                new Date().toLocaleDateString()\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\app\\\\create\\\\page.tsx\",\n                                            lineNumber: 142,\n                                            columnNumber: 17\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                            className: \"flex items-center\",\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_AlertCircle_Calendar_CheckCircle_Eye_Image_Save_Tag_lucide_react__WEBPACK_IMPORTED_MODULE_8__[\"default\"], {\n                                                    size: 16\n                                                }, void 0, false, {\n                                                    fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\app\\\\create\\\\page.tsx\",\n                                                    lineNumber: 147,\n                                                    columnNumber: 19\n                                                }, this),\n                                                formData.category || \"No category\"\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\app\\\\create\\\\page.tsx\",\n                                            lineNumber: 146,\n                                            columnNumber: 17\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\app\\\\create\\\\page.tsx\",\n                                    lineNumber: 141,\n                                    columnNumber: 15\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\app\\\\create\\\\page.tsx\",\n                            lineNumber: 139,\n                            columnNumber: 13\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"prose max-w-none\",\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"pre\", {\n                                className: \"whitespace-pre-wrap text-gray-700\",\n                                children: formData.content || \"No content yet...\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\app\\\\create\\\\page.tsx\",\n                                lineNumber: 153,\n                                columnNumber: 15\n                            }, this)\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\app\\\\create\\\\page.tsx\",\n                            lineNumber: 152,\n                            columnNumber: 13\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\app\\\\create\\\\page.tsx\",\n                    lineNumber: 138,\n                    columnNumber: 11\n                }, this) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"form\", {\n                    onSubmit: handleSubmit,\n                    className: \"space-y-6\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                    htmlFor: \"title\",\n                                    className: \"block text-sm font-medium text-gray-700 mb-2\",\n                                    children: \"Title *\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\app\\\\create\\\\page.tsx\",\n                                    lineNumber: 159,\n                                    columnNumber: 15\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                    type: \"text\",\n                                    id: \"title\",\n                                    name: \"title\",\n                                    value: formData.title,\n                                    onChange: handleChange,\n                                    required: true,\n                                    className: \"input-field\",\n                                    placeholder: \"Enter your post title...\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\app\\\\create\\\\page.tsx\",\n                                    lineNumber: 162,\n                                    columnNumber: 15\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\app\\\\create\\\\page.tsx\",\n                            lineNumber: 158,\n                            columnNumber: 13\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                    htmlFor: \"category\",\n                                    className: \"block text-sm font-medium text-gray-700 mb-2\",\n                                    children: \"Category *\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\app\\\\create\\\\page.tsx\",\n                                    lineNumber: 175,\n                                    columnNumber: 15\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"select\", {\n                                    id: \"category\",\n                                    name: \"category\",\n                                    value: formData.category,\n                                    onChange: handleChange,\n                                    required: true,\n                                    className: \"input-field\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                            value: \"\",\n                                            children: \"Select a category\"\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\app\\\\create\\\\page.tsx\",\n                                            lineNumber: 186,\n                                            columnNumber: 17\n                                        }, this),\n                                        categories.map((category)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                                value: category,\n                                                children: category\n                                            }, category, false, {\n                                                fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\app\\\\create\\\\page.tsx\",\n                                                lineNumber: 188,\n                                                columnNumber: 19\n                                            }, this))\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\app\\\\create\\\\page.tsx\",\n                                    lineNumber: 178,\n                                    columnNumber: 15\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\app\\\\create\\\\page.tsx\",\n                            lineNumber: 174,\n                            columnNumber: 13\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                    htmlFor: \"featuredImage\",\n                                    className: \"block text-sm font-medium text-gray-700 mb-2\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_AlertCircle_Calendar_CheckCircle_Eye_Image_Save_Tag_lucide_react__WEBPACK_IMPORTED_MODULE_9__[\"default\"], {\n                                            size: 16\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\app\\\\create\\\\page.tsx\",\n                                            lineNumber: 197,\n                                            columnNumber: 17\n                                        }, this),\n                                        \"Featured Image URL\"\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\app\\\\create\\\\page.tsx\",\n                                    lineNumber: 196,\n                                    columnNumber: 15\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                    type: \"url\",\n                                    id: \"featuredImage\",\n                                    name: \"featuredImage\",\n                                    value: formData.featuredImage,\n                                    onChange: handleChange,\n                                    className: \"input-field\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\app\\\\create\\\\page.tsx\",\n                                    lineNumber: 200,\n                                    columnNumber: 15\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\app\\\\create\\\\page.tsx\",\n                            lineNumber: 195,\n                            columnNumber: 13\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                    htmlFor: \"tags\",\n                                    className: \"block text-sm font-medium text-gray-700 mb-2\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_AlertCircle_Calendar_CheckCircle_Eye_Image_Save_Tag_lucide_react__WEBPACK_IMPORTED_MODULE_8__[\"default\"], {\n                                            size: 16\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\app\\\\create\\\\page.tsx\",\n                                            lineNumber: 212,\n                                            columnNumber: 17\n                                        }, this),\n                                        \"Tags\"\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\app\\\\create\\\\page.tsx\",\n                                    lineNumber: 211,\n                                    columnNumber: 15\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                    type: \"text\",\n                                    id: \"tags\",\n                                    name: \"tags\",\n                                    value: formData.tags,\n                                    onChange: handleChange,\n                                    className: \"input-field\",\n                                    placeholder: \"react, javascript, web-development (comma separated)\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\app\\\\create\\\\page.tsx\",\n                                    lineNumber: 215,\n                                    columnNumber: 15\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                    className: \"mt-1 text-sm text-gray-500\",\n                                    children: \"Separate tags with commas\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\app\\\\create\\\\page.tsx\",\n                                    lineNumber: 224,\n                                    columnNumber: 15\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\app\\\\create\\\\page.tsx\",\n                            lineNumber: 210,\n                            columnNumber: 13\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                    htmlFor: \"content\",\n                                    className: \"block text-sm font-medium text-gray-700 mb-2\",\n                                    children: \"Content * (Rich Text Editor)\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\app\\\\create\\\\page.tsx\",\n                                    lineNumber: 230,\n                                    columnNumber: 15\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_MarkdownEditor__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                                    content: formData.content,\n                                    onChange: (content)=>setFormData((prev)=>({\n                                                ...prev,\n                                                content\n                                            })),\n                                    placeholder: \"Write your post content here... Use the toolbar above to format your text.\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\app\\\\create\\\\page.tsx\",\n                                    lineNumber: 233,\n                                    columnNumber: 15\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                    className: \"mt-1 text-sm text-gray-500\",\n                                    children: \"Use the toolbar above to format your text with headings, lists, quotes, and more.\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\app\\\\create\\\\page.tsx\",\n                                    lineNumber: 238,\n                                    columnNumber: 15\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\app\\\\create\\\\page.tsx\",\n                            lineNumber: 229,\n                            columnNumber: 13\n                        }, this),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-4 pt-6 border-t\",\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    type: \"button\",\n                                    onClick: handleSaveDraft,\n                                    disabled: loading,\n                                    className: \"btn-secondary disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center space-x-2\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_AlertCircle_Calendar_CheckCircle_Eye_Image_Save_Tag_lucide_react__WEBPACK_IMPORTED_MODULE_10__[\"default\"], {\n                                            size: 16\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\app\\\\create\\\\page.tsx\",\n                                            lineNumber: 250,\n                                            columnNumber: 17\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                            children: loading ? \"Saving...\" : \"Save as Draft\"\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\app\\\\create\\\\page.tsx\",\n                                            lineNumber: 251,\n                                            columnNumber: 17\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\app\\\\create\\\\page.tsx\",\n                                    lineNumber: 244,\n                                    columnNumber: 15\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    type: \"button\",\n                                    onClick: handlePublish,\n                                    disabled: loading,\n                                    className: \"btn-primary disabled:opacity-50 disabled:cursor-not-allowed flex items-center justify-center space-x-2\",\n                                    children: [\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_barrel_optimize_names_AlertCircle_Calendar_CheckCircle_Eye_Image_Save_Tag_lucide_react__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {\n                                            size: 16\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\app\\\\create\\\\page.tsx\",\n                                            lineNumber: 260,\n                                            columnNumber: 17\n                                        }, this),\n                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                            children: loading ? \"Publishing...\" : \"Publish Now\"\n                                        }, void 0, false, {\n                                            fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\app\\\\create\\\\page.tsx\",\n                                            lineNumber: 261,\n                                            columnNumber: 17\n                                        }, this)\n                                    ]\n                                }, void 0, true, {\n                                    fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\app\\\\create\\\\page.tsx\",\n                                    lineNumber: 254,\n                                    columnNumber: 15\n                                }, this),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                    type: \"button\",\n                                    onClick: ()=>router.push(\"/dashboard\"),\n                                    className: \"btn-secondary\",\n                                    children: \"Cancel\"\n                                }, void 0, false, {\n                                    fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\app\\\\create\\\\page.tsx\",\n                                    lineNumber: 264,\n                                    columnNumber: 15\n                                }, this)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\app\\\\create\\\\page.tsx\",\n                            lineNumber: 243,\n                            columnNumber: 13\n                        }, this)\n                    ]\n                }, void 0, true, {\n                    fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\app\\\\create\\\\page.tsx\",\n                    lineNumber: 157,\n                    columnNumber: 11\n                }, this)\n            ]\n        }, void 0, true, {\n            fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\app\\\\create\\\\page.tsx\",\n            lineNumber: 109,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\app\\\\create\\\\page.tsx\",\n        lineNumber: 108,\n        columnNumber: 5\n    }, this);\n}\n_s(CreatePost, \"eZv8M7cpSEWOjzSKchsRmMbA7eM=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_2__.useRouter\n    ];\n});\n_c = CreatePost;\nvar _c;\n$RefreshReg$(_c, \"CreatePost\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvY3JlYXRlL3BhZ2UudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUVnQztBQUNXO0FBQzZDO0FBQ2hDO0FBRXpDLFNBQVNVOztJQUN0QixNQUFNQyxTQUFTViwwREFBU0E7SUFDeEIsTUFBTSxDQUFDVyxVQUFVQyxZQUFZLEdBQUdiLCtDQUFRQSxDQUFDO1FBQ3ZDYyxPQUFPO1FBQ1BDLFNBQVM7UUFDVEMsTUFBTTtRQUNOQyxlQUFlO1FBQ2ZDLFVBQVU7UUFDVkMsV0FBVztJQUNiO0lBQ0EsTUFBTSxDQUFDQyxTQUFTQyxXQUFXLEdBQUdyQiwrQ0FBUUEsQ0FBQztJQUN2QyxNQUFNLENBQUNzQixPQUFPQyxTQUFTLEdBQUd2QiwrQ0FBUUEsQ0FBQztJQUNuQyxNQUFNLENBQUN3QixTQUFTQyxXQUFXLEdBQUd6QiwrQ0FBUUEsQ0FBQztJQUN2QyxNQUFNLENBQUMwQixhQUFhQyxlQUFlLEdBQUczQiwrQ0FBUUEsQ0FBQztJQUUvQyxNQUFNNEIsYUFBYTtRQUNqQjtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO0tBQ0Q7SUFFRCxNQUFNQyxlQUFlLENBQUNDO1FBQ3BCLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxLQUFLLEVBQUVDLElBQUksRUFBRSxHQUFHSCxFQUFFSSxNQUFNO1FBQ3RDckIsWUFBWXNCLENBQUFBLE9BQVM7Z0JBQ25CLEdBQUdBLElBQUk7Z0JBQ1AsQ0FBQ0osS0FBSyxFQUFFRSxTQUFTLGFBQWEsRUFBR0MsTUFBTSxDQUFzQkUsT0FBTyxHQUFHSjtZQUN6RTtJQUNGO0lBRUEsTUFBTUssZUFBZSxPQUFPUDtRQUMxQkEsRUFBRVEsY0FBYztRQUNoQmpCLFdBQVc7UUFDWEUsU0FBUztRQUNURSxXQUFXO1FBRVgsSUFBSTtZQUNGLElBQUksQ0FBQ2IsU0FBU0UsS0FBSyxDQUFDeUIsSUFBSSxJQUFJO2dCQUMxQixNQUFNLElBQUlDLE1BQU07WUFDbEI7WUFDQSxJ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SUFBTXRELE9BQU80QyxJQUFJLENBQUM7b0NBQzNCTyxXQUFVOzhDQUNYOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQVNmO0dBN1F3QnBEOztRQUNQVCxzREFBU0E7OztLQURGUyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvYXBwL2NyZWF0ZS9wYWdlLnRzeD81YWRiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xyXG5cclxuaW1wb3J0IHsgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCdcclxuaW1wb3J0IHsgdXNlUm91dGVyIH0gZnJvbSAnbmV4dC9uYXZpZ2F0aW9uJ1xyXG5pbXBvcnQgeyBTYXZlLCBFeWUsIENhbGVuZGFyLCBUYWcsIEltYWdlLCBBbGVydENpcmNsZSwgQ2hlY2tDaXJjbGUgfSBmcm9tICdsdWNpZGUtcmVhY3QnXHJcbmltcG9ydCBNYXJrZG93bkVkaXRvciBmcm9tICdAL2NvbXBvbmVudHMvTWFya2Rvd25FZGl0b3InXHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDcmVhdGVQb3N0KCkge1xyXG4gIGNvbnN0IHJvdXRlciA9IHVzZVJvdXRlcigpXHJcbiAgY29uc3QgW2Zvcm1EYXRhLCBzZXRGb3JtRGF0YV0gPSB1c2VTdGF0ZSh7XHJcbiAgICB0aXRsZTogJycsXHJcbiAgICBjb250ZW50OiAnJyxcclxuICAgIHRhZ3M6ICcnLFxyXG4gICAgZmVhdHVyZWRJbWFnZTogJycsXHJcbiAgICBjYXRlZ29yeTogJycsXHJcbiAgICBwdWJsaXNoZWQ6IGZhbHNlXHJcbiAgfSlcclxuICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSB1c2VTdGF0ZShmYWxzZSlcclxuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlKCcnKVxyXG4gIGNvbnN0IFtzdWNjZXNzLCBzZXRTdWNjZXNzXSA9IHVzZVN0YXRlKCcnKVxyXG4gIGNvbnN0IFtzaG93UHJldmlldywgc2V0U2hvd1ByZXZpZXddID0gdXNlU3RhdGUoZmFsc2UpXHJcblxyXG4gIGNvbnN0IGNhdGVnb3JpZXMgPSBbXHJcbiAgICAnVGVjaG5vbG9neScsXHJcbiAgICAnTGlmZXN0eWxlJywgXHJcbiAgICAnVHJhdmVsJyxcclxuICAgICdGb29kJyxcclxuICAgICdCdXNpbmVzcycsXHJcbiAgICAnSGVhbHRoJyxcclxuICAgICdFZHVjYXRpb24nLFxyXG4gICAgJ0VudGVydGFpbm1lbnQnXHJcbiAgXVxyXG5cclxuICBjb25zdCBoYW5kbGVDaGFuZ2UgPSAoZTogUmVhY3QuQ2hhbmdlRXZlbnQ8SFRNTElucHV0RWxlbWVudCB8IEhUTUxUZXh0QXJlYUVsZW1lbnQgfCBIVE1MU2VsZWN0RWxlbWVudD4pID0+IHtcclxuICAgIGNvbnN0IHsgbmFtZSwgdmFsdWUsIHR5cGUgfSA9IGUudGFyZ2V0XHJcbiAgICBzZXRGb3JtRGF0YShwcmV2ID0+ICh7XHJcbiAgICAgIC4uLnByZXYsXHJcbiAgICAgIFtuYW1lXTogdHlwZSA9PT0gJ2NoZWNrYm94JyA/IChlLnRhcmdldCBhcyBIVE1MSW5wdXRFbGVtZW50KS5jaGVja2VkIDogdmFsdWVcclxuICAgIH0pKVxyXG4gIH1cclxuXHJcbiAgY29uc3QgaGFuZGxlU3VibWl0ID0gYXN5bmMgKGU6IFJlYWN0LkZvcm1FdmVudCkgPT4ge1xyXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXHJcbiAgICBzZXRMb2FkaW5nKHRydWUpXHJcbiAgICBzZXRFcnJvcignJylcclxuICAgIHNldFN1Y2Nlc3MoJycpXHJcblxyXG4gICAgdHJ5IHtcclxuICAgICAgaWYgKCFmb3JtRGF0YS50aXRsZS50cmltKCkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RpdGxlIGlzIHJlcXVpcmVkJylcclxuICAgICAgfVxyXG4gICAgICBpZiAoIWZvcm1EYXRhLmNvbnRlbnQudHJpbSgpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb250ZW50IGlzIHJlcXVpcmVkJylcclxuICAgICAgfVxyXG4gICAgICBpZiAoIWZvcm1EYXRhLmNhdGVnb3J5KSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2Ugc2VsZWN0IGEgY2F0ZWdvcnknKVxyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zb2xlLmxvZygnQ3JlYXRpbmcgcG9zdDonLCBmb3JtRGF0YSlcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJy9hcGkvcG9zdHMnLCB7XHJcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcclxuICAgICAgICAgIHRpdGxlOiBmb3JtRGF0YS50aXRsZSxcclxuICAgICAgICAgIGNvbnRlbnQ6IGZvcm1EYXRhLmNvbnRlbnQsXHJcbiAgICAgICAgICB0YWdzOiBmb3JtRGF0YS50YWdzLFxyXG4gICAgICAgICAgZmVhdHVyZWRJbWFnZTogZm9ybURhdGEuZmVhdHVyZWRJbWFnZSxcclxuICAgICAgICAgIGNhdGVnb3J5OiBmb3JtRGF0YS5jYXRlZ29yeSxcclxuICAgICAgICAgIHB1Ymxpc2hlZDogZm9ybURhdGEucHVibGlzaGVkLFxyXG4gICAgICAgIH0pLFxyXG4gICAgICB9KVxyXG5cclxuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEuZXJyb3IgfHwgJ0ZhaWxlZCB0byBjcmVhdGUgcG9zdCcpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxyXG4gICAgICBjb25zb2xlLmxvZygnUG9zdCBjcmVhdGVkOicsIHJlc3VsdClcclxuICAgICAgXHJcbiAgICAgIHNldFN1Y2Nlc3MoZm9ybURhdGEucHVibGlzaGVkID8gJ1Bvc3QgcHVibGlzaGVkIHN1Y2Nlc3NmdWxseSEnIDogJ1Bvc3Qgc2F2ZWQgYXMgZHJhZnQhJylcclxuICAgICAgXHJcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgIHJvdXRlci5wdXNoKCcvZGFzaGJvYXJkJylcclxuICAgICAgfSwgMTUwMClcclxuICAgICAgXHJcbiAgICB9IGNhdGNoIChlcnIpIHtcclxuICAgICAgc2V0RXJyb3IoZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6ICdFcnJvciBjcmVhdGluZyBwb3N0JylcclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgIHNldExvYWRpbmcoZmFsc2UpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBjb25zdCBoYW5kbGVTYXZlRHJhZnQgPSAoKSA9PiB7XHJcbiAgICBzZXRGb3JtRGF0YShwcmV2ID0+ICh7IC4uLnByZXYsIHB1Ymxpc2hlZDogZmFsc2UgfSkpXHJcbiAgICBoYW5kbGVTdWJtaXQobmV3IEV2ZW50KCdzdWJtaXQnKSBhcyBhbnkpXHJcbiAgfVxyXG5cclxuICBjb25zdCBoYW5kbGVQdWJsaXNoID0gKCkgPT4ge1xyXG4gICAgc2V0Rm9ybURhdGEocHJldiA9PiAoeyAuLi5wcmV2LCBwdWJsaXNoZWQ6IHRydWUgfSkpXHJcbiAgICBoYW5kbGVTdWJtaXQobmV3IEV2ZW50KCdzdWJtaXQnKSBhcyBhbnkpXHJcbiAgfVxyXG5cclxuICByZXR1cm4gKFxyXG4gICAgPGRpdiBjbGFzc05hbWU9XCJtYXgtdy00eGwgbXgtYXV0byBweC00IHNtOnB4LTYgbGc6cHgtOCBweS04XCI+XHJcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY2FyZFwiPlxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1iZXR3ZWVuIG1iLThcIj5cclxuICAgICAgICAgIDxoMSBjbGFzc05hbWU9XCJ0ZXh0LTN4bCBmb250LWJvbGQgdGV4dC1ncmF5LTkwMFwiPkNyZWF0ZSBOZXcgUG9zdDwvaDE+XHJcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImZsZXggc3BhY2UteC0yXCI+XHJcbiAgICAgICAgICAgIDxidXR0b25cclxuICAgICAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRTaG93UHJldmlldyghc2hvd1ByZXZpZXcpfVxyXG4gICAgICAgICAgICAgIGNsYXNzTmFtZT1cImJ0bi1zZWNvbmRhcnkgZmxleCBpdGVtcy1jZW50ZXIgc3BhY2UteC0yXCJcclxuICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgIDxFeWUgc2l6ZT17MTZ9IC8+XHJcbiAgICAgICAgICAgICAgPHNwYW4+e3Nob3dQcmV2aWV3ID8gJ0VkaXQnIDogJ1ByZXZpZXcnfTwvc3Bhbj5cclxuICAgICAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgICAgICBcclxuICAgICAgICB7ZXJyb3IgJiYgKFxyXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJtYi02IHAtNCBiZy1yZWQtMTAwIGJvcmRlciBib3JkZXItcmVkLTQwMCB0ZXh0LXJlZC03MDAgcm91bmRlZC1sZyBmbGV4IGl0ZW1zLWNlbnRlclwiPlxyXG4gICAgICAgICAgICA8QWxlcnRDaXJjbGUgc2l6ZT17MjB9IC8+XHJcbiAgICAgICAgICAgIHtlcnJvcn1cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICl9XHJcblxyXG4gICAgICAgIHtzdWNjZXNzICYmIChcclxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibWItNiBwLTQgYmctZ3JlZW4tMTAwIGJvcmRlciBib3JkZXItZ3JlZW4tNDAwIHRleHQtZ3JlZW4tNzAwIHJvdW5kZWQtbGcgZmxleCBpdGVtcy1jZW50ZXJcIj5cclxuICAgICAgICAgICAgPENoZWNrQ2lyY2xlIHNpemU9ezIwfSAvPlxyXG4gICAgICAgICAgICB7c3VjY2Vzc31cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICl9XHJcblxyXG4gICAgICAgIHtzaG93UHJldmlldyA/IChcclxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic3BhY2UteS02XCI+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYm9yZGVyLWIgcGItNFwiPlxyXG4gICAgICAgICAgICAgIDxoMiBjbGFzc05hbWU9XCJ0ZXh0LTJ4bCBmb250LWJvbGQgdGV4dC1ncmF5LTkwMCBtYi0yXCI+e2Zvcm1EYXRhLnRpdGxlIHx8ICdVbnRpdGxlZCBQb3N0J308L2gyPlxyXG4gICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIgc3BhY2UteC00IHRleHQtc20gdGV4dC1ncmF5LTUwMFwiPlxyXG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXJcIj5cclxuICAgICAgICAgICAgICAgICAgPENhbGVuZGFyIHNpemU9ezE2fSAvPlxyXG4gICAgICAgICAgICAgICAgICB7bmV3IERhdGUoKS50b0xvY2FsZURhdGVTdHJpbmcoKX1cclxuICAgICAgICAgICAgICAgIDwvc3Bhbj5cclxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyXCI+XHJcbiAgICAgICAgICAgICAgICAgIDxUYWcgc2l6ZT17MTZ9IC8+XHJcbiAgICAgICAgICAgICAgICAgIHtmb3JtRGF0YS5jYXRlZ29yeSB8fCAnTm8gY2F0ZWdvcnknfVxyXG4gICAgICAgICAgICAgICAgPC9zcGFuPlxyXG4gICAgICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJwcm9zZSBtYXgtdy1ub25lXCI+XHJcbiAgICAgICAgICAgICAgPHByZSBjbGFzc05hbWU9XCJ3aGl0ZXNwYWNlLXByZS13cmFwIHRleHQtZ3JheS03MDBcIj57Zm9ybURhdGEuY29udGVudCB8fCAnTm8gY29udGVudCB5ZXQuLi4nfTwvcHJlPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICAgICkgOiAoXHJcbiAgICAgICAgICA8Zm9ybSBvblN1Ym1pdD17aGFuZGxlU3VibWl0fSBjbGFzc05hbWU9XCJzcGFjZS15LTZcIj5cclxuICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICA8bGFiZWwgaHRtbEZvcj1cInRpdGxlXCIgY2xhc3NOYW1lPVwiYmxvY2sgdGV4dC1zbSBmb250LW1lZGl1bSB0ZXh0LWdyYXktNzAwIG1iLTJcIj5cclxuICAgICAgICAgICAgICAgIFRpdGxlICpcclxuICAgICAgICAgICAgICA8L2xhYmVsPlxyXG4gICAgICAgICAgICAgIDxpbnB1dFxyXG4gICAgICAgICAgICAgICAgdHlwZT1cInRleHRcIlxyXG4gICAgICAgICAgICAgICAgaWQ9XCJ0aXRsZVwiXHJcbiAgICAgICAgICAgICAgICBuYW1lPVwidGl0bGVcIlxyXG4gICAgICAgICAgICAgICAgdmFsdWU9e2Zvcm1EYXRhLnRpdGxlfVxyXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX1cclxuICAgICAgICAgICAgICAgIHJlcXVpcmVkXHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJpbnB1dC1maWVsZFwiXHJcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIkVudGVyIHlvdXIgcG9zdCB0aXRsZS4uLlwiXHJcbiAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgICAgIDxsYWJlbCBodG1sRm9yPVwiY2F0ZWdvcnlcIiBjbGFzc05hbWU9XCJibG9jayB0ZXh0LXNtIGZvbnQtbWVkaXVtIHRleHQtZ3JheS03MDAgbWItMlwiPlxyXG4gICAgICAgICAgICAgICAgQ2F0ZWdvcnkgKlxyXG4gICAgICAgICAgICAgIDwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgPHNlbGVjdFxyXG4gICAgICAgICAgICAgICAgaWQ9XCJjYXRlZ29yeVwiXHJcbiAgICAgICAgICAgICAgICBuYW1lPVwiY2F0ZWdvcnlcIlxyXG4gICAgICAgICAgICAgICAgdmFsdWU9e2Zvcm1EYXRhLmNhdGVnb3J5fVxyXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX1cclxuICAgICAgICAgICAgICAgIHJlcXVpcmVkXHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJpbnB1dC1maWVsZFwiXHJcbiAgICAgICAgICAgICAgPlxyXG4gICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIlwiPlNlbGVjdCBhIGNhdGVnb3J5PC9vcHRpb24+XHJcbiAgICAgICAgICAgICAgICB7Y2F0ZWdvcmllcy5tYXAoKGNhdGVnb3J5KSA9PiAoXHJcbiAgICAgICAgICAgICAgICAgIDxvcHRpb24ga2V5PXtjYXRlZ29yeX0gdmFsdWU9e2NhdGVnb3J5fT5cclxuICAgICAgICAgICAgICAgICAgICB7Y2F0ZWdvcnl9XHJcbiAgICAgICAgICAgICAgICAgIDwvb3B0aW9uPlxyXG4gICAgICAgICAgICAgICAgKSl9XHJcbiAgICAgICAgICAgICAgPC9zZWxlY3Q+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICA8bGFiZWwgaHRtbEZvcj1cImZlYXR1cmVkSW1hZ2VcIiBjbGFzc05hbWU9XCJibG9jayB0ZXh0LXNtIGZvbnQtbWVkaXVtIHRleHQtZ3JheS03MDAgbWItMlwiPlxyXG4gICAgICAgICAgICAgICAgPEltYWdlIHNpemU9ezE2fSAvPlxyXG4gICAgICAgICAgICAgICAgRmVhdHVyZWQgSW1hZ2UgVVJMXHJcbiAgICAgICAgICAgICAgPC9sYWJlbD5cclxuICAgICAgICAgICAgICA8aW5wdXRcclxuICAgICAgICAgICAgICAgIHR5cGU9XCJ1cmxcIlxyXG4gICAgICAgICAgICAgICAgaWQ9XCJmZWF0dXJlZEltYWdlXCJcclxuICAgICAgICAgICAgICAgIG5hbWU9XCJmZWF0dXJlZEltYWdlXCJcclxuICAgICAgICAgICAgICAgIHZhbHVlPXtmb3JtRGF0YS5mZWF0dXJlZEltYWdlfVxyXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U9e2hhbmRsZUNoYW5nZX1cclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImlucHV0LWZpZWxkXCJcclxuICAgICAgICAgICAgICAvPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgIDxkaXY+XHJcbiAgICAgICAgICAgICAgPGxhYmVsIGh0bWxGb3I9XCJ0YWdzXCIgY2xhc3NOYW1lPVwiYmxvY2sgdGV4dC1zbSBmb250LW1lZGl1bSB0ZXh0LWdyYXktNzAwIG1iLTJcIj5cclxuICAgICAgICAgICAgICAgIDxUYWcgc2l6ZT17MTZ9IC8+XHJcbiAgICAgICAgICAgICAgICBUYWdzXHJcbiAgICAgICAgICAgICAgPC9sYWJlbD5cclxuICAgICAgICAgICAgICA8aW5wdXRcclxuICAgICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcclxuICAgICAgICAgICAgICAgIGlkPVwidGFnc1wiXHJcbiAgICAgICAgICAgICAgICBuYW1lPVwidGFnc1wiXHJcbiAgICAgICAgICAgICAgICB2YWx1ZT17Zm9ybURhdGEudGFnc31cclxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtoYW5kbGVDaGFuZ2V9XHJcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJpbnB1dC1maWVsZFwiXHJcbiAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cInJlYWN0LCBqYXZhc2NyaXB0LCB3ZWItZGV2ZWxvcG1lbnQgKGNvbW1hIHNlcGFyYXRlZClcIlxyXG4gICAgICAgICAgICAgIC8+XHJcbiAgICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwibXQtMSB0ZXh0LXNtIHRleHQtZ3JheS01MDBcIj5cclxuICAgICAgICAgICAgICAgIFNlcGFyYXRlIHRhZ3Mgd2l0aCBjb21tYXNcclxuICAgICAgICAgICAgICA8L3A+XHJcbiAgICAgICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICA8bGFiZWwgaHRtbEZvcj1cImNvbnRlbnRcIiBjbGFzc05hbWU9XCJibG9jayB0ZXh0LXNtIGZvbnQtbWVkaXVtIHRleHQtZ3JheS03MDAgbWItMlwiPlxyXG4gICAgICAgICAgICAgICAgQ29udGVudCAqIChSaWNoIFRleHQgRWRpdG9yKVxyXG4gICAgICAgICAgICAgIDwvbGFiZWw+XHJcbiAgICAgICAgICAgICAgPE1hcmtkb3duRWRpdG9yXHJcbiAgICAgICAgICAgICAgICBjb250ZW50PXtmb3JtRGF0YS5jb250ZW50fVxyXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U9eyhjb250ZW50KSA9PiBzZXRGb3JtRGF0YShwcmV2ID0+ICh7IC4uLnByZXYsIGNvbnRlbnQgfSkpfVxyXG4gICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI9XCJXcml0ZSB5b3VyIHBvc3QgY29udGVudCBoZXJlLi4uIFVzZSB0aGUgdG9vbGJhciBhYm92ZSB0byBmb3JtYXQgeW91ciB0ZXh0LlwiXHJcbiAgICAgICAgICAgICAgLz5cclxuICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJtdC0xIHRleHQtc20gdGV4dC1ncmF5LTUwMFwiPlxyXG4gICAgICAgICAgICAgICAgVXNlIHRoZSB0b29sYmFyIGFib3ZlIHRvIGZvcm1hdCB5b3VyIHRleHQgd2l0aCBoZWFkaW5ncywgbGlzdHMsIHF1b3RlcywgYW5kIG1vcmUuXHJcbiAgICAgICAgICAgICAgPC9wPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBzbTpmbGV4LXJvdyBzcGFjZS15LTIgc206c3BhY2UteS0wIHNtOnNwYWNlLXgtNCBwdC02IGJvcmRlci10XCI+XHJcbiAgICAgICAgICAgICAgPGJ1dHRvblxyXG4gICAgICAgICAgICAgICAgdHlwZT1cImJ1dHRvblwiXHJcbiAgICAgICAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVTYXZlRHJhZnR9XHJcbiAgICAgICAgICAgICAgICBkaXNhYmxlZD17bG9hZGluZ31cclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImJ0bi1zZWNvbmRhcnkgZGlzYWJsZWQ6b3BhY2l0eS01MCBkaXNhYmxlZDpjdXJzb3Itbm90LWFsbG93ZWQgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgc3BhY2UteC0yXCJcclxuICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICA8U2F2ZSBzaXplPXsxNn0gLz5cclxuICAgICAgICAgICAgICAgIDxzcGFuPntsb2FkaW5nID8gJ1NhdmluZy4uLicgOiAnU2F2ZSBhcyBEcmFmdCd9PC9zcGFuPlxyXG4gICAgICAgICAgICAgIDwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIDxidXR0b25cclxuICAgICAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxyXG4gICAgICAgICAgICAgICAgb25DbGljaz17aGFuZGxlUHVibGlzaH1cclxuICAgICAgICAgICAgICAgIGRpc2FibGVkPXtsb2FkaW5nfVxyXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwiYnRuLXByaW1hcnkgZGlzYWJsZWQ6b3BhY2l0eS01MCBkaXNhYmxlZDpjdXJzb3Itbm90LWFsbG93ZWQgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgc3BhY2UteC0yXCJcclxuICAgICAgICAgICAgICA+XHJcbiAgICAgICAgICAgICAgICA8Q2FsZW5kYXIgc2l6ZT17MTZ9IC8+XHJcbiAgICAgICAgICAgICAgICA8c3Bhbj57bG9hZGluZyA/ICdQdWJsaXNoaW5nLi4uJyA6ICdQdWJsaXNoIE5vdyd9PC9zcGFuPlxyXG4gICAgICAgICAgICAgIDwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIDxidXR0b25cclxuICAgICAgICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxyXG4gICAgICAgICAgICAgICAgb25DbGljaz17KCkgPT4gcm91dGVyLnB1c2goJy9kYXNoYm9hcmQnKX1cclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cImJ0bi1zZWNvbmRhcnlcIlxyXG4gICAgICAgICAgICAgID5cclxuICAgICAgICAgICAgICAgIENhbmNlbFxyXG4gICAgICAgICAgICAgIDwvYnV0dG9uPlxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgIDwvZm9ybT5cclxuICAgICAgICApfVxyXG4gICAgICA8L2Rpdj5cclxuICAgIDwvZGl2PlxyXG4gIClcclxufVxyXG4iXSwibmFtZXMiOlsidXNlU3RhdGUiLCJ1c2VSb3V0ZXIiLCJTYXZlIiwiRXllIiwiQ2FsZW5kYXIiLCJUYWciLCJJbWFnZSIsIkFsZXJ0Q2lyY2xlIiwiQ2hlY2tDaXJjbGUiLCJNYXJrZG93bkVkaXRvciIsIkNyZWF0ZVBvc3QiLCJyb3V0ZXIiLCJmb3JtRGF0YSIsInNldEZvcm1EYXRhIiwidGl0bGUiLCJjb250ZW50IiwidGFncyIsImZlYXR1cmVkSW1hZ2UiLCJjYXRlZ29yeSIsInB1Ymxpc2hlZCIsImxvYWRpbmciLCJzZXRMb2FkaW5nIiwiZXJyb3IiLCJzZXRFcnJvciIsInN1Y2Nlc3MiLCJzZXRTdWNjZXNzIiwic2hvd1ByZXZpZXciLCJzZXRTaG93UHJldmlldyIsImNhdGVnb3JpZXMiLCJoYW5kbGVDaGFuZ2UiLCJlIiwibmFtZSIsInZhbHVlIiwidHlwZSIsInRhcmdldCIsInByZXYiLCJjaGVja2VkIiwiaGFuZGxlU3VibWl0IiwicHJldmVudERlZmF1bHQiLCJ0cmltIiwiRXJyb3IiLCJjb25zb2xlIiwibG9nIiwicmVzcG9uc2UiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsIm9rIiwiZXJyb3JEYXRhIiwianNvbiIsInJlc3VsdCIsInNldFRpbWVvdXQiLCJwdXNoIiwiZXJyIiwibWVzc2FnZSIsImhhbmRsZVNhdmVEcmFmdCIsIkV2ZW50IiwiaGFuZGxlUHVibGlzaCIsImRpdiIsImNsYXNzTmFtZSIsImgxIiwiYnV0dG9uIiwib25DbGljayIsInNpemUiLCJzcGFuIiwiaDIiLCJEYXRlIiwidG9Mb2NhbGVEYXRlU3RyaW5nIiwicHJlIiwiZm9ybSIsIm9uU3VibWl0IiwibGFiZWwiLCJodG1sRm9yIiwiaW5wdXQiLCJpZCIsIm9uQ2hhbmdlIiwicmVxdWlyZWQiLCJwbGFjZWhvbGRlciIsInNlbGVjdCIsIm9wdGlvbiIsIm1hcCIsInAiLCJkaXNhYmxlZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/create/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/components/MarkdownEditor.tsx":
/*!*******************************************!*\
  !*** ./src/components/MarkdownEditor.tsx ***!
  \*******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ MarkdownEditor; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _tiptap_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/react */ \"(app-pages-browser)/./node_modules/@tiptap/react/dist/index.js\");\n/* harmony import */ var _tiptap_starter_kit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/starter-kit */ \"(app-pages-browser)/./node_modules/@tiptap/starter-kit/dist/index.js\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\nfunction MarkdownEditor(param) {\n    let { content, onChange, placeholder } = param;\n    _s();\n    const editor = (0,_tiptap_react__WEBPACK_IMPORTED_MODULE_2__.useEditor)({\n        extensions: [\n            _tiptap_starter_kit__WEBPACK_IMPORTED_MODULE_1__[\"default\"].configure({\n                heading: {\n                    levels: [\n                        1,\n                        2,\n                        3\n                    ]\n                }\n            })\n        ],\n        content,\n        onUpdate: (param)=>{\n            let { editor } = param;\n            onChange(editor.getHTML());\n        },\n        editorProps: {\n            attributes: {\n                class: \"prose prose-sm sm:prose lg:prose-lg xl:prose-2xl mx-auto focus:outline-none min-h-[300px] p-4\",\n                placeholder: placeholder || \"Start writing your post...\"\n            }\n        }\n    });\n    if (!editor) {\n        return null;\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"border border-gray-300 rounded-lg overflow-hidden\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"border-b border-gray-200 bg-gray-50 p-2 flex flex-wrap gap-1\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        onClick: ()=>editor.chain().focus().toggleBold().run(),\n                        className: \"p-2 rounded hover:bg-gray-100 transition-colors \".concat(editor.isActive(\"bold\") ? \"bg-gray-200 text-blue-600\" : \"text-gray-600\"),\n                        title: \"Bold\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"strong\", {\n                            children: \"B\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\components\\\\MarkdownEditor.tsx\",\n                            lineNumber: 48,\n                            columnNumber: 11\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\components\\\\MarkdownEditor.tsx\",\n                        lineNumber: 41,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        onClick: ()=>editor.chain().focus().toggleItalic().run(),\n                        className: \"p-2 rounded hover:bg-gray-100 transition-colors \".concat(editor.isActive(\"italic\") ? \"bg-gray-200 text-blue-600\" : \"text-gray-600\"),\n                        title: \"Italic\",\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"em\", {\n                            children: \"I\"\n                        }, void 0, false, {\n                            fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\components\\\\MarkdownEditor.tsx\",\n                            lineNumber: 58,\n                            columnNumber: 11\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\components\\\\MarkdownEditor.tsx\",\n                        lineNumber: 51,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"w-px h-6 bg-gray-300 mx-1\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\components\\\\MarkdownEditor.tsx\",\n                        lineNumber: 61,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        onClick: ()=>editor.chain().focus().toggleHeading({\n                                level: 1\n                            }).run(),\n                        className: \"p-2 rounded hover:bg-gray-100 transition-colors \".concat(editor.isActive(\"heading\", {\n                            level: 1\n                        }) ? \"bg-gray-200 text-blue-600\" : \"text-gray-600\"),\n                        title: \"Heading 1\",\n                        children: \"H1\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\components\\\\MarkdownEditor.tsx\",\n                        lineNumber: 63,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        onClick: ()=>editor.chain().focus().toggleHeading({\n                                level: 2\n                            }).run(),\n                        className: \"p-2 rounded hover:bg-gray-100 transition-colors \".concat(editor.isActive(\"heading\", {\n                            level: 2\n                        }) ? \"bg-gray-200 text-blue-600\" : \"text-gray-600\"),\n                        title: \"Heading 2\",\n                        children: \"H2\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\components\\\\MarkdownEditor.tsx\",\n                        lineNumber: 73,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        onClick: ()=>editor.chain().focus().toggleHeading({\n                                level: 3\n                            }).run(),\n                        className: \"p-2 rounded hover:bg-gray-100 transition-colors \".concat(editor.isActive(\"heading\", {\n                            level: 3\n                        }) ? \"bg-gray-200 text-blue-600\" : \"text-gray-600\"),\n                        title: \"Heading 3\",\n                        children: \"H3\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\components\\\\MarkdownEditor.tsx\",\n                        lineNumber: 83,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"w-px h-6 bg-gray-300 mx-1\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\components\\\\MarkdownEditor.tsx\",\n                        lineNumber: 93,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        onClick: ()=>editor.chain().focus().toggleBulletList().run(),\n                        className: \"p-2 rounded hover:bg-gray-100 transition-colors \".concat(editor.isActive(\"bulletList\") ? \"bg-gray-200 text-blue-600\" : \"text-gray-600\"),\n                        title: \"Bullet List\",\n                        children: \"•\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\components\\\\MarkdownEditor.tsx\",\n                        lineNumber: 95,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        onClick: ()=>editor.chain().focus().toggleOrderedList().run(),\n                        className: \"p-2 rounded hover:bg-gray-100 transition-colors \".concat(editor.isActive(\"orderedList\") ? \"bg-gray-200 text-blue-600\" : \"text-gray-600\"),\n                        title: \"Numbered List\",\n                        children: \"1.\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\components\\\\MarkdownEditor.tsx\",\n                        lineNumber: 105,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        onClick: ()=>editor.chain().focus().toggleBlockquote().run(),\n                        className: \"p-2 rounded hover:bg-gray-100 transition-colors \".concat(editor.isActive(\"blockquote\") ? \"bg-gray-200 text-blue-600\" : \"text-gray-600\"),\n                        title: \"Quote\",\n                        children: '\"'\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\components\\\\MarkdownEditor.tsx\",\n                        lineNumber: 115,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        onClick: ()=>editor.chain().focus().toggleCode().run(),\n                        className: \"p-2 rounded hover:bg-gray-100 transition-colors \".concat(editor.isActive(\"code\") ? \"bg-gray-200 text-blue-600\" : \"text-gray-600\"),\n                        title: \"Code\",\n                        children: \"</>\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\components\\\\MarkdownEditor.tsx\",\n                        lineNumber: 125,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"w-px h-6 bg-gray-300 mx-1\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\components\\\\MarkdownEditor.tsx\",\n                        lineNumber: 135,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        onClick: ()=>editor.chain().focus().undo().run(),\n                        className: \"p-2 rounded hover:bg-gray-100 transition-colors text-gray-600\",\n                        title: \"Undo\",\n                        children: \"↶\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\components\\\\MarkdownEditor.tsx\",\n                        lineNumber: 137,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        onClick: ()=>editor.chain().focus().redo().run(),\n                        className: \"p-2 rounded hover:bg-gray-100 transition-colors text-gray-600\",\n                        title: \"Redo\",\n                        children: \"↷\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\components\\\\MarkdownEditor.tsx\",\n                        lineNumber: 145,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\components\\\\MarkdownEditor.tsx\",\n                lineNumber: 40,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_tiptap_react__WEBPACK_IMPORTED_MODULE_2__.EditorContent, {\n                editor: editor\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\components\\\\MarkdownEditor.tsx\",\n                lineNumber: 155,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\91965\\\\Desktop\\\\blogging\\\\src\\\\components\\\\MarkdownEditor.tsx\",\n        lineNumber: 38,\n        columnNumber: 5\n    }, this);\n}\n_s(MarkdownEditor, \"t0rsU/t1p+LiVrRpHUSgNnV9Lz4=\", false, function() {\n    return [\n        _tiptap_react__WEBPACK_IMPORTED_MODULE_2__.useEditor\n    ];\n});\n_c = MarkdownEditor;\nvar _c;\n$RefreshReg$(_c, \"MarkdownEditor\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL01hcmtkb3duRWRpdG9yLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFFd0Q7QUFDWjtBQVE3QixTQUFTRyxlQUFlLEtBQXVEO1FBQXZELEVBQUVDLE9BQU8sRUFBRUMsUUFBUSxFQUFFQyxXQUFXLEVBQXVCLEdBQXZEOztJQUNyQyxNQUFNQyxTQUFTUCx3REFBU0EsQ0FBQztRQUN2QlEsWUFBWTtZQUNWTiwyREFBVUEsQ0FBQ08sU0FBUyxDQUFDO2dCQUNuQkMsU0FBUztvQkFDUEMsUUFBUTt3QkFBQzt3QkFBRzt3QkFBRztxQkFBRTtnQkFDbkI7WUFDRjtTQUNEO1FBQ0RQO1FBQ0FRLFVBQVU7Z0JBQUMsRUFBRUwsTUFBTSxFQUFFO1lBQ25CRixTQUFTRSxPQUFPTSxPQUFPO1FBQ3pCO1FBQ0FDLGFBQWE7WUFDWEMsWUFBWTtnQkFDVkMsT0FBTztnQkFDUFYsYUFBYUEsZUFBZTtZQUM5QjtRQUNGO0lBQ0Y7SUFFQSxJQUFJLENBQUNDLFFBQVE7UUFDWCxPQUFPO0lBQ1Q7SUFFQSxxQkFDRSw4REFBQ1U7UUFBSUMsV0FBVTs7MEJBRWIsOERBQUNEO2dCQUFJQyxXQUFVOztrQ0FDYiw4REFBQ0M7d0JBQ0NDLFNBQVMsSUFBTWIsT0FBT2MsS0FBSyxHQUFHQyxLQUFLLEdBQUdDLFVBQVUsR0FBR0MsR0FBRzt3QkFDdEROLFdBQVcsbURBRVYsT0FEQ1gsT0FBT2tCLFFBQVEsQ0FBQyxVQUFVLDhCQUE4Qjt3QkFFMURDLE9BQU07a0NBRU4sNEVBQUNDO3NDQUFPOzs7Ozs7Ozs7OztrQ0FHViw4REFBQ1I7d0JBQ0NDLFNBQVMsSUFBTWIsT0FBT2MsS0FBSyxHQUFHQyxLQUFLLEdBQUdNLFlBQVksR0FBR0osR0FBRzt3QkFDeEROLFdBQVcsbURBRVYsT0FEQ1gsT0FBT2tCLFFBQVEsQ0FBQyxZQUFZLDhCQUE4Qjt3QkFFNURDLE9BQU07a0NBRU4sNEVBQUNHO3NDQUFHOzs7Ozs7Ozs7OztrQ0FHTiw4REFBQ1o7d0JBQUlDLFdBQVU7Ozs7OztrQ0FFZiw4REFBQ0M7d0JBQ0NDLFNBQVMsSUFBTWIsT0FBT2MsS0FBSyxHQUFHQyxLQUFLLEdBQUdRLGFBQWEsQ0FBQztnQ0FBRUMsT0FBTzs0QkFBRSxHQUFHUCxHQUFHO3dCQUNyRU4sV0FBVyxtREFFVixPQURDWCxPQUFPa0IsUUFBUSxDQUFDLFdBQVc7NEJBQUVNLE9BQU87d0JBQUUsS0FBSyw4QkFBOEI7d0JBRTNFTCxPQUFNO2tDQUNQOzs7Ozs7a0NBSUQsOERBQUNQO3dCQUNDQyxTQUFTLElBQU1iLE9BQU9jLEtBQUssR0FBR0MsS0FBSyxHQUFHUSxhQUFhLENBQUM7Z0NBQUVDLE9BQU87NEJBQUUsR0FBR1AsR0FBRzt3QkFDckVOLFdBQVcsbURBRVYsT0FEQ1gsT0FBT2tCLFFBQVEsQ0FBQyxXQUFXOzRCQUFFTSxPQUFPO3dCQUFFLEtBQUssOEJBQThCO3dCQUUzRUwsT0FBTTtrQ0FDUDs7Ozs7O2tDQUlELDhEQUFDUDt3QkFDQ0MsU0FBUyxJQUFNYixPQUFPYyxLQUFLLEdBQUdDLEtBQUssR0FBR1EsYUFBYSxDQUFDO2dDQUFFQyxPQUFPOzRCQUFFLEdBQUdQLEdBQUc7d0JBQ3JFTixXQUFXLG1EQUVWLE9BRENYLE9BQU9rQixRQUFRLENBQUMsV0FBVzs0QkFBRU0sT0FBTzt3QkFBRSxLQUFLLDhCQUE4Qjt3QkFFM0VMLE9BQU07a0NBQ1A7Ozs7OztrQ0FJRCw4REFBQ1Q7d0JBQUlDLFdBQVU7Ozs7OztrQ0FFZiw4REFBQ0M7d0JBQ0NDLFNBQVMsSUFBTWIsT0FBT2MsS0FBSyxHQUFHQyxLQUFLLEdBQUdVLGdCQUFnQixHQUFHUixHQUFHO3dCQUM1RE4sV0FBVyxtREFFVixPQURDWCxPQUFPa0IsUUFBUSxDQUFDLGdCQUFnQiw4QkFBOEI7d0JBRWhFQyxPQUFNO2tDQUNQOzs7Ozs7a0NBSUQsOERBQUNQO3dCQUNDQyxTQUFTLElBQU1iLE9BQU9jLEtBQUssR0FBR0MsS0FBSyxHQUFHVyxpQkFBaUIsR0FBR1QsR0FBRzt3QkFDN0ROLFdBQVcsbURBRVYsT0FEQ1gsT0FBT2tCLFFBQVEsQ0FBQyxpQkFBaUIsOEJBQThCO3dCQUVqRUMsT0FBTTtrQ0FDUDs7Ozs7O2tDQUlELDhEQUFDUDt3QkFDQ0MsU0FBUyxJQUFNYixPQUFPYyxLQUFLLEdBQUdDLEtBQUssR0FBR1ksZ0JBQWdCLEdBQUdWLEdBQUc7d0JBQzVETixXQUFXLG1EQUVWLE9BRENYLE9BQU9rQixRQUFRLENBQUMsZ0JBQWdCLDhCQUE4Qjt3QkFFaEVDLE9BQU07a0NBQ1A7Ozs7OztrQ0FJRCw4REFBQ1A7d0JBQ0NDLFNBQVMsSUFBTWIsT0FBT2MsS0FBSyxHQUFHQyxLQUFLLEdBQUdhLFVBQVUsR0FBR1gsR0FBRzt3QkFDdEROLFdBQVcsbURBRVYsT0FEQ1gsT0FBT2tCLFFBQVEsQ0FBQyxVQUFVLDhCQUE4Qjt3QkFFMURDLE9BQU07a0NBQ1A7Ozs7OztrQ0FJRCw4REFBQ1Q7d0JBQUlDLFdBQVU7Ozs7OztrQ0FFZiw4REFBQ0M7d0JBQ0NDLFNBQVMsSUFBTWIsT0FBT2MsS0FBSyxHQUFHQyxLQUFLLEdBQUdjLElBQUksR0FBR1osR0FBRzt3QkFDaEROLFdBQVU7d0JBQ1ZRLE9BQU07a0NBQ1A7Ozs7OztrQ0FJRCw4REFBQ1A7d0JBQ0NDLFNBQVMsSUFBTWIsT0FBT2MsS0FBSyxHQUFHQyxLQUFLLEdBQUdlLElBQUksR0FBR2IsR0FBRzt3QkFDaEROLFdBQVU7d0JBQ1ZRLE9BQU07a0NBQ1A7Ozs7Ozs7Ozs7OzswQkFNSCw4REFBQ3pCLHdEQUFhQTtnQkFBQ00sUUFBUUE7Ozs7Ozs7Ozs7OztBQUc3QjtHQWxKd0JKOztRQUNQSCxvREFBU0E7OztLQURGRyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9NYXJrZG93bkVkaXRvci50c3g/ZjQxOCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcclxuXHJcbmltcG9ydCB7IHVzZUVkaXRvciwgRWRpdG9yQ29udGVudCB9IGZyb20gJ0B0aXB0YXAvcmVhY3QnXHJcbmltcG9ydCBTdGFydGVyS2l0IGZyb20gJ0B0aXB0YXAvc3RhcnRlci1raXQnXHJcblxyXG5pbnRlcmZhY2UgTWFya2Rvd25FZGl0b3JQcm9wcyB7XHJcbiAgY29udGVudDogc3RyaW5nXHJcbiAgb25DaGFuZ2U6IChjb250ZW50OiBzdHJpbmcpID0+IHZvaWRcclxuICBwbGFjZWhvbGRlcj86IHN0cmluZ1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBNYXJrZG93bkVkaXRvcih7IGNvbnRlbnQsIG9uQ2hhbmdlLCBwbGFjZWhvbGRlciB9OiBNYXJrZG93bkVkaXRvclByb3BzKSB7XHJcbiAgY29uc3QgZWRpdG9yID0gdXNlRWRpdG9yKHtcclxuICAgIGV4dGVuc2lvbnM6IFtcclxuICAgICAgU3RhcnRlcktpdC5jb25maWd1cmUoe1xyXG4gICAgICAgIGhlYWRpbmc6IHtcclxuICAgICAgICAgIGxldmVsczogWzEsIDIsIDNdLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIH0pLFxyXG4gICAgXSxcclxuICAgIGNvbnRlbnQsXHJcbiAgICBvblVwZGF0ZTogKHsgZWRpdG9yIH0pID0+IHtcclxuICAgICAgb25DaGFuZ2UoZWRpdG9yLmdldEhUTUwoKSlcclxuICAgIH0sXHJcbiAgICBlZGl0b3JQcm9wczoge1xyXG4gICAgICBhdHRyaWJ1dGVzOiB7XHJcbiAgICAgICAgY2xhc3M6ICdwcm9zZSBwcm9zZS1zbSBzbTpwcm9zZSBsZzpwcm9zZS1sZyB4bDpwcm9zZS0yeGwgbXgtYXV0byBmb2N1czpvdXRsaW5lLW5vbmUgbWluLWgtWzMwMHB4XSBwLTQnLFxyXG4gICAgICAgIHBsYWNlaG9sZGVyOiBwbGFjZWhvbGRlciB8fCAnU3RhcnQgd3JpdGluZyB5b3VyIHBvc3QuLi4nLFxyXG4gICAgICB9LFxyXG4gICAgfSxcclxuICB9KVxyXG5cclxuICBpZiAoIWVkaXRvcikge1xyXG4gICAgcmV0dXJuIG51bGxcclxuICB9XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8ZGl2IGNsYXNzTmFtZT1cImJvcmRlciBib3JkZXItZ3JheS0zMDAgcm91bmRlZC1sZyBvdmVyZmxvdy1oaWRkZW5cIj5cclxuICAgICAgey8qIFRvb2xiYXIgKi99XHJcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYm9yZGVyLWIgYm9yZGVyLWdyYXktMjAwIGJnLWdyYXktNTAgcC0yIGZsZXggZmxleC13cmFwIGdhcC0xXCI+XHJcbiAgICAgICAgPGJ1dHRvblxyXG4gICAgICAgICAgb25DbGljaz17KCkgPT4gZWRpdG9yLmNoYWluKCkuZm9jdXMoKS50b2dnbGVCb2xkKCkucnVuKCl9XHJcbiAgICAgICAgICBjbGFzc05hbWU9e2BwLTIgcm91bmRlZCBob3ZlcjpiZy1ncmF5LTEwMCB0cmFuc2l0aW9uLWNvbG9ycyAke1xyXG4gICAgICAgICAgICBlZGl0b3IuaXNBY3RpdmUoJ2JvbGQnKSA/ICdiZy1ncmF5LTIwMCB0ZXh0LWJsdWUtNjAwJyA6ICd0ZXh0LWdyYXktNjAwJ1xyXG4gICAgICAgICAgfWB9XHJcbiAgICAgICAgICB0aXRsZT1cIkJvbGRcIlxyXG4gICAgICAgID5cclxuICAgICAgICAgIDxzdHJvbmc+Qjwvc3Ryb25nPlxyXG4gICAgICAgIDwvYnV0dG9uPlxyXG4gICAgICAgIFxyXG4gICAgICAgIDxidXR0b25cclxuICAgICAgICAgIG9uQ2xpY2s9eygpID0+IGVkaXRvci5jaGFpbigpLmZvY3VzKCkudG9nZ2xlSXRhbGljKCkucnVuKCl9XHJcbiAgICAgICAgICBjbGFzc05hbWU9e2BwLTIgcm91bmRlZCBob3ZlcjpiZy1ncmF5LTEwMCB0cmFuc2l0aW9uLWNvbG9ycyAke1xyXG4gICAgICAgICAgICBlZGl0b3IuaXNBY3RpdmUoJ2l0YWxpYycpID8gJ2JnLWdyYXktMjAwIHRleHQtYmx1ZS02MDAnIDogJ3RleHQtZ3JheS02MDAnXHJcbiAgICAgICAgICB9YH1cclxuICAgICAgICAgIHRpdGxlPVwiSXRhbGljXCJcclxuICAgICAgICA+XHJcbiAgICAgICAgICA8ZW0+STwvZW0+XHJcbiAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgXHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LXB4IGgtNiBiZy1ncmF5LTMwMCBteC0xXCIgLz5cclxuICAgICAgICBcclxuICAgICAgICA8YnV0dG9uXHJcbiAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBlZGl0b3IuY2hhaW4oKS5mb2N1cygpLnRvZ2dsZUhlYWRpbmcoeyBsZXZlbDogMSB9KS5ydW4oKX1cclxuICAgICAgICAgIGNsYXNzTmFtZT17YHAtMiByb3VuZGVkIGhvdmVyOmJnLWdyYXktMTAwIHRyYW5zaXRpb24tY29sb3JzICR7XHJcbiAgICAgICAgICAgIGVkaXRvci5pc0FjdGl2ZSgnaGVhZGluZycsIHsgbGV2ZWw6IDEgfSkgPyAnYmctZ3JheS0yMDAgdGV4dC1ibHVlLTYwMCcgOiAndGV4dC1ncmF5LTYwMCdcclxuICAgICAgICAgIH1gfVxyXG4gICAgICAgICAgdGl0bGU9XCJIZWFkaW5nIDFcIlxyXG4gICAgICAgID5cclxuICAgICAgICAgIEgxXHJcbiAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgXHJcbiAgICAgICAgPGJ1dHRvblxyXG4gICAgICAgICAgb25DbGljaz17KCkgPT4gZWRpdG9yLmNoYWluKCkuZm9jdXMoKS50b2dnbGVIZWFkaW5nKHsgbGV2ZWw6IDIgfSkucnVuKCl9XHJcbiAgICAgICAgICBjbGFzc05hbWU9e2BwLTIgcm91bmRlZCBob3ZlcjpiZy1ncmF5LTEwMCB0cmFuc2l0aW9uLWNvbG9ycyAke1xyXG4gICAgICAgICAgICBlZGl0b3IuaXNBY3RpdmUoJ2hlYWRpbmcnLCB7IGxldmVsOiAyIH0pID8gJ2JnLWdyYXktMjAwIHRleHQtYmx1ZS02MDAnIDogJ3RleHQtZ3JheS02MDAnXHJcbiAgICAgICAgICB9YH1cclxuICAgICAgICAgIHRpdGxlPVwiSGVhZGluZyAyXCJcclxuICAgICAgICA+XHJcbiAgICAgICAgICBIMlxyXG4gICAgICAgIDwvYnV0dG9uPlxyXG4gICAgICAgIFxyXG4gICAgICAgIDxidXR0b25cclxuICAgICAgICAgIG9uQ2xpY2s9eygpID0+IGVkaXRvci5jaGFpbigpLmZvY3VzKCkudG9nZ2xlSGVhZGluZyh7IGxldmVsOiAzIH0pLnJ1bigpfVxyXG4gICAgICAgICAgY2xhc3NOYW1lPXtgcC0yIHJvdW5kZWQgaG92ZXI6YmctZ3JheS0xMDAgdHJhbnNpdGlvbi1jb2xvcnMgJHtcclxuICAgICAgICAgICAgZWRpdG9yLmlzQWN0aXZlKCdoZWFkaW5nJywgeyBsZXZlbDogMyB9KSA/ICdiZy1ncmF5LTIwMCB0ZXh0LWJsdWUtNjAwJyA6ICd0ZXh0LWdyYXktNjAwJ1xyXG4gICAgICAgICAgfWB9XHJcbiAgICAgICAgICB0aXRsZT1cIkhlYWRpbmcgM1wiXHJcbiAgICAgICAgPlxyXG4gICAgICAgICAgSDNcclxuICAgICAgICA8L2J1dHRvbj5cclxuICAgICAgICBcclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInctcHggaC02IGJnLWdyYXktMzAwIG14LTFcIiAvPlxyXG4gICAgICAgIFxyXG4gICAgICAgIDxidXR0b25cclxuICAgICAgICAgIG9uQ2xpY2s9eygpID0+IGVkaXRvci5jaGFpbigpLmZvY3VzKCkudG9nZ2xlQnVsbGV0TGlzdCgpLnJ1bigpfVxyXG4gICAgICAgICAgY2xhc3NOYW1lPXtgcC0yIHJvdW5kZWQgaG92ZXI6YmctZ3JheS0xMDAgdHJhbnNpdGlvbi1jb2xvcnMgJHtcclxuICAgICAgICAgICAgZWRpdG9yLmlzQWN0aXZlKCdidWxsZXRMaXN0JykgPyAnYmctZ3JheS0yMDAgdGV4dC1ibHVlLTYwMCcgOiAndGV4dC1ncmF5LTYwMCdcclxuICAgICAgICAgIH1gfVxyXG4gICAgICAgICAgdGl0bGU9XCJCdWxsZXQgTGlzdFwiXHJcbiAgICAgICAgPlxyXG4gICAgICAgICAg4oCiXHJcbiAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgXHJcbiAgICAgICAgPGJ1dHRvblxyXG4gICAgICAgICAgb25DbGljaz17KCkgPT4gZWRpdG9yLmNoYWluKCkuZm9jdXMoKS50b2dnbGVPcmRlcmVkTGlzdCgpLnJ1bigpfVxyXG4gICAgICAgICAgY2xhc3NOYW1lPXtgcC0yIHJvdW5kZWQgaG92ZXI6YmctZ3JheS0xMDAgdHJhbnNpdGlvbi1jb2xvcnMgJHtcclxuICAgICAgICAgICAgZWRpdG9yLmlzQWN0aXZlKCdvcmRlcmVkTGlzdCcpID8gJ2JnLWdyYXktMjAwIHRleHQtYmx1ZS02MDAnIDogJ3RleHQtZ3JheS02MDAnXHJcbiAgICAgICAgICB9YH1cclxuICAgICAgICAgIHRpdGxlPVwiTnVtYmVyZWQgTGlzdFwiXHJcbiAgICAgICAgPlxyXG4gICAgICAgICAgMS5cclxuICAgICAgICA8L2J1dHRvbj5cclxuICAgICAgICBcclxuICAgICAgICA8YnV0dG9uXHJcbiAgICAgICAgICBvbkNsaWNrPXsoKSA9PiBlZGl0b3IuY2hhaW4oKS5mb2N1cygpLnRvZ2dsZUJsb2NrcXVvdGUoKS5ydW4oKX1cclxuICAgICAgICAgIGNsYXNzTmFtZT17YHAtMiByb3VuZGVkIGhvdmVyOmJnLWdyYXktMTAwIHRyYW5zaXRpb24tY29sb3JzICR7XHJcbiAgICAgICAgICAgIGVkaXRvci5pc0FjdGl2ZSgnYmxvY2txdW90ZScpID8gJ2JnLWdyYXktMjAwIHRleHQtYmx1ZS02MDAnIDogJ3RleHQtZ3JheS02MDAnXHJcbiAgICAgICAgICB9YH1cclxuICAgICAgICAgIHRpdGxlPVwiUXVvdGVcIlxyXG4gICAgICAgID5cclxuICAgICAgICAgIFwiXHJcbiAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgXHJcbiAgICAgICAgPGJ1dHRvblxyXG4gICAgICAgICAgb25DbGljaz17KCkgPT4gZWRpdG9yLmNoYWluKCkuZm9jdXMoKS50b2dnbGVDb2RlKCkucnVuKCl9XHJcbiAgICAgICAgICBjbGFzc05hbWU9e2BwLTIgcm91bmRlZCBob3ZlcjpiZy1ncmF5LTEwMCB0cmFuc2l0aW9uLWNvbG9ycyAke1xyXG4gICAgICAgICAgICBlZGl0b3IuaXNBY3RpdmUoJ2NvZGUnKSA/ICdiZy1ncmF5LTIwMCB0ZXh0LWJsdWUtNjAwJyA6ICd0ZXh0LWdyYXktNjAwJ1xyXG4gICAgICAgICAgfWB9XHJcbiAgICAgICAgICB0aXRsZT1cIkNvZGVcIlxyXG4gICAgICAgID5cclxuICAgICAgICAgICZsdDsvJmd0O1xyXG4gICAgICAgIDwvYnV0dG9uPlxyXG4gICAgICAgIFxyXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidy1weCBoLTYgYmctZ3JheS0zMDAgbXgtMVwiIC8+XHJcbiAgICAgICAgXHJcbiAgICAgICAgPGJ1dHRvblxyXG4gICAgICAgICAgb25DbGljaz17KCkgPT4gZWRpdG9yLmNoYWluKCkuZm9jdXMoKS51bmRvKCkucnVuKCl9XHJcbiAgICAgICAgICBjbGFzc05hbWU9XCJwLTIgcm91bmRlZCBob3ZlcjpiZy1ncmF5LTEwMCB0cmFuc2l0aW9uLWNvbG9ycyB0ZXh0LWdyYXktNjAwXCJcclxuICAgICAgICAgIHRpdGxlPVwiVW5kb1wiXHJcbiAgICAgICAgPlxyXG4gICAgICAgICAg4oa2XHJcbiAgICAgICAgPC9idXR0b24+XHJcbiAgICAgICAgXHJcbiAgICAgICAgPGJ1dHRvblxyXG4gICAgICAgICAgb25DbGljaz17KCkgPT4gZWRpdG9yLmNoYWluKCkuZm9jdXMoKS5yZWRvKCkucnVuKCl9XHJcbiAgICAgICAgICBjbGFzc05hbWU9XCJwLTIgcm91bmRlZCBob3ZlcjpiZy1ncmF5LTEwMCB0cmFuc2l0aW9uLWNvbG9ycyB0ZXh0LWdyYXktNjAwXCJcclxuICAgICAgICAgIHRpdGxlPVwiUmVkb1wiXHJcbiAgICAgICAgPlxyXG4gICAgICAgICAg4oa3XHJcbiAgICAgICAgPC9idXR0b24+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgICBcclxuICAgICAgey8qIEVkaXRvciBDb250ZW50ICovfVxyXG4gICAgICA8RWRpdG9yQ29udGVudCBlZGl0b3I9e2VkaXRvcn0gLz5cclxuICAgIDwvZGl2PlxyXG4gIClcclxufVxyXG4iXSwibmFtZXMiOlsidXNlRWRpdG9yIiwiRWRpdG9yQ29udGVudCIsIlN0YXJ0ZXJLaXQiLCJNYXJrZG93bkVkaXRvciIsImNvbnRlbnQiLCJvbkNoYW5nZSIsInBsYWNlaG9sZGVyIiwiZWRpdG9yIiwiZXh0ZW5zaW9ucyIsImNvbmZpZ3VyZSIsImhlYWRpbmciLCJsZXZlbHMiLCJvblVwZGF0ZSIsImdldEhUTUwiLCJlZGl0b3JQcm9wcyIsImF0dHJpYnV0ZXMiLCJjbGFzcyIsImRpdiIsImNsYXNzTmFtZSIsImJ1dHRvbiIsIm9uQ2xpY2siLCJjaGFpbiIsImZvY3VzIiwidG9nZ2xlQm9sZCIsInJ1biIsImlzQWN0aXZlIiwidGl0bGUiLCJzdHJvbmciLCJ0b2dnbGVJdGFsaWMiLCJlbSIsInRvZ2dsZUhlYWRpbmciLCJsZXZlbCIsInRvZ2dsZUJ1bGxldExpc3QiLCJ0b2dnbGVPcmRlcmVkTGlzdCIsInRvZ2dsZUJsb2NrcXVvdGUiLCJ0b2dnbGVDb2RlIiwidW5kbyIsInJlZG8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/MarkdownEditor.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider'); // TODO: Delete with enableRenderableContext\n\nvar REACT_CONSUMER_TYPE = Symbol.for('react.consumer');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar REACT_CACHE_TYPE = Symbol.for('react.cache');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\nvar enableRenderableContext = false;\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false;\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n}\n\nvar REACT_CLIENT_REFERENCE$2 = Symbol.for('react.client.reference'); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  if (typeof type === 'function') {\n    if (type.$$typeof === REACT_CLIENT_REFERENCE$2) {\n      // TODO: Create a convention for naming client references with debug info.\n      return null;\n    }\n\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n    case REACT_CACHE_TYPE:\n      {\n        return 'Cache';\n      }\n\n  }\n\n  if (typeof type === 'object') {\n    {\n      if (typeof type.tag === 'number') {\n        error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n      }\n    }\n\n    switch (type.$$typeof) {\n      case REACT_PROVIDER_TYPE:\n        {\n          var provider = type;\n          return getContextName(provider._context) + '.Provider';\n        }\n\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n\n        {\n          return getContextName(context) + '.Consumer';\n        }\n\n      case REACT_CONSUMER_TYPE:\n        {\n          return null;\n        }\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n    }\n  }\n\n  return null;\n}\n\n// $FlowFixMe[method-unbinding]\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar assign = Object.assign;\n\n/*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object'; // $FlowFixMe[incompatible-return]\n\n    return type;\n  }\n} // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar REACT_CLIENT_REFERENCE$1 = Symbol.for('react.client.reference');\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || enableRenderableContext  || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_CLIENT_REFERENCE$1 || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n/**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */\n\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (!fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n  /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */\n\n\n  var RunInRootFrame = {\n    DetermineComponentFrameRoot: function () {\n      var control;\n\n      try {\n        // This should throw.\n        if (construct) {\n          // Something should be setting the props in the constructor.\n          var Fake = function () {\n            throw Error();\n          }; // $FlowFixMe[prop-missing]\n\n\n          Object.defineProperty(Fake.prototype, 'props', {\n            set: function () {\n              // We use a throwing setter instead of frozen or non-writable props\n              // because that won't throw in a non-strict mode function.\n              throw Error();\n            }\n          });\n\n          if (typeof Reflect === 'object' && Reflect.construct) {\n            // We construct a different control for this case to include any extra\n            // frames added by the construct call.\n            try {\n              Reflect.construct(Fake, []);\n            } catch (x) {\n              control = x;\n            }\n\n            Reflect.construct(fn, [], Fake);\n          } else {\n            try {\n              Fake.call();\n            } catch (x) {\n              control = x;\n            } // $FlowFixMe[prop-missing] found when upgrading Flow\n\n\n            fn.call(Fake.prototype);\n          }\n        } else {\n          try {\n            throw Error();\n          } catch (x) {\n            control = x;\n          } // TODO(luna): This will currently only throw if the function component\n          // tries to access React/ReactDOM/props. We should probably make this throw\n          // in simple components too\n\n\n          var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n          // component, which we don't yet support. Attach a noop catch handler to\n          // silence the error.\n          // TODO: Implement component stacks for async client components?\n\n          if (maybePromise && typeof maybePromise.catch === 'function') {\n            maybePromise.catch(function () {});\n          }\n        }\n      } catch (sample) {\n        // This is inlined manually because closure doesn't do it for us.\n        if (sample && control && typeof sample.stack === 'string') {\n          return [sample.stack, control.stack];\n        }\n      }\n\n      return [null, null];\n    }\n  }; // $FlowFixMe[prop-missing]\n\n  RunInRootFrame.DetermineComponentFrameRoot.displayName = 'DetermineComponentFrameRoot';\n  var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, 'name'); // Before ES6, the `name` property was not configurable.\n\n  if (namePropDescriptor && namePropDescriptor.configurable) {\n    // V8 utilizes a function's `name` property when generating a stack trace.\n    Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // Configurable properties can be updated even if its writable descriptor\n    // is set to `false`.\n    // $FlowFixMe[cannot-write]\n    'name', {\n      value: 'DetermineComponentFrameRoot'\n    });\n  }\n\n  try {\n    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),\n        sampleStack = _RunInRootFrame$Deter[0],\n        controlStack = _RunInRootFrame$Deter[1];\n\n    if (sampleStack && controlStack) {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sampleStack.split('\\n');\n      var controlLines = controlStack.split('\\n');\n      var s = 0;\n      var c = 0;\n\n      while (s < sampleLines.length && !sampleLines[s].includes('DetermineComponentFrameRoot')) {\n        s++;\n      }\n\n      while (c < controlLines.length && !controlLines[c].includes('DetermineComponentFrameRoot')) {\n        c++;\n      } // We couldn't find our intentionally injected common root frame, attempt\n      // to find another common root frame by search from the bottom of the\n      // control stack...\n\n\n      if (s === sampleLines.length || c === controlLines.length) {\n        s = sampleLines.length - 1;\n        c = controlLines.length - 1;\n\n        while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n          // We expect at least one stack frame to be shared.\n          // Typically this will be the root most one. However, stack frames may be\n          // cut off due to maximum stack limits. In this case, one maybe cut off\n          // earlier than the other. We assume that the sample is longer or the same\n          // and there for cut off earlier. So we should find the root most frame in\n          // the sample somewhere in the control.\n          c--;\n        }\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                if (true) {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\nvar REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference');\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    {\n      var warnAboutAccessingRef = function () {\n        if (!specialPropRefWarningShown) {\n          specialPropRefWarningShown = true;\n\n          error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n        }\n      };\n\n      warnAboutAccessingRef.isReactWarning = true;\n      Object.defineProperty(props, 'ref', {\n        get: warnAboutAccessingRef,\n        configurable: true\n      });\n    }\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nfunction ReactElement(type, key, _ref, self, source, owner, props) {\n  var ref;\n\n  {\n    ref = _ref;\n  }\n\n  var element;\n\n  {\n    // In prod, `ref` is a regular property. It will be removed in a\n    // future release.\n    element = {\n      // This tag allows us to uniquely identify this as a React Element\n      $$typeof: REACT_ELEMENT_TYPE,\n      // Built-in properties that belong on the element\n      type: type,\n      key: key,\n      ref: ref,\n      props: props,\n      // Record the component responsible for creating this element.\n      _owner: owner\n    };\n  }\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // debugInfo contains Server Component debug information.\n\n    Object.defineProperty(element, '_debugInfo', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: null\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n}\nvar didWarnAboutKeySpread = {};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV$1(type, config, maybeKey, isStaticChildren, source, self) {\n  {\n    if (!isValidElementType(type)) {\n      // This is an invalid element type.\n      //\n      // We warn in this case but don't throw. We expect the element creation to\n      // succeed and there will likely be errors in render.\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    } else {\n      // This is a valid element type.\n      // Skip key warning if the type isn't valid since our key validation logic\n      // doesn't expect a non-string/function type and can throw confusing\n      // errors. We don't want exception behavior to differ between dev and\n      // prod. (Rendering will throw with a helpful message and as soon as the\n      // type is fixed, the key warnings will appear.)\n      var children = config.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    } // Warn about key spread regardless of whether the type is valid.\n\n\n    if (hasOwnProperty.call(config, 'key')) {\n      var componentName = getComponentNameFromType(type);\n      var keys = Object.keys(config).filter(function (k) {\n        return k !== 'key';\n      });\n      var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';\n\n      if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n        var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n\n        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + '  let props = %s;\\n' + '  <%s {...props} />\\n' + 'React keys must be passed directly to JSX without using spread:\\n' + '  let props = %s;\\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);\n\n        didWarnAboutKeySpread[componentName + beforeExample] = true;\n      }\n    }\n\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      {\n        ref = config.ref;\n      }\n\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && // Skip over reserved prop names\n      propName !== 'key' && (propName !== 'ref')) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    var element = ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    }\n\n    return element;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object' || !node) {\n      return;\n    }\n\n    if (node.$$typeof === REACT_CLIENT_REFERENCE) ; else if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\nvar ownerHasKeyUseWarning = {};\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement(null);\n  }\n}\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = getComponentNameFromType(parentType);\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  // TODO: Move this to render phase instead of at element creation.\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement(null);\n    }\n  }\n}\n\nvar jsxDEV = jsxDEV$1 ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsxDEV = jsxDEV;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsSUFBSSxJQUFxQztBQUN6QztBQUNBOztBQUVBLFlBQVksbUJBQU8sQ0FBQyxzR0FBMEI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxlQUFlO0FBQ2hIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVIsa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBLHFDQUFxQzs7QUFFckMsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBLHFFQUFxRTs7QUFFckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0dBQWtHOztBQUVsRztBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQ0FBaUM7O0FBRWpDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLEdBQUc7QUFDZCxXQUFXLGVBQWU7QUFDMUIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtB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QUFXLGNBQWM7QUFDekI7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQjtBQUNoQixjQUFjO0FBQ2QsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcz8xOGY5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKTtcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKTtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKTsgLy8gVE9ETzogRGVsZXRlIHdpdGggZW5hYmxlUmVuZGVyYWJsZUNvbnRleHRcblxudmFyIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jb25zdW1lcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIFJFQUNUX0NBQ0hFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jYWNoZScpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxudmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xudmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7IC8vIE5vIGtub3duIGJ1Z3MsIGJ1dCBuZWVkcyBwZXJmb3JtYW5jZSB0ZXN0aW5nXG5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG52YXIgZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQgPSBmYWxzZTtcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMikge1xuICAgICAgLy8gVE9ETzogQ3JlYXRlIGEgY29udmVudGlvbiBmb3IgbmFtaW5nIGNsaWVudCByZWZlcmVuY2VzIHdpdGggZGVidWcgaW5mby5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUocHJvdmlkZXIuX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcblxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLypcbiAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG4gKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG4gKi9cbi8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl0gb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5mdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICB7XG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSB1c2luZyBpdCBoZXJlLicsIHR5cGVOYW1lKHZhbHVlKSk7XG5cbiAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpOyAvLyB0aHJvdyAodG8gaGVscCBjYWxsZXJzIGZpbmQgdHJvdWJsZXNob290aW5nIGNvbW1lbnRzKVxuICAgIH1cbiAgfVxufVxuXG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIE5vdGU6IHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIChlLmcuIGlmIGl0J3MgYSBwb2x5ZmlsbCkuXG5cblxuICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IGVuYWJsZURlYnVnVHJhY2luZyAgfHwgdHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSB8fCBlbmFibGVMZWdhY3lIaWRkZW4gIHx8IHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8IGVuYWJsZVNjb3BlQVBJICB8fCBlbmFibGVDYWNoZUVsZW1lbnQgIHx8IGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nICkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgZW5hYmxlUmVuZGVyYWJsZUNvbnRleHQgIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gVGhpcyBuZWVkcyB0byBpbmNsdWRlIGFsbCBwb3NzaWJsZSBtb2R1bGUgcmVmZXJlbmNlIG9iamVjdFxuICAgIC8vIHR5cGVzIHN1cHBvcnRlZCBieSBhbnkgRmxpZ2h0IGNvbmZpZ3VyYXRpb24gYW55d2hlcmUgc2luY2VcbiAgICAvLyB3ZSBkb24ndCBrbm93IHdoaWNoIEZsaWdodCBidWlsZCB0aGlzIHdpbGwgZW5kIHVwIGJlaW5nIHVzZWRcbiAgICAvLyB3aXRoLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5mdW5jdGlvbiBpc0FycmF5KGEpIHtcbiAgcmV0dXJuIGlzQXJyYXlJbXBsKGEpO1xufVxuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV0gRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cbi8qKlxuICogTGV2ZXJhZ2VzIG5hdGl2ZSBicm93c2VyL1ZNIHN0YWNrIGZyYW1lcyB0byBnZXQgcHJvcGVyIGRldGFpbHMgKGUuZy5cbiAqIGZpbGVuYW1lLCBsaW5lICsgY29sIG51bWJlcikgZm9yIGEgc2luZ2xlIGNvbXBvbmVudCBpbiBhIGNvbXBvbmVudCBzdGFjay4gV2VcbiAqIGRvIHRoaXMgYnk6XG4gKiAgICgxKSB0aHJvd2luZyBhbmQgY2F0Y2hpbmcgYW4gZXJyb3IgaW4gdGhlIGZ1bmN0aW9uIC0gdGhpcyB3aWxsIGJlIG91clxuICogICAgICAgY29udHJvbCBlcnJvci5cbiAqICAgKDIpIGNhbGxpbmcgdGhlIGNvbXBvbmVudCB3aGljaCB3aWxsIGV2ZW50dWFsbHkgdGhyb3cgYW4gZXJyb3IgdGhhdCB3ZSdsbFxuICogICAgICAgY2F0Y2ggLSB0aGlzIHdpbGwgYmUgb3VyIHNhbXBsZSBlcnJvci5cbiAqICAgKDMpIGRpZmZpbmcgdGhlIGNvbnRyb2wgYW5kIHNhbXBsZSBlcnJvciBzdGFja3MgdG8gZmluZCB0aGUgc3RhY2sgZnJhbWVcbiAqICAgICAgIHdoaWNoIHJlcHJlc2VudHMgb3VyIGNvbXBvbmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlcjtcblxuICB7XG4gICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50OyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEZpbmRpbmcgYSBjb21tb24gc3RhY2sgZnJhbWUgYmV0d2VlbiBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGNhbiBiZVxuICAgKiB0cmlja3kgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcyBhbmQgbGV2ZWxzIG9mIHN0YWNrIHRyYWNlIHRydW5jYXRpb24gZnJvbVxuICAgKiBkaWZmZXJlbnQgSlMgVk1zLiBTbyBpbnN0ZWFkIHdlJ2xsIGF0dGVtcHQgdG8gY29udHJvbCB3aGF0IHRoYXQgY29tbW9uXG4gICAqIGZyYW1lIHNob3VsZCBiZSB0aHJvdWdoIHRoaXMgb2JqZWN0IG1ldGhvZDpcbiAgICogSGF2aW5nIGJvdGggdGhlIHNhbXBsZSBhbmQgY29udHJvbCBlcnJvcnMgYmUgaW4gdGhlIGZ1bmN0aW9uIHVuZGVyIHRoZVxuICAgKiBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIHByb3BlcnR5LCArIHNldHRpbmcgdGhlIGBuYW1lYCBhbmRcbiAgICogYGRpc3BsYXlOYW1lYCBwcm9wZXJ0aWVzIG9mIHRoZSBmdW5jdGlvbiBlbnN1cmVzIHRoYXQgYSBzdGFja1xuICAgKiBmcmFtZSBleGlzdHMgdGhhdCBoYXMgdGhlIG1ldGhvZCBuYW1lIGBEZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lUm9vdGAgaW5cbiAgICogaXQgZm9yIGJvdGggY29udHJvbCBhbmQgc2FtcGxlIHN0YWNrcy5cbiAgICovXG5cblxuICB2YXIgUnVuSW5Sb290RnJhbWUgPSB7XG4gICAgRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29udHJvbDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgfSAvLyBUT0RPKGx1bmEpOiBUaGlzIHdpbGwgY3VycmVudGx5IG9ubHkgdGhyb3cgaWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudFxuICAgICAgICAgIC8vIHRyaWVzIHRvIGFjY2VzcyBSZWFjdC9SZWFjdERPTS9wcm9wcy4gV2Ugc2hvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyB0aHJvd1xuICAgICAgICAgIC8vIGluIHNpbXBsZSBjb21wb25lbnRzIHRvb1xuXG5cbiAgICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gZm4oKTsgLy8gSWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudCByZXR1cm5zIGEgcHJvbWlzZSwgaXQncyBsaWtlbHkgYW4gYXN5bmNcbiAgICAgICAgICAvLyBjb21wb25lbnQsIHdoaWNoIHdlIGRvbid0IHlldCBzdXBwb3J0LiBBdHRhY2ggYSBub29wIGNhdGNoIGhhbmRsZXIgdG9cbiAgICAgICAgICAvLyBzaWxlbmNlIHRoZSBlcnJvci5cbiAgICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgY29tcG9uZW50IHN0YWNrcyBmb3IgYXN5bmMgY2xpZW50IGNvbXBvbmVudHM/XG5cbiAgICAgICAgICBpZiAobWF5YmVQcm9taXNlICYmIHR5cGVvZiBtYXliZVByb21pc2UuY2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICAgICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIFtzYW1wbGUuc3RhY2ssIGNvbnRyb2wuc3RhY2tdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gICAgfVxuICB9OyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cblxuICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QuZGlzcGxheU5hbWUgPSAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290JztcbiAgdmFyIG5hbWVQcm9wRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LCAnbmFtZScpOyAvLyBCZWZvcmUgRVM2LCB0aGUgYG5hbWVgIHByb3BlcnR5IHdhcyBub3QgY29uZmlndXJhYmxlLlxuXG4gIGlmIChuYW1lUHJvcERlc2NyaXB0b3IgJiYgbmFtZVByb3BEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkge1xuICAgIC8vIFY4IHV0aWxpemVzIGEgZnVuY3Rpb24ncyBgbmFtZWAgcHJvcGVydHkgd2hlbiBnZW5lcmF0aW5nIGEgc3RhY2sgdHJhY2UuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgLy8gQ29uZmlndXJhYmxlIHByb3BlcnRpZXMgY2FuIGJlIHVwZGF0ZWQgZXZlbiBpZiBpdHMgd3JpdGFibGUgZGVzY3JpcHRvclxuICAgIC8vIGlzIHNldCB0byBgZmFsc2VgLlxuICAgIC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXVxuICAgICduYW1lJywge1xuICAgICAgdmFsdWU6ICdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnXG4gICAgfSk7XG4gIH1cblxuICB0cnkge1xuICAgIHZhciBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPSBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QoKSxcbiAgICAgICAgc2FtcGxlU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMF0sXG4gICAgICAgIGNvbnRyb2xTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclsxXTtcblxuICAgIGlmIChzYW1wbGVTdGFjayAmJiBjb250cm9sU3RhY2spIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZVN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sU3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSAwO1xuICAgICAgdmFyIGMgPSAwO1xuXG4gICAgICB3aGlsZSAocyA8IHNhbXBsZUxpbmVzLmxlbmd0aCAmJiAhc2FtcGxlTGluZXNbc10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIHMrKztcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGMgPCBjb250cm9sTGluZXMubGVuZ3RoICYmICFjb250cm9sTGluZXNbY10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIGMrKztcbiAgICAgIH0gLy8gV2UgY291bGRuJ3QgZmluZCBvdXIgaW50ZW50aW9uYWxseSBpbmplY3RlZCBjb21tb24gcm9vdCBmcmFtZSwgYXR0ZW1wdFxuICAgICAgLy8gdG8gZmluZCBhbm90aGVyIGNvbW1vbiByb290IGZyYW1lIGJ5IHNlYXJjaCBmcm9tIHRoZSBib3R0b20gb2YgdGhlXG4gICAgICAvLyBjb250cm9sIHN0YWNrLi4uXG5cblxuICAgICAgaWYgKHMgPT09IHNhbXBsZUxpbmVzLmxlbmd0aCB8fCBjID09PSBjb250cm9sTGluZXMubGVuZ3RoKSB7XG4gICAgICAgIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgICBjLS07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7IC8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBhIHVzZXItcHJvdmlkZWQgXCJkaXNwbGF5TmFtZVwiXG4gICAgICAgICAgICAgICAgLy8gc3BsaWNlIGl0IGluIHRvIG1ha2UgdGhlIHN0YWNrIG1vcmUgcmVhZGFibGUuXG5cblxuICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoJzxhbm9ueW1vdXM+JykpIHtcbiAgICAgICAgICAgICAgICAgIF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKCc8YW5vbnltb3VzPicsIGZuLmRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIG93bmVyRm4pIHtcblxuICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZSwgc2hvdWxkQ29uc3RydWN0KHR5cGUpKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKHR5cGUpO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZScpO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlTGlzdCcpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUucmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIC8vIE1lbW8gbWF5IGNvbnRhaW4gYW55IGNvbXBvbmVudCB0eXBlIHNvIHdlIHJlY3Vyc2l2ZWx5IHJlc29sdmUgaXQuXG4gICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBMYXp5IG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihpbml0KHBheWxvYWQpLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpO1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xudmFyIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xudmFyIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB7XG4gICAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxuZnVuY3Rpb24gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgX3JlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIHJlZjtcblxuICB7XG4gICAgcmVmID0gX3JlZjtcbiAgfVxuXG4gIHZhciBlbGVtZW50O1xuXG4gIHtcbiAgICAvLyBJbiBwcm9kLCBgcmVmYCBpcyBhIHJlZ3VsYXIgcHJvcGVydHkuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiBhXG4gICAgLy8gZnV0dXJlIHJlbGVhc2UuXG4gICAgZWxlbWVudCA9IHtcbiAgICAgIC8vIFRoaXMgdGFnIGFsbG93cyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBrZXk6IGtleSxcbiAgICAgIHJlZjogcmVmLFxuICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICAgIF9vd25lcjogb3duZXJcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBkZWJ1Z0luZm8gY29udGFpbnMgU2VydmVyIENvbXBvbmVudCBkZWJ1ZyBpbmZvcm1hdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX2RlYnVnSW5mbycsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IG51bGxcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIGlmICghaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpKSB7XG4gICAgICAvLyBUaGlzIGlzIGFuIGludmFsaWQgZWxlbWVudCB0eXBlLlxuICAgICAgLy9cbiAgICAgIC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgYSB2YWxpZCBlbGVtZW50IHR5cGUuXG4gICAgICAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAgICAgLy8gZG9lc24ndCBleHBlY3QgYSBub24tc3RyaW5nL2Z1bmN0aW9uIHR5cGUgYW5kIGNhbiB0aHJvdyBjb25mdXNpbmdcbiAgICAgIC8vIGVycm9ycy4gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZFxuICAgICAgLy8gcHJvZC4gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlXG4gICAgICAvLyB0eXBlIGlzIGZpeGVkLCB0aGUga2V5IHdhcm5pbmdzIHdpbGwgYXBwZWFyLilcbiAgICAgIHZhciBjaGlsZHJlbiA9IGNvbmZpZy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gV2FybiBhYm91dCBrZXkgc3ByZWFkIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgdHlwZSBpcyB2YWxpZC5cblxuXG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhjb25maWcpLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgICAgICByZXR1cm4gayAhPT0gJ2tleSc7XG4gICAgICB9KTtcbiAgICAgIHZhciBiZWZvcmVFeGFtcGxlID0ga2V5cy5sZW5ndGggPiAwID8gJ3trZXk6IHNvbWVLZXksICcgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3trZXk6IHNvbWVLZXl9JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdKSB7XG4gICAgICAgIHZhciBhZnRlckV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAneycgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3t9JztcblxuICAgICAgICBlcnJvcignQSBwcm9wcyBvYmplY3QgY29udGFpbmluZyBhIFwia2V5XCIgcHJvcCBpcyBiZWluZyBzcHJlYWQgaW50byBKU1g6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMgey4uLnByb3BzfSAvPlxcbicgKyAnUmVhY3Qga2V5cyBtdXN0IGJlIHBhc3NlZCBkaXJlY3RseSB0byBKU1ggd2l0aG91dCB1c2luZyBzcHJlYWQ6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JywgYmVmb3JlRXhhbXBsZSwgY29tcG9uZW50TmFtZSwgYWZ0ZXJFeGFtcGxlLCBjb21wb25lbnROYW1lKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY29tcG9uZW50TmFtZSArIGJlZm9yZUV4YW1wbGVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciBrZXkgPSBudWxsO1xuICAgIHZhciByZWYgPSBudWxsOyAvLyBDdXJyZW50bHksIGtleSBjYW4gYmUgc3ByZWFkIGluIGFzIGEgcHJvcC4gVGhpcyBjYXVzZXMgYSBwb3RlbnRpYWxcbiAgICAvLyBpc3N1ZSBpZiBrZXkgaXMgYWxzbyBleHBsaWNpdGx5IGRlY2xhcmVkIChpZS4gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz5cbiAgICAvLyBvciA8ZGl2IGtleT1cIkhpXCIgey4uLnByb3BzfSAvPiApLiBXZSB3YW50IHRvIGRlcHJlY2F0ZSBrZXkgc3ByZWFkLFxuICAgIC8vIGJ1dCBhcyBhbiBpbnRlcm1lZGlhcnkgc3RlcCwgd2Ugd2lsbCB1c2UganN4REVWIGZvciBldmVyeXRoaW5nIGV4Y2VwdFxuICAgIC8vIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+LCBiZWNhdXNlIHdlIGFyZW4ndCBjdXJyZW50bHkgYWJsZSB0byB0ZWxsIGlmXG4gICAgLy8ga2V5IGlzIGV4cGxpY2l0bHkgZGVjbGFyZWQgdG8gYmUgdW5kZWZpbmVkIG9yIG5vdC5cblxuICAgIGlmIChtYXliZUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSAnJyArIG1heWJlS2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICB7XG4gICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAge1xuICAgICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgfVxuXG4gICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKTtcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmIC8vIFNraXAgb3ZlciByZXNlcnZlZCBwcm9wIG5hbWVzXG4gICAgICBwcm9wTmFtZSAhPT0gJ2tleScgJiYgKHByb3BOYW1lICE9PSAncmVmJykpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xuXG4gICAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cblxuXG5mdW5jdGlvbiB2YWxpZGF0ZUNoaWxkS2V5cyhub2RlLCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnIHx8ICFub2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UpIDsgZWxzZSBpZiAoaXNBcnJheShub2RlKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG5cbiAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgICBub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuXG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpIHtcbiAge1xuICAgIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgICBpZiAoIWluZm8pIHtcbiAgICAgIHZhciBwYXJlbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHBhcmVudFR5cGUpO1xuXG4gICAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gcmVuZGVyIHBoYXNlIGluc3RlYWQgb2YgYXQgZWxlbWVudCBjcmVhdGlvbi5cbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKGtleSAhPT0gJ2NoaWxkcmVuJyAmJiBrZXkgIT09ICdrZXknKSB7XG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGZyYWdtZW50KTtcblxuICAgICAgZXJyb3IoJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJyk7XG5cbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG52YXIganN4REVWID0ganN4REVWJDEgO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanM/MjA2ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/core/dist/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@tiptap/core/dist/index.js ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CommandManager: function() { return /* binding */ CommandManager; },\n/* harmony export */   Editor: function() { return /* binding */ Editor; },\n/* harmony export */   Extension: function() { return /* binding */ Extension; },\n/* harmony export */   InputRule: function() { return /* binding */ InputRule; },\n/* harmony export */   Mark: function() { return /* binding */ Mark; },\n/* harmony export */   Node: function() { return /* binding */ Node; },\n/* harmony export */   NodePos: function() { return /* binding */ NodePos; },\n/* harmony export */   NodeView: function() { return /* binding */ NodeView; },\n/* harmony export */   PasteRule: function() { return /* binding */ PasteRule; },\n/* harmony export */   Tracker: function() { return /* binding */ Tracker; },\n/* harmony export */   callOrReturn: function() { return /* binding */ callOrReturn; },\n/* harmony export */   canInsertNode: function() { return /* binding */ canInsertNode; },\n/* harmony export */   combineTransactionSteps: function() { return /* binding */ combineTransactionSteps; },\n/* harmony export */   createChainableState: function() { return /* binding */ createChainableState; },\n/* harmony export */   createDocument: function() { return /* binding */ createDocument; },\n/* harmony export */   createNodeFromContent: function() { return /* binding */ createNodeFromContent; },\n/* harmony export */   createStyleTag: function() { return /* binding */ createStyleTag; },\n/* harmony export */   defaultBlockAt: function() { return /* binding */ defaultBlockAt; },\n/* harmony export */   deleteProps: function() { return /* binding */ deleteProps; },\n/* harmony export */   elementFromString: function() { return /* binding */ elementFromString; },\n/* harmony export */   escapeForRegEx: function() { return /* binding */ escapeForRegEx; },\n/* harmony export */   extensions: function() { return /* binding */ index; },\n/* harmony export */   findChildren: function() { return /* binding */ findChildren; },\n/* harmony export */   findChildrenInRange: function() { return /* binding */ findChildrenInRange; },\n/* harmony export */   findDuplicates: function() { return /* binding */ findDuplicates; },\n/* harmony export */   findParentNode: function() { return /* binding */ findParentNode; },\n/* harmony export */   findParentNodeClosestToPos: function() { return /* binding */ findParentNodeClosestToPos; },\n/* harmony export */   fromString: function() { return /* binding */ fromString; },\n/* harmony export */   generateHTML: function() { return /* binding */ generateHTML; },\n/* harmony export */   generateJSON: function() { return /* binding */ generateJSON; },\n/* harmony export */   generateText: function() { return /* binding */ generateText; },\n/* harmony export */   getAttributes: function() { return /* binding */ getAttributes; },\n/* harmony export */   getAttributesFromExtensions: function() { return /* binding */ getAttributesFromExtensions; },\n/* harmony export */   getChangedRanges: function() { return /* binding */ getChangedRanges; },\n/* harmony export */   getDebugJSON: function() { return /* binding */ getDebugJSON; },\n/* harmony export */   getExtensionField: function() { return /* binding */ getExtensionField; },\n/* harmony export */   getHTMLFromFragment: function() { return /* binding */ getHTMLFromFragment; },\n/* harmony export */   getMarkAttributes: function() { return /* binding */ getMarkAttributes; },\n/* harmony export */   getMarkRange: function() { return /* binding */ getMarkRange; },\n/* harmony export */   getMarkType: function() { return /* binding */ getMarkType; },\n/* harmony export */   getMarksBetween: function() { return /* binding */ getMarksBetween; },\n/* harmony export */   getNodeAtPosition: function() { return /* binding */ getNodeAtPosition; },\n/* harmony export */   getNodeAttributes: function() { return /* binding */ getNodeAttributes; },\n/* harmony export */   getNodeType: function() { return /* binding */ getNodeType; },\n/* harmony export */   getRenderedAttributes: function() { return /* binding */ getRenderedAttributes; },\n/* harmony export */   getSchema: function() { return /* binding */ getSchema; },\n/* harmony export */   getSchemaByResolvedExtensions: function() { return /* binding */ getSchemaByResolvedExtensions; },\n/* harmony export */   getSchemaTypeByName: function() { return /* binding */ getSchemaTypeByName; },\n/* harmony export */   getSchemaTypeNameByName: function() { return /* binding */ getSchemaTypeNameByName; },\n/* harmony export */   getSplittedAttributes: function() { return /* binding */ getSplittedAttributes; },\n/* harmony export */   getText: function() { return /* binding */ getText; },\n/* harmony export */   getTextBetween: function() { return /* binding */ getTextBetween; },\n/* harmony export */   getTextContentFromNodes: function() { return /* binding */ getTextContentFromNodes; },\n/* harmony export */   getTextSerializersFromSchema: function() { return /* binding */ getTextSerializersFromSchema; },\n/* harmony export */   injectExtensionAttributesToParseRule: function() { return /* binding */ injectExtensionAttributesToParseRule; },\n/* harmony export */   inputRulesPlugin: function() { return /* binding */ inputRulesPlugin; },\n/* harmony export */   isActive: function() { return /* binding */ isActive; },\n/* harmony export */   isAtEndOfNode: function() { return /* binding */ isAtEndOfNode; },\n/* harmony export */   isAtStartOfNode: function() { return /* binding */ isAtStartOfNode; },\n/* harmony export */   isEmptyObject: function() { return /* binding */ isEmptyObject; },\n/* harmony export */   isExtensionRulesEnabled: function() { return /* binding */ isExtensionRulesEnabled; },\n/* harmony export */   isFunction: function() { return /* binding */ isFunction; },\n/* harmony export */   isList: function() { return /* binding */ isList; },\n/* harmony export */   isMacOS: function() { return /* binding */ isMacOS; },\n/* harmony export */   isMarkActive: function() { return /* binding */ isMarkActive; },\n/* harmony export */   isNodeActive: function() { return /* binding */ isNodeActive; },\n/* harmony export */   isNodeEmpty: function() { return /* binding */ isNodeEmpty; },\n/* harmony export */   isNodeSelection: function() { return /* binding */ isNodeSelection; },\n/* harmony export */   isNumber: function() { return /* binding */ isNumber; },\n/* harmony export */   isPlainObject: function() { return /* binding */ isPlainObject; },\n/* harmony export */   isRegExp: function() { return /* binding */ isRegExp; },\n/* harmony export */   isString: function() { return /* binding */ isString; },\n/* harmony export */   isTextSelection: function() { return /* binding */ isTextSelection; },\n/* harmony export */   isiOS: function() { return /* binding */ isiOS; },\n/* harmony export */   markInputRule: function() { return /* binding */ markInputRule; },\n/* harmony export */   markPasteRule: function() { return /* binding */ markPasteRule; },\n/* harmony export */   mergeAttributes: function() { return /* binding */ mergeAttributes; },\n/* harmony export */   mergeDeep: function() { return /* binding */ mergeDeep; },\n/* harmony export */   minMax: function() { return /* binding */ minMax; },\n/* harmony export */   nodeInputRule: function() { return /* binding */ nodeInputRule; },\n/* harmony export */   nodePasteRule: function() { return /* binding */ nodePasteRule; },\n/* harmony export */   objectIncludes: function() { return /* binding */ objectIncludes; },\n/* harmony export */   pasteRulesPlugin: function() { return /* binding */ pasteRulesPlugin; },\n/* harmony export */   posToDOMRect: function() { return /* binding */ posToDOMRect; },\n/* harmony export */   removeDuplicates: function() { return /* binding */ removeDuplicates; },\n/* harmony export */   resolveFocusPosition: function() { return /* binding */ resolveFocusPosition; },\n/* harmony export */   rewriteUnknownContent: function() { return /* binding */ rewriteUnknownContent; },\n/* harmony export */   selectionToInsertionEnd: function() { return /* binding */ selectionToInsertionEnd; },\n/* harmony export */   splitExtensions: function() { return /* binding */ splitExtensions; },\n/* harmony export */   textInputRule: function() { return /* binding */ textInputRule; },\n/* harmony export */   textPasteRule: function() { return /* binding */ textPasteRule; },\n/* harmony export */   textblockTypeInputRule: function() { return /* binding */ textblockTypeInputRule; },\n/* harmony export */   wrappingInputRule: function() { return /* binding */ wrappingInputRule; }\n/* harmony export */ });\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ \"(app-pages-browser)/./node_modules/@tiptap/pm/state/dist/index.js\");\n/* harmony import */ var _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/pm/view */ \"(app-pages-browser)/./node_modules/@tiptap/pm/view/dist/index.js\");\n/* harmony import */ var _tiptap_pm_keymap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/pm/keymap */ \"(app-pages-browser)/./node_modules/@tiptap/pm/keymap/dist/index.js\");\n/* harmony import */ var _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tiptap/pm/model */ \"(app-pages-browser)/./node_modules/@tiptap/pm/model/dist/index.js\");\n/* harmony import */ var _tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tiptap/pm/transform */ \"(app-pages-browser)/./node_modules/@tiptap/pm/transform/dist/index.js\");\n/* harmony import */ var _tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tiptap/pm/commands */ \"(app-pages-browser)/./node_modules/@tiptap/pm/commands/dist/index.js\");\n/* harmony import */ var _tiptap_pm_schema_list__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tiptap/pm/schema-list */ \"(app-pages-browser)/./node_modules/@tiptap/pm/schema-list/dist/index.js\");\n\n\n\n\n\n\n\n\n/**\n * Takes a Transaction & Editor State and turns it into a chainable state object\n * @param config The transaction and state to create the chainable state from\n * @returns A chainable Editor state object\n */\nfunction createChainableState(config) {\n    const { state, transaction } = config;\n    let { selection } = transaction;\n    let { doc } = transaction;\n    let { storedMarks } = transaction;\n    return {\n        ...state,\n        apply: state.apply.bind(state),\n        applyTransaction: state.applyTransaction.bind(state),\n        plugins: state.plugins,\n        schema: state.schema,\n        reconfigure: state.reconfigure.bind(state),\n        toJSON: state.toJSON.bind(state),\n        get storedMarks() {\n            return storedMarks;\n        },\n        get selection() {\n            return selection;\n        },\n        get doc() {\n            return doc;\n        },\n        get tr() {\n            selection = transaction.selection;\n            doc = transaction.doc;\n            storedMarks = transaction.storedMarks;\n            return transaction;\n        },\n    };\n}\n\nclass CommandManager {\n    constructor(props) {\n        this.editor = props.editor;\n        this.rawCommands = this.editor.extensionManager.commands;\n        this.customState = props.state;\n    }\n    get hasCustomState() {\n        return !!this.customState;\n    }\n    get state() {\n        return this.customState || this.editor.state;\n    }\n    get commands() {\n        const { rawCommands, editor, state } = this;\n        const { view } = editor;\n        const { tr } = state;\n        const props = this.buildProps(tr);\n        return Object.fromEntries(Object.entries(rawCommands).map(([name, command]) => {\n            const method = (...args) => {\n                const callback = command(...args)(props);\n                if (!tr.getMeta('preventDispatch') && !this.hasCustomState) {\n                    view.dispatch(tr);\n                }\n                return callback;\n            };\n            return [name, method];\n        }));\n    }\n    get chain() {\n        return () => this.createChain();\n    }\n    get can() {\n        return () => this.createCan();\n    }\n    createChain(startTr, shouldDispatch = true) {\n        const { rawCommands, editor, state } = this;\n        const { view } = editor;\n        const callbacks = [];\n        const hasStartTransaction = !!startTr;\n        const tr = startTr || state.tr;\n        const run = () => {\n            if (!hasStartTransaction\n                && shouldDispatch\n                && !tr.getMeta('preventDispatch')\n                && !this.hasCustomState) {\n                view.dispatch(tr);\n            }\n            return callbacks.every(callback => callback === true);\n        };\n        const chain = {\n            ...Object.fromEntries(Object.entries(rawCommands).map(([name, command]) => {\n                const chainedCommand = (...args) => {\n                    const props = this.buildProps(tr, shouldDispatch);\n                    const callback = command(...args)(props);\n                    callbacks.push(callback);\n                    return chain;\n                };\n                return [name, chainedCommand];\n            })),\n            run,\n        };\n        return chain;\n    }\n    createCan(startTr) {\n        const { rawCommands, state } = this;\n        const dispatch = false;\n        const tr = startTr || state.tr;\n        const props = this.buildProps(tr, dispatch);\n        const formattedCommands = Object.fromEntries(Object.entries(rawCommands).map(([name, command]) => {\n            return [name, (...args) => command(...args)({ ...props, dispatch: undefined })];\n        }));\n        return {\n            ...formattedCommands,\n            chain: () => this.createChain(tr, dispatch),\n        };\n    }\n    buildProps(tr, shouldDispatch = true) {\n        const { rawCommands, editor, state } = this;\n        const { view } = editor;\n        const props = {\n            tr,\n            editor,\n            view,\n            state: createChainableState({\n                state,\n                transaction: tr,\n            }),\n            dispatch: shouldDispatch ? () => undefined : undefined,\n            chain: () => this.createChain(tr, shouldDispatch),\n            can: () => this.createCan(tr),\n            get commands() {\n                return Object.fromEntries(Object.entries(rawCommands).map(([name, command]) => {\n                    return [name, (...args) => command(...args)(props)];\n                }));\n            },\n        };\n        return props;\n    }\n}\n\nclass EventEmitter {\n    constructor() {\n        this.callbacks = {};\n    }\n    on(event, fn) {\n        if (!this.callbacks[event]) {\n            this.callbacks[event] = [];\n        }\n        this.callbacks[event].push(fn);\n        return this;\n    }\n    emit(event, ...args) {\n        const callbacks = this.callbacks[event];\n        if (callbacks) {\n            callbacks.forEach(callback => callback.apply(this, args));\n        }\n        return this;\n    }\n    off(event, fn) {\n        const callbacks = this.callbacks[event];\n        if (callbacks) {\n            if (fn) {\n                this.callbacks[event] = callbacks.filter(callback => callback !== fn);\n            }\n            else {\n                delete this.callbacks[event];\n            }\n        }\n        return this;\n    }\n    once(event, fn) {\n        const onceFn = (...args) => {\n            this.off(event, onceFn);\n            fn.apply(this, args);\n        };\n        return this.on(event, onceFn);\n    }\n    removeAllListeners() {\n        this.callbacks = {};\n    }\n}\n\n/**\n * Returns a field from an extension\n * @param extension The Tiptap extension\n * @param field The field, for example `renderHTML` or `priority`\n * @param context The context object that should be passed as `this` into the function\n * @returns The field value\n */\nfunction getExtensionField(extension, field, context) {\n    if (extension.config[field] === undefined && extension.parent) {\n        return getExtensionField(extension.parent, field, context);\n    }\n    if (typeof extension.config[field] === 'function') {\n        const value = extension.config[field].bind({\n            ...context,\n            parent: extension.parent\n                ? getExtensionField(extension.parent, field, context)\n                : null,\n        });\n        return value;\n    }\n    return extension.config[field];\n}\n\nfunction splitExtensions(extensions) {\n    const baseExtensions = extensions.filter(extension => extension.type === 'extension');\n    const nodeExtensions = extensions.filter(extension => extension.type === 'node');\n    const markExtensions = extensions.filter(extension => extension.type === 'mark');\n    return {\n        baseExtensions,\n        nodeExtensions,\n        markExtensions,\n    };\n}\n\n/**\n * Get a list of all extension attributes defined in `addAttribute` and `addGlobalAttribute`.\n * @param extensions List of extensions\n */\nfunction getAttributesFromExtensions(extensions) {\n    const extensionAttributes = [];\n    const { nodeExtensions, markExtensions } = splitExtensions(extensions);\n    const nodeAndMarkExtensions = [...nodeExtensions, ...markExtensions];\n    const defaultAttribute = {\n        default: null,\n        rendered: true,\n        renderHTML: null,\n        parseHTML: null,\n        keepOnSplit: true,\n        isRequired: false,\n    };\n    extensions.forEach(extension => {\n        const context = {\n            name: extension.name,\n            options: extension.options,\n            storage: extension.storage,\n            extensions: nodeAndMarkExtensions,\n        };\n        const addGlobalAttributes = getExtensionField(extension, 'addGlobalAttributes', context);\n        if (!addGlobalAttributes) {\n            return;\n        }\n        const globalAttributes = addGlobalAttributes();\n        globalAttributes.forEach(globalAttribute => {\n            globalAttribute.types.forEach(type => {\n                Object\n                    .entries(globalAttribute.attributes)\n                    .forEach(([name, attribute]) => {\n                    extensionAttributes.push({\n                        type,\n                        name,\n                        attribute: {\n                            ...defaultAttribute,\n                            ...attribute,\n                        },\n                    });\n                });\n            });\n        });\n    });\n    nodeAndMarkExtensions.forEach(extension => {\n        const context = {\n            name: extension.name,\n            options: extension.options,\n            storage: extension.storage,\n        };\n        const addAttributes = getExtensionField(extension, 'addAttributes', context);\n        if (!addAttributes) {\n            return;\n        }\n        // TODO: remove `as Attributes`\n        const attributes = addAttributes();\n        Object\n            .entries(attributes)\n            .forEach(([name, attribute]) => {\n            const mergedAttr = {\n                ...defaultAttribute,\n                ...attribute,\n            };\n            if (typeof (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === 'function') {\n                mergedAttr.default = mergedAttr.default();\n            }\n            if ((mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.isRequired) && (mergedAttr === null || mergedAttr === void 0 ? void 0 : mergedAttr.default) === undefined) {\n                delete mergedAttr.default;\n            }\n            extensionAttributes.push({\n                type: extension.name,\n                name,\n                attribute: mergedAttr,\n            });\n        });\n    });\n    return extensionAttributes;\n}\n\nfunction getNodeType(nameOrType, schema) {\n    if (typeof nameOrType === 'string') {\n        if (!schema.nodes[nameOrType]) {\n            throw Error(`There is no node type named '${nameOrType}'. Maybe you forgot to add the extension?`);\n        }\n        return schema.nodes[nameOrType];\n    }\n    return nameOrType;\n}\n\nfunction mergeAttributes(...objects) {\n    return objects\n        .filter(item => !!item)\n        .reduce((items, item) => {\n        const mergedAttributes = { ...items };\n        Object.entries(item).forEach(([key, value]) => {\n            const exists = mergedAttributes[key];\n            if (!exists) {\n                mergedAttributes[key] = value;\n                return;\n            }\n            if (key === 'class') {\n                const valueClasses = value ? String(value).split(' ') : [];\n                const existingClasses = mergedAttributes[key] ? mergedAttributes[key].split(' ') : [];\n                const insertClasses = valueClasses.filter(valueClass => !existingClasses.includes(valueClass));\n                mergedAttributes[key] = [...existingClasses, ...insertClasses].join(' ');\n            }\n            else if (key === 'style') {\n                const newStyles = value ? value.split(';').map((style) => style.trim()).filter(Boolean) : [];\n                const existingStyles = mergedAttributes[key] ? mergedAttributes[key].split(';').map((style) => style.trim()).filter(Boolean) : [];\n                const styleMap = new Map();\n                existingStyles.forEach(style => {\n                    const [property, val] = style.split(':').map(part => part.trim());\n                    styleMap.set(property, val);\n                });\n                newStyles.forEach(style => {\n                    const [property, val] = style.split(':').map(part => part.trim());\n                    styleMap.set(property, val);\n                });\n                mergedAttributes[key] = Array.from(styleMap.entries()).map(([property, val]) => `${property}: ${val}`).join('; ');\n            }\n            else {\n                mergedAttributes[key] = value;\n            }\n        });\n        return mergedAttributes;\n    }, {});\n}\n\nfunction getRenderedAttributes(nodeOrMark, extensionAttributes) {\n    return extensionAttributes\n        .filter(attribute => attribute.type === nodeOrMark.type.name)\n        .filter(item => item.attribute.rendered)\n        .map(item => {\n        if (!item.attribute.renderHTML) {\n            return {\n                [item.name]: nodeOrMark.attrs[item.name],\n            };\n        }\n        return item.attribute.renderHTML(nodeOrMark.attrs) || {};\n    })\n        .reduce((attributes, attribute) => mergeAttributes(attributes, attribute), {});\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\nfunction isFunction(value) {\n    return typeof value === 'function';\n}\n\n/**\n * Optionally calls `value` as a function.\n * Otherwise it is returned directly.\n * @param value Function or any value.\n * @param context Optional context to bind to function.\n * @param props Optional props to pass to function.\n */\nfunction callOrReturn(value, context = undefined, ...props) {\n    if (isFunction(value)) {\n        if (context) {\n            return value.bind(context)(...props);\n        }\n        return value(...props);\n    }\n    return value;\n}\n\nfunction isEmptyObject(value = {}) {\n    return Object.keys(value).length === 0 && value.constructor === Object;\n}\n\nfunction fromString(value) {\n    if (typeof value !== 'string') {\n        return value;\n    }\n    if (value.match(/^[+-]?(?:\\d*\\.)?\\d+$/)) {\n        return Number(value);\n    }\n    if (value === 'true') {\n        return true;\n    }\n    if (value === 'false') {\n        return false;\n    }\n    return value;\n}\n\n/**\n * This function merges extension attributes into parserule attributes (`attrs` or `getAttrs`).\n * Cancels when `getAttrs` returned `false`.\n * @param parseRule ProseMirror ParseRule\n * @param extensionAttributes List of attributes to inject\n */\nfunction injectExtensionAttributesToParseRule(parseRule, extensionAttributes) {\n    if ('style' in parseRule) {\n        return parseRule;\n    }\n    return {\n        ...parseRule,\n        getAttrs: (node) => {\n            const oldAttributes = parseRule.getAttrs ? parseRule.getAttrs(node) : parseRule.attrs;\n            if (oldAttributes === false) {\n                return false;\n            }\n            const newAttributes = extensionAttributes.reduce((items, item) => {\n                const value = item.attribute.parseHTML\n                    ? item.attribute.parseHTML(node)\n                    : fromString((node).getAttribute(item.name));\n                if (value === null || value === undefined) {\n                    return items;\n                }\n                return {\n                    ...items,\n                    [item.name]: value,\n                };\n            }, {});\n            return { ...oldAttributes, ...newAttributes };\n        },\n    };\n}\n\nfunction cleanUpSchemaItem(data) {\n    return Object.fromEntries(\n    // @ts-ignore\n    Object.entries(data).filter(([key, value]) => {\n        if (key === 'attrs' && isEmptyObject(value)) {\n            return false;\n        }\n        return value !== null && value !== undefined;\n    }));\n}\n/**\n * Creates a new Prosemirror schema based on the given extensions.\n * @param extensions An array of Tiptap extensions\n * @param editor The editor instance\n * @returns A Prosemirror schema\n */\nfunction getSchemaByResolvedExtensions(extensions, editor) {\n    var _a;\n    const allAttributes = getAttributesFromExtensions(extensions);\n    const { nodeExtensions, markExtensions } = splitExtensions(extensions);\n    const topNode = (_a = nodeExtensions.find(extension => getExtensionField(extension, 'topNode'))) === null || _a === void 0 ? void 0 : _a.name;\n    const nodes = Object.fromEntries(nodeExtensions.map(extension => {\n        const extensionAttributes = allAttributes.filter(attribute => attribute.type === extension.name);\n        const context = {\n            name: extension.name,\n            options: extension.options,\n            storage: extension.storage,\n            editor,\n        };\n        const extraNodeFields = extensions.reduce((fields, e) => {\n            const extendNodeSchema = getExtensionField(e, 'extendNodeSchema', context);\n            return {\n                ...fields,\n                ...(extendNodeSchema ? extendNodeSchema(extension) : {}),\n            };\n        }, {});\n        const schema = cleanUpSchemaItem({\n            ...extraNodeFields,\n            content: callOrReturn(getExtensionField(extension, 'content', context)),\n            marks: callOrReturn(getExtensionField(extension, 'marks', context)),\n            group: callOrReturn(getExtensionField(extension, 'group', context)),\n            inline: callOrReturn(getExtensionField(extension, 'inline', context)),\n            atom: callOrReturn(getExtensionField(extension, 'atom', context)),\n            selectable: callOrReturn(getExtensionField(extension, 'selectable', context)),\n            draggable: callOrReturn(getExtensionField(extension, 'draggable', context)),\n            code: callOrReturn(getExtensionField(extension, 'code', context)),\n            whitespace: callOrReturn(getExtensionField(extension, 'whitespace', context)),\n            linebreakReplacement: callOrReturn(getExtensionField(extension, 'linebreakReplacement', context)),\n            defining: callOrReturn(getExtensionField(extension, 'defining', context)),\n            isolating: callOrReturn(getExtensionField(extension, 'isolating', context)),\n            attrs: Object.fromEntries(extensionAttributes.map(extensionAttribute => {\n                var _a;\n                return [extensionAttribute.name, { default: (_a = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a === void 0 ? void 0 : _a.default }];\n            })),\n        });\n        const parseHTML = callOrReturn(getExtensionField(extension, 'parseHTML', context));\n        if (parseHTML) {\n            schema.parseDOM = parseHTML.map(parseRule => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));\n        }\n        const renderHTML = getExtensionField(extension, 'renderHTML', context);\n        if (renderHTML) {\n            schema.toDOM = node => renderHTML({\n                node,\n                HTMLAttributes: getRenderedAttributes(node, extensionAttributes),\n            });\n        }\n        const renderText = getExtensionField(extension, 'renderText', context);\n        if (renderText) {\n            schema.toText = renderText;\n        }\n        return [extension.name, schema];\n    }));\n    const marks = Object.fromEntries(markExtensions.map(extension => {\n        const extensionAttributes = allAttributes.filter(attribute => attribute.type === extension.name);\n        const context = {\n            name: extension.name,\n            options: extension.options,\n            storage: extension.storage,\n            editor,\n        };\n        const extraMarkFields = extensions.reduce((fields, e) => {\n            const extendMarkSchema = getExtensionField(e, 'extendMarkSchema', context);\n            return {\n                ...fields,\n                ...(extendMarkSchema ? extendMarkSchema(extension) : {}),\n            };\n        }, {});\n        const schema = cleanUpSchemaItem({\n            ...extraMarkFields,\n            inclusive: callOrReturn(getExtensionField(extension, 'inclusive', context)),\n            excludes: callOrReturn(getExtensionField(extension, 'excludes', context)),\n            group: callOrReturn(getExtensionField(extension, 'group', context)),\n            spanning: callOrReturn(getExtensionField(extension, 'spanning', context)),\n            code: callOrReturn(getExtensionField(extension, 'code', context)),\n            attrs: Object.fromEntries(extensionAttributes.map(extensionAttribute => {\n                var _a;\n                return [extensionAttribute.name, { default: (_a = extensionAttribute === null || extensionAttribute === void 0 ? void 0 : extensionAttribute.attribute) === null || _a === void 0 ? void 0 : _a.default }];\n            })),\n        });\n        const parseHTML = callOrReturn(getExtensionField(extension, 'parseHTML', context));\n        if (parseHTML) {\n            schema.parseDOM = parseHTML.map(parseRule => injectExtensionAttributesToParseRule(parseRule, extensionAttributes));\n        }\n        const renderHTML = getExtensionField(extension, 'renderHTML', context);\n        if (renderHTML) {\n            schema.toDOM = mark => renderHTML({\n                mark,\n                HTMLAttributes: getRenderedAttributes(mark, extensionAttributes),\n            });\n        }\n        return [extension.name, schema];\n    }));\n    return new _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Schema({\n        topNode,\n        nodes,\n        marks,\n    });\n}\n\n/**\n * Tries to get a node or mark type by its name.\n * @param name The name of the node or mark type\n * @param schema The Prosemiror schema to search in\n * @returns The node or mark type, or null if it doesn't exist\n */\nfunction getSchemaTypeByName(name, schema) {\n    return schema.nodes[name] || schema.marks[name] || null;\n}\n\nfunction isExtensionRulesEnabled(extension, enabled) {\n    if (Array.isArray(enabled)) {\n        return enabled.some(enabledExtension => {\n            const name = typeof enabledExtension === 'string'\n                ? enabledExtension\n                : enabledExtension.name;\n            return name === extension.name;\n        });\n    }\n    return enabled;\n}\n\nfunction getHTMLFromFragment(fragment, schema) {\n    const documentFragment = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.DOMSerializer.fromSchema(schema).serializeFragment(fragment);\n    const temporaryDocument = document.implementation.createHTMLDocument();\n    const container = temporaryDocument.createElement('div');\n    container.appendChild(documentFragment);\n    return container.innerHTML;\n}\n\n/**\n * Returns the text content of a resolved prosemirror position\n * @param $from The resolved position to get the text content from\n * @param maxMatch The maximum number of characters to match\n * @returns The text content\n */\nconst getTextContentFromNodes = ($from, maxMatch = 500) => {\n    let textBefore = '';\n    const sliceEndPos = $from.parentOffset;\n    $from.parent.nodesBetween(Math.max(0, sliceEndPos - maxMatch), sliceEndPos, (node, pos, parent, index) => {\n        var _a, _b;\n        const chunk = ((_b = (_a = node.type.spec).toText) === null || _b === void 0 ? void 0 : _b.call(_a, {\n            node,\n            pos,\n            parent,\n            index,\n        }))\n            || node.textContent\n            || '%leaf%';\n        textBefore += node.isAtom && !node.isText ? chunk : chunk.slice(0, Math.max(0, sliceEndPos - pos));\n    });\n    return textBefore;\n};\n\nfunction isRegExp(value) {\n    return Object.prototype.toString.call(value) === '[object RegExp]';\n}\n\nclass InputRule {\n    constructor(config) {\n        this.find = config.find;\n        this.handler = config.handler;\n    }\n}\nconst inputRuleMatcherHandler = (text, find) => {\n    if (isRegExp(find)) {\n        return find.exec(text);\n    }\n    const inputRuleMatch = find(text);\n    if (!inputRuleMatch) {\n        return null;\n    }\n    const result = [inputRuleMatch.text];\n    result.index = inputRuleMatch.index;\n    result.input = text;\n    result.data = inputRuleMatch.data;\n    if (inputRuleMatch.replaceWith) {\n        if (!inputRuleMatch.text.includes(inputRuleMatch.replaceWith)) {\n            console.warn('[tiptap warn]: \"inputRuleMatch.replaceWith\" must be part of \"inputRuleMatch.text\".');\n        }\n        result.push(inputRuleMatch.replaceWith);\n    }\n    return result;\n};\nfunction run$1(config) {\n    var _a;\n    const { editor, from, to, text, rules, plugin, } = config;\n    const { view } = editor;\n    if (view.composing) {\n        return false;\n    }\n    const $from = view.state.doc.resolve(from);\n    if (\n    // check for code node\n    $from.parent.type.spec.code\n        // check for code mark\n        || !!((_a = ($from.nodeBefore || $from.nodeAfter)) === null || _a === void 0 ? void 0 : _a.marks.find(mark => mark.type.spec.code))) {\n        return false;\n    }\n    let matched = false;\n    const textBefore = getTextContentFromNodes($from) + text;\n    rules.forEach(rule => {\n        if (matched) {\n            return;\n        }\n        const match = inputRuleMatcherHandler(textBefore, rule.find);\n        if (!match) {\n            return;\n        }\n        const tr = view.state.tr;\n        const state = createChainableState({\n            state: view.state,\n            transaction: tr,\n        });\n        const range = {\n            from: from - (match[0].length - text.length),\n            to,\n        };\n        const { commands, chain, can } = new CommandManager({\n            editor,\n            state,\n        });\n        const handler = rule.handler({\n            state,\n            range,\n            match,\n            commands,\n            chain,\n            can,\n        });\n        // stop if there are no changes\n        if (handler === null || !tr.steps.length) {\n            return;\n        }\n        // store transform as meta data\n        // so we can undo input rules within the `undoInputRules` command\n        tr.setMeta(plugin, {\n            transform: tr,\n            from,\n            to,\n            text,\n        });\n        view.dispatch(tr);\n        matched = true;\n    });\n    return matched;\n}\n/**\n * Create an input rules plugin. When enabled, it will cause text\n * input that matches any of the given rules to trigger the rule’s\n * action.\n */\nfunction inputRulesPlugin(props) {\n    const { editor, rules } = props;\n    const plugin = new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        state: {\n            init() {\n                return null;\n            },\n            apply(tr, prev, state) {\n                const stored = tr.getMeta(plugin);\n                if (stored) {\n                    return stored;\n                }\n                // if InputRule is triggered by insertContent()\n                const simulatedInputMeta = tr.getMeta('applyInputRules');\n                const isSimulatedInput = !!simulatedInputMeta;\n                if (isSimulatedInput) {\n                    setTimeout(() => {\n                        let { text } = simulatedInputMeta;\n                        if (typeof text === 'string') {\n                            text = text;\n                        }\n                        else {\n                            text = getHTMLFromFragment(_tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment.from(text), state.schema);\n                        }\n                        const { from } = simulatedInputMeta;\n                        const to = from + text.length;\n                        run$1({\n                            editor,\n                            from,\n                            to,\n                            text,\n                            rules,\n                            plugin,\n                        });\n                    });\n                }\n                return tr.selectionSet || tr.docChanged ? null : prev;\n            },\n        },\n        props: {\n            handleTextInput(view, from, to, text) {\n                return run$1({\n                    editor,\n                    from,\n                    to,\n                    text,\n                    rules,\n                    plugin,\n                });\n            },\n            handleDOMEvents: {\n                compositionend: view => {\n                    setTimeout(() => {\n                        const { $cursor } = view.state.selection;\n                        if ($cursor) {\n                            run$1({\n                                editor,\n                                from: $cursor.pos,\n                                to: $cursor.pos,\n                                text: '',\n                                rules,\n                                plugin,\n                            });\n                        }\n                    });\n                    return false;\n                },\n            },\n            // add support for input rules to trigger on enter\n            // this is useful for example for code blocks\n            handleKeyDown(view, event) {\n                if (event.key !== 'Enter') {\n                    return false;\n                }\n                const { $cursor } = view.state.selection;\n                if ($cursor) {\n                    return run$1({\n                        editor,\n                        from: $cursor.pos,\n                        to: $cursor.pos,\n                        text: '\\n',\n                        rules,\n                        plugin,\n                    });\n                }\n                return false;\n            },\n        },\n        // @ts-ignore\n        isInputRules: true,\n    });\n    return plugin;\n}\n\n// see: https://github.com/mesqueeb/is-what/blob/88d6e4ca92fb2baab6003c54e02eedf4e729e5ab/src/index.ts\nfunction getType(value) {\n    return Object.prototype.toString.call(value).slice(8, -1);\n}\nfunction isPlainObject(value) {\n    if (getType(value) !== 'Object') {\n        return false;\n    }\n    return value.constructor === Object && Object.getPrototypeOf(value) === Object.prototype;\n}\n\nfunction mergeDeep(target, source) {\n    const output = { ...target };\n    if (isPlainObject(target) && isPlainObject(source)) {\n        Object.keys(source).forEach(key => {\n            if (isPlainObject(source[key]) && isPlainObject(target[key])) {\n                output[key] = mergeDeep(target[key], source[key]);\n            }\n            else {\n                output[key] = source[key];\n            }\n        });\n    }\n    return output;\n}\n\n/**\n * The Mark class is used to create custom mark extensions.\n * @see https://tiptap.dev/api/extensions#create-a-new-extension\n */\nclass Mark {\n    constructor(config = {}) {\n        this.type = 'mark';\n        this.name = 'mark';\n        this.parent = null;\n        this.child = null;\n        this.config = {\n            name: this.name,\n            defaultOptions: {},\n        };\n        this.config = {\n            ...this.config,\n            ...config,\n        };\n        this.name = this.config.name;\n        if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {\n            console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`);\n        }\n        // TODO: remove `addOptions` fallback\n        this.options = this.config.defaultOptions;\n        if (this.config.addOptions) {\n            this.options = callOrReturn(getExtensionField(this, 'addOptions', {\n                name: this.name,\n            }));\n        }\n        this.storage = callOrReturn(getExtensionField(this, 'addStorage', {\n            name: this.name,\n            options: this.options,\n        })) || {};\n    }\n    static create(config = {}) {\n        return new Mark(config);\n    }\n    configure(options = {}) {\n        // return a new instance so we can use the same extension\n        // with different calls of `configure`\n        const extension = this.extend({\n            ...this.config,\n            addOptions: () => {\n                return mergeDeep(this.options, options);\n            },\n        });\n        // Always preserve the current name\n        extension.name = this.name;\n        // Set the parent to be our parent\n        extension.parent = this.parent;\n        return extension;\n    }\n    extend(extendedConfig = {}) {\n        const extension = new Mark(extendedConfig);\n        extension.parent = this;\n        this.child = extension;\n        extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;\n        if (extendedConfig.defaultOptions && Object.keys(extendedConfig.defaultOptions).length > 0) {\n            console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`);\n        }\n        extension.options = callOrReturn(getExtensionField(extension, 'addOptions', {\n            name: extension.name,\n        }));\n        extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\n            name: extension.name,\n            options: extension.options,\n        }));\n        return extension;\n    }\n    static handleExit({ editor, mark }) {\n        const { tr } = editor.state;\n        const currentPos = editor.state.selection.$from;\n        const isAtEnd = currentPos.pos === currentPos.end();\n        if (isAtEnd) {\n            const currentMarks = currentPos.marks();\n            const isInMark = !!currentMarks.find(m => (m === null || m === void 0 ? void 0 : m.type.name) === mark.name);\n            if (!isInMark) {\n                return false;\n            }\n            const removeMark = currentMarks.find(m => (m === null || m === void 0 ? void 0 : m.type.name) === mark.name);\n            if (removeMark) {\n                tr.removeStoredMark(removeMark);\n            }\n            tr.insertText(' ', currentPos.pos);\n            editor.view.dispatch(tr);\n            return true;\n        }\n        return false;\n    }\n}\n\nfunction isNumber(value) {\n    return typeof value === 'number';\n}\n\n/**\n * Paste rules are used to react to pasted content.\n * @see https://tiptap.dev/docs/editor/extensions/custom-extensions/extend-existing#paste-rules\n */\nclass PasteRule {\n    constructor(config) {\n        this.find = config.find;\n        this.handler = config.handler;\n    }\n}\nconst pasteRuleMatcherHandler = (text, find, event) => {\n    if (isRegExp(find)) {\n        return [...text.matchAll(find)];\n    }\n    const matches = find(text, event);\n    if (!matches) {\n        return [];\n    }\n    return matches.map(pasteRuleMatch => {\n        const result = [pasteRuleMatch.text];\n        result.index = pasteRuleMatch.index;\n        result.input = text;\n        result.data = pasteRuleMatch.data;\n        if (pasteRuleMatch.replaceWith) {\n            if (!pasteRuleMatch.text.includes(pasteRuleMatch.replaceWith)) {\n                console.warn('[tiptap warn]: \"pasteRuleMatch.replaceWith\" must be part of \"pasteRuleMatch.text\".');\n            }\n            result.push(pasteRuleMatch.replaceWith);\n        }\n        return result;\n    });\n};\nfunction run(config) {\n    const { editor, state, from, to, rule, pasteEvent, dropEvent, } = config;\n    const { commands, chain, can } = new CommandManager({\n        editor,\n        state,\n    });\n    const handlers = [];\n    state.doc.nodesBetween(from, to, (node, pos) => {\n        if (!node.isTextblock || node.type.spec.code) {\n            return;\n        }\n        const resolvedFrom = Math.max(from, pos);\n        const resolvedTo = Math.min(to, pos + node.content.size);\n        const textToMatch = node.textBetween(resolvedFrom - pos, resolvedTo - pos, undefined, '\\ufffc');\n        const matches = pasteRuleMatcherHandler(textToMatch, rule.find, pasteEvent);\n        matches.forEach(match => {\n            if (match.index === undefined) {\n                return;\n            }\n            const start = resolvedFrom + match.index + 1;\n            const end = start + match[0].length;\n            const range = {\n                from: state.tr.mapping.map(start),\n                to: state.tr.mapping.map(end),\n            };\n            const handler = rule.handler({\n                state,\n                range,\n                match,\n                commands,\n                chain,\n                can,\n                pasteEvent,\n                dropEvent,\n            });\n            handlers.push(handler);\n        });\n    });\n    const success = handlers.every(handler => handler !== null);\n    return success;\n}\n// When dragging across editors, must get another editor instance to delete selection content.\nlet tiptapDragFromOtherEditor = null;\nconst createClipboardPasteEvent = (text) => {\n    var _a;\n    const event = new ClipboardEvent('paste', {\n        clipboardData: new DataTransfer(),\n    });\n    (_a = event.clipboardData) === null || _a === void 0 ? void 0 : _a.setData('text/html', text);\n    return event;\n};\n/**\n * Create an paste rules plugin. When enabled, it will cause pasted\n * text that matches any of the given rules to trigger the rule’s\n * action.\n */\nfunction pasteRulesPlugin(props) {\n    const { editor, rules } = props;\n    let dragSourceElement = null;\n    let isPastedFromProseMirror = false;\n    let isDroppedFromProseMirror = false;\n    let pasteEvent = typeof ClipboardEvent !== 'undefined' ? new ClipboardEvent('paste') : null;\n    let dropEvent;\n    try {\n        dropEvent = typeof DragEvent !== 'undefined' ? new DragEvent('drop') : null;\n    }\n    catch {\n        dropEvent = null;\n    }\n    const processEvent = ({ state, from, to, rule, pasteEvt, }) => {\n        const tr = state.tr;\n        const chainableState = createChainableState({\n            state,\n            transaction: tr,\n        });\n        const handler = run({\n            editor,\n            state: chainableState,\n            from: Math.max(from - 1, 0),\n            to: to.b - 1,\n            rule,\n            pasteEvent: pasteEvt,\n            dropEvent,\n        });\n        if (!handler || !tr.steps.length) {\n            return;\n        }\n        try {\n            dropEvent = typeof DragEvent !== 'undefined' ? new DragEvent('drop') : null;\n        }\n        catch {\n            dropEvent = null;\n        }\n        pasteEvent = typeof ClipboardEvent !== 'undefined' ? new ClipboardEvent('paste') : null;\n        return tr;\n    };\n    const plugins = rules.map(rule => {\n        return new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n            // we register a global drag handler to track the current drag source element\n            view(view) {\n                const handleDragstart = (event) => {\n                    var _a;\n                    dragSourceElement = ((_a = view.dom.parentElement) === null || _a === void 0 ? void 0 : _a.contains(event.target))\n                        ? view.dom.parentElement\n                        : null;\n                    if (dragSourceElement) {\n                        tiptapDragFromOtherEditor = editor;\n                    }\n                };\n                const handleDragend = () => {\n                    if (tiptapDragFromOtherEditor) {\n                        tiptapDragFromOtherEditor = null;\n                    }\n                };\n                window.addEventListener('dragstart', handleDragstart);\n                window.addEventListener('dragend', handleDragend);\n                return {\n                    destroy() {\n                        window.removeEventListener('dragstart', handleDragstart);\n                        window.removeEventListener('dragend', handleDragend);\n                    },\n                };\n            },\n            props: {\n                handleDOMEvents: {\n                    drop: (view, event) => {\n                        isDroppedFromProseMirror = dragSourceElement === view.dom.parentElement;\n                        dropEvent = event;\n                        if (!isDroppedFromProseMirror) {\n                            const dragFromOtherEditor = tiptapDragFromOtherEditor;\n                            if (dragFromOtherEditor === null || dragFromOtherEditor === void 0 ? void 0 : dragFromOtherEditor.isEditable) {\n                                // setTimeout to avoid the wrong content after drop, timeout arg can't be empty or 0\n                                setTimeout(() => {\n                                    const selection = dragFromOtherEditor.state.selection;\n                                    if (selection) {\n                                        dragFromOtherEditor.commands.deleteRange({ from: selection.from, to: selection.to });\n                                    }\n                                }, 10);\n                            }\n                        }\n                        return false;\n                    },\n                    paste: (_view, event) => {\n                        var _a;\n                        const html = (_a = event.clipboardData) === null || _a === void 0 ? void 0 : _a.getData('text/html');\n                        pasteEvent = event;\n                        isPastedFromProseMirror = !!(html === null || html === void 0 ? void 0 : html.includes('data-pm-slice'));\n                        return false;\n                    },\n                },\n            },\n            appendTransaction: (transactions, oldState, state) => {\n                const transaction = transactions[0];\n                const isPaste = transaction.getMeta('uiEvent') === 'paste' && !isPastedFromProseMirror;\n                const isDrop = transaction.getMeta('uiEvent') === 'drop' && !isDroppedFromProseMirror;\n                // if PasteRule is triggered by insertContent()\n                const simulatedPasteMeta = transaction.getMeta('applyPasteRules');\n                const isSimulatedPaste = !!simulatedPasteMeta;\n                if (!isPaste && !isDrop && !isSimulatedPaste) {\n                    return;\n                }\n                // Handle simulated paste\n                if (isSimulatedPaste) {\n                    let { text } = simulatedPasteMeta;\n                    if (typeof text === 'string') {\n                        text = text;\n                    }\n                    else {\n                        text = getHTMLFromFragment(_tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment.from(text), state.schema);\n                    }\n                    const { from } = simulatedPasteMeta;\n                    const to = from + text.length;\n                    const pasteEvt = createClipboardPasteEvent(text);\n                    return processEvent({\n                        rule,\n                        state,\n                        from,\n                        to: { b: to },\n                        pasteEvt,\n                    });\n                }\n                // handle actual paste/drop\n                const from = oldState.doc.content.findDiffStart(state.doc.content);\n                const to = oldState.doc.content.findDiffEnd(state.doc.content);\n                // stop if there is no changed range\n                if (!isNumber(from) || !to || from === to.b) {\n                    return;\n                }\n                return processEvent({\n                    rule,\n                    state,\n                    from,\n                    to,\n                    pasteEvt: pasteEvent,\n                });\n            },\n        });\n    });\n    return plugins;\n}\n\nfunction findDuplicates(items) {\n    const filtered = items.filter((el, index) => items.indexOf(el) !== index);\n    return Array.from(new Set(filtered));\n}\n\nclass ExtensionManager {\n    constructor(extensions, editor) {\n        this.splittableMarks = [];\n        this.editor = editor;\n        this.extensions = ExtensionManager.resolve(extensions);\n        this.schema = getSchemaByResolvedExtensions(this.extensions, editor);\n        this.setupExtensions();\n    }\n    /**\n     * Returns a flattened and sorted extension list while\n     * also checking for duplicated extensions and warns the user.\n     * @param extensions An array of Tiptap extensions\n     * @returns An flattened and sorted array of Tiptap extensions\n     */\n    static resolve(extensions) {\n        const resolvedExtensions = ExtensionManager.sort(ExtensionManager.flatten(extensions));\n        const duplicatedNames = findDuplicates(resolvedExtensions.map(extension => extension.name));\n        if (duplicatedNames.length) {\n            console.warn(`[tiptap warn]: Duplicate extension names found: [${duplicatedNames\n                .map(item => `'${item}'`)\n                .join(', ')}]. This can lead to issues.`);\n        }\n        return resolvedExtensions;\n    }\n    /**\n     * Create a flattened array of extensions by traversing the `addExtensions` field.\n     * @param extensions An array of Tiptap extensions\n     * @returns A flattened array of Tiptap extensions\n     */\n    static flatten(extensions) {\n        return (extensions\n            .map(extension => {\n            const context = {\n                name: extension.name,\n                options: extension.options,\n                storage: extension.storage,\n            };\n            const addExtensions = getExtensionField(extension, 'addExtensions', context);\n            if (addExtensions) {\n                return [extension, ...this.flatten(addExtensions())];\n            }\n            return extension;\n        })\n            // `Infinity` will break TypeScript so we set a number that is probably high enough\n            .flat(10));\n    }\n    /**\n     * Sort extensions by priority.\n     * @param extensions An array of Tiptap extensions\n     * @returns A sorted array of Tiptap extensions by priority\n     */\n    static sort(extensions) {\n        const defaultPriority = 100;\n        return extensions.sort((a, b) => {\n            const priorityA = getExtensionField(a, 'priority') || defaultPriority;\n            const priorityB = getExtensionField(b, 'priority') || defaultPriority;\n            if (priorityA > priorityB) {\n                return -1;\n            }\n            if (priorityA < priorityB) {\n                return 1;\n            }\n            return 0;\n        });\n    }\n    /**\n     * Get all commands from the extensions.\n     * @returns An object with all commands where the key is the command name and the value is the command function\n     */\n    get commands() {\n        return this.extensions.reduce((commands, extension) => {\n            const context = {\n                name: extension.name,\n                options: extension.options,\n                storage: extension.storage,\n                editor: this.editor,\n                type: getSchemaTypeByName(extension.name, this.schema),\n            };\n            const addCommands = getExtensionField(extension, 'addCommands', context);\n            if (!addCommands) {\n                return commands;\n            }\n            return {\n                ...commands,\n                ...addCommands(),\n            };\n        }, {});\n    }\n    /**\n     * Get all registered Prosemirror plugins from the extensions.\n     * @returns An array of Prosemirror plugins\n     */\n    get plugins() {\n        const { editor } = this;\n        // With ProseMirror, first plugins within an array are executed first.\n        // In Tiptap, we provide the ability to override plugins,\n        // so it feels more natural to run plugins at the end of an array first.\n        // That’s why we have to reverse the `extensions` array and sort again\n        // based on the `priority` option.\n        const extensions = ExtensionManager.sort([...this.extensions].reverse());\n        const inputRules = [];\n        const pasteRules = [];\n        const allPlugins = extensions\n            .map(extension => {\n            const context = {\n                name: extension.name,\n                options: extension.options,\n                storage: extension.storage,\n                editor,\n                type: getSchemaTypeByName(extension.name, this.schema),\n            };\n            const plugins = [];\n            const addKeyboardShortcuts = getExtensionField(extension, 'addKeyboardShortcuts', context);\n            let defaultBindings = {};\n            // bind exit handling\n            if (extension.type === 'mark' && getExtensionField(extension, 'exitable', context)) {\n                defaultBindings.ArrowRight = () => Mark.handleExit({ editor, mark: extension });\n            }\n            if (addKeyboardShortcuts) {\n                const bindings = Object.fromEntries(Object.entries(addKeyboardShortcuts()).map(([shortcut, method]) => {\n                    return [shortcut, () => method({ editor })];\n                }));\n                defaultBindings = { ...defaultBindings, ...bindings };\n            }\n            const keyMapPlugin = (0,_tiptap_pm_keymap__WEBPACK_IMPORTED_MODULE_2__.keymap)(defaultBindings);\n            plugins.push(keyMapPlugin);\n            const addInputRules = getExtensionField(extension, 'addInputRules', context);\n            if (isExtensionRulesEnabled(extension, editor.options.enableInputRules) && addInputRules) {\n                inputRules.push(...addInputRules());\n            }\n            const addPasteRules = getExtensionField(extension, 'addPasteRules', context);\n            if (isExtensionRulesEnabled(extension, editor.options.enablePasteRules) && addPasteRules) {\n                pasteRules.push(...addPasteRules());\n            }\n            const addProseMirrorPlugins = getExtensionField(extension, 'addProseMirrorPlugins', context);\n            if (addProseMirrorPlugins) {\n                const proseMirrorPlugins = addProseMirrorPlugins();\n                plugins.push(...proseMirrorPlugins);\n            }\n            return plugins;\n        })\n            .flat();\n        return [\n            inputRulesPlugin({\n                editor,\n                rules: inputRules,\n            }),\n            ...pasteRulesPlugin({\n                editor,\n                rules: pasteRules,\n            }),\n            ...allPlugins,\n        ];\n    }\n    /**\n     * Get all attributes from the extensions.\n     * @returns An array of attributes\n     */\n    get attributes() {\n        return getAttributesFromExtensions(this.extensions);\n    }\n    /**\n     * Get all node views from the extensions.\n     * @returns An object with all node views where the key is the node name and the value is the node view function\n     */\n    get nodeViews() {\n        const { editor } = this;\n        const { nodeExtensions } = splitExtensions(this.extensions);\n        return Object.fromEntries(nodeExtensions\n            .filter(extension => !!getExtensionField(extension, 'addNodeView'))\n            .map(extension => {\n            const extensionAttributes = this.attributes.filter(attribute => attribute.type === extension.name);\n            const context = {\n                name: extension.name,\n                options: extension.options,\n                storage: extension.storage,\n                editor,\n                type: getNodeType(extension.name, this.schema),\n            };\n            const addNodeView = getExtensionField(extension, 'addNodeView', context);\n            if (!addNodeView) {\n                return [];\n            }\n            const nodeview = (node, view, getPos, decorations, innerDecorations) => {\n                const HTMLAttributes = getRenderedAttributes(node, extensionAttributes);\n                return addNodeView()({\n                    // pass-through\n                    node,\n                    view,\n                    getPos: getPos,\n                    decorations,\n                    innerDecorations,\n                    // tiptap-specific\n                    editor,\n                    extension,\n                    HTMLAttributes,\n                });\n            };\n            return [extension.name, nodeview];\n        }));\n    }\n    /**\n     * Go through all extensions, create extension storages & setup marks\n     * & bind editor event listener.\n     */\n    setupExtensions() {\n        this.extensions.forEach(extension => {\n            var _a;\n            // store extension storage in editor\n            this.editor.extensionStorage[extension.name] = extension.storage;\n            const context = {\n                name: extension.name,\n                options: extension.options,\n                storage: extension.storage,\n                editor: this.editor,\n                type: getSchemaTypeByName(extension.name, this.schema),\n            };\n            if (extension.type === 'mark') {\n                const keepOnSplit = (_a = callOrReturn(getExtensionField(extension, 'keepOnSplit', context))) !== null && _a !== void 0 ? _a : true;\n                if (keepOnSplit) {\n                    this.splittableMarks.push(extension.name);\n                }\n            }\n            const onBeforeCreate = getExtensionField(extension, 'onBeforeCreate', context);\n            const onCreate = getExtensionField(extension, 'onCreate', context);\n            const onUpdate = getExtensionField(extension, 'onUpdate', context);\n            const onSelectionUpdate = getExtensionField(extension, 'onSelectionUpdate', context);\n            const onTransaction = getExtensionField(extension, 'onTransaction', context);\n            const onFocus = getExtensionField(extension, 'onFocus', context);\n            const onBlur = getExtensionField(extension, 'onBlur', context);\n            const onDestroy = getExtensionField(extension, 'onDestroy', context);\n            if (onBeforeCreate) {\n                this.editor.on('beforeCreate', onBeforeCreate);\n            }\n            if (onCreate) {\n                this.editor.on('create', onCreate);\n            }\n            if (onUpdate) {\n                this.editor.on('update', onUpdate);\n            }\n            if (onSelectionUpdate) {\n                this.editor.on('selectionUpdate', onSelectionUpdate);\n            }\n            if (onTransaction) {\n                this.editor.on('transaction', onTransaction);\n            }\n            if (onFocus) {\n                this.editor.on('focus', onFocus);\n            }\n            if (onBlur) {\n                this.editor.on('blur', onBlur);\n            }\n            if (onDestroy) {\n                this.editor.on('destroy', onDestroy);\n            }\n        });\n    }\n}\n\n/**\n * The Extension class is the base class for all extensions.\n * @see https://tiptap.dev/api/extensions#create-a-new-extension\n */\nclass Extension {\n    constructor(config = {}) {\n        this.type = 'extension';\n        this.name = 'extension';\n        this.parent = null;\n        this.child = null;\n        this.config = {\n            name: this.name,\n            defaultOptions: {},\n        };\n        this.config = {\n            ...this.config,\n            ...config,\n        };\n        this.name = this.config.name;\n        if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {\n            console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`);\n        }\n        // TODO: remove `addOptions` fallback\n        this.options = this.config.defaultOptions;\n        if (this.config.addOptions) {\n            this.options = callOrReturn(getExtensionField(this, 'addOptions', {\n                name: this.name,\n            }));\n        }\n        this.storage = callOrReturn(getExtensionField(this, 'addStorage', {\n            name: this.name,\n            options: this.options,\n        })) || {};\n    }\n    static create(config = {}) {\n        return new Extension(config);\n    }\n    configure(options = {}) {\n        // return a new instance so we can use the same extension\n        // with different calls of `configure`\n        const extension = this.extend({\n            ...this.config,\n            addOptions: () => {\n                return mergeDeep(this.options, options);\n            },\n        });\n        // Always preserve the current name\n        extension.name = this.name;\n        // Set the parent to be our parent\n        extension.parent = this.parent;\n        return extension;\n    }\n    extend(extendedConfig = {}) {\n        const extension = new Extension({ ...this.config, ...extendedConfig });\n        extension.parent = this;\n        this.child = extension;\n        extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;\n        if (extendedConfig.defaultOptions && Object.keys(extendedConfig.defaultOptions).length > 0) {\n            console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`);\n        }\n        extension.options = callOrReturn(getExtensionField(extension, 'addOptions', {\n            name: extension.name,\n        }));\n        extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\n            name: extension.name,\n            options: extension.options,\n        }));\n        return extension;\n    }\n}\n\n/**\n * Gets the text between two positions in a Prosemirror node\n * and serializes it using the given text serializers and block separator (see getText)\n * @param startNode The Prosemirror node to start from\n * @param range The range of the text to get\n * @param options Options for the text serializer & block separator\n * @returns The text between the two positions\n */\nfunction getTextBetween(startNode, range, options) {\n    const { from, to } = range;\n    const { blockSeparator = '\\n\\n', textSerializers = {} } = options || {};\n    let text = '';\n    startNode.nodesBetween(from, to, (node, pos, parent, index) => {\n        var _a;\n        if (node.isBlock && pos > from) {\n            text += blockSeparator;\n        }\n        const textSerializer = textSerializers === null || textSerializers === void 0 ? void 0 : textSerializers[node.type.name];\n        if (textSerializer) {\n            if (parent) {\n                text += textSerializer({\n                    node,\n                    pos,\n                    parent,\n                    index,\n                    range,\n                });\n            }\n            // do not descend into child nodes when there exists a serializer\n            return false;\n        }\n        if (node.isText) {\n            text += (_a = node === null || node === void 0 ? void 0 : node.text) === null || _a === void 0 ? void 0 : _a.slice(Math.max(from, pos) - pos, to - pos); // eslint-disable-line\n        }\n    });\n    return text;\n}\n\n/**\n * Find text serializers `toText` in a Prosemirror schema\n * @param schema The Prosemirror schema to search in\n * @returns A record of text serializers by node name\n */\nfunction getTextSerializersFromSchema(schema) {\n    return Object.fromEntries(Object.entries(schema.nodes)\n        .filter(([, node]) => node.spec.toText)\n        .map(([name, node]) => [name, node.spec.toText]));\n}\n\nconst ClipboardTextSerializer = Extension.create({\n    name: 'clipboardTextSerializer',\n    addOptions() {\n        return {\n            blockSeparator: undefined,\n        };\n    },\n    addProseMirrorPlugins() {\n        return [\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n                key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey('clipboardTextSerializer'),\n                props: {\n                    clipboardTextSerializer: () => {\n                        const { editor } = this;\n                        const { state, schema } = editor;\n                        const { doc, selection } = state;\n                        const { ranges } = selection;\n                        const from = Math.min(...ranges.map(range => range.$from.pos));\n                        const to = Math.max(...ranges.map(range => range.$to.pos));\n                        const textSerializers = getTextSerializersFromSchema(schema);\n                        const range = { from, to };\n                        return getTextBetween(doc, range, {\n                            ...(this.options.blockSeparator !== undefined\n                                ? { blockSeparator: this.options.blockSeparator }\n                                : {}),\n                            textSerializers,\n                        });\n                    },\n                },\n            }),\n        ];\n    },\n});\n\nconst blur = () => ({ editor, view }) => {\n    requestAnimationFrame(() => {\n        var _a;\n        if (!editor.isDestroyed) {\n            view.dom.blur();\n            // Browsers should remove the caret on blur but safari does not.\n            // See: https://github.com/ueberdosis/tiptap/issues/2405\n            (_a = window === null || window === void 0 ? void 0 : window.getSelection()) === null || _a === void 0 ? void 0 : _a.removeAllRanges();\n        }\n    });\n    return true;\n};\n\nconst clearContent = (emitUpdate = false) => ({ commands }) => {\n    return commands.setContent('', emitUpdate);\n};\n\nconst clearNodes = () => ({ state, tr, dispatch }) => {\n    const { selection } = tr;\n    const { ranges } = selection;\n    if (!dispatch) {\n        return true;\n    }\n    ranges.forEach(({ $from, $to }) => {\n        state.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {\n            if (node.type.isText) {\n                return;\n            }\n            const { doc, mapping } = tr;\n            const $mappedFrom = doc.resolve(mapping.map(pos));\n            const $mappedTo = doc.resolve(mapping.map(pos + node.nodeSize));\n            const nodeRange = $mappedFrom.blockRange($mappedTo);\n            if (!nodeRange) {\n                return;\n            }\n            const targetLiftDepth = (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.liftTarget)(nodeRange);\n            if (node.type.isTextblock) {\n                const { defaultType } = $mappedFrom.parent.contentMatchAt($mappedFrom.index());\n                tr.setNodeMarkup(nodeRange.start, defaultType);\n            }\n            if (targetLiftDepth || targetLiftDepth === 0) {\n                tr.lift(nodeRange, targetLiftDepth);\n            }\n        });\n    });\n    return true;\n};\n\nconst command = fn => props => {\n    return fn(props);\n};\n\nconst createParagraphNear = () => ({ state, dispatch }) => {\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.createParagraphNear)(state, dispatch);\n};\n\nconst cut = (originRange, targetPos) => ({ editor, tr }) => {\n    const { state } = editor;\n    const contentSlice = state.doc.slice(originRange.from, originRange.to);\n    tr.deleteRange(originRange.from, originRange.to);\n    const newPos = tr.mapping.map(targetPos);\n    tr.insert(newPos, contentSlice.content);\n    tr.setSelection(new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection(tr.doc.resolve(Math.max(newPos - 1, 0))));\n    return true;\n};\n\nconst deleteCurrentNode = () => ({ tr, dispatch }) => {\n    const { selection } = tr;\n    const currentNode = selection.$anchor.node();\n    // if there is content inside the current node, break out of this command\n    if (currentNode.content.size > 0) {\n        return false;\n    }\n    const $pos = tr.selection.$anchor;\n    for (let depth = $pos.depth; depth > 0; depth -= 1) {\n        const node = $pos.node(depth);\n        if (node.type === currentNode.type) {\n            if (dispatch) {\n                const from = $pos.before(depth);\n                const to = $pos.after(depth);\n                tr.delete(from, to).scrollIntoView();\n            }\n            return true;\n        }\n    }\n    return false;\n};\n\nconst deleteNode = typeOrName => ({ tr, state, dispatch }) => {\n    const type = getNodeType(typeOrName, state.schema);\n    const $pos = tr.selection.$anchor;\n    for (let depth = $pos.depth; depth > 0; depth -= 1) {\n        const node = $pos.node(depth);\n        if (node.type === type) {\n            if (dispatch) {\n                const from = $pos.before(depth);\n                const to = $pos.after(depth);\n                tr.delete(from, to).scrollIntoView();\n            }\n            return true;\n        }\n    }\n    return false;\n};\n\nconst deleteRange = range => ({ tr, dispatch }) => {\n    const { from, to } = range;\n    if (dispatch) {\n        tr.delete(from, to);\n    }\n    return true;\n};\n\nconst deleteSelection = () => ({ state, dispatch }) => {\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.deleteSelection)(state, dispatch);\n};\n\nconst enter = () => ({ commands }) => {\n    return commands.keyboardShortcut('Enter');\n};\n\nconst exitCode = () => ({ state, dispatch }) => {\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.exitCode)(state, dispatch);\n};\n\n/**\n * Check if object1 includes object2\n * @param object1 Object\n * @param object2 Object\n */\nfunction objectIncludes(object1, object2, options = { strict: true }) {\n    const keys = Object.keys(object2);\n    if (!keys.length) {\n        return true;\n    }\n    return keys.every(key => {\n        if (options.strict) {\n            return object2[key] === object1[key];\n        }\n        if (isRegExp(object2[key])) {\n            return object2[key].test(object1[key]);\n        }\n        return object2[key] === object1[key];\n    });\n}\n\nfunction findMarkInSet(marks, type, attributes = {}) {\n    return marks.find(item => {\n        return (item.type === type\n            && objectIncludes(\n            // Only check equality for the attributes that are provided\n            Object.fromEntries(Object.keys(attributes).map(k => [k, item.attrs[k]])), attributes));\n    });\n}\nfunction isMarkInSet(marks, type, attributes = {}) {\n    return !!findMarkInSet(marks, type, attributes);\n}\n/**\n * Get the range of a mark at a resolved position.\n */\nfunction getMarkRange(\n/**\n * The position to get the mark range for.\n */\n$pos, \n/**\n * The mark type to get the range for.\n */\ntype, \n/**\n * The attributes to match against.\n * If not provided, only the first mark at the position will be matched.\n */\nattributes) {\n    var _a;\n    if (!$pos || !type) {\n        return;\n    }\n    let start = $pos.parent.childAfter($pos.parentOffset);\n    // If the cursor is at the start of a text node that does not have the mark, look backward\n    if (!start.node || !start.node.marks.some(mark => mark.type === type)) {\n        start = $pos.parent.childBefore($pos.parentOffset);\n    }\n    // If there is no text node with the mark even backward, return undefined\n    if (!start.node || !start.node.marks.some(mark => mark.type === type)) {\n        return;\n    }\n    // Default to only matching against the first mark's attributes\n    attributes = attributes || ((_a = start.node.marks[0]) === null || _a === void 0 ? void 0 : _a.attrs);\n    // We now know that the cursor is either at the start, middle or end of a text node with the specified mark\n    // so we can look it up on the targeted mark\n    const mark = findMarkInSet([...start.node.marks], type, attributes);\n    if (!mark) {\n        return;\n    }\n    let startIndex = start.index;\n    let startPos = $pos.start() + start.offset;\n    let endIndex = startIndex + 1;\n    let endPos = startPos + start.node.nodeSize;\n    while (startIndex > 0\n        && isMarkInSet([...$pos.parent.child(startIndex - 1).marks], type, attributes)) {\n        startIndex -= 1;\n        startPos -= $pos.parent.child(startIndex).nodeSize;\n    }\n    while (endIndex < $pos.parent.childCount\n        && isMarkInSet([...$pos.parent.child(endIndex).marks], type, attributes)) {\n        endPos += $pos.parent.child(endIndex).nodeSize;\n        endIndex += 1;\n    }\n    return {\n        from: startPos,\n        to: endPos,\n    };\n}\n\nfunction getMarkType(nameOrType, schema) {\n    if (typeof nameOrType === 'string') {\n        if (!schema.marks[nameOrType]) {\n            throw Error(`There is no mark type named '${nameOrType}'. Maybe you forgot to add the extension?`);\n        }\n        return schema.marks[nameOrType];\n    }\n    return nameOrType;\n}\n\nconst extendMarkRange = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {\n    const type = getMarkType(typeOrName, state.schema);\n    const { doc, selection } = tr;\n    const { $from, from, to } = selection;\n    if (dispatch) {\n        const range = getMarkRange($from, type, attributes);\n        if (range && range.from <= from && range.to >= to) {\n            const newSelection = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(doc, range.from, range.to);\n            tr.setSelection(newSelection);\n        }\n    }\n    return true;\n};\n\nconst first = commands => props => {\n    const items = typeof commands === 'function'\n        ? commands(props)\n        : commands;\n    for (let i = 0; i < items.length; i += 1) {\n        if (items[i](props)) {\n            return true;\n        }\n    }\n    return false;\n};\n\nfunction isTextSelection(value) {\n    return value instanceof _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection;\n}\n\nfunction minMax(value = 0, min = 0, max = 0) {\n    return Math.min(Math.max(value, min), max);\n}\n\nfunction resolveFocusPosition(doc, position = null) {\n    if (!position) {\n        return null;\n    }\n    const selectionAtStart = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.atStart(doc);\n    const selectionAtEnd = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.atEnd(doc);\n    if (position === 'start' || position === true) {\n        return selectionAtStart;\n    }\n    if (position === 'end') {\n        return selectionAtEnd;\n    }\n    const minPos = selectionAtStart.from;\n    const maxPos = selectionAtEnd.to;\n    if (position === 'all') {\n        return _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(doc, minMax(0, minPos, maxPos), minMax(doc.content.size, minPos, maxPos));\n    }\n    return _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(doc, minMax(position, minPos, maxPos), minMax(position, minPos, maxPos));\n}\n\nfunction isAndroid() {\n    return navigator.platform === 'Android' || /android/i.test(navigator.userAgent);\n}\n\nfunction isiOS() {\n    return [\n        'iPad Simulator',\n        'iPhone Simulator',\n        'iPod Simulator',\n        'iPad',\n        'iPhone',\n        'iPod',\n    ].includes(navigator.platform)\n        // iPad on iOS 13 detection\n        || (navigator.userAgent.includes('Mac') && 'ontouchend' in document);\n}\n\nconst focus = (position = null, options = {}) => ({ editor, view, tr, dispatch, }) => {\n    options = {\n        scrollIntoView: true,\n        ...options,\n    };\n    const delayedFocus = () => {\n        // focus within `requestAnimationFrame` breaks focus on iOS and Android\n        // so we have to call this\n        if (isiOS() || isAndroid()) {\n            view.dom.focus();\n        }\n        // For React we have to focus asynchronously. Otherwise wild things happen.\n        // see: https://github.com/ueberdosis/tiptap/issues/1520\n        requestAnimationFrame(() => {\n            if (!editor.isDestroyed) {\n                view.focus();\n                if (options === null || options === void 0 ? void 0 : options.scrollIntoView) {\n                    editor.commands.scrollIntoView();\n                }\n            }\n        });\n    };\n    if ((view.hasFocus() && position === null) || position === false) {\n        return true;\n    }\n    // we don’t try to resolve a NodeSelection or CellSelection\n    if (dispatch && position === null && !isTextSelection(editor.state.selection)) {\n        delayedFocus();\n        return true;\n    }\n    // pass through tr.doc instead of editor.state.doc\n    // since transactions could change the editors state before this command has been run\n    const selection = resolveFocusPosition(tr.doc, position) || editor.state.selection;\n    const isSameSelection = editor.state.selection.eq(selection);\n    if (dispatch) {\n        if (!isSameSelection) {\n            tr.setSelection(selection);\n        }\n        // `tr.setSelection` resets the stored marks\n        // so we’ll restore them if the selection is the same as before\n        if (isSameSelection && tr.storedMarks) {\n            tr.setStoredMarks(tr.storedMarks);\n        }\n        delayedFocus();\n    }\n    return true;\n};\n\nconst forEach = (items, fn) => props => {\n    return items.every((item, index) => fn(item, { ...props, index }));\n};\n\nconst insertContent = (value, options) => ({ tr, commands }) => {\n    return commands.insertContentAt({ from: tr.selection.from, to: tr.selection.to }, value, options);\n};\n\nconst removeWhitespaces = (node) => {\n    const children = node.childNodes;\n    for (let i = children.length - 1; i >= 0; i -= 1) {\n        const child = children[i];\n        if (child.nodeType === 3 && child.nodeValue && /^(\\n\\s\\s|\\n)$/.test(child.nodeValue)) {\n            node.removeChild(child);\n        }\n        else if (child.nodeType === 1) {\n            removeWhitespaces(child);\n        }\n    }\n    return node;\n};\nfunction elementFromString(value) {\n    // add a wrapper to preserve leading and trailing whitespace\n    const wrappedValue = `<body>${value}</body>`;\n    const html = new window.DOMParser().parseFromString(wrappedValue, 'text/html').body;\n    return removeWhitespaces(html);\n}\n\n/**\n * Takes a JSON or HTML content and creates a Prosemirror node or fragment from it.\n * @param content The JSON or HTML content to create the node from\n * @param schema The Prosemirror schema to use for the node\n * @param options Options for the parser\n * @returns The created Prosemirror node or fragment\n */\nfunction createNodeFromContent(content, schema, options) {\n    if (content instanceof _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Node || content instanceof _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment) {\n        return content;\n    }\n    options = {\n        slice: true,\n        parseOptions: {},\n        ...options,\n    };\n    const isJSONContent = typeof content === 'object' && content !== null;\n    const isTextContent = typeof content === 'string';\n    if (isJSONContent) {\n        try {\n            const isArrayContent = Array.isArray(content) && content.length > 0;\n            // if the JSON Content is an array of nodes, create a fragment for each node\n            if (isArrayContent) {\n                return _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment.fromArray(content.map(item => schema.nodeFromJSON(item)));\n            }\n            const node = schema.nodeFromJSON(content);\n            if (options.errorOnInvalidContent) {\n                node.check();\n            }\n            return node;\n        }\n        catch (error) {\n            if (options.errorOnInvalidContent) {\n                throw new Error('[tiptap error]: Invalid JSON content', { cause: error });\n            }\n            console.warn('[tiptap warn]: Invalid content.', 'Passed value:', content, 'Error:', error);\n            return createNodeFromContent('', schema, options);\n        }\n    }\n    if (isTextContent) {\n        // Check for invalid content\n        if (options.errorOnInvalidContent) {\n            let hasInvalidContent = false;\n            let invalidContent = '';\n            // A copy of the current schema with a catch-all node at the end\n            const contentCheckSchema = new _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Schema({\n                topNode: schema.spec.topNode,\n                marks: schema.spec.marks,\n                // Prosemirror's schemas are executed such that: the last to execute, matches last\n                // This means that we can add a catch-all node at the end of the schema to catch any content that we don't know how to handle\n                nodes: schema.spec.nodes.append({\n                    __tiptap__private__unknown__catch__all__node: {\n                        content: 'inline*',\n                        group: 'block',\n                        parseDOM: [\n                            {\n                                tag: '*',\n                                getAttrs: e => {\n                                    // If this is ever called, we know that the content has something that we don't know how to handle in the schema\n                                    hasInvalidContent = true;\n                                    // Try to stringify the element for a more helpful error message\n                                    invalidContent = typeof e === 'string' ? e : e.outerHTML;\n                                    return null;\n                                },\n                            },\n                        ],\n                    },\n                }),\n            });\n            if (options.slice) {\n                _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.DOMParser.fromSchema(contentCheckSchema).parseSlice(elementFromString(content), options.parseOptions);\n            }\n            else {\n                _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.DOMParser.fromSchema(contentCheckSchema).parse(elementFromString(content), options.parseOptions);\n            }\n            if (options.errorOnInvalidContent && hasInvalidContent) {\n                throw new Error('[tiptap error]: Invalid HTML content', { cause: new Error(`Invalid element found: ${invalidContent}`) });\n            }\n        }\n        const parser = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.DOMParser.fromSchema(schema);\n        if (options.slice) {\n            return parser.parseSlice(elementFromString(content), options.parseOptions).content;\n        }\n        return parser.parse(elementFromString(content), options.parseOptions);\n    }\n    return createNodeFromContent('', schema, options);\n}\n\n// source: https://github.com/ProseMirror/prosemirror-state/blob/master/src/selection.js#L466\nfunction selectionToInsertionEnd(tr, startLen, bias) {\n    const last = tr.steps.length - 1;\n    if (last < startLen) {\n        return;\n    }\n    const step = tr.steps[last];\n    if (!(step instanceof _tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.ReplaceStep || step instanceof _tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.ReplaceAroundStep)) {\n        return;\n    }\n    const map = tr.mapping.maps[last];\n    let end = 0;\n    map.forEach((_from, _to, _newFrom, newTo) => {\n        if (end === 0) {\n            end = newTo;\n        }\n    });\n    tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near(tr.doc.resolve(end), bias));\n}\n\nconst isFragment = (nodeOrFragment) => {\n    return !('type' in nodeOrFragment);\n};\nconst insertContentAt = (position, value, options) => ({ tr, dispatch, editor }) => {\n    var _a;\n    if (dispatch) {\n        options = {\n            parseOptions: editor.options.parseOptions,\n            updateSelection: true,\n            applyInputRules: false,\n            applyPasteRules: false,\n            ...options,\n        };\n        let content;\n        const emitContentError = (error) => {\n            editor.emit('contentError', {\n                editor,\n                error,\n                disableCollaboration: () => {\n                    if (editor.storage.collaboration) {\n                        editor.storage.collaboration.isDisabled = true;\n                    }\n                },\n            });\n        };\n        const parseOptions = {\n            preserveWhitespace: 'full',\n            ...options.parseOptions,\n        };\n        // If `emitContentError` is enabled, we want to check the content for errors\n        // but ignore them (do not remove the invalid content from the document)\n        if (!options.errorOnInvalidContent && !editor.options.enableContentCheck && editor.options.emitContentError) {\n            try {\n                createNodeFromContent(value, editor.schema, {\n                    parseOptions,\n                    errorOnInvalidContent: true,\n                });\n            }\n            catch (e) {\n                emitContentError(e);\n            }\n        }\n        try {\n            content = createNodeFromContent(value, editor.schema, {\n                parseOptions,\n                errorOnInvalidContent: (_a = options.errorOnInvalidContent) !== null && _a !== void 0 ? _a : editor.options.enableContentCheck,\n            });\n        }\n        catch (e) {\n            emitContentError(e);\n            return false;\n        }\n        let { from, to } = typeof position === 'number' ? { from: position, to: position } : { from: position.from, to: position.to };\n        let isOnlyTextContent = true;\n        let isOnlyBlockContent = true;\n        const nodes = isFragment(content) ? content : [content];\n        nodes.forEach(node => {\n            // check if added node is valid\n            node.check();\n            isOnlyTextContent = isOnlyTextContent ? node.isText && node.marks.length === 0 : false;\n            isOnlyBlockContent = isOnlyBlockContent ? node.isBlock : false;\n        });\n        // check if we can replace the wrapping node by\n        // the newly inserted content\n        // example:\n        // replace an empty paragraph by an inserted image\n        // instead of inserting the image below the paragraph\n        if (from === to && isOnlyBlockContent) {\n            const { parent } = tr.doc.resolve(from);\n            const isEmptyTextBlock = parent.isTextblock && !parent.type.spec.code && !parent.childCount;\n            if (isEmptyTextBlock) {\n                from -= 1;\n                to += 1;\n            }\n        }\n        let newContent;\n        // if there is only plain text we have to use `insertText`\n        // because this will keep the current marks\n        if (isOnlyTextContent) {\n            // if value is string, we can use it directly\n            // otherwise if it is an array, we have to join it\n            if (Array.isArray(value)) {\n                newContent = value.map(v => v.text || '').join('');\n            }\n            else if (value instanceof _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment) {\n                let text = '';\n                value.forEach(node => {\n                    if (node.text) {\n                        text += node.text;\n                    }\n                });\n                newContent = text;\n            }\n            else if (typeof value === 'object' && !!value && !!value.text) {\n                newContent = value.text;\n            }\n            else {\n                newContent = value;\n            }\n            tr.insertText(newContent, from, to);\n        }\n        else {\n            newContent = content;\n            tr.replaceWith(from, to, newContent);\n        }\n        // set cursor at end of inserted content\n        if (options.updateSelection) {\n            selectionToInsertionEnd(tr, tr.steps.length - 1, -1);\n        }\n        if (options.applyInputRules) {\n            tr.setMeta('applyInputRules', { from, text: newContent });\n        }\n        if (options.applyPasteRules) {\n            tr.setMeta('applyPasteRules', { from, text: newContent });\n        }\n    }\n    return true;\n};\n\nconst joinUp = () => ({ state, dispatch }) => {\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.joinUp)(state, dispatch);\n};\nconst joinDown = () => ({ state, dispatch }) => {\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.joinDown)(state, dispatch);\n};\nconst joinBackward = () => ({ state, dispatch }) => {\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.joinBackward)(state, dispatch);\n};\nconst joinForward = () => ({ state, dispatch }) => {\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.joinForward)(state, dispatch);\n};\n\nconst joinItemBackward = () => ({ state, dispatch, tr, }) => {\n    try {\n        const point = (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.joinPoint)(state.doc, state.selection.$from.pos, -1);\n        if (point === null || point === undefined) {\n            return false;\n        }\n        tr.join(point, 2);\n        if (dispatch) {\n            dispatch(tr);\n        }\n        return true;\n    }\n    catch {\n        return false;\n    }\n};\n\nconst joinItemForward = () => ({ state, dispatch, tr, }) => {\n    try {\n        const point = (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.joinPoint)(state.doc, state.selection.$from.pos, +1);\n        if (point === null || point === undefined) {\n            return false;\n        }\n        tr.join(point, 2);\n        if (dispatch) {\n            dispatch(tr);\n        }\n        return true;\n    }\n    catch {\n        return false;\n    }\n};\n\nconst joinTextblockBackward = () => ({ state, dispatch }) => {\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.joinTextblockBackward)(state, dispatch);\n};\n\nconst joinTextblockForward = () => ({ state, dispatch }) => {\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.joinTextblockForward)(state, dispatch);\n};\n\nfunction isMacOS() {\n    return typeof navigator !== 'undefined'\n        ? /Mac/.test(navigator.platform)\n        : false;\n}\n\nfunction normalizeKeyName(name) {\n    const parts = name.split(/-(?!$)/);\n    let result = parts[parts.length - 1];\n    if (result === 'Space') {\n        result = ' ';\n    }\n    let alt;\n    let ctrl;\n    let shift;\n    let meta;\n    for (let i = 0; i < parts.length - 1; i += 1) {\n        const mod = parts[i];\n        if (/^(cmd|meta|m)$/i.test(mod)) {\n            meta = true;\n        }\n        else if (/^a(lt)?$/i.test(mod)) {\n            alt = true;\n        }\n        else if (/^(c|ctrl|control)$/i.test(mod)) {\n            ctrl = true;\n        }\n        else if (/^s(hift)?$/i.test(mod)) {\n            shift = true;\n        }\n        else if (/^mod$/i.test(mod)) {\n            if (isiOS() || isMacOS()) {\n                meta = true;\n            }\n            else {\n                ctrl = true;\n            }\n        }\n        else {\n            throw new Error(`Unrecognized modifier name: ${mod}`);\n        }\n    }\n    if (alt) {\n        result = `Alt-${result}`;\n    }\n    if (ctrl) {\n        result = `Ctrl-${result}`;\n    }\n    if (meta) {\n        result = `Meta-${result}`;\n    }\n    if (shift) {\n        result = `Shift-${result}`;\n    }\n    return result;\n}\nconst keyboardShortcut = name => ({ editor, view, tr, dispatch, }) => {\n    const keys = normalizeKeyName(name).split(/-(?!$)/);\n    const key = keys.find(item => !['Alt', 'Ctrl', 'Meta', 'Shift'].includes(item));\n    const event = new KeyboardEvent('keydown', {\n        key: key === 'Space'\n            ? ' '\n            : key,\n        altKey: keys.includes('Alt'),\n        ctrlKey: keys.includes('Ctrl'),\n        metaKey: keys.includes('Meta'),\n        shiftKey: keys.includes('Shift'),\n        bubbles: true,\n        cancelable: true,\n    });\n    const capturedTransaction = editor.captureTransaction(() => {\n        view.someProp('handleKeyDown', f => f(view, event));\n    });\n    capturedTransaction === null || capturedTransaction === void 0 ? void 0 : capturedTransaction.steps.forEach(step => {\n        const newStep = step.map(tr.mapping);\n        if (newStep && dispatch) {\n            tr.maybeStep(newStep);\n        }\n    });\n    return true;\n};\n\nfunction isNodeActive(state, typeOrName, attributes = {}) {\n    const { from, to, empty } = state.selection;\n    const type = typeOrName ? getNodeType(typeOrName, state.schema) : null;\n    const nodeRanges = [];\n    state.doc.nodesBetween(from, to, (node, pos) => {\n        if (node.isText) {\n            return;\n        }\n        const relativeFrom = Math.max(from, pos);\n        const relativeTo = Math.min(to, pos + node.nodeSize);\n        nodeRanges.push({\n            node,\n            from: relativeFrom,\n            to: relativeTo,\n        });\n    });\n    const selectionRange = to - from;\n    const matchedNodeRanges = nodeRanges\n        .filter(nodeRange => {\n        if (!type) {\n            return true;\n        }\n        return type.name === nodeRange.node.type.name;\n    })\n        .filter(nodeRange => objectIncludes(nodeRange.node.attrs, attributes, { strict: false }));\n    if (empty) {\n        return !!matchedNodeRanges.length;\n    }\n    const range = matchedNodeRanges.reduce((sum, nodeRange) => sum + nodeRange.to - nodeRange.from, 0);\n    return range >= selectionRange;\n}\n\nconst lift = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\n    const type = getNodeType(typeOrName, state.schema);\n    const isActive = isNodeActive(state, type, attributes);\n    if (!isActive) {\n        return false;\n    }\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.lift)(state, dispatch);\n};\n\nconst liftEmptyBlock = () => ({ state, dispatch }) => {\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.liftEmptyBlock)(state, dispatch);\n};\n\nconst liftListItem = typeOrName => ({ state, dispatch }) => {\n    const type = getNodeType(typeOrName, state.schema);\n    return (0,_tiptap_pm_schema_list__WEBPACK_IMPORTED_MODULE_6__.liftListItem)(type)(state, dispatch);\n};\n\nconst newlineInCode = () => ({ state, dispatch }) => {\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.newlineInCode)(state, dispatch);\n};\n\n/**\n * Get the type of a schema item by its name.\n * @param name The name of the schema item\n * @param schema The Prosemiror schema to search in\n * @returns The type of the schema item (`node` or `mark`), or null if it doesn't exist\n */\nfunction getSchemaTypeNameByName(name, schema) {\n    if (schema.nodes[name]) {\n        return 'node';\n    }\n    if (schema.marks[name]) {\n        return 'mark';\n    }\n    return null;\n}\n\n/**\n * Remove a property or an array of properties from an object\n * @param obj Object\n * @param key Key to remove\n */\nfunction deleteProps(obj, propOrProps) {\n    const props = typeof propOrProps === 'string'\n        ? [propOrProps]\n        : propOrProps;\n    return Object\n        .keys(obj)\n        .reduce((newObj, prop) => {\n        if (!props.includes(prop)) {\n            newObj[prop] = obj[prop];\n        }\n        return newObj;\n    }, {});\n}\n\nconst resetAttributes = (typeOrName, attributes) => ({ tr, state, dispatch }) => {\n    let nodeType = null;\n    let markType = null;\n    const schemaType = getSchemaTypeNameByName(typeof typeOrName === 'string' ? typeOrName : typeOrName.name, state.schema);\n    if (!schemaType) {\n        return false;\n    }\n    if (schemaType === 'node') {\n        nodeType = getNodeType(typeOrName, state.schema);\n    }\n    if (schemaType === 'mark') {\n        markType = getMarkType(typeOrName, state.schema);\n    }\n    if (dispatch) {\n        tr.selection.ranges.forEach(range => {\n            state.doc.nodesBetween(range.$from.pos, range.$to.pos, (node, pos) => {\n                if (nodeType && nodeType === node.type) {\n                    tr.setNodeMarkup(pos, undefined, deleteProps(node.attrs, attributes));\n                }\n                if (markType && node.marks.length) {\n                    node.marks.forEach(mark => {\n                        if (markType === mark.type) {\n                            tr.addMark(pos, pos + node.nodeSize, markType.create(deleteProps(mark.attrs, attributes)));\n                        }\n                    });\n                }\n            });\n        });\n    }\n    return true;\n};\n\nconst scrollIntoView = () => ({ tr, dispatch }) => {\n    if (dispatch) {\n        tr.scrollIntoView();\n    }\n    return true;\n};\n\nconst selectAll = () => ({ tr, dispatch }) => {\n    if (dispatch) {\n        const selection = new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.AllSelection(tr.doc);\n        tr.setSelection(selection);\n    }\n    return true;\n};\n\nconst selectNodeBackward = () => ({ state, dispatch }) => {\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.selectNodeBackward)(state, dispatch);\n};\n\nconst selectNodeForward = () => ({ state, dispatch }) => {\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.selectNodeForward)(state, dispatch);\n};\n\nconst selectParentNode = () => ({ state, dispatch }) => {\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.selectParentNode)(state, dispatch);\n};\n\n// @ts-ignore\n// TODO: add types to @types/prosemirror-commands\nconst selectTextblockEnd = () => ({ state, dispatch }) => {\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.selectTextblockEnd)(state, dispatch);\n};\n\n// @ts-ignore\n// TODO: add types to @types/prosemirror-commands\nconst selectTextblockStart = () => ({ state, dispatch }) => {\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.selectTextblockStart)(state, dispatch);\n};\n\n/**\n * Create a new Prosemirror document node from content.\n * @param content The JSON or HTML content to create the document from\n * @param schema The Prosemirror schema to use for the document\n * @param parseOptions Options for the parser\n * @returns The created Prosemirror document node\n */\nfunction createDocument(content, schema, parseOptions = {}, options = {}) {\n    return createNodeFromContent(content, schema, {\n        slice: false,\n        parseOptions,\n        errorOnInvalidContent: options.errorOnInvalidContent,\n    });\n}\n\nconst setContent = (content, emitUpdate = false, parseOptions = {}, options = {}) => ({ editor, tr, dispatch, commands, }) => {\n    var _a, _b;\n    const { doc } = tr;\n    // This is to keep backward compatibility with the previous behavior\n    // TODO remove this in the next major version\n    if (parseOptions.preserveWhitespace !== 'full') {\n        const document = createDocument(content, editor.schema, parseOptions, {\n            errorOnInvalidContent: (_a = options.errorOnInvalidContent) !== null && _a !== void 0 ? _a : editor.options.enableContentCheck,\n        });\n        if (dispatch) {\n            tr.replaceWith(0, doc.content.size, document).setMeta('preventUpdate', !emitUpdate);\n        }\n        return true;\n    }\n    if (dispatch) {\n        tr.setMeta('preventUpdate', !emitUpdate);\n    }\n    return commands.insertContentAt({ from: 0, to: doc.content.size }, content, {\n        parseOptions,\n        errorOnInvalidContent: (_b = options.errorOnInvalidContent) !== null && _b !== void 0 ? _b : editor.options.enableContentCheck,\n    });\n};\n\nfunction getMarkAttributes(state, typeOrName) {\n    const type = getMarkType(typeOrName, state.schema);\n    const { from, to, empty } = state.selection;\n    const marks = [];\n    if (empty) {\n        if (state.storedMarks) {\n            marks.push(...state.storedMarks);\n        }\n        marks.push(...state.selection.$head.marks());\n    }\n    else {\n        state.doc.nodesBetween(from, to, node => {\n            marks.push(...node.marks);\n        });\n    }\n    const mark = marks.find(markItem => markItem.type.name === type.name);\n    if (!mark) {\n        return {};\n    }\n    return { ...mark.attrs };\n}\n\n/**\n * Returns a new `Transform` based on all steps of the passed transactions.\n * @param oldDoc The Prosemirror node to start from\n * @param transactions The transactions to combine\n * @returns A new `Transform` with all steps of the passed transactions\n */\nfunction combineTransactionSteps(oldDoc, transactions) {\n    const transform = new _tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.Transform(oldDoc);\n    transactions.forEach(transaction => {\n        transaction.steps.forEach(step => {\n            transform.step(step);\n        });\n    });\n    return transform;\n}\n\n/**\n * Gets the default block type at a given match\n * @param match The content match to get the default block type from\n * @returns The default block type or null\n */\nfunction defaultBlockAt(match) {\n    for (let i = 0; i < match.edgeCount; i += 1) {\n        const { type } = match.edge(i);\n        if (type.isTextblock && !type.hasRequiredAttrs()) {\n            return type;\n        }\n    }\n    return null;\n}\n\n/**\n * Find children inside a Prosemirror node that match a predicate.\n * @param node The Prosemirror node to search in\n * @param predicate The predicate to match\n * @returns An array of nodes with their positions\n */\nfunction findChildren(node, predicate) {\n    const nodesWithPos = [];\n    node.descendants((child, pos) => {\n        if (predicate(child)) {\n            nodesWithPos.push({\n                node: child,\n                pos,\n            });\n        }\n    });\n    return nodesWithPos;\n}\n\n/**\n * Same as `findChildren` but searches only within a `range`.\n * @param node The Prosemirror node to search in\n * @param range The range to search in\n * @param predicate The predicate to match\n * @returns An array of nodes with their positions\n */\nfunction findChildrenInRange(node, range, predicate) {\n    const nodesWithPos = [];\n    // if (range.from === range.to) {\n    //   const nodeAt = node.nodeAt(range.from)\n    //   if (nodeAt) {\n    //     nodesWithPos.push({\n    //       node: nodeAt,\n    //       pos: range.from,\n    //     })\n    //   }\n    // }\n    node.nodesBetween(range.from, range.to, (child, pos) => {\n        if (predicate(child)) {\n            nodesWithPos.push({\n                node: child,\n                pos,\n            });\n        }\n    });\n    return nodesWithPos;\n}\n\n/**\n * Finds the closest parent node to a resolved position that matches a predicate.\n * @param $pos The resolved position to search from\n * @param predicate The predicate to match\n * @returns The closest parent node to the resolved position that matches the predicate\n * @example ```js\n * findParentNodeClosestToPos($from, node => node.type.name === 'paragraph')\n * ```\n */\nfunction findParentNodeClosestToPos($pos, predicate) {\n    for (let i = $pos.depth; i > 0; i -= 1) {\n        const node = $pos.node(i);\n        if (predicate(node)) {\n            return {\n                pos: i > 0 ? $pos.before(i) : 0,\n                start: $pos.start(i),\n                depth: i,\n                node,\n            };\n        }\n    }\n}\n\n/**\n * Finds the closest parent node to the current selection that matches a predicate.\n * @param predicate The predicate to match\n * @returns A command that finds the closest parent node to the current selection that matches the predicate\n * @example ```js\n * findParentNode(node => node.type.name === 'paragraph')\n * ```\n */\nfunction findParentNode(predicate) {\n    return (selection) => findParentNodeClosestToPos(selection.$from, predicate);\n}\n\nfunction getSchema(extensions, editor) {\n    const resolvedExtensions = ExtensionManager.resolve(extensions);\n    return getSchemaByResolvedExtensions(resolvedExtensions, editor);\n}\n\n/**\n * Generate HTML from a JSONContent\n * @param doc The JSONContent to generate HTML from\n * @param extensions The extensions to use for the schema\n * @returns The generated HTML\n */\nfunction generateHTML(doc, extensions) {\n    const schema = getSchema(extensions);\n    const contentNode = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Node.fromJSON(schema, doc);\n    return getHTMLFromFragment(contentNode.content, schema);\n}\n\n/**\n * Generate JSONContent from HTML\n * @param html The HTML to generate JSONContent from\n * @param extensions The extensions to use for the schema\n * @returns The generated JSONContent\n */\nfunction generateJSON(html, extensions) {\n    const schema = getSchema(extensions);\n    const dom = elementFromString(html);\n    return _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.DOMParser.fromSchema(schema).parse(dom).toJSON();\n}\n\n/**\n * Gets the text of a Prosemirror node\n * @param node The Prosemirror node\n * @param options Options for the text serializer & block separator\n * @returns The text of the node\n * @example ```js\n * const text = getText(node, { blockSeparator: '\\n' })\n * ```\n */\nfunction getText(node, options) {\n    const range = {\n        from: 0,\n        to: node.content.size,\n    };\n    return getTextBetween(node, range, options);\n}\n\n/**\n * Generate raw text from a JSONContent\n * @param doc The JSONContent to generate text from\n * @param extensions The extensions to use for the schema\n * @param options Options for the text generation f.e. blockSeparator or textSerializers\n * @returns The generated text\n */\nfunction generateText(doc, extensions, options) {\n    const { blockSeparator = '\\n\\n', textSerializers = {} } = options || {};\n    const schema = getSchema(extensions);\n    const contentNode = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Node.fromJSON(schema, doc);\n    return getText(contentNode, {\n        blockSeparator,\n        textSerializers: {\n            ...getTextSerializersFromSchema(schema),\n            ...textSerializers,\n        },\n    });\n}\n\nfunction getNodeAttributes(state, typeOrName) {\n    const type = getNodeType(typeOrName, state.schema);\n    const { from, to } = state.selection;\n    const nodes = [];\n    state.doc.nodesBetween(from, to, node => {\n        nodes.push(node);\n    });\n    const node = nodes.reverse().find(nodeItem => nodeItem.type.name === type.name);\n    if (!node) {\n        return {};\n    }\n    return { ...node.attrs };\n}\n\n/**\n * Get node or mark attributes by type or name on the current editor state\n * @param state The current editor state\n * @param typeOrName The node or mark type or name\n * @returns The attributes of the node or mark or an empty object\n */\nfunction getAttributes(state, typeOrName) {\n    const schemaType = getSchemaTypeNameByName(typeof typeOrName === 'string' ? typeOrName : typeOrName.name, state.schema);\n    if (schemaType === 'node') {\n        return getNodeAttributes(state, typeOrName);\n    }\n    if (schemaType === 'mark') {\n        return getMarkAttributes(state, typeOrName);\n    }\n    return {};\n}\n\n/**\n * Removes duplicated values within an array.\n * Supports numbers, strings and objects.\n */\nfunction removeDuplicates(array, by = JSON.stringify) {\n    const seen = {};\n    return array.filter(item => {\n        const key = by(item);\n        return Object.prototype.hasOwnProperty.call(seen, key)\n            ? false\n            : (seen[key] = true);\n    });\n}\n\n/**\n * Removes duplicated ranges and ranges that are\n * fully captured by other ranges.\n */\nfunction simplifyChangedRanges(changes) {\n    const uniqueChanges = removeDuplicates(changes);\n    return uniqueChanges.length === 1\n        ? uniqueChanges\n        : uniqueChanges.filter((change, index) => {\n            const rest = uniqueChanges.filter((_, i) => i !== index);\n            return !rest.some(otherChange => {\n                return change.oldRange.from >= otherChange.oldRange.from\n                    && change.oldRange.to <= otherChange.oldRange.to\n                    && change.newRange.from >= otherChange.newRange.from\n                    && change.newRange.to <= otherChange.newRange.to;\n            });\n        });\n}\n/**\n * Returns a list of changed ranges\n * based on the first and last state of all steps.\n */\nfunction getChangedRanges(transform) {\n    const { mapping, steps } = transform;\n    const changes = [];\n    mapping.maps.forEach((stepMap, index) => {\n        const ranges = [];\n        // This accounts for step changes where no range was actually altered\n        // e.g. when setting a mark, node attribute, etc.\n        // @ts-ignore\n        if (!stepMap.ranges.length) {\n            const { from, to } = steps[index];\n            if (from === undefined || to === undefined) {\n                return;\n            }\n            ranges.push({ from, to });\n        }\n        else {\n            stepMap.forEach((from, to) => {\n                ranges.push({ from, to });\n            });\n        }\n        ranges.forEach(({ from, to }) => {\n            const newStart = mapping.slice(index).map(from, -1);\n            const newEnd = mapping.slice(index).map(to);\n            const oldStart = mapping.invert().map(newStart, -1);\n            const oldEnd = mapping.invert().map(newEnd);\n            changes.push({\n                oldRange: {\n                    from: oldStart,\n                    to: oldEnd,\n                },\n                newRange: {\n                    from: newStart,\n                    to: newEnd,\n                },\n            });\n        });\n    });\n    return simplifyChangedRanges(changes);\n}\n\nfunction getDebugJSON(node, startOffset = 0) {\n    const isTopNode = node.type === node.type.schema.topNodeType;\n    const increment = isTopNode ? 0 : 1;\n    const from = startOffset;\n    const to = from + node.nodeSize;\n    const marks = node.marks.map(mark => {\n        const output = {\n            type: mark.type.name,\n        };\n        if (Object.keys(mark.attrs).length) {\n            output.attrs = { ...mark.attrs };\n        }\n        return output;\n    });\n    const attrs = { ...node.attrs };\n    const output = {\n        type: node.type.name,\n        from,\n        to,\n    };\n    if (Object.keys(attrs).length) {\n        output.attrs = attrs;\n    }\n    if (marks.length) {\n        output.marks = marks;\n    }\n    if (node.content.childCount) {\n        output.content = [];\n        node.forEach((child, offset) => {\n            var _a;\n            (_a = output.content) === null || _a === void 0 ? void 0 : _a.push(getDebugJSON(child, startOffset + offset + increment));\n        });\n    }\n    if (node.text) {\n        output.text = node.text;\n    }\n    return output;\n}\n\nfunction getMarksBetween(from, to, doc) {\n    const marks = [];\n    // get all inclusive marks on empty selection\n    if (from === to) {\n        doc\n            .resolve(from)\n            .marks()\n            .forEach(mark => {\n            const $pos = doc.resolve(from);\n            const range = getMarkRange($pos, mark.type);\n            if (!range) {\n                return;\n            }\n            marks.push({\n                mark,\n                ...range,\n            });\n        });\n    }\n    else {\n        doc.nodesBetween(from, to, (node, pos) => {\n            if (!node || (node === null || node === void 0 ? void 0 : node.nodeSize) === undefined) {\n                return;\n            }\n            marks.push(...node.marks.map(mark => ({\n                from: pos,\n                to: pos + node.nodeSize,\n                mark,\n            })));\n        });\n    }\n    return marks;\n}\n\n/**\n * Finds the first node of a given type or name in the current selection.\n * @param state The editor state.\n * @param typeOrName The node type or name.\n * @param pos The position to start searching from.\n * @param maxDepth The maximum depth to search.\n * @returns The node and the depth as an array.\n */\nconst getNodeAtPosition = (state, typeOrName, pos, maxDepth = 20) => {\n    const $pos = state.doc.resolve(pos);\n    let currentDepth = maxDepth;\n    let node = null;\n    while (currentDepth > 0 && node === null) {\n        const currentNode = $pos.node(currentDepth);\n        if ((currentNode === null || currentNode === void 0 ? void 0 : currentNode.type.name) === typeOrName) {\n            node = currentNode;\n        }\n        else {\n            currentDepth -= 1;\n        }\n    }\n    return [node, currentDepth];\n};\n\n/**\n * Return attributes of an extension that should be splitted by keepOnSplit flag\n * @param extensionAttributes Array of extension attributes\n * @param typeName The type of the extension\n * @param attributes The attributes of the extension\n * @returns The splitted attributes\n */\nfunction getSplittedAttributes(extensionAttributes, typeName, attributes) {\n    return Object.fromEntries(Object\n        .entries(attributes)\n        .filter(([name]) => {\n        const extensionAttribute = extensionAttributes.find(item => {\n            return item.type === typeName && item.name === name;\n        });\n        if (!extensionAttribute) {\n            return false;\n        }\n        return extensionAttribute.attribute.keepOnSplit;\n    }));\n}\n\nfunction isMarkActive(state, typeOrName, attributes = {}) {\n    const { empty, ranges } = state.selection;\n    const type = typeOrName ? getMarkType(typeOrName, state.schema) : null;\n    if (empty) {\n        return !!(state.storedMarks || state.selection.$from.marks())\n            .filter(mark => {\n            if (!type) {\n                return true;\n            }\n            return type.name === mark.type.name;\n        })\n            .find(mark => objectIncludes(mark.attrs, attributes, { strict: false }));\n    }\n    let selectionRange = 0;\n    const markRanges = [];\n    ranges.forEach(({ $from, $to }) => {\n        const from = $from.pos;\n        const to = $to.pos;\n        state.doc.nodesBetween(from, to, (node, pos) => {\n            if (!node.isText && !node.marks.length) {\n                return;\n            }\n            const relativeFrom = Math.max(from, pos);\n            const relativeTo = Math.min(to, pos + node.nodeSize);\n            const range = relativeTo - relativeFrom;\n            selectionRange += range;\n            markRanges.push(...node.marks.map(mark => ({\n                mark,\n                from: relativeFrom,\n                to: relativeTo,\n            })));\n        });\n    });\n    if (selectionRange === 0) {\n        return false;\n    }\n    // calculate range of matched mark\n    const matchedRange = markRanges\n        .filter(markRange => {\n        if (!type) {\n            return true;\n        }\n        return type.name === markRange.mark.type.name;\n    })\n        .filter(markRange => objectIncludes(markRange.mark.attrs, attributes, { strict: false }))\n        .reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);\n    // calculate range of marks that excludes the searched mark\n    // for example `code` doesn’t allow any other marks\n    const excludedRange = markRanges\n        .filter(markRange => {\n        if (!type) {\n            return true;\n        }\n        return markRange.mark.type !== type && markRange.mark.type.excludes(type);\n    })\n        .reduce((sum, markRange) => sum + markRange.to - markRange.from, 0);\n    // we only include the result of `excludedRange`\n    // if there is a match at all\n    const range = matchedRange > 0 ? matchedRange + excludedRange : matchedRange;\n    return range >= selectionRange;\n}\n\nfunction isActive(state, name, attributes = {}) {\n    if (!name) {\n        return isNodeActive(state, null, attributes) || isMarkActive(state, null, attributes);\n    }\n    const schemaType = getSchemaTypeNameByName(name, state.schema);\n    if (schemaType === 'node') {\n        return isNodeActive(state, name, attributes);\n    }\n    if (schemaType === 'mark') {\n        return isMarkActive(state, name, attributes);\n    }\n    return false;\n}\n\nconst isAtEndOfNode = (state, nodeType) => {\n    const { $from, $to, $anchor } = state.selection;\n    if (nodeType) {\n        const parentNode = findParentNode(node => node.type.name === nodeType)(state.selection);\n        if (!parentNode) {\n            return false;\n        }\n        const $parentPos = state.doc.resolve(parentNode.pos + 1);\n        if ($anchor.pos + 1 === $parentPos.end()) {\n            return true;\n        }\n        return false;\n    }\n    if ($to.parentOffset < $to.parent.nodeSize - 2 || $from.pos !== $to.pos) {\n        return false;\n    }\n    return true;\n};\n\nconst isAtStartOfNode = (state) => {\n    const { $from, $to } = state.selection;\n    if ($from.parentOffset > 0 || $from.pos !== $to.pos) {\n        return false;\n    }\n    return true;\n};\n\nfunction isList(name, extensions) {\n    const { nodeExtensions } = splitExtensions(extensions);\n    const extension = nodeExtensions.find(item => item.name === name);\n    if (!extension) {\n        return false;\n    }\n    const context = {\n        name: extension.name,\n        options: extension.options,\n        storage: extension.storage,\n    };\n    const group = callOrReturn(getExtensionField(extension, 'group', context));\n    if (typeof group !== 'string') {\n        return false;\n    }\n    return group.split(' ').includes('list');\n}\n\n/**\n * Returns true if the given prosemirror node is empty.\n */\nfunction isNodeEmpty(node, { checkChildren = true, ignoreWhitespace = false, } = {}) {\n    var _a;\n    if (ignoreWhitespace) {\n        if (node.type.name === 'hardBreak') {\n            // Hard breaks are considered empty\n            return true;\n        }\n        if (node.isText) {\n            return /^\\s*$/m.test((_a = node.text) !== null && _a !== void 0 ? _a : '');\n        }\n    }\n    if (node.isText) {\n        return !node.text;\n    }\n    if (node.isAtom || node.isLeaf) {\n        return false;\n    }\n    if (node.content.childCount === 0) {\n        return true;\n    }\n    if (checkChildren) {\n        let isContentEmpty = true;\n        node.content.forEach(childNode => {\n            if (isContentEmpty === false) {\n                // Exit early for perf\n                return;\n            }\n            if (!isNodeEmpty(childNode, { ignoreWhitespace, checkChildren })) {\n                isContentEmpty = false;\n            }\n        });\n        return isContentEmpty;\n    }\n    return false;\n}\n\nfunction isNodeSelection(value) {\n    return value instanceof _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection;\n}\n\nfunction posToDOMRect(view, from, to) {\n    const minPos = 0;\n    const maxPos = view.state.doc.content.size;\n    const resolvedFrom = minMax(from, minPos, maxPos);\n    const resolvedEnd = minMax(to, minPos, maxPos);\n    const start = view.coordsAtPos(resolvedFrom);\n    const end = view.coordsAtPos(resolvedEnd, -1);\n    const top = Math.min(start.top, end.top);\n    const bottom = Math.max(start.bottom, end.bottom);\n    const left = Math.min(start.left, end.left);\n    const right = Math.max(start.right, end.right);\n    const width = right - left;\n    const height = bottom - top;\n    const x = left;\n    const y = top;\n    const data = {\n        top,\n        bottom,\n        left,\n        right,\n        width,\n        height,\n        x,\n        y,\n    };\n    return {\n        ...data,\n        toJSON: () => data,\n    };\n}\n\n/**\n * The actual implementation of the rewriteUnknownContent function\n */\nfunction rewriteUnknownContentInner({ json, validMarks, validNodes, options, rewrittenContent = [], }) {\n    if (json.marks && Array.isArray(json.marks)) {\n        json.marks = json.marks.filter(mark => {\n            const name = typeof mark === 'string' ? mark : mark.type;\n            if (validMarks.has(name)) {\n                return true;\n            }\n            rewrittenContent.push({\n                original: JSON.parse(JSON.stringify(mark)),\n                unsupported: name,\n            });\n            // Just ignore any unknown marks\n            return false;\n        });\n    }\n    if (json.content && Array.isArray(json.content)) {\n        json.content = json.content\n            .map(value => rewriteUnknownContentInner({\n            json: value,\n            validMarks,\n            validNodes,\n            options,\n            rewrittenContent,\n        }).json)\n            .filter(a => a !== null && a !== undefined);\n    }\n    if (json.type && !validNodes.has(json.type)) {\n        rewrittenContent.push({\n            original: JSON.parse(JSON.stringify(json)),\n            unsupported: json.type,\n        });\n        if (json.content && Array.isArray(json.content) && ((options === null || options === void 0 ? void 0 : options.fallbackToParagraph) !== false)) {\n            // Just treat it like a paragraph and hope for the best\n            json.type = 'paragraph';\n            return {\n                json,\n                rewrittenContent,\n            };\n        }\n        // or just omit it entirely\n        return {\n            json: null,\n            rewrittenContent,\n        };\n    }\n    return { json, rewrittenContent };\n}\n/**\n * Rewrite unknown nodes and marks within JSON content\n * Allowing for user within the editor\n */\nfunction rewriteUnknownContent(\n/**\n * The JSON content to clean of unknown nodes and marks\n */\njson, \n/**\n * The schema to use for validation\n */\nschema, \n/**\n * Options for the cleaning process\n */\noptions) {\n    return rewriteUnknownContentInner({\n        json,\n        validNodes: new Set(Object.keys(schema.nodes)),\n        validMarks: new Set(Object.keys(schema.marks)),\n        options,\n    });\n}\n\nfunction canSetMark(state, tr, newMarkType) {\n    var _a;\n    const { selection } = tr;\n    let cursor = null;\n    if (isTextSelection(selection)) {\n        cursor = selection.$cursor;\n    }\n    if (cursor) {\n        const currentMarks = (_a = state.storedMarks) !== null && _a !== void 0 ? _a : cursor.marks();\n        // There can be no current marks that exclude the new mark\n        return (!!newMarkType.isInSet(currentMarks)\n            || !currentMarks.some(mark => mark.type.excludes(newMarkType)));\n    }\n    const { ranges } = selection;\n    return ranges.some(({ $from, $to }) => {\n        let someNodeSupportsMark = $from.depth === 0\n            ? state.doc.inlineContent && state.doc.type.allowsMarkType(newMarkType)\n            : false;\n        state.doc.nodesBetween($from.pos, $to.pos, (node, _pos, parent) => {\n            // If we already found a mark that we can enable, return false to bypass the remaining search\n            if (someNodeSupportsMark) {\n                return false;\n            }\n            if (node.isInline) {\n                const parentAllowsMarkType = !parent || parent.type.allowsMarkType(newMarkType);\n                const currentMarksAllowMarkType = !!newMarkType.isInSet(node.marks)\n                    || !node.marks.some(otherMark => otherMark.type.excludes(newMarkType));\n                someNodeSupportsMark = parentAllowsMarkType && currentMarksAllowMarkType;\n            }\n            return !someNodeSupportsMark;\n        });\n        return someNodeSupportsMark;\n    });\n}\nconst setMark = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {\n    const { selection } = tr;\n    const { empty, ranges } = selection;\n    const type = getMarkType(typeOrName, state.schema);\n    if (dispatch) {\n        if (empty) {\n            const oldAttributes = getMarkAttributes(state, type);\n            tr.addStoredMark(type.create({\n                ...oldAttributes,\n                ...attributes,\n            }));\n        }\n        else {\n            ranges.forEach(range => {\n                const from = range.$from.pos;\n                const to = range.$to.pos;\n                state.doc.nodesBetween(from, to, (node, pos) => {\n                    const trimmedFrom = Math.max(pos, from);\n                    const trimmedTo = Math.min(pos + node.nodeSize, to);\n                    const someHasMark = node.marks.find(mark => mark.type === type);\n                    // if there is already a mark of this type\n                    // we know that we have to merge its attributes\n                    // otherwise we add a fresh new mark\n                    if (someHasMark) {\n                        node.marks.forEach(mark => {\n                            if (type === mark.type) {\n                                tr.addMark(trimmedFrom, trimmedTo, type.create({\n                                    ...mark.attrs,\n                                    ...attributes,\n                                }));\n                            }\n                        });\n                    }\n                    else {\n                        tr.addMark(trimmedFrom, trimmedTo, type.create(attributes));\n                    }\n                });\n            });\n        }\n    }\n    return canSetMark(state, tr, type);\n};\n\nconst setMeta = (key, value) => ({ tr }) => {\n    tr.setMeta(key, value);\n    return true;\n};\n\nconst setNode = (typeOrName, attributes = {}) => ({ state, dispatch, chain }) => {\n    const type = getNodeType(typeOrName, state.schema);\n    let attributesToCopy;\n    if (state.selection.$anchor.sameParent(state.selection.$head)) {\n        // only copy attributes if the selection is pointing to a node of the same type\n        attributesToCopy = state.selection.$anchor.parent.attrs;\n    }\n    // TODO: use a fallback like insertContent?\n    if (!type.isTextblock) {\n        console.warn('[tiptap warn]: Currently \"setNode()\" only supports text block nodes.');\n        return false;\n    }\n    return (chain()\n        // try to convert node to default node if needed\n        .command(({ commands }) => {\n        const canSetBlock = (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.setBlockType)(type, { ...attributesToCopy, ...attributes })(state);\n        if (canSetBlock) {\n            return true;\n        }\n        return commands.clearNodes();\n    })\n        .command(({ state: updatedState }) => {\n        return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.setBlockType)(type, { ...attributesToCopy, ...attributes })(updatedState, dispatch);\n    })\n        .run());\n};\n\nconst setNodeSelection = position => ({ tr, dispatch }) => {\n    if (dispatch) {\n        const { doc } = tr;\n        const from = minMax(position, 0, doc.content.size);\n        const selection = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.create(doc, from);\n        tr.setSelection(selection);\n    }\n    return true;\n};\n\nconst setTextSelection = position => ({ tr, dispatch }) => {\n    if (dispatch) {\n        const { doc } = tr;\n        const { from, to } = typeof position === 'number' ? { from: position, to: position } : position;\n        const minPos = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.atStart(doc).from;\n        const maxPos = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.atEnd(doc).to;\n        const resolvedFrom = minMax(from, minPos, maxPos);\n        const resolvedEnd = minMax(to, minPos, maxPos);\n        const selection = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(doc, resolvedFrom, resolvedEnd);\n        tr.setSelection(selection);\n    }\n    return true;\n};\n\nconst sinkListItem = typeOrName => ({ state, dispatch }) => {\n    const type = getNodeType(typeOrName, state.schema);\n    return (0,_tiptap_pm_schema_list__WEBPACK_IMPORTED_MODULE_6__.sinkListItem)(type)(state, dispatch);\n};\n\nfunction ensureMarks(state, splittableMarks) {\n    const marks = state.storedMarks || (state.selection.$to.parentOffset && state.selection.$from.marks());\n    if (marks) {\n        const filteredMarks = marks.filter(mark => splittableMarks === null || splittableMarks === void 0 ? void 0 : splittableMarks.includes(mark.type.name));\n        state.tr.ensureMarks(filteredMarks);\n    }\n}\nconst splitBlock = ({ keepMarks = true } = {}) => ({ tr, state, dispatch, editor, }) => {\n    const { selection, doc } = tr;\n    const { $from, $to } = selection;\n    const extensionAttributes = editor.extensionManager.attributes;\n    const newAttributes = getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs);\n    if (selection instanceof _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection && selection.node.isBlock) {\n        if (!$from.parentOffset || !(0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.canSplit)(doc, $from.pos)) {\n            return false;\n        }\n        if (dispatch) {\n            if (keepMarks) {\n                ensureMarks(state, editor.extensionManager.splittableMarks);\n            }\n            tr.split($from.pos).scrollIntoView();\n        }\n        return true;\n    }\n    if (!$from.parent.isBlock) {\n        return false;\n    }\n    const atEnd = $to.parentOffset === $to.parent.content.size;\n    const deflt = $from.depth === 0\n        ? undefined\n        : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));\n    let types = atEnd && deflt\n        ? [\n            {\n                type: deflt,\n                attrs: newAttributes,\n            },\n        ]\n        : undefined;\n    let can = (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.canSplit)(tr.doc, tr.mapping.map($from.pos), 1, types);\n    if (!types\n        && !can\n        && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.canSplit)(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : undefined)) {\n        can = true;\n        types = deflt\n            ? [\n                {\n                    type: deflt,\n                    attrs: newAttributes,\n                },\n            ]\n            : undefined;\n    }\n    if (dispatch) {\n        if (can) {\n            if (selection instanceof _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection) {\n                tr.deleteSelection();\n            }\n            tr.split(tr.mapping.map($from.pos), 1, types);\n            if (deflt && !atEnd && !$from.parentOffset && $from.parent.type !== deflt) {\n                const first = tr.mapping.map($from.before());\n                const $first = tr.doc.resolve(first);\n                if ($from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt)) {\n                    tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);\n                }\n            }\n        }\n        if (keepMarks) {\n            ensureMarks(state, editor.extensionManager.splittableMarks);\n        }\n        tr.scrollIntoView();\n    }\n    return can;\n};\n\nconst splitListItem = (typeOrName, overrideAttrs = {}) => ({ tr, state, dispatch, editor, }) => {\n    var _a;\n    const type = getNodeType(typeOrName, state.schema);\n    const { $from, $to } = state.selection;\n    // @ts-ignore\n    // eslint-disable-next-line\n    const node = state.selection.node;\n    if ((node && node.isBlock) || $from.depth < 2 || !$from.sameParent($to)) {\n        return false;\n    }\n    const grandParent = $from.node(-1);\n    if (grandParent.type !== type) {\n        return false;\n    }\n    const extensionAttributes = editor.extensionManager.attributes;\n    if ($from.parent.content.size === 0 && $from.node(-1).childCount === $from.indexAfter(-1)) {\n        // In an empty block. If this is a nested list, the wrapping\n        // list item should be split. Otherwise, bail out and let next\n        // command handle lifting.\n        if ($from.depth === 2\n            || $from.node(-3).type !== type\n            || $from.index(-2) !== $from.node(-2).childCount - 1) {\n            return false;\n        }\n        if (dispatch) {\n            let wrap = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment.empty;\n            // eslint-disable-next-line\n            const depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;\n            // Build a fragment containing empty versions of the structure\n            // from the outer list item to the parent node of the cursor\n            for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d -= 1) {\n                wrap = _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment.from($from.node(d).copy(wrap));\n            }\n            // eslint-disable-next-line\n            const depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1 : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;\n            // Add a second list item with an empty default start node\n            const newNextTypeAttributes = {\n                ...getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs),\n                ...overrideAttrs,\n            };\n            const nextType = ((_a = type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.createAndFill(newNextTypeAttributes)) || undefined;\n            wrap = wrap.append(_tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Fragment.from(type.createAndFill(null, nextType) || undefined));\n            const start = $from.before($from.depth - (depthBefore - 1));\n            tr.replace(start, $from.after(-depthAfter), new _tiptap_pm_model__WEBPACK_IMPORTED_MODULE_3__.Slice(wrap, 4 - depthBefore, 0));\n            let sel = -1;\n            tr.doc.nodesBetween(start, tr.doc.content.size, (n, pos) => {\n                if (sel > -1) {\n                    return false;\n                }\n                if (n.isTextblock && n.content.size === 0) {\n                    sel = pos + 1;\n                }\n            });\n            if (sel > -1) {\n                tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.near(tr.doc.resolve(sel)));\n            }\n            tr.scrollIntoView();\n        }\n        return true;\n    }\n    const nextType = $to.pos === $from.end() ? grandParent.contentMatchAt(0).defaultType : null;\n    const newTypeAttributes = {\n        ...getSplittedAttributes(extensionAttributes, grandParent.type.name, grandParent.attrs),\n        ...overrideAttrs,\n    };\n    const newNextTypeAttributes = {\n        ...getSplittedAttributes(extensionAttributes, $from.node().type.name, $from.node().attrs),\n        ...overrideAttrs,\n    };\n    tr.delete($from.pos, $to.pos);\n    const types = nextType\n        ? [\n            { type, attrs: newTypeAttributes },\n            { type: nextType, attrs: newNextTypeAttributes },\n        ]\n        : [{ type, attrs: newTypeAttributes }];\n    if (!(0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.canSplit)(tr.doc, $from.pos, 2)) {\n        return false;\n    }\n    if (dispatch) {\n        const { selection, storedMarks } = state;\n        const { splittableMarks } = editor.extensionManager;\n        const marks = storedMarks || (selection.$to.parentOffset && selection.$from.marks());\n        tr.split($from.pos, 2, types).scrollIntoView();\n        if (!marks || !dispatch) {\n            return true;\n        }\n        const filteredMarks = marks.filter(mark => splittableMarks.includes(mark.type.name));\n        tr.ensureMarks(filteredMarks);\n    }\n    return true;\n};\n\nconst joinListBackwards = (tr, listType) => {\n    const list = findParentNode(node => node.type === listType)(tr.selection);\n    if (!list) {\n        return true;\n    }\n    const before = tr.doc.resolve(Math.max(0, list.pos - 1)).before(list.depth);\n    if (before === undefined) {\n        return true;\n    }\n    const nodeBefore = tr.doc.nodeAt(before);\n    const canJoinBackwards = list.node.type === (nodeBefore === null || nodeBefore === void 0 ? void 0 : nodeBefore.type) && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.canJoin)(tr.doc, list.pos);\n    if (!canJoinBackwards) {\n        return true;\n    }\n    tr.join(list.pos);\n    return true;\n};\nconst joinListForwards = (tr, listType) => {\n    const list = findParentNode(node => node.type === listType)(tr.selection);\n    if (!list) {\n        return true;\n    }\n    const after = tr.doc.resolve(list.start).after(list.depth);\n    if (after === undefined) {\n        return true;\n    }\n    const nodeAfter = tr.doc.nodeAt(after);\n    const canJoinForwards = list.node.type === (nodeAfter === null || nodeAfter === void 0 ? void 0 : nodeAfter.type) && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.canJoin)(tr.doc, after);\n    if (!canJoinForwards) {\n        return true;\n    }\n    tr.join(after);\n    return true;\n};\nconst toggleList = (listTypeOrName, itemTypeOrName, keepMarks, attributes = {}) => ({ editor, tr, state, dispatch, chain, commands, can, }) => {\n    const { extensions, splittableMarks } = editor.extensionManager;\n    const listType = getNodeType(listTypeOrName, state.schema);\n    const itemType = getNodeType(itemTypeOrName, state.schema);\n    const { selection, storedMarks } = state;\n    const { $from, $to } = selection;\n    const range = $from.blockRange($to);\n    const marks = storedMarks || (selection.$to.parentOffset && selection.$from.marks());\n    if (!range) {\n        return false;\n    }\n    const parentList = findParentNode(node => isList(node.type.name, extensions))(selection);\n    if (range.depth >= 1 && parentList && range.depth - parentList.depth <= 1) {\n        // remove list\n        if (parentList.node.type === listType) {\n            return commands.liftListItem(itemType);\n        }\n        // change list type\n        if (isList(parentList.node.type.name, extensions)\n            && listType.validContent(parentList.node.content)\n            && dispatch) {\n            return chain()\n                .command(() => {\n                tr.setNodeMarkup(parentList.pos, listType);\n                return true;\n            })\n                .command(() => joinListBackwards(tr, listType))\n                .command(() => joinListForwards(tr, listType))\n                .run();\n        }\n    }\n    if (!keepMarks || !marks || !dispatch) {\n        return chain()\n            // try to convert node to default node if needed\n            .command(() => {\n            const canWrapInList = can().wrapInList(listType, attributes);\n            if (canWrapInList) {\n                return true;\n            }\n            return commands.clearNodes();\n        })\n            .wrapInList(listType, attributes)\n            .command(() => joinListBackwards(tr, listType))\n            .command(() => joinListForwards(tr, listType))\n            .run();\n    }\n    return (chain()\n        // try to convert node to default node if needed\n        .command(() => {\n        const canWrapInList = can().wrapInList(listType, attributes);\n        const filteredMarks = marks.filter(mark => splittableMarks.includes(mark.type.name));\n        tr.ensureMarks(filteredMarks);\n        if (canWrapInList) {\n            return true;\n        }\n        return commands.clearNodes();\n    })\n        .wrapInList(listType, attributes)\n        .command(() => joinListBackwards(tr, listType))\n        .command(() => joinListForwards(tr, listType))\n        .run());\n};\n\nconst toggleMark = (typeOrName, attributes = {}, options = {}) => ({ state, commands }) => {\n    const { extendEmptyMarkRange = false } = options;\n    const type = getMarkType(typeOrName, state.schema);\n    const isActive = isMarkActive(state, type, attributes);\n    if (isActive) {\n        return commands.unsetMark(type, { extendEmptyMarkRange });\n    }\n    return commands.setMark(type, attributes);\n};\n\nconst toggleNode = (typeOrName, toggleTypeOrName, attributes = {}) => ({ state, commands }) => {\n    const type = getNodeType(typeOrName, state.schema);\n    const toggleType = getNodeType(toggleTypeOrName, state.schema);\n    const isActive = isNodeActive(state, type, attributes);\n    let attributesToCopy;\n    if (state.selection.$anchor.sameParent(state.selection.$head)) {\n        // only copy attributes if the selection is pointing to a node of the same type\n        attributesToCopy = state.selection.$anchor.parent.attrs;\n    }\n    if (isActive) {\n        return commands.setNode(toggleType, attributesToCopy);\n    }\n    // If the node is not active, we want to set the new node type with the given attributes\n    // Copying over the attributes from the current node if the selection is pointing to a node of the same type\n    return commands.setNode(type, { ...attributesToCopy, ...attributes });\n};\n\nconst toggleWrap = (typeOrName, attributes = {}) => ({ state, commands }) => {\n    const type = getNodeType(typeOrName, state.schema);\n    const isActive = isNodeActive(state, type, attributes);\n    if (isActive) {\n        return commands.lift(type);\n    }\n    return commands.wrapIn(type, attributes);\n};\n\nconst undoInputRule = () => ({ state, dispatch }) => {\n    const plugins = state.plugins;\n    for (let i = 0; i < plugins.length; i += 1) {\n        const plugin = plugins[i];\n        let undoable;\n        // @ts-ignore\n        // eslint-disable-next-line\n        if (plugin.spec.isInputRules && (undoable = plugin.getState(state))) {\n            if (dispatch) {\n                const tr = state.tr;\n                const toUndo = undoable.transform;\n                for (let j = toUndo.steps.length - 1; j >= 0; j -= 1) {\n                    tr.step(toUndo.steps[j].invert(toUndo.docs[j]));\n                }\n                if (undoable.text) {\n                    const marks = tr.doc.resolve(undoable.from).marks();\n                    tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks));\n                }\n                else {\n                    tr.delete(undoable.from, undoable.to);\n                }\n            }\n            return true;\n        }\n    }\n    return false;\n};\n\nconst unsetAllMarks = () => ({ tr, dispatch }) => {\n    const { selection } = tr;\n    const { empty, ranges } = selection;\n    if (empty) {\n        return true;\n    }\n    if (dispatch) {\n        ranges.forEach(range => {\n            tr.removeMark(range.$from.pos, range.$to.pos);\n        });\n    }\n    return true;\n};\n\nconst unsetMark = (typeOrName, options = {}) => ({ tr, state, dispatch }) => {\n    var _a;\n    const { extendEmptyMarkRange = false } = options;\n    const { selection } = tr;\n    const type = getMarkType(typeOrName, state.schema);\n    const { $from, empty, ranges } = selection;\n    if (!dispatch) {\n        return true;\n    }\n    if (empty && extendEmptyMarkRange) {\n        let { from, to } = selection;\n        const attrs = (_a = $from.marks().find(mark => mark.type === type)) === null || _a === void 0 ? void 0 : _a.attrs;\n        const range = getMarkRange($from, type, attrs);\n        if (range) {\n            from = range.from;\n            to = range.to;\n        }\n        tr.removeMark(from, to, type);\n    }\n    else {\n        ranges.forEach(range => {\n            tr.removeMark(range.$from.pos, range.$to.pos, type);\n        });\n    }\n    tr.removeStoredMark(type);\n    return true;\n};\n\nconst updateAttributes = (typeOrName, attributes = {}) => ({ tr, state, dispatch }) => {\n    let nodeType = null;\n    let markType = null;\n    const schemaType = getSchemaTypeNameByName(typeof typeOrName === 'string' ? typeOrName : typeOrName.name, state.schema);\n    if (!schemaType) {\n        return false;\n    }\n    if (schemaType === 'node') {\n        nodeType = getNodeType(typeOrName, state.schema);\n    }\n    if (schemaType === 'mark') {\n        markType = getMarkType(typeOrName, state.schema);\n    }\n    if (dispatch) {\n        tr.selection.ranges.forEach((range) => {\n            const from = range.$from.pos;\n            const to = range.$to.pos;\n            let lastPos;\n            let lastNode;\n            let trimmedFrom;\n            let trimmedTo;\n            if (tr.selection.empty) {\n                state.doc.nodesBetween(from, to, (node, pos) => {\n                    if (nodeType && nodeType === node.type) {\n                        trimmedFrom = Math.max(pos, from);\n                        trimmedTo = Math.min(pos + node.nodeSize, to);\n                        lastPos = pos;\n                        lastNode = node;\n                    }\n                });\n            }\n            else {\n                state.doc.nodesBetween(from, to, (node, pos) => {\n                    if (pos < from && nodeType && nodeType === node.type) {\n                        trimmedFrom = Math.max(pos, from);\n                        trimmedTo = Math.min(pos + node.nodeSize, to);\n                        lastPos = pos;\n                        lastNode = node;\n                    }\n                    if (pos >= from && pos <= to) {\n                        if (nodeType && nodeType === node.type) {\n                            tr.setNodeMarkup(pos, undefined, {\n                                ...node.attrs,\n                                ...attributes,\n                            });\n                        }\n                        if (markType && node.marks.length) {\n                            node.marks.forEach((mark) => {\n                                if (markType === mark.type) {\n                                    const trimmedFrom2 = Math.max(pos, from);\n                                    const trimmedTo2 = Math.min(pos + node.nodeSize, to);\n                                    tr.addMark(trimmedFrom2, trimmedTo2, markType.create({\n                                        ...mark.attrs,\n                                        ...attributes,\n                                    }));\n                                }\n                            });\n                        }\n                    }\n                });\n            }\n            if (lastNode) {\n                if (lastPos !== undefined) {\n                    tr.setNodeMarkup(lastPos, undefined, {\n                        ...lastNode.attrs,\n                        ...attributes,\n                    });\n                }\n                if (markType && lastNode.marks.length) {\n                    lastNode.marks.forEach((mark) => {\n                        if (markType === mark.type) {\n                            tr.addMark(trimmedFrom, trimmedTo, markType.create({\n                                ...mark.attrs,\n                                ...attributes,\n                            }));\n                        }\n                    });\n                }\n            }\n        });\n    }\n    return true;\n};\n\nconst wrapIn = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\n    const type = getNodeType(typeOrName, state.schema);\n    return (0,_tiptap_pm_commands__WEBPACK_IMPORTED_MODULE_5__.wrapIn)(type, attributes)(state, dispatch);\n};\n\nconst wrapInList = (typeOrName, attributes = {}) => ({ state, dispatch }) => {\n    const type = getNodeType(typeOrName, state.schema);\n    return (0,_tiptap_pm_schema_list__WEBPACK_IMPORTED_MODULE_6__.wrapInList)(type, attributes)(state, dispatch);\n};\n\nvar commands = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  blur: blur,\n  clearContent: clearContent,\n  clearNodes: clearNodes,\n  command: command,\n  createParagraphNear: createParagraphNear,\n  cut: cut,\n  deleteCurrentNode: deleteCurrentNode,\n  deleteNode: deleteNode,\n  deleteRange: deleteRange,\n  deleteSelection: deleteSelection,\n  enter: enter,\n  exitCode: exitCode,\n  extendMarkRange: extendMarkRange,\n  first: first,\n  focus: focus,\n  forEach: forEach,\n  insertContent: insertContent,\n  insertContentAt: insertContentAt,\n  joinBackward: joinBackward,\n  joinDown: joinDown,\n  joinForward: joinForward,\n  joinItemBackward: joinItemBackward,\n  joinItemForward: joinItemForward,\n  joinTextblockBackward: joinTextblockBackward,\n  joinTextblockForward: joinTextblockForward,\n  joinUp: joinUp,\n  keyboardShortcut: keyboardShortcut,\n  lift: lift,\n  liftEmptyBlock: liftEmptyBlock,\n  liftListItem: liftListItem,\n  newlineInCode: newlineInCode,\n  resetAttributes: resetAttributes,\n  scrollIntoView: scrollIntoView,\n  selectAll: selectAll,\n  selectNodeBackward: selectNodeBackward,\n  selectNodeForward: selectNodeForward,\n  selectParentNode: selectParentNode,\n  selectTextblockEnd: selectTextblockEnd,\n  selectTextblockStart: selectTextblockStart,\n  setContent: setContent,\n  setMark: setMark,\n  setMeta: setMeta,\n  setNode: setNode,\n  setNodeSelection: setNodeSelection,\n  setTextSelection: setTextSelection,\n  sinkListItem: sinkListItem,\n  splitBlock: splitBlock,\n  splitListItem: splitListItem,\n  toggleList: toggleList,\n  toggleMark: toggleMark,\n  toggleNode: toggleNode,\n  toggleWrap: toggleWrap,\n  undoInputRule: undoInputRule,\n  unsetAllMarks: unsetAllMarks,\n  unsetMark: unsetMark,\n  updateAttributes: updateAttributes,\n  wrapIn: wrapIn,\n  wrapInList: wrapInList\n});\n\nconst Commands = Extension.create({\n    name: 'commands',\n    addCommands() {\n        return {\n            ...commands,\n        };\n    },\n});\n\nconst Drop = Extension.create({\n    name: 'drop',\n    addProseMirrorPlugins() {\n        return [\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n                key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey('tiptapDrop'),\n                props: {\n                    handleDrop: (_, e, slice, moved) => {\n                        this.editor.emit('drop', {\n                            editor: this.editor,\n                            event: e,\n                            slice,\n                            moved,\n                        });\n                    },\n                },\n            }),\n        ];\n    },\n});\n\nconst Editable = Extension.create({\n    name: 'editable',\n    addProseMirrorPlugins() {\n        return [\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n                key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey('editable'),\n                props: {\n                    editable: () => this.editor.options.editable,\n                },\n            }),\n        ];\n    },\n});\n\nconst focusEventsPluginKey = new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey('focusEvents');\nconst FocusEvents = Extension.create({\n    name: 'focusEvents',\n    addProseMirrorPlugins() {\n        const { editor } = this;\n        return [\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n                key: focusEventsPluginKey,\n                props: {\n                    handleDOMEvents: {\n                        focus: (view, event) => {\n                            editor.isFocused = true;\n                            const transaction = editor.state.tr\n                                .setMeta('focus', { event })\n                                .setMeta('addToHistory', false);\n                            view.dispatch(transaction);\n                            return false;\n                        },\n                        blur: (view, event) => {\n                            editor.isFocused = false;\n                            const transaction = editor.state.tr\n                                .setMeta('blur', { event })\n                                .setMeta('addToHistory', false);\n                            view.dispatch(transaction);\n                            return false;\n                        },\n                    },\n                },\n            }),\n        ];\n    },\n});\n\nconst Keymap = Extension.create({\n    name: 'keymap',\n    addKeyboardShortcuts() {\n        const handleBackspace = () => this.editor.commands.first(({ commands }) => [\n            () => commands.undoInputRule(),\n            // maybe convert first text block node to default node\n            () => commands.command(({ tr }) => {\n                const { selection, doc } = tr;\n                const { empty, $anchor } = selection;\n                const { pos, parent } = $anchor;\n                const $parentPos = $anchor.parent.isTextblock && pos > 0 ? tr.doc.resolve(pos - 1) : $anchor;\n                const parentIsIsolating = $parentPos.parent.type.spec.isolating;\n                const parentPos = $anchor.pos - $anchor.parentOffset;\n                const isAtStart = (parentIsIsolating && $parentPos.parent.childCount === 1)\n                    ? parentPos === $anchor.pos\n                    : _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.atStart(doc).from === pos;\n                if (!empty\n                    || !parent.type.isTextblock\n                    || parent.textContent.length\n                    || !isAtStart\n                    || (isAtStart && $anchor.parent.type.name === 'paragraph') // prevent clearNodes when no nodes to clear, otherwise history stack is appended\n                ) {\n                    return false;\n                }\n                return commands.clearNodes();\n            }),\n            () => commands.deleteSelection(),\n            () => commands.joinBackward(),\n            () => commands.selectNodeBackward(),\n        ]);\n        const handleDelete = () => this.editor.commands.first(({ commands }) => [\n            () => commands.deleteSelection(),\n            () => commands.deleteCurrentNode(),\n            () => commands.joinForward(),\n            () => commands.selectNodeForward(),\n        ]);\n        const handleEnter = () => this.editor.commands.first(({ commands }) => [\n            () => commands.newlineInCode(),\n            () => commands.createParagraphNear(),\n            () => commands.liftEmptyBlock(),\n            () => commands.splitBlock(),\n        ]);\n        const baseKeymap = {\n            Enter: handleEnter,\n            'Mod-Enter': () => this.editor.commands.exitCode(),\n            Backspace: handleBackspace,\n            'Mod-Backspace': handleBackspace,\n            'Shift-Backspace': handleBackspace,\n            Delete: handleDelete,\n            'Mod-Delete': handleDelete,\n            'Mod-a': () => this.editor.commands.selectAll(),\n        };\n        const pcKeymap = {\n            ...baseKeymap,\n        };\n        const macKeymap = {\n            ...baseKeymap,\n            'Ctrl-h': handleBackspace,\n            'Alt-Backspace': handleBackspace,\n            'Ctrl-d': handleDelete,\n            'Ctrl-Alt-Backspace': handleDelete,\n            'Alt-Delete': handleDelete,\n            'Alt-d': handleDelete,\n            'Ctrl-a': () => this.editor.commands.selectTextblockStart(),\n            'Ctrl-e': () => this.editor.commands.selectTextblockEnd(),\n        };\n        if (isiOS() || isMacOS()) {\n            return macKeymap;\n        }\n        return pcKeymap;\n    },\n    addProseMirrorPlugins() {\n        return [\n            // With this plugin we check if the whole document was selected and deleted.\n            // In this case we will additionally call `clearNodes()` to convert e.g. a heading\n            // to a paragraph if necessary.\n            // This is an alternative to ProseMirror's `AllSelection`, which doesn’t work well\n            // with many other commands.\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n                key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey('clearDocument'),\n                appendTransaction: (transactions, oldState, newState) => {\n                    if (transactions.some(tr => tr.getMeta('composition'))) {\n                        return;\n                    }\n                    const docChanges = transactions.some(transaction => transaction.docChanged)\n                        && !oldState.doc.eq(newState.doc);\n                    const ignoreTr = transactions.some(transaction => transaction.getMeta('preventClearDocument'));\n                    if (!docChanges || ignoreTr) {\n                        return;\n                    }\n                    const { empty, from, to } = oldState.selection;\n                    const allFrom = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.atStart(oldState.doc).from;\n                    const allEnd = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.atEnd(oldState.doc).to;\n                    const allWasSelected = from === allFrom && to === allEnd;\n                    if (empty || !allWasSelected) {\n                        return;\n                    }\n                    const isEmpty = isNodeEmpty(newState.doc);\n                    if (!isEmpty) {\n                        return;\n                    }\n                    const tr = newState.tr;\n                    const state = createChainableState({\n                        state: newState,\n                        transaction: tr,\n                    });\n                    const { commands } = new CommandManager({\n                        editor: this.editor,\n                        state,\n                    });\n                    commands.clearNodes();\n                    if (!tr.steps.length) {\n                        return;\n                    }\n                    return tr;\n                },\n            }),\n        ];\n    },\n});\n\nconst Paste = Extension.create({\n    name: 'paste',\n    addProseMirrorPlugins() {\n        return [\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n                key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey('tiptapPaste'),\n                props: {\n                    handlePaste: (_view, e, slice) => {\n                        this.editor.emit('paste', {\n                            editor: this.editor,\n                            event: e,\n                            slice,\n                        });\n                    },\n                },\n            }),\n        ];\n    },\n});\n\nconst Tabindex = Extension.create({\n    name: 'tabindex',\n    addProseMirrorPlugins() {\n        return [\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n                key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey('tabindex'),\n                props: {\n                    attributes: () => (this.editor.isEditable ? { tabindex: '0' } : {}),\n                },\n            }),\n        ];\n    },\n});\n\nvar index = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  ClipboardTextSerializer: ClipboardTextSerializer,\n  Commands: Commands,\n  Drop: Drop,\n  Editable: Editable,\n  FocusEvents: FocusEvents,\n  Keymap: Keymap,\n  Paste: Paste,\n  Tabindex: Tabindex,\n  focusEventsPluginKey: focusEventsPluginKey\n});\n\nclass NodePos {\n    get name() {\n        return this.node.type.name;\n    }\n    constructor(pos, editor, isBlock = false, node = null) {\n        this.currentNode = null;\n        this.actualDepth = null;\n        this.isBlock = isBlock;\n        this.resolvedPos = pos;\n        this.editor = editor;\n        this.currentNode = node;\n    }\n    get node() {\n        return this.currentNode || this.resolvedPos.node();\n    }\n    get element() {\n        return this.editor.view.domAtPos(this.pos).node;\n    }\n    get depth() {\n        var _a;\n        return (_a = this.actualDepth) !== null && _a !== void 0 ? _a : this.resolvedPos.depth;\n    }\n    get pos() {\n        return this.resolvedPos.pos;\n    }\n    get content() {\n        return this.node.content;\n    }\n    set content(content) {\n        let from = this.from;\n        let to = this.to;\n        if (this.isBlock) {\n            if (this.content.size === 0) {\n                console.error(`You can’t set content on a block node. Tried to set content on ${this.name} at ${this.pos}`);\n                return;\n            }\n            from = this.from + 1;\n            to = this.to - 1;\n        }\n        this.editor.commands.insertContentAt({ from, to }, content);\n    }\n    get attributes() {\n        return this.node.attrs;\n    }\n    get textContent() {\n        return this.node.textContent;\n    }\n    get size() {\n        return this.node.nodeSize;\n    }\n    get from() {\n        if (this.isBlock) {\n            return this.pos;\n        }\n        return this.resolvedPos.start(this.resolvedPos.depth);\n    }\n    get range() {\n        return {\n            from: this.from,\n            to: this.to,\n        };\n    }\n    get to() {\n        if (this.isBlock) {\n            return this.pos + this.size;\n        }\n        return this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1);\n    }\n    get parent() {\n        if (this.depth === 0) {\n            return null;\n        }\n        const parentPos = this.resolvedPos.start(this.resolvedPos.depth - 1);\n        const $pos = this.resolvedPos.doc.resolve(parentPos);\n        return new NodePos($pos, this.editor);\n    }\n    get before() {\n        let $pos = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2));\n        if ($pos.depth !== this.depth) {\n            $pos = this.resolvedPos.doc.resolve(this.from - 3);\n        }\n        return new NodePos($pos, this.editor);\n    }\n    get after() {\n        let $pos = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1));\n        if ($pos.depth !== this.depth) {\n            $pos = this.resolvedPos.doc.resolve(this.to + 3);\n        }\n        return new NodePos($pos, this.editor);\n    }\n    get children() {\n        const children = [];\n        this.node.content.forEach((node, offset) => {\n            const isBlock = node.isBlock && !node.isTextblock;\n            const isNonTextAtom = node.isAtom && !node.isText;\n            const targetPos = this.pos + offset + (isNonTextAtom ? 0 : 1);\n            // Check if targetPos is within valid document range\n            if (targetPos < 0 || targetPos > this.resolvedPos.doc.nodeSize - 2) {\n                return;\n            }\n            const $pos = this.resolvedPos.doc.resolve(targetPos);\n            if (!isBlock && $pos.depth <= this.depth) {\n                return;\n            }\n            const childNodePos = new NodePos($pos, this.editor, isBlock, isBlock ? node : null);\n            if (isBlock) {\n                childNodePos.actualDepth = this.depth + 1;\n            }\n            children.push(new NodePos($pos, this.editor, isBlock, isBlock ? node : null));\n        });\n        return children;\n    }\n    get firstChild() {\n        return this.children[0] || null;\n    }\n    get lastChild() {\n        const children = this.children;\n        return children[children.length - 1] || null;\n    }\n    closest(selector, attributes = {}) {\n        let node = null;\n        let currentNode = this.parent;\n        while (currentNode && !node) {\n            if (currentNode.node.type.name === selector) {\n                if (Object.keys(attributes).length > 0) {\n                    const nodeAttributes = currentNode.node.attrs;\n                    const attrKeys = Object.keys(attributes);\n                    for (let index = 0; index < attrKeys.length; index += 1) {\n                        const key = attrKeys[index];\n                        if (nodeAttributes[key] !== attributes[key]) {\n                            break;\n                        }\n                    }\n                }\n                else {\n                    node = currentNode;\n                }\n            }\n            currentNode = currentNode.parent;\n        }\n        return node;\n    }\n    querySelector(selector, attributes = {}) {\n        return this.querySelectorAll(selector, attributes, true)[0] || null;\n    }\n    querySelectorAll(selector, attributes = {}, firstItemOnly = false) {\n        let nodes = [];\n        if (!this.children || this.children.length === 0) {\n            return nodes;\n        }\n        const attrKeys = Object.keys(attributes);\n        /**\n         * Finds all children recursively that match the selector and attributes\n         * If firstItemOnly is true, it will return the first item found\n         */\n        this.children.forEach(childPos => {\n            // If we already found a node and we only want the first item, we dont need to keep going\n            if (firstItemOnly && nodes.length > 0) {\n                return;\n            }\n            if (childPos.node.type.name === selector) {\n                const doesAllAttributesMatch = attrKeys.every(key => attributes[key] === childPos.node.attrs[key]);\n                if (doesAllAttributesMatch) {\n                    nodes.push(childPos);\n                }\n            }\n            // If we already found a node and we only want the first item, we can stop here and skip the recursion\n            if (firstItemOnly && nodes.length > 0) {\n                return;\n            }\n            nodes = nodes.concat(childPos.querySelectorAll(selector, attributes, firstItemOnly));\n        });\n        return nodes;\n    }\n    setAttribute(attributes) {\n        const { tr } = this.editor.state;\n        tr.setNodeMarkup(this.from, undefined, {\n            ...this.node.attrs,\n            ...attributes,\n        });\n        this.editor.view.dispatch(tr);\n    }\n}\n\nconst style = `.ProseMirror {\n  position: relative;\n}\n\n.ProseMirror {\n  word-wrap: break-word;\n  white-space: pre-wrap;\n  white-space: break-spaces;\n  -webkit-font-variant-ligatures: none;\n  font-variant-ligatures: none;\n  font-feature-settings: \"liga\" 0; /* the above doesn't seem to work in Edge */\n}\n\n.ProseMirror [contenteditable=\"false\"] {\n  white-space: normal;\n}\n\n.ProseMirror [contenteditable=\"false\"] [contenteditable=\"true\"] {\n  white-space: pre-wrap;\n}\n\n.ProseMirror pre {\n  white-space: pre-wrap;\n}\n\nimg.ProseMirror-separator {\n  display: inline !important;\n  border: none !important;\n  margin: 0 !important;\n  width: 0 !important;\n  height: 0 !important;\n}\n\n.ProseMirror-gapcursor {\n  display: none;\n  pointer-events: none;\n  position: absolute;\n  margin: 0;\n}\n\n.ProseMirror-gapcursor:after {\n  content: \"\";\n  display: block;\n  position: absolute;\n  top: -2px;\n  width: 20px;\n  border-top: 1px solid black;\n  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;\n}\n\n@keyframes ProseMirror-cursor-blink {\n  to {\n    visibility: hidden;\n  }\n}\n\n.ProseMirror-hideselection *::selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection *::-moz-selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection * {\n  caret-color: transparent;\n}\n\n.ProseMirror-focused .ProseMirror-gapcursor {\n  display: block;\n}\n\n.tippy-box[data-animation=fade][data-state=hidden] {\n  opacity: 0\n}`;\n\nfunction createStyleTag(style, nonce, suffix) {\n    const tiptapStyleTag = document.querySelector(`style[data-tiptap-style${suffix ? `-${suffix}` : ''}]`);\n    if (tiptapStyleTag !== null) {\n        return tiptapStyleTag;\n    }\n    const styleNode = document.createElement('style');\n    if (nonce) {\n        styleNode.setAttribute('nonce', nonce);\n    }\n    styleNode.setAttribute(`data-tiptap-style${suffix ? `-${suffix}` : ''}`, '');\n    styleNode.innerHTML = style;\n    document.getElementsByTagName('head')[0].appendChild(styleNode);\n    return styleNode;\n}\n\nclass Editor extends EventEmitter {\n    constructor(options = {}) {\n        super();\n        this.isFocused = false;\n        /**\n         * The editor is considered initialized after the `create` event has been emitted.\n         */\n        this.isInitialized = false;\n        this.extensionStorage = {};\n        this.options = {\n            element: document.createElement('div'),\n            content: '',\n            injectCSS: true,\n            injectNonce: undefined,\n            extensions: [],\n            autofocus: false,\n            editable: true,\n            editorProps: {},\n            parseOptions: {},\n            coreExtensionOptions: {},\n            enableInputRules: true,\n            enablePasteRules: true,\n            enableCoreExtensions: true,\n            enableContentCheck: false,\n            emitContentError: false,\n            onBeforeCreate: () => null,\n            onCreate: () => null,\n            onUpdate: () => null,\n            onSelectionUpdate: () => null,\n            onTransaction: () => null,\n            onFocus: () => null,\n            onBlur: () => null,\n            onDestroy: () => null,\n            onContentError: ({ error }) => { throw error; },\n            onPaste: () => null,\n            onDrop: () => null,\n        };\n        this.isCapturingTransaction = false;\n        this.capturedTransaction = null;\n        this.setOptions(options);\n        this.createExtensionManager();\n        this.createCommandManager();\n        this.createSchema();\n        this.on('beforeCreate', this.options.onBeforeCreate);\n        this.emit('beforeCreate', { editor: this });\n        this.on('contentError', this.options.onContentError);\n        this.createView();\n        this.injectCSS();\n        this.on('create', this.options.onCreate);\n        this.on('update', this.options.onUpdate);\n        this.on('selectionUpdate', this.options.onSelectionUpdate);\n        this.on('transaction', this.options.onTransaction);\n        this.on('focus', this.options.onFocus);\n        this.on('blur', this.options.onBlur);\n        this.on('destroy', this.options.onDestroy);\n        this.on('drop', ({ event, slice, moved }) => this.options.onDrop(event, slice, moved));\n        this.on('paste', ({ event, slice }) => this.options.onPaste(event, slice));\n        window.setTimeout(() => {\n            if (this.isDestroyed) {\n                return;\n            }\n            this.commands.focus(this.options.autofocus);\n            this.emit('create', { editor: this });\n            this.isInitialized = true;\n        }, 0);\n    }\n    /**\n     * Returns the editor storage.\n     */\n    get storage() {\n        return this.extensionStorage;\n    }\n    /**\n     * An object of all registered commands.\n     */\n    get commands() {\n        return this.commandManager.commands;\n    }\n    /**\n     * Create a command chain to call multiple commands at once.\n     */\n    chain() {\n        return this.commandManager.chain();\n    }\n    /**\n     * Check if a command or a command chain can be executed. Without executing it.\n     */\n    can() {\n        return this.commandManager.can();\n    }\n    /**\n     * Inject CSS styles.\n     */\n    injectCSS() {\n        if (this.options.injectCSS && document) {\n            this.css = createStyleTag(style, this.options.injectNonce);\n        }\n    }\n    /**\n     * Update editor options.\n     *\n     * @param options A list of options\n     */\n    setOptions(options = {}) {\n        this.options = {\n            ...this.options,\n            ...options,\n        };\n        if (!this.view || !this.state || this.isDestroyed) {\n            return;\n        }\n        if (this.options.editorProps) {\n            this.view.setProps(this.options.editorProps);\n        }\n        this.view.updateState(this.state);\n    }\n    /**\n     * Update editable state of the editor.\n     */\n    setEditable(editable, emitUpdate = true) {\n        this.setOptions({ editable });\n        if (emitUpdate) {\n            this.emit('update', { editor: this, transaction: this.state.tr });\n        }\n    }\n    /**\n     * Returns whether the editor is editable.\n     */\n    get isEditable() {\n        // since plugins are applied after creating the view\n        // `editable` is always `true` for one tick.\n        // that’s why we also have to check for `options.editable`\n        return this.options.editable && this.view && this.view.editable;\n    }\n    /**\n     * Returns the editor state.\n     */\n    get state() {\n        return this.view.state;\n    }\n    /**\n     * Register a ProseMirror plugin.\n     *\n     * @param plugin A ProseMirror plugin\n     * @param handlePlugins Control how to merge the plugin into the existing plugins.\n     * @returns The new editor state\n     */\n    registerPlugin(plugin, handlePlugins) {\n        const plugins = isFunction(handlePlugins)\n            ? handlePlugins(plugin, [...this.state.plugins])\n            : [...this.state.plugins, plugin];\n        const state = this.state.reconfigure({ plugins });\n        this.view.updateState(state);\n        return state;\n    }\n    /**\n     * Unregister a ProseMirror plugin.\n     *\n     * @param nameOrPluginKeyToRemove The plugins name\n     * @returns The new editor state or undefined if the editor is destroyed\n     */\n    unregisterPlugin(nameOrPluginKeyToRemove) {\n        if (this.isDestroyed) {\n            return undefined;\n        }\n        const prevPlugins = this.state.plugins;\n        let plugins = prevPlugins;\n        [].concat(nameOrPluginKeyToRemove).forEach(nameOrPluginKey => {\n            // @ts-ignore\n            const name = typeof nameOrPluginKey === 'string' ? `${nameOrPluginKey}$` : nameOrPluginKey.key;\n            // @ts-ignore\n            plugins = plugins.filter(plugin => !plugin.key.startsWith(name));\n        });\n        if (prevPlugins.length === plugins.length) {\n            // No plugin was removed, so we don’t need to update the state\n            return undefined;\n        }\n        const state = this.state.reconfigure({\n            plugins,\n        });\n        this.view.updateState(state);\n        return state;\n    }\n    /**\n     * Creates an extension manager.\n     */\n    createExtensionManager() {\n        var _a, _b;\n        const coreExtensions = this.options.enableCoreExtensions ? [\n            Editable,\n            ClipboardTextSerializer.configure({\n                blockSeparator: (_b = (_a = this.options.coreExtensionOptions) === null || _a === void 0 ? void 0 : _a.clipboardTextSerializer) === null || _b === void 0 ? void 0 : _b.blockSeparator,\n            }),\n            Commands,\n            FocusEvents,\n            Keymap,\n            Tabindex,\n            Drop,\n            Paste,\n        ].filter(ext => {\n            if (typeof this.options.enableCoreExtensions === 'object') {\n                return this.options.enableCoreExtensions[ext.name] !== false;\n            }\n            return true;\n        }) : [];\n        const allExtensions = [...coreExtensions, ...this.options.extensions].filter(extension => {\n            return ['extension', 'node', 'mark'].includes(extension === null || extension === void 0 ? void 0 : extension.type);\n        });\n        this.extensionManager = new ExtensionManager(allExtensions, this);\n    }\n    /**\n     * Creates an command manager.\n     */\n    createCommandManager() {\n        this.commandManager = new CommandManager({\n            editor: this,\n        });\n    }\n    /**\n     * Creates a ProseMirror schema.\n     */\n    createSchema() {\n        this.schema = this.extensionManager.schema;\n    }\n    /**\n     * Creates a ProseMirror view.\n     */\n    createView() {\n        var _a;\n        let doc;\n        try {\n            doc = createDocument(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: this.options.enableContentCheck });\n        }\n        catch (e) {\n            if (!(e instanceof Error) || !['[tiptap error]: Invalid JSON content', '[tiptap error]: Invalid HTML content'].includes(e.message)) {\n                // Not the content error we were expecting\n                throw e;\n            }\n            this.emit('contentError', {\n                editor: this,\n                error: e,\n                disableCollaboration: () => {\n                    if (this.storage.collaboration) {\n                        this.storage.collaboration.isDisabled = true;\n                    }\n                    // To avoid syncing back invalid content, reinitialize the extensions without the collaboration extension\n                    this.options.extensions = this.options.extensions.filter(extension => extension.name !== 'collaboration');\n                    // Restart the initialization process by recreating the extension manager with the new set of extensions\n                    this.createExtensionManager();\n                },\n            });\n            // Content is invalid, but attempt to create it anyway, stripping out the invalid parts\n            doc = createDocument(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: false });\n        }\n        const selection = resolveFocusPosition(doc, this.options.autofocus);\n        this.view = new _tiptap_pm_view__WEBPACK_IMPORTED_MODULE_1__.EditorView(this.options.element, {\n            ...this.options.editorProps,\n            attributes: {\n                // add `role=\"textbox\"` to the editor element\n                role: 'textbox',\n                ...(_a = this.options.editorProps) === null || _a === void 0 ? void 0 : _a.attributes,\n            },\n            dispatchTransaction: this.dispatchTransaction.bind(this),\n            state: _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.EditorState.create({\n                doc,\n                selection: selection || undefined,\n            }),\n        });\n        // `editor.view` is not yet available at this time.\n        // Therefore we will add all plugins and node views directly afterwards.\n        const newState = this.state.reconfigure({\n            plugins: this.extensionManager.plugins,\n        });\n        this.view.updateState(newState);\n        this.createNodeViews();\n        this.prependClass();\n        // Let’s store the editor instance in the DOM element.\n        // So we’ll have access to it for tests.\n        // @ts-ignore\n        const dom = this.view.dom;\n        dom.editor = this;\n    }\n    /**\n     * Creates all node views.\n     */\n    createNodeViews() {\n        if (this.view.isDestroyed) {\n            return;\n        }\n        this.view.setProps({\n            nodeViews: this.extensionManager.nodeViews,\n        });\n    }\n    /**\n     * Prepend class name to element.\n     */\n    prependClass() {\n        this.view.dom.className = `tiptap ${this.view.dom.className}`;\n    }\n    captureTransaction(fn) {\n        this.isCapturingTransaction = true;\n        fn();\n        this.isCapturingTransaction = false;\n        const tr = this.capturedTransaction;\n        this.capturedTransaction = null;\n        return tr;\n    }\n    /**\n     * The callback over which to send transactions (state updates) produced by the view.\n     *\n     * @param transaction An editor state transaction\n     */\n    dispatchTransaction(transaction) {\n        // if the editor / the view of the editor was destroyed\n        // the transaction should not be dispatched as there is no view anymore.\n        if (this.view.isDestroyed) {\n            return;\n        }\n        if (this.isCapturingTransaction) {\n            if (!this.capturedTransaction) {\n                this.capturedTransaction = transaction;\n                return;\n            }\n            transaction.steps.forEach(step => { var _a; return (_a = this.capturedTransaction) === null || _a === void 0 ? void 0 : _a.step(step); });\n            return;\n        }\n        const state = this.state.apply(transaction);\n        const selectionHasChanged = !this.state.selection.eq(state.selection);\n        this.emit('beforeTransaction', {\n            editor: this,\n            transaction,\n            nextState: state,\n        });\n        this.view.updateState(state);\n        this.emit('transaction', {\n            editor: this,\n            transaction,\n        });\n        if (selectionHasChanged) {\n            this.emit('selectionUpdate', {\n                editor: this,\n                transaction,\n            });\n        }\n        const focus = transaction.getMeta('focus');\n        const blur = transaction.getMeta('blur');\n        if (focus) {\n            this.emit('focus', {\n                editor: this,\n                event: focus.event,\n                transaction,\n            });\n        }\n        if (blur) {\n            this.emit('blur', {\n                editor: this,\n                event: blur.event,\n                transaction,\n            });\n        }\n        if (!transaction.docChanged || transaction.getMeta('preventUpdate')) {\n            return;\n        }\n        this.emit('update', {\n            editor: this,\n            transaction,\n        });\n    }\n    /**\n     * Get attributes of the currently selected node or mark.\n     */\n    getAttributes(nameOrType) {\n        return getAttributes(this.state, nameOrType);\n    }\n    isActive(nameOrAttributes, attributesOrUndefined) {\n        const name = typeof nameOrAttributes === 'string' ? nameOrAttributes : null;\n        const attributes = typeof nameOrAttributes === 'string' ? attributesOrUndefined : nameOrAttributes;\n        return isActive(this.state, name, attributes);\n    }\n    /**\n     * Get the document as JSON.\n     */\n    getJSON() {\n        return this.state.doc.toJSON();\n    }\n    /**\n     * Get the document as HTML.\n     */\n    getHTML() {\n        return getHTMLFromFragment(this.state.doc.content, this.schema);\n    }\n    /**\n     * Get the document as text.\n     */\n    getText(options) {\n        const { blockSeparator = '\\n\\n', textSerializers = {} } = options || {};\n        return getText(this.state.doc, {\n            blockSeparator,\n            textSerializers: {\n                ...getTextSerializersFromSchema(this.schema),\n                ...textSerializers,\n            },\n        });\n    }\n    /**\n     * Check if there is no content.\n     */\n    get isEmpty() {\n        return isNodeEmpty(this.state.doc);\n    }\n    /**\n     * Get the number of characters for the current document.\n     *\n     * @deprecated\n     */\n    getCharacterCount() {\n        console.warn('[tiptap warn]: \"editor.getCharacterCount()\" is deprecated. Please use \"editor.storage.characterCount.characters()\" instead.');\n        return this.state.doc.content.size - 2;\n    }\n    /**\n     * Destroy the editor.\n     */\n    destroy() {\n        this.emit('destroy');\n        if (this.view) {\n            // Cleanup our reference to prevent circular references which caused memory leaks\n            // @ts-ignore\n            const dom = this.view.dom;\n            if (dom && dom.editor) {\n                delete dom.editor;\n            }\n            this.view.destroy();\n        }\n        this.removeAllListeners();\n    }\n    /**\n     * Check if the editor is already destroyed.\n     */\n    get isDestroyed() {\n        var _a;\n        // @ts-ignore\n        return !((_a = this.view) === null || _a === void 0 ? void 0 : _a.docView);\n    }\n    $node(selector, attributes) {\n        var _a;\n        return ((_a = this.$doc) === null || _a === void 0 ? void 0 : _a.querySelector(selector, attributes)) || null;\n    }\n    $nodes(selector, attributes) {\n        var _a;\n        return ((_a = this.$doc) === null || _a === void 0 ? void 0 : _a.querySelectorAll(selector, attributes)) || null;\n    }\n    $pos(pos) {\n        const $pos = this.state.doc.resolve(pos);\n        return new NodePos($pos, this);\n    }\n    get $doc() {\n        return this.$pos(0);\n    }\n}\n\n/**\n * Build an input rule that adds a mark when the\n * matched text is typed into it.\n * @see https://tiptap.dev/docs/editor/extensions/custom-extensions/extend-existing#input-rules\n */\nfunction markInputRule(config) {\n    return new InputRule({\n        find: config.find,\n        handler: ({ state, range, match }) => {\n            const attributes = callOrReturn(config.getAttributes, undefined, match);\n            if (attributes === false || attributes === null) {\n                return null;\n            }\n            const { tr } = state;\n            const captureGroup = match[match.length - 1];\n            const fullMatch = match[0];\n            if (captureGroup) {\n                const startSpaces = fullMatch.search(/\\S/);\n                const textStart = range.from + fullMatch.indexOf(captureGroup);\n                const textEnd = textStart + captureGroup.length;\n                const excludedMarks = getMarksBetween(range.from, range.to, state.doc)\n                    .filter(item => {\n                    // @ts-ignore\n                    const excluded = item.mark.type.excluded;\n                    return excluded.find(type => type === config.type && type !== item.mark.type);\n                })\n                    .filter(item => item.to > textStart);\n                if (excludedMarks.length) {\n                    return null;\n                }\n                if (textEnd < range.to) {\n                    tr.delete(textEnd, range.to);\n                }\n                if (textStart > range.from) {\n                    tr.delete(range.from + startSpaces, textStart);\n                }\n                const markEnd = range.from + startSpaces + captureGroup.length;\n                tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));\n                tr.removeStoredMark(config.type);\n            }\n        },\n    });\n}\n\n/**\n * Build an input rule that adds a node when the\n * matched text is typed into it.\n * @see https://tiptap.dev/docs/editor/extensions/custom-extensions/extend-existing#input-rules\n */\nfunction nodeInputRule(config) {\n    return new InputRule({\n        find: config.find,\n        handler: ({ state, range, match }) => {\n            const attributes = callOrReturn(config.getAttributes, undefined, match) || {};\n            const { tr } = state;\n            const start = range.from;\n            let end = range.to;\n            const newNode = config.type.create(attributes);\n            if (match[1]) {\n                const offset = match[0].lastIndexOf(match[1]);\n                let matchStart = start + offset;\n                if (matchStart > end) {\n                    matchStart = end;\n                }\n                else {\n                    end = matchStart + match[1].length;\n                }\n                // insert last typed character\n                const lastChar = match[0][match[0].length - 1];\n                tr.insertText(lastChar, start + match[0].length - 1);\n                // insert node from input rule\n                tr.replaceWith(matchStart, end, newNode);\n            }\n            else if (match[0]) {\n                const insertionStart = config.type.isInline ? start : start - 1;\n                tr.insert(insertionStart, config.type.create(attributes)).delete(tr.mapping.map(start), tr.mapping.map(end));\n            }\n            tr.scrollIntoView();\n        },\n    });\n}\n\n/**\n * Build an input rule that changes the type of a textblock when the\n * matched text is typed into it. When using a regular expresion you’ll\n * probably want the regexp to start with `^`, so that the pattern can\n * only occur at the start of a textblock.\n * @see https://tiptap.dev/docs/editor/extensions/custom-extensions/extend-existing#input-rules\n */\nfunction textblockTypeInputRule(config) {\n    return new InputRule({\n        find: config.find,\n        handler: ({ state, range, match }) => {\n            const $start = state.doc.resolve(range.from);\n            const attributes = callOrReturn(config.getAttributes, undefined, match) || {};\n            if (!$start.node(-1).canReplaceWith($start.index(-1), $start.indexAfter(-1), config.type)) {\n                return null;\n            }\n            state.tr\n                .delete(range.from, range.to)\n                .setBlockType(range.from, range.from, config.type, attributes);\n        },\n    });\n}\n\n/**\n * Build an input rule that replaces text when the\n * matched text is typed into it.\n * @see https://tiptap.dev/docs/editor/extensions/custom-extensions/extend-existing#input-rules\n */\nfunction textInputRule(config) {\n    return new InputRule({\n        find: config.find,\n        handler: ({ state, range, match }) => {\n            let insert = config.replace;\n            let start = range.from;\n            const end = range.to;\n            if (match[1]) {\n                const offset = match[0].lastIndexOf(match[1]);\n                insert += match[0].slice(offset + match[1].length);\n                start += offset;\n                const cutOff = start - end;\n                if (cutOff > 0) {\n                    insert = match[0].slice(offset - cutOff, offset) + insert;\n                    start = end;\n                }\n            }\n            state.tr.insertText(insert, start, end);\n        },\n    });\n}\n\n/**\n * Build an input rule for automatically wrapping a textblock when a\n * given string is typed. When using a regular expresion you’ll\n * probably want the regexp to start with `^`, so that the pattern can\n * only occur at the start of a textblock.\n *\n * `type` is the type of node to wrap in.\n *\n * By default, if there’s a node with the same type above the newly\n * wrapped node, the rule will try to join those\n * two nodes. You can pass a join predicate, which takes a regular\n * expression match and the node before the wrapped node, and can\n * return a boolean to indicate whether a join should happen.\n * @see https://tiptap.dev/docs/editor/extensions/custom-extensions/extend-existing#input-rules\n */\nfunction wrappingInputRule(config) {\n    return new InputRule({\n        find: config.find,\n        handler: ({ state, range, match, chain, }) => {\n            const attributes = callOrReturn(config.getAttributes, undefined, match) || {};\n            const tr = state.tr.delete(range.from, range.to);\n            const $start = tr.doc.resolve(range.from);\n            const blockRange = $start.blockRange();\n            const wrapping = blockRange && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.findWrapping)(blockRange, config.type, attributes);\n            if (!wrapping) {\n                return null;\n            }\n            tr.wrap(blockRange, wrapping);\n            if (config.keepMarks && config.editor) {\n                const { selection, storedMarks } = state;\n                const { splittableMarks } = config.editor.extensionManager;\n                const marks = storedMarks || (selection.$to.parentOffset && selection.$from.marks());\n                if (marks) {\n                    const filteredMarks = marks.filter(mark => splittableMarks.includes(mark.type.name));\n                    tr.ensureMarks(filteredMarks);\n                }\n            }\n            if (config.keepAttributes) {\n                /** If the nodeType is `bulletList` or `orderedList` set the `nodeType` as `listItem` */\n                const nodeType = config.type.name === 'bulletList' || config.type.name === 'orderedList' ? 'listItem' : 'taskList';\n                chain().updateAttributes(nodeType, attributes).run();\n            }\n            const before = tr.doc.resolve(range.from - 1).nodeBefore;\n            if (before\n                && before.type === config.type\n                && (0,_tiptap_pm_transform__WEBPACK_IMPORTED_MODULE_4__.canJoin)(tr.doc, range.from - 1)\n                && (!config.joinPredicate || config.joinPredicate(match, before))) {\n                tr.join(range.from - 1);\n            }\n        },\n    });\n}\n\n/**\n * The Node class is used to create custom node extensions.\n * @see https://tiptap.dev/api/extensions#create-a-new-extension\n */\nclass Node {\n    constructor(config = {}) {\n        this.type = 'node';\n        this.name = 'node';\n        this.parent = null;\n        this.child = null;\n        this.config = {\n            name: this.name,\n            defaultOptions: {},\n        };\n        this.config = {\n            ...this.config,\n            ...config,\n        };\n        this.name = this.config.name;\n        if (config.defaultOptions && Object.keys(config.defaultOptions).length > 0) {\n            console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${this.name}\".`);\n        }\n        // TODO: remove `addOptions` fallback\n        this.options = this.config.defaultOptions;\n        if (this.config.addOptions) {\n            this.options = callOrReturn(getExtensionField(this, 'addOptions', {\n                name: this.name,\n            }));\n        }\n        this.storage = callOrReturn(getExtensionField(this, 'addStorage', {\n            name: this.name,\n            options: this.options,\n        })) || {};\n    }\n    static create(config = {}) {\n        return new Node(config);\n    }\n    configure(options = {}) {\n        // return a new instance so we can use the same extension\n        // with different calls of `configure`\n        const extension = this.extend({\n            ...this.config,\n            addOptions: () => {\n                return mergeDeep(this.options, options);\n            },\n        });\n        // Always preserve the current name\n        extension.name = this.name;\n        // Set the parent to be our parent\n        extension.parent = this.parent;\n        return extension;\n    }\n    extend(extendedConfig = {}) {\n        const extension = new Node(extendedConfig);\n        extension.parent = this;\n        this.child = extension;\n        extension.name = extendedConfig.name ? extendedConfig.name : extension.parent.name;\n        if (extendedConfig.defaultOptions && Object.keys(extendedConfig.defaultOptions).length > 0) {\n            console.warn(`[tiptap warn]: BREAKING CHANGE: \"defaultOptions\" is deprecated. Please use \"addOptions\" instead. Found in extension: \"${extension.name}\".`);\n        }\n        extension.options = callOrReturn(getExtensionField(extension, 'addOptions', {\n            name: extension.name,\n        }));\n        extension.storage = callOrReturn(getExtensionField(extension, 'addStorage', {\n            name: extension.name,\n            options: extension.options,\n        }));\n        return extension;\n    }\n}\n\n/**\n * Node views are used to customize the rendered DOM structure of a node.\n * @see https://tiptap.dev/guide/node-views\n */\nclass NodeView {\n    constructor(component, props, options) {\n        this.isDragging = false;\n        this.component = component;\n        this.editor = props.editor;\n        this.options = {\n            stopEvent: null,\n            ignoreMutation: null,\n            ...options,\n        };\n        this.extension = props.extension;\n        this.node = props.node;\n        this.decorations = props.decorations;\n        this.innerDecorations = props.innerDecorations;\n        this.view = props.view;\n        this.HTMLAttributes = props.HTMLAttributes;\n        this.getPos = props.getPos;\n        this.mount();\n    }\n    mount() {\n        // eslint-disable-next-line\n        return;\n    }\n    get dom() {\n        return this.editor.view.dom;\n    }\n    get contentDOM() {\n        return null;\n    }\n    onDragStart(event) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        const { view } = this.editor;\n        const target = event.target;\n        // get the drag handle element\n        // `closest` is not available for text nodes so we may have to use its parent\n        const dragHandle = target.nodeType === 3\n            ? (_a = target.parentElement) === null || _a === void 0 ? void 0 : _a.closest('[data-drag-handle]')\n            : target.closest('[data-drag-handle]');\n        if (!this.dom || ((_b = this.contentDOM) === null || _b === void 0 ? void 0 : _b.contains(target)) || !dragHandle) {\n            return;\n        }\n        let x = 0;\n        let y = 0;\n        // calculate offset for drag element if we use a different drag handle element\n        if (this.dom !== dragHandle) {\n            const domBox = this.dom.getBoundingClientRect();\n            const handleBox = dragHandle.getBoundingClientRect();\n            // In React, we have to go through nativeEvent to reach offsetX/offsetY.\n            const offsetX = (_c = event.offsetX) !== null && _c !== void 0 ? _c : (_d = event.nativeEvent) === null || _d === void 0 ? void 0 : _d.offsetX;\n            const offsetY = (_e = event.offsetY) !== null && _e !== void 0 ? _e : (_f = event.nativeEvent) === null || _f === void 0 ? void 0 : _f.offsetY;\n            x = handleBox.x - domBox.x + offsetX;\n            y = handleBox.y - domBox.y + offsetY;\n        }\n        const clonedNode = this.dom.cloneNode(true);\n        (_g = event.dataTransfer) === null || _g === void 0 ? void 0 : _g.setDragImage(clonedNode, x, y);\n        const pos = this.getPos();\n        if (typeof pos !== 'number') {\n            return;\n        }\n        // we need to tell ProseMirror that we want to move the whole node\n        // so we create a NodeSelection\n        const selection = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.create(view.state.doc, pos);\n        const transaction = view.state.tr.setSelection(selection);\n        view.dispatch(transaction);\n    }\n    stopEvent(event) {\n        var _a;\n        if (!this.dom) {\n            return false;\n        }\n        if (typeof this.options.stopEvent === 'function') {\n            return this.options.stopEvent({ event });\n        }\n        const target = event.target;\n        const isInElement = this.dom.contains(target) && !((_a = this.contentDOM) === null || _a === void 0 ? void 0 : _a.contains(target));\n        // any event from child nodes should be handled by ProseMirror\n        if (!isInElement) {\n            return false;\n        }\n        const isDragEvent = event.type.startsWith('drag');\n        const isDropEvent = event.type === 'drop';\n        const isInput = ['INPUT', 'BUTTON', 'SELECT', 'TEXTAREA'].includes(target.tagName) || target.isContentEditable;\n        // any input event within node views should be ignored by ProseMirror\n        if (isInput && !isDropEvent && !isDragEvent) {\n            return true;\n        }\n        const { isEditable } = this.editor;\n        const { isDragging } = this;\n        const isDraggable = !!this.node.type.spec.draggable;\n        const isSelectable = _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.isSelectable(this.node);\n        const isCopyEvent = event.type === 'copy';\n        const isPasteEvent = event.type === 'paste';\n        const isCutEvent = event.type === 'cut';\n        const isClickEvent = event.type === 'mousedown';\n        // ProseMirror tries to drag selectable nodes\n        // even if `draggable` is set to `false`\n        // this fix prevents that\n        if (!isDraggable && isSelectable && isDragEvent && event.target === this.dom) {\n            event.preventDefault();\n        }\n        if (isDraggable && isDragEvent && !isDragging && event.target === this.dom) {\n            event.preventDefault();\n            return false;\n        }\n        // we have to store that dragging started\n        if (isDraggable && isEditable && !isDragging && isClickEvent) {\n            const dragHandle = target.closest('[data-drag-handle]');\n            const isValidDragHandle = dragHandle && (this.dom === dragHandle || this.dom.contains(dragHandle));\n            if (isValidDragHandle) {\n                this.isDragging = true;\n                document.addEventListener('dragend', () => {\n                    this.isDragging = false;\n                }, { once: true });\n                document.addEventListener('drop', () => {\n                    this.isDragging = false;\n                }, { once: true });\n                document.addEventListener('mouseup', () => {\n                    this.isDragging = false;\n                }, { once: true });\n            }\n        }\n        // these events are handled by prosemirror\n        if (isDragging\n            || isDropEvent\n            || isCopyEvent\n            || isPasteEvent\n            || isCutEvent\n            || (isClickEvent && isSelectable)) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Called when a DOM [mutation](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver) or a selection change happens within the view.\n     * @return `false` if the editor should re-read the selection or re-parse the range around the mutation\n     * @return `true` if it can safely be ignored.\n     */\n    ignoreMutation(mutation) {\n        if (!this.dom || !this.contentDOM) {\n            return true;\n        }\n        if (typeof this.options.ignoreMutation === 'function') {\n            return this.options.ignoreMutation({ mutation });\n        }\n        // a leaf/atom node is like a black box for ProseMirror\n        // and should be fully handled by the node view\n        if (this.node.isLeaf || this.node.isAtom) {\n            return true;\n        }\n        // ProseMirror should handle any selections\n        if (mutation.type === 'selection') {\n            return false;\n        }\n        // try to prevent a bug on iOS and Android that will break node views on enter\n        // this is because ProseMirror can’t preventDispatch on enter\n        // this will lead to a re-render of the node view on enter\n        // see: https://github.com/ueberdosis/tiptap/issues/1214\n        // see: https://github.com/ueberdosis/tiptap/issues/2534\n        if (this.dom.contains(mutation.target)\n            && mutation.type === 'childList'\n            && (isiOS() || isAndroid())\n            && this.editor.isFocused) {\n            const changedNodes = [\n                ...Array.from(mutation.addedNodes),\n                ...Array.from(mutation.removedNodes),\n            ];\n            // we’ll check if every changed node is contentEditable\n            // to make sure it’s probably mutated by ProseMirror\n            if (changedNodes.every(node => node.isContentEditable)) {\n                return false;\n            }\n        }\n        // we will allow mutation contentDOM with attributes\n        // so we can for example adding classes within our node view\n        if (this.contentDOM === mutation.target && mutation.type === 'attributes') {\n            return true;\n        }\n        // ProseMirror should handle any changes within contentDOM\n        if (this.contentDOM.contains(mutation.target)) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Update the attributes of the prosemirror node.\n     */\n    updateAttributes(attributes) {\n        this.editor.commands.command(({ tr }) => {\n            const pos = this.getPos();\n            if (typeof pos !== 'number') {\n                return false;\n            }\n            tr.setNodeMarkup(pos, undefined, {\n                ...this.node.attrs,\n                ...attributes,\n            });\n            return true;\n        });\n    }\n    /**\n     * Delete the node.\n     */\n    deleteNode() {\n        const from = this.getPos();\n        if (typeof from !== 'number') {\n            return;\n        }\n        const to = from + this.node.nodeSize;\n        this.editor.commands.deleteRange({ from, to });\n    }\n}\n\n/**\n * Build an paste rule that adds a mark when the\n * matched text is pasted into it.\n * @see https://tiptap.dev/docs/editor/extensions/custom-extensions/extend-existing#paste-rules\n */\nfunction markPasteRule(config) {\n    return new PasteRule({\n        find: config.find,\n        handler: ({ state, range, match, pasteEvent, }) => {\n            const attributes = callOrReturn(config.getAttributes, undefined, match, pasteEvent);\n            if (attributes === false || attributes === null) {\n                return null;\n            }\n            const { tr } = state;\n            const captureGroup = match[match.length - 1];\n            const fullMatch = match[0];\n            let markEnd = range.to;\n            if (captureGroup) {\n                const startSpaces = fullMatch.search(/\\S/);\n                const textStart = range.from + fullMatch.indexOf(captureGroup);\n                const textEnd = textStart + captureGroup.length;\n                const excludedMarks = getMarksBetween(range.from, range.to, state.doc)\n                    .filter(item => {\n                    // @ts-ignore\n                    const excluded = item.mark.type.excluded;\n                    return excluded.find(type => type === config.type && type !== item.mark.type);\n                })\n                    .filter(item => item.to > textStart);\n                if (excludedMarks.length) {\n                    return null;\n                }\n                if (textEnd < range.to) {\n                    tr.delete(textEnd, range.to);\n                }\n                if (textStart > range.from) {\n                    tr.delete(range.from + startSpaces, textStart);\n                }\n                markEnd = range.from + startSpaces + captureGroup.length;\n                tr.addMark(range.from + startSpaces, markEnd, config.type.create(attributes || {}));\n                tr.removeStoredMark(config.type);\n            }\n        },\n    });\n}\n\nfunction canInsertNode(state, nodeType) {\n    const { selection } = state;\n    const { $from } = selection;\n    // Special handling for NodeSelection\n    if (selection instanceof _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection) {\n        const index = $from.index();\n        const parent = $from.parent;\n        // Can we replace the selected node with the horizontal rule?\n        return parent.canReplaceWith(index, index + 1, nodeType);\n    }\n    // Default: check if we can insert at the current position\n    let depth = $from.depth;\n    while (depth >= 0) {\n        const index = $from.index(depth);\n        const parent = $from.node(depth);\n        const match = parent.contentMatchAt(index);\n        if (match.matchType(nodeType)) {\n            return true;\n        }\n        depth -= 1;\n    }\n    return false;\n}\n\n// source: https://stackoverflow.com/a/6969486\nfunction escapeForRegEx(string) {\n    return string.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n}\n\nfunction isString(value) {\n    return typeof value === 'string';\n}\n\n/**\n * Build an paste rule that adds a node when the\n * matched text is pasted into it.\n * @see https://tiptap.dev/docs/editor/extensions/custom-extensions/extend-existing#paste-rules\n */\nfunction nodePasteRule(config) {\n    return new PasteRule({\n        find: config.find,\n        handler({ match, chain, range, pasteEvent, }) {\n            const attributes = callOrReturn(config.getAttributes, undefined, match, pasteEvent);\n            const content = callOrReturn(config.getContent, undefined, attributes);\n            if (attributes === false || attributes === null) {\n                return null;\n            }\n            const node = { type: config.type.name, attrs: attributes };\n            if (content) {\n                node.content = content;\n            }\n            if (match.input) {\n                chain().deleteRange(range).insertContentAt(range.from, node);\n            }\n        },\n    });\n}\n\n/**\n * Build an paste rule that replaces text when the\n * matched text is pasted into it.\n * @see https://tiptap.dev/docs/editor/extensions/custom-extensions/extend-existing#paste-rules\n */\nfunction textPasteRule(config) {\n    return new PasteRule({\n        find: config.find,\n        handler: ({ state, range, match }) => {\n            let insert = config.replace;\n            let start = range.from;\n            const end = range.to;\n            if (match[1]) {\n                const offset = match[0].lastIndexOf(match[1]);\n                insert += match[0].slice(offset + match[1].length);\n                start += offset;\n                const cutOff = start - end;\n                if (cutOff > 0) {\n                    insert = match[0].slice(offset - cutOff, offset) + insert;\n                    start = end;\n                }\n            }\n            state.tr.insertText(insert, start, end);\n        },\n    });\n}\n\nclass Tracker {\n    constructor(transaction) {\n        this.transaction = transaction;\n        this.currentStep = this.transaction.steps.length;\n    }\n    map(position) {\n        let deleted = false;\n        const mappedPosition = this.transaction.steps\n            .slice(this.currentStep)\n            .reduce((newPosition, step) => {\n            const mapResult = step.getMap().mapResult(newPosition);\n            if (mapResult.deleted) {\n                deleted = true;\n            }\n            return mapResult.pos;\n        }, position);\n        return {\n            position: mappedPosition,\n            deleted,\n        };\n    }\n}\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2NvcmUvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXlIO0FBQzVFO0FBQ0Y7QUFDMEQ7QUFDb0M7QUFDc2lCO0FBQzNpQjs7QUFFcEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakMsVUFBVSxZQUFZO0FBQ3RCLFVBQVUsTUFBTTtBQUNoQixVQUFVLGNBQWM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2QkFBNkI7QUFDN0MsZ0JBQWdCLE9BQU87QUFDdkIsZ0JBQWdCLEtBQUs7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2QkFBNkI7QUFDN0MsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJB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QUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0IsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQSw2QkFBNkIsMkRBQWE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsSUFBSSxZQUFZO0FBQ2pDO0FBQ0E7QUFDQSxpQkFBaUIsSUFBSSxZQUFZO0FBQ2pDO0FBQ0E7QUFDQSxpQkFBaUIsSUFBSSxZQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsVUFBVTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLElBQUk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsVUFBVTtBQUNyRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0NBQWtDO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLEtBQUs7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUc7QUFDakc7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7O0FBRUE7QUFDQSxZQUFZLFlBQVk7QUFDeEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0EsNkJBQTZCLDJEQUFhO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtDQUFrQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFNC9DO0FBQzUvQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9jb3JlL2Rpc3QvaW5kZXguanM/NzcxZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQbHVnaW4sIFBsdWdpbktleSwgVGV4dFNlbGVjdGlvbiwgU2VsZWN0aW9uLCBBbGxTZWxlY3Rpb24sIE5vZGVTZWxlY3Rpb24sIEVkaXRvclN0YXRlIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSc7XG5pbXBvcnQgeyBFZGl0b3JWaWV3IH0gZnJvbSAnQHRpcHRhcC9wbS92aWV3JztcbmltcG9ydCB7IGtleW1hcCB9IGZyb20gJ0B0aXB0YXAvcG0va2V5bWFwJztcbmltcG9ydCB7IFNjaGVtYSwgRE9NU2VyaWFsaXplciwgRnJhZ21lbnQsIE5vZGUgYXMgTm9kZSQxLCBET01QYXJzZXIsIFNsaWNlIH0gZnJvbSAnQHRpcHRhcC9wbS9tb2RlbCc7XG5pbXBvcnQgeyBsaWZ0VGFyZ2V0LCBSZXBsYWNlU3RlcCwgUmVwbGFjZUFyb3VuZFN0ZXAsIGpvaW5Qb2ludCwgVHJhbnNmb3JtLCBjYW5TcGxpdCwgY2FuSm9pbiwgZmluZFdyYXBwaW5nIH0gZnJvbSAnQHRpcHRhcC9wbS90cmFuc2Zvcm0nO1xuaW1wb3J0IHsgY3JlYXRlUGFyYWdyYXBoTmVhciBhcyBjcmVhdGVQYXJhZ3JhcGhOZWFyJDEsIGRlbGV0ZVNlbGVjdGlvbiBhcyBkZWxldGVTZWxlY3Rpb24kMSwgZXhpdENvZGUgYXMgZXhpdENvZGUkMSwgam9pblVwIGFzIGpvaW5VcCQxLCBqb2luRG93biBhcyBqb2luRG93biQxLCBqb2luQmFja3dhcmQgYXMgam9pbkJhY2t3YXJkJDEsIGpvaW5Gb3J3YXJkIGFzIGpvaW5Gb3J3YXJkJDEsIGpvaW5UZXh0YmxvY2tCYWNrd2FyZCBhcyBqb2luVGV4dGJsb2NrQmFja3dhcmQkMSwgam9pblRleHRibG9ja0ZvcndhcmQgYXMgam9pblRleHRibG9ja0ZvcndhcmQkMSwgbGlmdCBhcyBsaWZ0JDEsIGxpZnRFbXB0eUJsb2NrIGFzIGxpZnRFbXB0eUJsb2NrJDEsIG5ld2xpbmVJbkNvZGUgYXMgbmV3bGluZUluQ29kZSQxLCBzZWxlY3ROb2RlQmFja3dhcmQgYXMgc2VsZWN0Tm9kZUJhY2t3YXJkJDEsIHNlbGVjdE5vZGVGb3J3YXJkIGFzIHNlbGVjdE5vZGVGb3J3YXJkJDEsIHNlbGVjdFBhcmVudE5vZGUgYXMgc2VsZWN0UGFyZW50Tm9kZSQxLCBzZWxlY3RUZXh0YmxvY2tFbmQgYXMgc2VsZWN0VGV4dGJsb2NrRW5kJDEsIHNlbGVjdFRleHRibG9ja1N0YXJ0IGFzIHNlbGVjdFRleHRibG9ja1N0YXJ0JDEsIHNldEJsb2NrVHlwZSwgd3JhcEluIGFzIHdyYXBJbiQxIH0gZnJvbSAnQHRpcHRhcC9wbS9jb21tYW5kcyc7XG5pbXBvcnQgeyBsaWZ0TGlzdEl0ZW0gYXMgbGlmdExpc3RJdGVtJDEsIHNpbmtMaXN0SXRlbSBhcyBzaW5rTGlzdEl0ZW0kMSwgd3JhcEluTGlzdCBhcyB3cmFwSW5MaXN0JDEgfSBmcm9tICdAdGlwdGFwL3BtL3NjaGVtYS1saXN0JztcblxuLyoqXG4gKiBUYWtlcyBhIFRyYW5zYWN0aW9uICYgRWRpdG9yIFN0YXRlIGFuZCB0dXJucyBpdCBpbnRvIGEgY2hhaW5hYmxlIHN0YXRlIG9iamVjdFxuICogQHBhcmFtIGNvbmZpZyBUaGUgdHJhbnNhY3Rpb24gYW5kIHN0YXRlIHRvIGNyZWF0ZSB0aGUgY2hhaW5hYmxlIHN0YXRlIGZyb21cbiAqIEByZXR1cm5zIEEgY2hhaW5hYmxlIEVkaXRvciBzdGF0ZSBvYmplY3RcbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2hhaW5hYmxlU3RhdGUoY29uZmlnKSB7XG4gICAgY29uc3QgeyBzdGF0ZSwgdHJhbnNhY3Rpb24gfSA9IGNvbmZpZztcbiAgICBsZXQgeyBzZWxlY3Rpb24gfSA9IHRyYW5zYWN0aW9uO1xuICAgIGxldCB7IGRvYyB9ID0gdHJhbnNhY3Rpb247XG4gICAgbGV0IHsgc3RvcmVkTWFya3MgfSA9IHRyYW5zYWN0aW9uO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLnN0YXRlLFxuICAgICAgICBhcHBseTogc3RhdGUuYXBwbHkuYmluZChzdGF0ZSksXG4gICAgICAgIGFwcGx5VHJhbnNhY3Rpb246IHN0YXRlLmFwcGx5VHJhbnNhY3Rpb24uYmluZChzdGF0ZSksXG4gICAgICAgIHBsdWdpbnM6IHN0YXRlLnBsdWdpbnMsXG4gICAgICAgIHNjaGVtYTogc3RhdGUuc2NoZW1hLFxuICAgICAgICByZWNvbmZpZ3VyZTogc3RhdGUucmVjb25maWd1cmUuYmluZChzdGF0ZSksXG4gICAgICAgIHRvSlNPTjogc3RhdGUudG9KU09OLmJpbmQoc3RhdGUpLFxuICAgICAgICBnZXQgc3RvcmVkTWFya3MoKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RvcmVkTWFya3M7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBzZWxlY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0aW9uO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgZG9jKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRvYztcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IHRyKCkge1xuICAgICAgICAgICAgc2VsZWN0aW9uID0gdHJhbnNhY3Rpb24uc2VsZWN0aW9uO1xuICAgICAgICAgICAgZG9jID0gdHJhbnNhY3Rpb24uZG9jO1xuICAgICAgICAgICAgc3RvcmVkTWFya3MgPSB0cmFuc2FjdGlvbi5zdG9yZWRNYXJrcztcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2FjdGlvbjtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuXG5jbGFzcyBDb21tYW5kTWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgdGhpcy5lZGl0b3IgPSBwcm9wcy5lZGl0b3I7XG4gICAgICAgIHRoaXMucmF3Q29tbWFuZHMgPSB0aGlzLmVkaXRvci5leHRlbnNpb25NYW5hZ2VyLmNvbW1hbmRzO1xuICAgICAgICB0aGlzLmN1c3RvbVN0YXRlID0gcHJvcHMuc3RhdGU7XG4gICAgfVxuICAgIGdldCBoYXNDdXN0b21TdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5jdXN0b21TdGF0ZTtcbiAgICB9XG4gICAgZ2V0IHN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXN0b21TdGF0ZSB8fCB0aGlzLmVkaXRvci5zdGF0ZTtcbiAgICB9XG4gICAgZ2V0IGNvbW1hbmRzKCkge1xuICAgICAgICBjb25zdCB7IHJhd0NvbW1hbmRzLCBlZGl0b3IsIHN0YXRlIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHZpZXcgfSA9IGVkaXRvcjtcbiAgICAgICAgY29uc3QgeyB0ciB9ID0gc3RhdGU7XG4gICAgICAgIGNvbnN0IHByb3BzID0gdGhpcy5idWlsZFByb3BzKHRyKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhyYXdDb21tYW5kcykubWFwKChbbmFtZSwgY29tbWFuZF0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1ldGhvZCA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBjb21tYW5kKC4uLmFyZ3MpKHByb3BzKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRyLmdldE1ldGEoJ3ByZXZlbnREaXNwYXRjaCcpICYmICF0aGlzLmhhc0N1c3RvbVN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2s7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIFtuYW1lLCBtZXRob2RdO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIGdldCBjaGFpbigpIHtcbiAgICAgICAgcmV0dXJuICgpID0+IHRoaXMuY3JlYXRlQ2hhaW4oKTtcbiAgICB9XG4gICAgZ2V0IGNhbigpIHtcbiAgICAgICAgcmV0dXJuICgpID0+IHRoaXMuY3JlYXRlQ2FuKCk7XG4gICAgfVxuICAgIGNyZWF0ZUNoYWluKHN0YXJ0VHIsIHNob3VsZERpc3BhdGNoID0gdHJ1ZSkge1xuICAgICAgICBjb25zdCB7IHJhd0NvbW1hbmRzLCBlZGl0b3IsIHN0YXRlIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHZpZXcgfSA9IGVkaXRvcjtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gW107XG4gICAgICAgIGNvbnN0IGhhc1N0YXJ0VHJhbnNhY3Rpb24gPSAhIXN0YXJ0VHI7XG4gICAgICAgIGNvbnN0IHRyID0gc3RhcnRUciB8fCBzdGF0ZS50cjtcbiAgICAgICAgY29uc3QgcnVuID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFoYXNTdGFydFRyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgJiYgc2hvdWxkRGlzcGF0Y2hcbiAgICAgICAgICAgICAgICAmJiAhdHIuZ2V0TWV0YSgncHJldmVudERpc3BhdGNoJylcbiAgICAgICAgICAgICAgICAmJiAhdGhpcy5oYXNDdXN0b21TdGF0ZSkge1xuICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrcy5ldmVyeShjYWxsYmFjayA9PiBjYWxsYmFjayA9PT0gdHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNoYWluID0ge1xuICAgICAgICAgICAgLi4uT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKHJhd0NvbW1hbmRzKS5tYXAoKFtuYW1lLCBjb21tYW5kXSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYWluZWRDb21tYW5kID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcHMgPSB0aGlzLmJ1aWxkUHJvcHModHIsIHNob3VsZERpc3BhdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBjb21tYW5kKC4uLmFyZ3MpKHByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hhaW47XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW25hbWUsIGNoYWluZWRDb21tYW5kXTtcbiAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgIHJ1bixcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNoYWluO1xuICAgIH1cbiAgICBjcmVhdGVDYW4oc3RhcnRUcikge1xuICAgICAgICBjb25zdCB7IHJhd0NvbW1hbmRzLCBzdGF0ZSB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgZGlzcGF0Y2ggPSBmYWxzZTtcbiAgICAgICAgY29uc3QgdHIgPSBzdGFydFRyIHx8IHN0YXRlLnRyO1xuICAgICAgICBjb25zdCBwcm9wcyA9IHRoaXMuYnVpbGRQcm9wcyh0ciwgZGlzcGF0Y2gpO1xuICAgICAgICBjb25zdCBmb3JtYXR0ZWRDb21tYW5kcyA9IE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhyYXdDb21tYW5kcykubWFwKChbbmFtZSwgY29tbWFuZF0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiBbbmFtZSwgKC4uLmFyZ3MpID0+IGNvbW1hbmQoLi4uYXJncykoeyAuLi5wcm9wcywgZGlzcGF0Y2g6IHVuZGVmaW5lZCB9KV07XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmZvcm1hdHRlZENvbW1hbmRzLFxuICAgICAgICAgICAgY2hhaW46ICgpID0+IHRoaXMuY3JlYXRlQ2hhaW4odHIsIGRpc3BhdGNoKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYnVpbGRQcm9wcyh0ciwgc2hvdWxkRGlzcGF0Y2ggPSB0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgcmF3Q29tbWFuZHMsIGVkaXRvciwgc3RhdGUgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgdmlldyB9ID0gZWRpdG9yO1xuICAgICAgICBjb25zdCBwcm9wcyA9IHtcbiAgICAgICAgICAgIHRyLFxuICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgdmlldyxcbiAgICAgICAgICAgIHN0YXRlOiBjcmVhdGVDaGFpbmFibGVTdGF0ZSh7XG4gICAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IHRyLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBkaXNwYXRjaDogc2hvdWxkRGlzcGF0Y2ggPyAoKSA9PiB1bmRlZmluZWQgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjaGFpbjogKCkgPT4gdGhpcy5jcmVhdGVDaGFpbih0ciwgc2hvdWxkRGlzcGF0Y2gpLFxuICAgICAgICAgICAgY2FuOiAoKSA9PiB0aGlzLmNyZWF0ZUNhbih0ciksXG4gICAgICAgICAgICBnZXQgY29tbWFuZHMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhyYXdDb21tYW5kcykubWFwKChbbmFtZSwgY29tbWFuZF0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtuYW1lLCAoLi4uYXJncykgPT4gY29tbWFuZCguLi5hcmdzKShwcm9wcyldO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwcm9wcztcbiAgICB9XG59XG5cbmNsYXNzIEV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzID0ge307XG4gICAgfVxuICAgIG9uKGV2ZW50LCBmbikge1xuICAgICAgICBpZiAoIXRoaXMuY2FsbGJhY2tzW2V2ZW50XSkge1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFja3NbZXZlbnRdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWxsYmFja3NbZXZlbnRdLnB1c2goZm4pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZW1pdChldmVudCwgLi4uYXJncykge1xuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzLmNhbGxiYWNrc1tldmVudF07XG4gICAgICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3MpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgb2ZmKGV2ZW50LCBmbikge1xuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSB0aGlzLmNhbGxiYWNrc1tldmVudF07XG4gICAgICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzW2V2ZW50XSA9IGNhbGxiYWNrcy5maWx0ZXIoY2FsbGJhY2sgPT4gY2FsbGJhY2sgIT09IGZuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNhbGxiYWNrc1tldmVudF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG9uY2UoZXZlbnQsIGZuKSB7XG4gICAgICAgIGNvbnN0IG9uY2VGbiA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9mZihldmVudCwgb25jZUZuKTtcbiAgICAgICAgICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5vbihldmVudCwgb25jZUZuKTtcbiAgICB9XG4gICAgcmVtb3ZlQWxsTGlzdGVuZXJzKCkge1xuICAgICAgICB0aGlzLmNhbGxiYWNrcyA9IHt9O1xuICAgIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZmllbGQgZnJvbSBhbiBleHRlbnNpb25cbiAqIEBwYXJhbSBleHRlbnNpb24gVGhlIFRpcHRhcCBleHRlbnNpb25cbiAqIEBwYXJhbSBmaWVsZCBUaGUgZmllbGQsIGZvciBleGFtcGxlIGByZW5kZXJIVE1MYCBvciBgcHJpb3JpdHlgXG4gKiBAcGFyYW0gY29udGV4dCBUaGUgY29udGV4dCBvYmplY3QgdGhhdCBzaG91bGQgYmUgcGFzc2VkIGFzIGB0aGlzYCBpbnRvIHRoZSBmdW5jdGlvblxuICogQHJldHVybnMgVGhlIGZpZWxkIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgZmllbGQsIGNvbnRleHQpIHtcbiAgICBpZiAoZXh0ZW5zaW9uLmNvbmZpZ1tmaWVsZF0gPT09IHVuZGVmaW5lZCAmJiBleHRlbnNpb24ucGFyZW50KSB7XG4gICAgICAgIHJldHVybiBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24ucGFyZW50LCBmaWVsZCwgY29udGV4dCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZXh0ZW5zaW9uLmNvbmZpZ1tmaWVsZF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBleHRlbnNpb24uY29uZmlnW2ZpZWxkXS5iaW5kKHtcbiAgICAgICAgICAgIC4uLmNvbnRleHQsXG4gICAgICAgICAgICBwYXJlbnQ6IGV4dGVuc2lvbi5wYXJlbnRcbiAgICAgICAgICAgICAgICA/IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbi5wYXJlbnQsIGZpZWxkLCBjb250ZXh0KVxuICAgICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGV4dGVuc2lvbi5jb25maWdbZmllbGRdO1xufVxuXG5mdW5jdGlvbiBzcGxpdEV4dGVuc2lvbnMoZXh0ZW5zaW9ucykge1xuICAgIGNvbnN0IGJhc2VFeHRlbnNpb25zID0gZXh0ZW5zaW9ucy5maWx0ZXIoZXh0ZW5zaW9uID0+IGV4dGVuc2lvbi50eXBlID09PSAnZXh0ZW5zaW9uJyk7XG4gICAgY29uc3Qgbm9kZUV4dGVuc2lvbnMgPSBleHRlbnNpb25zLmZpbHRlcihleHRlbnNpb24gPT4gZXh0ZW5zaW9uLnR5cGUgPT09ICdub2RlJyk7XG4gICAgY29uc3QgbWFya0V4dGVuc2lvbnMgPSBleHRlbnNpb25zLmZpbHRlcihleHRlbnNpb24gPT4gZXh0ZW5zaW9uLnR5cGUgPT09ICdtYXJrJyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYmFzZUV4dGVuc2lvbnMsXG4gICAgICAgIG5vZGVFeHRlbnNpb25zLFxuICAgICAgICBtYXJrRXh0ZW5zaW9ucyxcbiAgICB9O1xufVxuXG4vKipcbiAqIEdldCBhIGxpc3Qgb2YgYWxsIGV4dGVuc2lvbiBhdHRyaWJ1dGVzIGRlZmluZWQgaW4gYGFkZEF0dHJpYnV0ZWAgYW5kIGBhZGRHbG9iYWxBdHRyaWJ1dGVgLlxuICogQHBhcmFtIGV4dGVuc2lvbnMgTGlzdCBvZiBleHRlbnNpb25zXG4gKi9cbmZ1bmN0aW9uIGdldEF0dHJpYnV0ZXNGcm9tRXh0ZW5zaW9ucyhleHRlbnNpb25zKSB7XG4gICAgY29uc3QgZXh0ZW5zaW9uQXR0cmlidXRlcyA9IFtdO1xuICAgIGNvbnN0IHsgbm9kZUV4dGVuc2lvbnMsIG1hcmtFeHRlbnNpb25zIH0gPSBzcGxpdEV4dGVuc2lvbnMoZXh0ZW5zaW9ucyk7XG4gICAgY29uc3Qgbm9kZUFuZE1hcmtFeHRlbnNpb25zID0gWy4uLm5vZGVFeHRlbnNpb25zLCAuLi5tYXJrRXh0ZW5zaW9uc107XG4gICAgY29uc3QgZGVmYXVsdEF0dHJpYnV0ZSA9IHtcbiAgICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgICAgcmVuZGVyZWQ6IHRydWUsXG4gICAgICAgIHJlbmRlckhUTUw6IG51bGwsXG4gICAgICAgIHBhcnNlSFRNTDogbnVsbCxcbiAgICAgICAga2VlcE9uU3BsaXQ6IHRydWUsXG4gICAgICAgIGlzUmVxdWlyZWQ6IGZhbHNlLFxuICAgIH07XG4gICAgZXh0ZW5zaW9ucy5mb3JFYWNoKGV4dGVuc2lvbiA9PiB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXG4gICAgICAgICAgICBleHRlbnNpb25zOiBub2RlQW5kTWFya0V4dGVuc2lvbnMsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGFkZEdsb2JhbEF0dHJpYnV0ZXMgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdhZGRHbG9iYWxBdHRyaWJ1dGVzJywgY29udGV4dCk7XG4gICAgICAgIGlmICghYWRkR2xvYmFsQXR0cmlidXRlcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGdsb2JhbEF0dHJpYnV0ZXMgPSBhZGRHbG9iYWxBdHRyaWJ1dGVzKCk7XG4gICAgICAgIGdsb2JhbEF0dHJpYnV0ZXMuZm9yRWFjaChnbG9iYWxBdHRyaWJ1dGUgPT4ge1xuICAgICAgICAgICAgZ2xvYmFsQXR0cmlidXRlLnR5cGVzLmZvckVhY2godHlwZSA9PiB7XG4gICAgICAgICAgICAgICAgT2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIC5lbnRyaWVzKGdsb2JhbEF0dHJpYnV0ZS5hdHRyaWJ1dGVzKVxuICAgICAgICAgICAgICAgICAgICAuZm9yRWFjaCgoW25hbWUsIGF0dHJpYnV0ZV0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uQXR0cmlidXRlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uZGVmYXVsdEF0dHJpYnV0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5hdHRyaWJ1dGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBub2RlQW5kTWFya0V4dGVuc2lvbnMuZm9yRWFjaChleHRlbnNpb24gPT4ge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgICAgICAgIHN0b3JhZ2U6IGV4dGVuc2lvbi5zdG9yYWdlLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBhZGRBdHRyaWJ1dGVzID0gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnYWRkQXR0cmlidXRlcycsIGNvbnRleHQpO1xuICAgICAgICBpZiAoIWFkZEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiByZW1vdmUgYGFzIEF0dHJpYnV0ZXNgXG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBhZGRBdHRyaWJ1dGVzKCk7XG4gICAgICAgIE9iamVjdFxuICAgICAgICAgICAgLmVudHJpZXMoYXR0cmlidXRlcylcbiAgICAgICAgICAgIC5mb3JFYWNoKChbbmFtZSwgYXR0cmlidXRlXSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWVyZ2VkQXR0ciA9IHtcbiAgICAgICAgICAgICAgICAuLi5kZWZhdWx0QXR0cmlidXRlLFxuICAgICAgICAgICAgICAgIC4uLmF0dHJpYnV0ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodHlwZW9mIChtZXJnZWRBdHRyID09PSBudWxsIHx8IG1lcmdlZEF0dHIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1lcmdlZEF0dHIuZGVmYXVsdCkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBtZXJnZWRBdHRyLmRlZmF1bHQgPSBtZXJnZWRBdHRyLmRlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgobWVyZ2VkQXR0ciA9PT0gbnVsbCB8fCBtZXJnZWRBdHRyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtZXJnZWRBdHRyLmlzUmVxdWlyZWQpICYmIChtZXJnZWRBdHRyID09PSBudWxsIHx8IG1lcmdlZEF0dHIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1lcmdlZEF0dHIuZGVmYXVsdCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBtZXJnZWRBdHRyLmRlZmF1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHRlbnNpb25BdHRyaWJ1dGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlOiBtZXJnZWRBdHRyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBleHRlbnNpb25BdHRyaWJ1dGVzO1xufVxuXG5mdW5jdGlvbiBnZXROb2RlVHlwZShuYW1lT3JUeXBlLCBzY2hlbWEpIHtcbiAgICBpZiAodHlwZW9mIG5hbWVPclR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICghc2NoZW1hLm5vZGVzW25hbWVPclR5cGVdKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgVGhlcmUgaXMgbm8gbm9kZSB0eXBlIG5hbWVkICcke25hbWVPclR5cGV9Jy4gTWF5YmUgeW91IGZvcmdvdCB0byBhZGQgdGhlIGV4dGVuc2lvbj9gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NoZW1hLm5vZGVzW25hbWVPclR5cGVdO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZU9yVHlwZTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VBdHRyaWJ1dGVzKC4uLm9iamVjdHMpIHtcbiAgICByZXR1cm4gb2JqZWN0c1xuICAgICAgICAuZmlsdGVyKGl0ZW0gPT4gISFpdGVtKVxuICAgICAgICAucmVkdWNlKChpdGVtcywgaXRlbSkgPT4ge1xuICAgICAgICBjb25zdCBtZXJnZWRBdHRyaWJ1dGVzID0geyAuLi5pdGVtcyB9O1xuICAgICAgICBPYmplY3QuZW50cmllcyhpdGVtKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0cyA9IG1lcmdlZEF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgICAgIGlmICghZXhpc3RzKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VkQXR0cmlidXRlc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGtleSA9PT0gJ2NsYXNzJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlQ2xhc3NlcyA9IHZhbHVlID8gU3RyaW5nKHZhbHVlKS5zcGxpdCgnICcpIDogW107XG4gICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdDbGFzc2VzID0gbWVyZ2VkQXR0cmlidXRlc1trZXldID8gbWVyZ2VkQXR0cmlidXRlc1trZXldLnNwbGl0KCcgJykgOiBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnNlcnRDbGFzc2VzID0gdmFsdWVDbGFzc2VzLmZpbHRlcih2YWx1ZUNsYXNzID0+ICFleGlzdGluZ0NsYXNzZXMuaW5jbHVkZXModmFsdWVDbGFzcykpO1xuICAgICAgICAgICAgICAgIG1lcmdlZEF0dHJpYnV0ZXNba2V5XSA9IFsuLi5leGlzdGluZ0NsYXNzZXMsIC4uLmluc2VydENsYXNzZXNdLmpvaW4oJyAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtleSA9PT0gJ3N0eWxlJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1N0eWxlcyA9IHZhbHVlID8gdmFsdWUuc3BsaXQoJzsnKS5tYXAoKHN0eWxlKSA9PiBzdHlsZS50cmltKCkpLmZpbHRlcihCb29sZWFuKSA6IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nU3R5bGVzID0gbWVyZ2VkQXR0cmlidXRlc1trZXldID8gbWVyZ2VkQXR0cmlidXRlc1trZXldLnNwbGl0KCc7JykubWFwKChzdHlsZSkgPT4gc3R5bGUudHJpbSgpKS5maWx0ZXIoQm9vbGVhbikgOiBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHlsZU1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICBleGlzdGluZ1N0eWxlcy5mb3JFYWNoKHN0eWxlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW3Byb3BlcnR5LCB2YWxdID0gc3R5bGUuc3BsaXQoJzonKS5tYXAocGFydCA9PiBwYXJ0LnRyaW0oKSk7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlTWFwLnNldChwcm9wZXJ0eSwgdmFsKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBuZXdTdHlsZXMuZm9yRWFjaChzdHlsZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtwcm9wZXJ0eSwgdmFsXSA9IHN0eWxlLnNwbGl0KCc6JykubWFwKHBhcnQgPT4gcGFydC50cmltKCkpO1xuICAgICAgICAgICAgICAgICAgICBzdHlsZU1hcC5zZXQocHJvcGVydHksIHZhbCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbWVyZ2VkQXR0cmlidXRlc1trZXldID0gQXJyYXkuZnJvbShzdHlsZU1hcC5lbnRyaWVzKCkpLm1hcCgoW3Byb3BlcnR5LCB2YWxdKSA9PiBgJHtwcm9wZXJ0eX06ICR7dmFsfWApLmpvaW4oJzsgJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXJnZWRBdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtZXJnZWRBdHRyaWJ1dGVzO1xuICAgIH0sIHt9KTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVuZGVyZWRBdHRyaWJ1dGVzKG5vZGVPck1hcmssIGV4dGVuc2lvbkF0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gZXh0ZW5zaW9uQXR0cmlidXRlc1xuICAgICAgICAuZmlsdGVyKGF0dHJpYnV0ZSA9PiBhdHRyaWJ1dGUudHlwZSA9PT0gbm9kZU9yTWFyay50eXBlLm5hbWUpXG4gICAgICAgIC5maWx0ZXIoaXRlbSA9PiBpdGVtLmF0dHJpYnV0ZS5yZW5kZXJlZClcbiAgICAgICAgLm1hcChpdGVtID0+IHtcbiAgICAgICAgaWYgKCFpdGVtLmF0dHJpYnV0ZS5yZW5kZXJIVE1MKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIFtpdGVtLm5hbWVdOiBub2RlT3JNYXJrLmF0dHJzW2l0ZW0ubmFtZV0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtLmF0dHJpYnV0ZS5yZW5kZXJIVE1MKG5vZGVPck1hcmsuYXR0cnMpIHx8IHt9O1xuICAgIH0pXG4gICAgICAgIC5yZWR1Y2UoKGF0dHJpYnV0ZXMsIGF0dHJpYnV0ZSkgPT4gbWVyZ2VBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMsIGF0dHJpYnV0ZSksIHt9KTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtZnVuY3Rpb24tdHlwZVxuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG59XG5cbi8qKlxuICogT3B0aW9uYWxseSBjYWxscyBgdmFsdWVgIGFzIGEgZnVuY3Rpb24uXG4gKiBPdGhlcndpc2UgaXQgaXMgcmV0dXJuZWQgZGlyZWN0bHkuXG4gKiBAcGFyYW0gdmFsdWUgRnVuY3Rpb24gb3IgYW55IHZhbHVlLlxuICogQHBhcmFtIGNvbnRleHQgT3B0aW9uYWwgY29udGV4dCB0byBiaW5kIHRvIGZ1bmN0aW9uLlxuICogQHBhcmFtIHByb3BzIE9wdGlvbmFsIHByb3BzIHRvIHBhc3MgdG8gZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNhbGxPclJldHVybih2YWx1ZSwgY29udGV4dCA9IHVuZGVmaW5lZCwgLi4ucHJvcHMpIHtcbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICAgICAgaWYgKGNvbnRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5iaW5kKGNvbnRleHQpKC4uLnByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWUoLi4ucHJvcHMpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGlzRW1wdHlPYmplY3QodmFsdWUgPSB7fSkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID09PSAwICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICh2YWx1ZS5tYXRjaCgvXlsrLV0/KD86XFxkKlxcLik/XFxkKyQvKSkge1xuICAgICAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSAndHJ1ZScpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gJ2ZhbHNlJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIG1lcmdlcyBleHRlbnNpb24gYXR0cmlidXRlcyBpbnRvIHBhcnNlcnVsZSBhdHRyaWJ1dGVzIChgYXR0cnNgIG9yIGBnZXRBdHRyc2ApLlxuICogQ2FuY2VscyB3aGVuIGBnZXRBdHRyc2AgcmV0dXJuZWQgYGZhbHNlYC5cbiAqIEBwYXJhbSBwYXJzZVJ1bGUgUHJvc2VNaXJyb3IgUGFyc2VSdWxlXG4gKiBAcGFyYW0gZXh0ZW5zaW9uQXR0cmlidXRlcyBMaXN0IG9mIGF0dHJpYnV0ZXMgdG8gaW5qZWN0XG4gKi9cbmZ1bmN0aW9uIGluamVjdEV4dGVuc2lvbkF0dHJpYnV0ZXNUb1BhcnNlUnVsZShwYXJzZVJ1bGUsIGV4dGVuc2lvbkF0dHJpYnV0ZXMpIHtcbiAgICBpZiAoJ3N0eWxlJyBpbiBwYXJzZVJ1bGUpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlUnVsZTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucGFyc2VSdWxlLFxuICAgICAgICBnZXRBdHRyczogKG5vZGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9sZEF0dHJpYnV0ZXMgPSBwYXJzZVJ1bGUuZ2V0QXR0cnMgPyBwYXJzZVJ1bGUuZ2V0QXR0cnMobm9kZSkgOiBwYXJzZVJ1bGUuYXR0cnM7XG4gICAgICAgICAgICBpZiAob2xkQXR0cmlidXRlcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZXdBdHRyaWJ1dGVzID0gZXh0ZW5zaW9uQXR0cmlidXRlcy5yZWR1Y2UoKGl0ZW1zLCBpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBpdGVtLmF0dHJpYnV0ZS5wYXJzZUhUTUxcbiAgICAgICAgICAgICAgICAgICAgPyBpdGVtLmF0dHJpYnV0ZS5wYXJzZUhUTUwobm9kZSlcbiAgICAgICAgICAgICAgICAgICAgOiBmcm9tU3RyaW5nKChub2RlKS5nZXRBdHRyaWJ1dGUoaXRlbS5uYW1lKSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAuLi5pdGVtcyxcbiAgICAgICAgICAgICAgICAgICAgW2l0ZW0ubmFtZV06IHZhbHVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgICByZXR1cm4geyAuLi5vbGRBdHRyaWJ1dGVzLCAuLi5uZXdBdHRyaWJ1dGVzIH07XG4gICAgICAgIH0sXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gY2xlYW5VcFNjaGVtYUl0ZW0oZGF0YSkge1xuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIE9iamVjdC5lbnRyaWVzKGRhdGEpLmZpbHRlcigoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGlmIChrZXkgPT09ICdhdHRycycgJiYgaXNFbXB0eU9iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZDtcbiAgICB9KSk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgUHJvc2VtaXJyb3Igc2NoZW1hIGJhc2VkIG9uIHRoZSBnaXZlbiBleHRlbnNpb25zLlxuICogQHBhcmFtIGV4dGVuc2lvbnMgQW4gYXJyYXkgb2YgVGlwdGFwIGV4dGVuc2lvbnNcbiAqIEBwYXJhbSBlZGl0b3IgVGhlIGVkaXRvciBpbnN0YW5jZVxuICogQHJldHVybnMgQSBQcm9zZW1pcnJvciBzY2hlbWFcbiAqL1xuZnVuY3Rpb24gZ2V0U2NoZW1hQnlSZXNvbHZlZEV4dGVuc2lvbnMoZXh0ZW5zaW9ucywgZWRpdG9yKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGFsbEF0dHJpYnV0ZXMgPSBnZXRBdHRyaWJ1dGVzRnJvbUV4dGVuc2lvbnMoZXh0ZW5zaW9ucyk7XG4gICAgY29uc3QgeyBub2RlRXh0ZW5zaW9ucywgbWFya0V4dGVuc2lvbnMgfSA9IHNwbGl0RXh0ZW5zaW9ucyhleHRlbnNpb25zKTtcbiAgICBjb25zdCB0b3BOb2RlID0gKF9hID0gbm9kZUV4dGVuc2lvbnMuZmluZChleHRlbnNpb24gPT4gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAndG9wTm9kZScpKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5hbWU7XG4gICAgY29uc3Qgbm9kZXMgPSBPYmplY3QuZnJvbUVudHJpZXMobm9kZUV4dGVuc2lvbnMubWFwKGV4dGVuc2lvbiA9PiB7XG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbkF0dHJpYnV0ZXMgPSBhbGxBdHRyaWJ1dGVzLmZpbHRlcihhdHRyaWJ1dGUgPT4gYXR0cmlidXRlLnR5cGUgPT09IGV4dGVuc2lvbi5uYW1lKTtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICAgICAgICBzdG9yYWdlOiBleHRlbnNpb24uc3RvcmFnZSxcbiAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZXh0cmFOb2RlRmllbGRzID0gZXh0ZW5zaW9ucy5yZWR1Y2UoKGZpZWxkcywgZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXh0ZW5kTm9kZVNjaGVtYSA9IGdldEV4dGVuc2lvbkZpZWxkKGUsICdleHRlbmROb2RlU2NoZW1hJywgY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLmZpZWxkcyxcbiAgICAgICAgICAgICAgICAuLi4oZXh0ZW5kTm9kZVNjaGVtYSA/IGV4dGVuZE5vZGVTY2hlbWEoZXh0ZW5zaW9uKSA6IHt9KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gY2xlYW5VcFNjaGVtYUl0ZW0oe1xuICAgICAgICAgICAgLi4uZXh0cmFOb2RlRmllbGRzLFxuICAgICAgICAgICAgY29udGVudDogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2NvbnRlbnQnLCBjb250ZXh0KSksXG4gICAgICAgICAgICBtYXJrczogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ21hcmtzJywgY29udGV4dCkpLFxuICAgICAgICAgICAgZ3JvdXA6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdncm91cCcsIGNvbnRleHQpKSxcbiAgICAgICAgICAgIGlubGluZTogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2lubGluZScsIGNvbnRleHQpKSxcbiAgICAgICAgICAgIGF0b206IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdhdG9tJywgY29udGV4dCkpLFxuICAgICAgICAgICAgc2VsZWN0YWJsZTogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ3NlbGVjdGFibGUnLCBjb250ZXh0KSksXG4gICAgICAgICAgICBkcmFnZ2FibGU6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdkcmFnZ2FibGUnLCBjb250ZXh0KSksXG4gICAgICAgICAgICBjb2RlOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnY29kZScsIGNvbnRleHQpKSxcbiAgICAgICAgICAgIHdoaXRlc3BhY2U6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICd3aGl0ZXNwYWNlJywgY29udGV4dCkpLFxuICAgICAgICAgICAgbGluZWJyZWFrUmVwbGFjZW1lbnQ6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdsaW5lYnJlYWtSZXBsYWNlbWVudCcsIGNvbnRleHQpKSxcbiAgICAgICAgICAgIGRlZmluaW5nOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnZGVmaW5pbmcnLCBjb250ZXh0KSksXG4gICAgICAgICAgICBpc29sYXRpbmc6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdpc29sYXRpbmcnLCBjb250ZXh0KSksXG4gICAgICAgICAgICBhdHRyczogT2JqZWN0LmZyb21FbnRyaWVzKGV4dGVuc2lvbkF0dHJpYnV0ZXMubWFwKGV4dGVuc2lvbkF0dHJpYnV0ZSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIHJldHVybiBbZXh0ZW5zaW9uQXR0cmlidXRlLm5hbWUsIHsgZGVmYXVsdDogKF9hID0gZXh0ZW5zaW9uQXR0cmlidXRlID09PSBudWxsIHx8IGV4dGVuc2lvbkF0dHJpYnV0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXh0ZW5zaW9uQXR0cmlidXRlLmF0dHJpYnV0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlZmF1bHQgfV07XG4gICAgICAgICAgICB9KSksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwYXJzZUhUTUwgPSBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAncGFyc2VIVE1MJywgY29udGV4dCkpO1xuICAgICAgICBpZiAocGFyc2VIVE1MKSB7XG4gICAgICAgICAgICBzY2hlbWEucGFyc2VET00gPSBwYXJzZUhUTUwubWFwKHBhcnNlUnVsZSA9PiBpbmplY3RFeHRlbnNpb25BdHRyaWJ1dGVzVG9QYXJzZVJ1bGUocGFyc2VSdWxlLCBleHRlbnNpb25BdHRyaWJ1dGVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVuZGVySFRNTCA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ3JlbmRlckhUTUwnLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlbmRlckhUTUwpIHtcbiAgICAgICAgICAgIHNjaGVtYS50b0RPTSA9IG5vZGUgPT4gcmVuZGVySFRNTCh7XG4gICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICBIVE1MQXR0cmlidXRlczogZ2V0UmVuZGVyZWRBdHRyaWJ1dGVzKG5vZGUsIGV4dGVuc2lvbkF0dHJpYnV0ZXMpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVuZGVyVGV4dCA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ3JlbmRlclRleHQnLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlbmRlclRleHQpIHtcbiAgICAgICAgICAgIHNjaGVtYS50b1RleHQgPSByZW5kZXJUZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbZXh0ZW5zaW9uLm5hbWUsIHNjaGVtYV07XG4gICAgfSkpO1xuICAgIGNvbnN0IG1hcmtzID0gT2JqZWN0LmZyb21FbnRyaWVzKG1hcmtFeHRlbnNpb25zLm1hcChleHRlbnNpb24gPT4ge1xuICAgICAgICBjb25zdCBleHRlbnNpb25BdHRyaWJ1dGVzID0gYWxsQXR0cmlidXRlcy5maWx0ZXIoYXR0cmlidXRlID0+IGF0dHJpYnV0ZS50eXBlID09PSBleHRlbnNpb24ubmFtZSk7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXG4gICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGV4dHJhTWFya0ZpZWxkcyA9IGV4dGVuc2lvbnMucmVkdWNlKChmaWVsZHMsIGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGV4dGVuZE1hcmtTY2hlbWEgPSBnZXRFeHRlbnNpb25GaWVsZChlLCAnZXh0ZW5kTWFya1NjaGVtYScsIGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5maWVsZHMsXG4gICAgICAgICAgICAgICAgLi4uKGV4dGVuZE1hcmtTY2hlbWEgPyBleHRlbmRNYXJrU2NoZW1hKGV4dGVuc2lvbikgOiB7fSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IGNsZWFuVXBTY2hlbWFJdGVtKHtcbiAgICAgICAgICAgIC4uLmV4dHJhTWFya0ZpZWxkcyxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2luY2x1c2l2ZScsIGNvbnRleHQpKSxcbiAgICAgICAgICAgIGV4Y2x1ZGVzOiBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnZXhjbHVkZXMnLCBjb250ZXh0KSksXG4gICAgICAgICAgICBncm91cDogY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2dyb3VwJywgY29udGV4dCkpLFxuICAgICAgICAgICAgc3Bhbm5pbmc6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdzcGFubmluZycsIGNvbnRleHQpKSxcbiAgICAgICAgICAgIGNvZGU6IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdjb2RlJywgY29udGV4dCkpLFxuICAgICAgICAgICAgYXR0cnM6IE9iamVjdC5mcm9tRW50cmllcyhleHRlbnNpb25BdHRyaWJ1dGVzLm1hcChleHRlbnNpb25BdHRyaWJ1dGUgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2V4dGVuc2lvbkF0dHJpYnV0ZS5uYW1lLCB7IGRlZmF1bHQ6IChfYSA9IGV4dGVuc2lvbkF0dHJpYnV0ZSA9PT0gbnVsbCB8fCBleHRlbnNpb25BdHRyaWJ1dGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV4dGVuc2lvbkF0dHJpYnV0ZS5hdHRyaWJ1dGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZWZhdWx0IH1dO1xuICAgICAgICAgICAgfSkpLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcGFyc2VIVE1MID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ3BhcnNlSFRNTCcsIGNvbnRleHQpKTtcbiAgICAgICAgaWYgKHBhcnNlSFRNTCkge1xuICAgICAgICAgICAgc2NoZW1hLnBhcnNlRE9NID0gcGFyc2VIVE1MLm1hcChwYXJzZVJ1bGUgPT4gaW5qZWN0RXh0ZW5zaW9uQXR0cmlidXRlc1RvUGFyc2VSdWxlKHBhcnNlUnVsZSwgZXh0ZW5zaW9uQXR0cmlidXRlcykpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlbmRlckhUTUwgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdyZW5kZXJIVE1MJywgY29udGV4dCk7XG4gICAgICAgIGlmIChyZW5kZXJIVE1MKSB7XG4gICAgICAgICAgICBzY2hlbWEudG9ET00gPSBtYXJrID0+IHJlbmRlckhUTUwoe1xuICAgICAgICAgICAgICAgIG1hcmssXG4gICAgICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IGdldFJlbmRlcmVkQXR0cmlidXRlcyhtYXJrLCBleHRlbnNpb25BdHRyaWJ1dGVzKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbZXh0ZW5zaW9uLm5hbWUsIHNjaGVtYV07XG4gICAgfSkpO1xuICAgIHJldHVybiBuZXcgU2NoZW1hKHtcbiAgICAgICAgdG9wTm9kZSxcbiAgICAgICAgbm9kZXMsXG4gICAgICAgIG1hcmtzLFxuICAgIH0pO1xufVxuXG4vKipcbiAqIFRyaWVzIHRvIGdldCBhIG5vZGUgb3IgbWFyayB0eXBlIGJ5IGl0cyBuYW1lLlxuICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIG5vZGUgb3IgbWFyayB0eXBlXG4gKiBAcGFyYW0gc2NoZW1hIFRoZSBQcm9zZW1pcm9yIHNjaGVtYSB0byBzZWFyY2ggaW5cbiAqIEByZXR1cm5zIFRoZSBub2RlIG9yIG1hcmsgdHlwZSwgb3IgbnVsbCBpZiBpdCBkb2Vzbid0IGV4aXN0XG4gKi9cbmZ1bmN0aW9uIGdldFNjaGVtYVR5cGVCeU5hbWUobmFtZSwgc2NoZW1hKSB7XG4gICAgcmV0dXJuIHNjaGVtYS5ub2Rlc1tuYW1lXSB8fCBzY2hlbWEubWFya3NbbmFtZV0gfHwgbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNFeHRlbnNpb25SdWxlc0VuYWJsZWQoZXh0ZW5zaW9uLCBlbmFibGVkKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZW5hYmxlZCkpIHtcbiAgICAgICAgcmV0dXJuIGVuYWJsZWQuc29tZShlbmFibGVkRXh0ZW5zaW9uID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSB0eXBlb2YgZW5hYmxlZEV4dGVuc2lvbiA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICAgICA/IGVuYWJsZWRFeHRlbnNpb25cbiAgICAgICAgICAgICAgICA6IGVuYWJsZWRFeHRlbnNpb24ubmFtZTtcbiAgICAgICAgICAgIHJldHVybiBuYW1lID09PSBleHRlbnNpb24ubmFtZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBlbmFibGVkO1xufVxuXG5mdW5jdGlvbiBnZXRIVE1MRnJvbUZyYWdtZW50KGZyYWdtZW50LCBzY2hlbWEpIHtcbiAgICBjb25zdCBkb2N1bWVudEZyYWdtZW50ID0gRE9NU2VyaWFsaXplci5mcm9tU2NoZW1hKHNjaGVtYSkuc2VyaWFsaXplRnJhZ21lbnQoZnJhZ21lbnQpO1xuICAgIGNvbnN0IHRlbXBvcmFyeURvY3VtZW50ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCk7XG4gICAgY29uc3QgY29udGFpbmVyID0gdGVtcG9yYXJ5RG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGRvY3VtZW50RnJhZ21lbnQpO1xuICAgIHJldHVybiBjb250YWluZXIuaW5uZXJIVE1MO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHRleHQgY29udGVudCBvZiBhIHJlc29sdmVkIHByb3NlbWlycm9yIHBvc2l0aW9uXG4gKiBAcGFyYW0gJGZyb20gVGhlIHJlc29sdmVkIHBvc2l0aW9uIHRvIGdldCB0aGUgdGV4dCBjb250ZW50IGZyb21cbiAqIEBwYXJhbSBtYXhNYXRjaCBUaGUgbWF4aW11bSBudW1iZXIgb2YgY2hhcmFjdGVycyB0byBtYXRjaFxuICogQHJldHVybnMgVGhlIHRleHQgY29udGVudFxuICovXG5jb25zdCBnZXRUZXh0Q29udGVudEZyb21Ob2RlcyA9ICgkZnJvbSwgbWF4TWF0Y2ggPSA1MDApID0+IHtcbiAgICBsZXQgdGV4dEJlZm9yZSA9ICcnO1xuICAgIGNvbnN0IHNsaWNlRW5kUG9zID0gJGZyb20ucGFyZW50T2Zmc2V0O1xuICAgICRmcm9tLnBhcmVudC5ub2Rlc0JldHdlZW4oTWF0aC5tYXgoMCwgc2xpY2VFbmRQb3MgLSBtYXhNYXRjaCksIHNsaWNlRW5kUG9zLCAobm9kZSwgcG9zLCBwYXJlbnQsIGluZGV4KSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGNodW5rID0gKChfYiA9IChfYSA9IG5vZGUudHlwZS5zcGVjKS50b1RleHQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCB7XG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgcG9zLFxuICAgICAgICAgICAgcGFyZW50LFxuICAgICAgICAgICAgaW5kZXgsXG4gICAgICAgIH0pKVxuICAgICAgICAgICAgfHwgbm9kZS50ZXh0Q29udGVudFxuICAgICAgICAgICAgfHwgJyVsZWFmJSc7XG4gICAgICAgIHRleHRCZWZvcmUgKz0gbm9kZS5pc0F0b20gJiYgIW5vZGUuaXNUZXh0ID8gY2h1bmsgOiBjaHVuay5zbGljZSgwLCBNYXRoLm1heCgwLCBzbGljZUVuZFBvcyAtIHBvcykpO1xuICAgIH0pO1xuICAgIHJldHVybiB0ZXh0QmVmb3JlO1xufTtcblxuZnVuY3Rpb24gaXNSZWdFeHAodmFsdWUpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5cbmNsYXNzIElucHV0UnVsZSB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHRoaXMuZmluZCA9IGNvbmZpZy5maW5kO1xuICAgICAgICB0aGlzLmhhbmRsZXIgPSBjb25maWcuaGFuZGxlcjtcbiAgICB9XG59XG5jb25zdCBpbnB1dFJ1bGVNYXRjaGVySGFuZGxlciA9ICh0ZXh0LCBmaW5kKSA9PiB7XG4gICAgaWYgKGlzUmVnRXhwKGZpbmQpKSB7XG4gICAgICAgIHJldHVybiBmaW5kLmV4ZWModGV4dCk7XG4gICAgfVxuICAgIGNvbnN0IGlucHV0UnVsZU1hdGNoID0gZmluZCh0ZXh0KTtcbiAgICBpZiAoIWlucHV0UnVsZU1hdGNoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBbaW5wdXRSdWxlTWF0Y2gudGV4dF07XG4gICAgcmVzdWx0LmluZGV4ID0gaW5wdXRSdWxlTWF0Y2guaW5kZXg7XG4gICAgcmVzdWx0LmlucHV0ID0gdGV4dDtcbiAgICByZXN1bHQuZGF0YSA9IGlucHV0UnVsZU1hdGNoLmRhdGE7XG4gICAgaWYgKGlucHV0UnVsZU1hdGNoLnJlcGxhY2VXaXRoKSB7XG4gICAgICAgIGlmICghaW5wdXRSdWxlTWF0Y2gudGV4dC5pbmNsdWRlcyhpbnB1dFJ1bGVNYXRjaC5yZXBsYWNlV2l0aCkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignW3RpcHRhcCB3YXJuXTogXCJpbnB1dFJ1bGVNYXRjaC5yZXBsYWNlV2l0aFwiIG11c3QgYmUgcGFydCBvZiBcImlucHV0UnVsZU1hdGNoLnRleHRcIi4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaChpbnB1dFJ1bGVNYXRjaC5yZXBsYWNlV2l0aCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuZnVuY3Rpb24gcnVuJDEoY29uZmlnKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHsgZWRpdG9yLCBmcm9tLCB0bywgdGV4dCwgcnVsZXMsIHBsdWdpbiwgfSA9IGNvbmZpZztcbiAgICBjb25zdCB7IHZpZXcgfSA9IGVkaXRvcjtcbiAgICBpZiAodmlldy5jb21wb3NpbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCAkZnJvbSA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoZnJvbSk7XG4gICAgaWYgKFxuICAgIC8vIGNoZWNrIGZvciBjb2RlIG5vZGVcbiAgICAkZnJvbS5wYXJlbnQudHlwZS5zcGVjLmNvZGVcbiAgICAgICAgLy8gY2hlY2sgZm9yIGNvZGUgbWFya1xuICAgICAgICB8fCAhISgoX2EgPSAoJGZyb20ubm9kZUJlZm9yZSB8fCAkZnJvbS5ub2RlQWZ0ZXIpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFya3MuZmluZChtYXJrID0+IG1hcmsudHlwZS5zcGVjLmNvZGUpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBtYXRjaGVkID0gZmFsc2U7XG4gICAgY29uc3QgdGV4dEJlZm9yZSA9IGdldFRleHRDb250ZW50RnJvbU5vZGVzKCRmcm9tKSArIHRleHQ7XG4gICAgcnVsZXMuZm9yRWFjaChydWxlID0+IHtcbiAgICAgICAgaWYgKG1hdGNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYXRjaCA9IGlucHV0UnVsZU1hdGNoZXJIYW5kbGVyKHRleHRCZWZvcmUsIHJ1bGUuZmluZCk7XG4gICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ciA9IHZpZXcuc3RhdGUudHI7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gY3JlYXRlQ2hhaW5hYmxlU3RhdGUoe1xuICAgICAgICAgICAgc3RhdGU6IHZpZXcuc3RhdGUsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbjogdHIsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByYW5nZSA9IHtcbiAgICAgICAgICAgIGZyb206IGZyb20gLSAobWF0Y2hbMF0ubGVuZ3RoIC0gdGV4dC5sZW5ndGgpLFxuICAgICAgICAgICAgdG8sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHsgY29tbWFuZHMsIGNoYWluLCBjYW4gfSA9IG5ldyBDb21tYW5kTWFuYWdlcih7XG4gICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSBydWxlLmhhbmRsZXIoe1xuICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICByYW5nZSxcbiAgICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgICAgY29tbWFuZHMsXG4gICAgICAgICAgICBjaGFpbixcbiAgICAgICAgICAgIGNhbixcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHN0b3AgaWYgdGhlcmUgYXJlIG5vIGNoYW5nZXNcbiAgICAgICAgaWYgKGhhbmRsZXIgPT09IG51bGwgfHwgIXRyLnN0ZXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN0b3JlIHRyYW5zZm9ybSBhcyBtZXRhIGRhdGFcbiAgICAgICAgLy8gc28gd2UgY2FuIHVuZG8gaW5wdXQgcnVsZXMgd2l0aGluIHRoZSBgdW5kb0lucHV0UnVsZXNgIGNvbW1hbmRcbiAgICAgICAgdHIuc2V0TWV0YShwbHVnaW4sIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdHIsXG4gICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICB0ZXh0LFxuICAgICAgICB9KTtcbiAgICAgICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgICAgIG1hdGNoZWQgPSB0cnVlO1xuICAgIH0pO1xuICAgIHJldHVybiBtYXRjaGVkO1xufVxuLyoqXG4gKiBDcmVhdGUgYW4gaW5wdXQgcnVsZXMgcGx1Z2luLiBXaGVuIGVuYWJsZWQsIGl0IHdpbGwgY2F1c2UgdGV4dFxuICogaW5wdXQgdGhhdCBtYXRjaGVzIGFueSBvZiB0aGUgZ2l2ZW4gcnVsZXMgdG8gdHJpZ2dlciB0aGUgcnVsZeKAmXNcbiAqIGFjdGlvbi5cbiAqL1xuZnVuY3Rpb24gaW5wdXRSdWxlc1BsdWdpbihwcm9wcykge1xuICAgIGNvbnN0IHsgZWRpdG9yLCBydWxlcyB9ID0gcHJvcHM7XG4gICAgY29uc3QgcGx1Z2luID0gbmV3IFBsdWdpbih7XG4gICAgICAgIHN0YXRlOiB7XG4gICAgICAgICAgICBpbml0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFwcGx5KHRyLCBwcmV2LCBzdGF0ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0b3JlZCA9IHRyLmdldE1ldGEocGx1Z2luKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RvcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdG9yZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGlmIElucHV0UnVsZSBpcyB0cmlnZ2VyZWQgYnkgaW5zZXJ0Q29udGVudCgpXG4gICAgICAgICAgICAgICAgY29uc3Qgc2ltdWxhdGVkSW5wdXRNZXRhID0gdHIuZ2V0TWV0YSgnYXBwbHlJbnB1dFJ1bGVzJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNTaW11bGF0ZWRJbnB1dCA9ICEhc2ltdWxhdGVkSW5wdXRNZXRhO1xuICAgICAgICAgICAgICAgIGlmIChpc1NpbXVsYXRlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHsgdGV4dCB9ID0gc2ltdWxhdGVkSW5wdXRNZXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0ZXh0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9IGdldEhUTUxGcm9tRnJhZ21lbnQoRnJhZ21lbnQuZnJvbSh0ZXh0KSwgc3RhdGUuc2NoZW1hKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZnJvbSB9ID0gc2ltdWxhdGVkSW5wdXRNZXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG8gPSBmcm9tICsgdGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBydW4kMSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbHVnaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0ci5zZWxlY3Rpb25TZXQgfHwgdHIuZG9jQ2hhbmdlZCA/IG51bGwgOiBwcmV2O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIGhhbmRsZVRleHRJbnB1dCh2aWV3LCBmcm9tLCB0bywgdGV4dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBydW4kMSh7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgdG8sXG4gICAgICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzLFxuICAgICAgICAgICAgICAgICAgICBwbHVnaW4sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFuZGxlRE9NRXZlbnRzOiB7XG4gICAgICAgICAgICAgICAgY29tcG9zaXRpb25lbmQ6IHZpZXcgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgJGN1cnNvciB9ID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJGN1cnNvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1biQxKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tOiAkY3Vyc29yLnBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG86ICRjdXJzb3IucG9zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsdWdpbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGFkZCBzdXBwb3J0IGZvciBpbnB1dCBydWxlcyB0byB0cmlnZ2VyIG9uIGVudGVyXG4gICAgICAgICAgICAvLyB0aGlzIGlzIHVzZWZ1bCBmb3IgZXhhbXBsZSBmb3IgY29kZSBibG9ja3NcbiAgICAgICAgICAgIGhhbmRsZUtleURvd24odmlldywgZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQua2V5ICE9PSAnRW50ZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyAkY3Vyc29yIH0gPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgICAgICAgICBpZiAoJGN1cnNvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnVuJDEoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogJGN1cnNvci5wb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICB0bzogJGN1cnNvci5wb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiAnXFxuJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGx1Z2luLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpc0lucHV0UnVsZXM6IHRydWUsXG4gICAgfSk7XG4gICAgcmV0dXJuIHBsdWdpbjtcbn1cblxuLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vbWVzcXVlZWIvaXMtd2hhdC9ibG9iLzg4ZDZlNGNhOTJmYjJiYWFiNjAwM2M1NGUwMmVlZGY0ZTcyOWU1YWIvc3JjL2luZGV4LnRzXG5mdW5jdGlvbiBnZXRUeXBlKHZhbHVlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkuc2xpY2UoOCwgLTEpO1xufVxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICAgIGlmIChnZXRUeXBlKHZhbHVlKSAhPT0gJ09iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUuY29uc3RydWN0b3IgPT09IE9iamVjdCAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsdWUpID09PSBPYmplY3QucHJvdG90eXBlO1xufVxuXG5mdW5jdGlvbiBtZXJnZURlZXAodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICBjb25zdCBvdXRwdXQgPSB7IC4uLnRhcmdldCB9O1xuICAgIGlmIChpc1BsYWluT2JqZWN0KHRhcmdldCkgJiYgaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzUGxhaW5PYmplY3Qoc291cmNlW2tleV0pICYmIGlzUGxhaW5PYmplY3QodGFyZ2V0W2tleV0pKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W2tleV0gPSBtZXJnZURlZXAodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xufVxuXG4vKipcbiAqIFRoZSBNYXJrIGNsYXNzIGlzIHVzZWQgdG8gY3JlYXRlIGN1c3RvbSBtYXJrIGV4dGVuc2lvbnMuXG4gKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9hcGkvZXh0ZW5zaW9ucyNjcmVhdGUtYS1uZXctZXh0ZW5zaW9uXG4gKi9cbmNsYXNzIE1hcmsge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHRoaXMudHlwZSA9ICdtYXJrJztcbiAgICAgICAgdGhpcy5uYW1lID0gJ21hcmsnO1xuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuY2hpbGQgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgIGRlZmF1bHRPcHRpb25zOiB7fSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jb25maWcgPSB7XG4gICAgICAgICAgICAuLi50aGlzLmNvbmZpZyxcbiAgICAgICAgICAgIC4uLmNvbmZpZyxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5jb25maWcubmFtZTtcbiAgICAgICAgaWYgKGNvbmZpZy5kZWZhdWx0T3B0aW9ucyAmJiBPYmplY3Qua2V5cyhjb25maWcuZGVmYXVsdE9wdGlvbnMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgW3RpcHRhcCB3YXJuXTogQlJFQUtJTkcgQ0hBTkdFOiBcImRlZmF1bHRPcHRpb25zXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcImFkZE9wdGlvbnNcIiBpbnN0ZWFkLiBGb3VuZCBpbiBleHRlbnNpb246IFwiJHt0aGlzLm5hbWV9XCIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogcmVtb3ZlIGBhZGRPcHRpb25zYCBmYWxsYmFja1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB0aGlzLmNvbmZpZy5kZWZhdWx0T3B0aW9ucztcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmFkZE9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZCh0aGlzLCAnYWRkT3B0aW9ucycsIHtcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdG9yYWdlID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKHRoaXMsICdhZGRTdG9yYWdlJywge1xuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zLFxuICAgICAgICB9KSkgfHwge307XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUoY29uZmlnID0ge30pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXJrKGNvbmZpZyk7XG4gICAgfVxuICAgIGNvbmZpZ3VyZShvcHRpb25zID0ge30pIHtcbiAgICAgICAgLy8gcmV0dXJuIGEgbmV3IGluc3RhbmNlIHNvIHdlIGNhbiB1c2UgdGhlIHNhbWUgZXh0ZW5zaW9uXG4gICAgICAgIC8vIHdpdGggZGlmZmVyZW50IGNhbGxzIG9mIGBjb25maWd1cmVgXG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbiA9IHRoaXMuZXh0ZW5kKHtcbiAgICAgICAgICAgIC4uLnRoaXMuY29uZmlnLFxuICAgICAgICAgICAgYWRkT3B0aW9uczogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXJnZURlZXAodGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBBbHdheXMgcHJlc2VydmUgdGhlIGN1cnJlbnQgbmFtZVxuICAgICAgICBleHRlbnNpb24ubmFtZSA9IHRoaXMubmFtZTtcbiAgICAgICAgLy8gU2V0IHRoZSBwYXJlbnQgdG8gYmUgb3VyIHBhcmVudFxuICAgICAgICBleHRlbnNpb24ucGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgIHJldHVybiBleHRlbnNpb247XG4gICAgfVxuICAgIGV4dGVuZChleHRlbmRlZENvbmZpZyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbiA9IG5ldyBNYXJrKGV4dGVuZGVkQ29uZmlnKTtcbiAgICAgICAgZXh0ZW5zaW9uLnBhcmVudCA9IHRoaXM7XG4gICAgICAgIHRoaXMuY2hpbGQgPSBleHRlbnNpb247XG4gICAgICAgIGV4dGVuc2lvbi5uYW1lID0gZXh0ZW5kZWRDb25maWcubmFtZSA/IGV4dGVuZGVkQ29uZmlnLm5hbWUgOiBleHRlbnNpb24ucGFyZW50Lm5hbWU7XG4gICAgICAgIGlmIChleHRlbmRlZENvbmZpZy5kZWZhdWx0T3B0aW9ucyAmJiBPYmplY3Qua2V5cyhleHRlbmRlZENvbmZpZy5kZWZhdWx0T3B0aW9ucykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBbdGlwdGFwIHdhcm5dOiBCUkVBS0lORyBDSEFOR0U6IFwiZGVmYXVsdE9wdGlvbnNcIiBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIFwiYWRkT3B0aW9uc1wiIGluc3RlYWQuIEZvdW5kIGluIGV4dGVuc2lvbjogXCIke2V4dGVuc2lvbi5uYW1lfVwiLmApO1xuICAgICAgICB9XG4gICAgICAgIGV4dGVuc2lvbi5vcHRpb25zID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2FkZE9wdGlvbnMnLCB7XG4gICAgICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgfSkpO1xuICAgICAgICBleHRlbnNpb24uc3RvcmFnZSA9IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdhZGRTdG9yYWdlJywge1xuICAgICAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gZXh0ZW5zaW9uO1xuICAgIH1cbiAgICBzdGF0aWMgaGFuZGxlRXhpdCh7IGVkaXRvciwgbWFyayB9KSB7XG4gICAgICAgIGNvbnN0IHsgdHIgfSA9IGVkaXRvci5zdGF0ZTtcbiAgICAgICAgY29uc3QgY3VycmVudFBvcyA9IGVkaXRvci5zdGF0ZS5zZWxlY3Rpb24uJGZyb207XG4gICAgICAgIGNvbnN0IGlzQXRFbmQgPSBjdXJyZW50UG9zLnBvcyA9PT0gY3VycmVudFBvcy5lbmQoKTtcbiAgICAgICAgaWYgKGlzQXRFbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRNYXJrcyA9IGN1cnJlbnRQb3MubWFya3MoKTtcbiAgICAgICAgICAgIGNvbnN0IGlzSW5NYXJrID0gISFjdXJyZW50TWFya3MuZmluZChtID0+IChtID09PSBudWxsIHx8IG0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG0udHlwZS5uYW1lKSA9PT0gbWFyay5uYW1lKTtcbiAgICAgICAgICAgIGlmICghaXNJbk1hcmspIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZW1vdmVNYXJrID0gY3VycmVudE1hcmtzLmZpbmQobSA9PiAobSA9PT0gbnVsbCB8fCBtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtLnR5cGUubmFtZSkgPT09IG1hcmsubmFtZSk7XG4gICAgICAgICAgICBpZiAocmVtb3ZlTWFyaykge1xuICAgICAgICAgICAgICAgIHRyLnJlbW92ZVN0b3JlZE1hcmsocmVtb3ZlTWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ci5pbnNlcnRUZXh0KCcgJywgY3VycmVudFBvcy5wb3MpO1xuICAgICAgICAgICAgZWRpdG9yLnZpZXcuZGlzcGF0Y2godHIpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJztcbn1cblxuLyoqXG4gKiBQYXN0ZSBydWxlcyBhcmUgdXNlZCB0byByZWFjdCB0byBwYXN0ZWQgY29udGVudC5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2RvY3MvZWRpdG9yL2V4dGVuc2lvbnMvY3VzdG9tLWV4dGVuc2lvbnMvZXh0ZW5kLWV4aXN0aW5nI3Bhc3RlLXJ1bGVzXG4gKi9cbmNsYXNzIFBhc3RlUnVsZSB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XG4gICAgICAgIHRoaXMuZmluZCA9IGNvbmZpZy5maW5kO1xuICAgICAgICB0aGlzLmhhbmRsZXIgPSBjb25maWcuaGFuZGxlcjtcbiAgICB9XG59XG5jb25zdCBwYXN0ZVJ1bGVNYXRjaGVySGFuZGxlciA9ICh0ZXh0LCBmaW5kLCBldmVudCkgPT4ge1xuICAgIGlmIChpc1JlZ0V4cChmaW5kKSkge1xuICAgICAgICByZXR1cm4gWy4uLnRleHQubWF0Y2hBbGwoZmluZCldO1xuICAgIH1cbiAgICBjb25zdCBtYXRjaGVzID0gZmluZCh0ZXh0LCBldmVudCk7XG4gICAgaWYgKCFtYXRjaGVzKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoZXMubWFwKHBhc3RlUnVsZU1hdGNoID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW3Bhc3RlUnVsZU1hdGNoLnRleHRdO1xuICAgICAgICByZXN1bHQuaW5kZXggPSBwYXN0ZVJ1bGVNYXRjaC5pbmRleDtcbiAgICAgICAgcmVzdWx0LmlucHV0ID0gdGV4dDtcbiAgICAgICAgcmVzdWx0LmRhdGEgPSBwYXN0ZVJ1bGVNYXRjaC5kYXRhO1xuICAgICAgICBpZiAocGFzdGVSdWxlTWF0Y2gucmVwbGFjZVdpdGgpIHtcbiAgICAgICAgICAgIGlmICghcGFzdGVSdWxlTWF0Y2gudGV4dC5pbmNsdWRlcyhwYXN0ZVJ1bGVNYXRjaC5yZXBsYWNlV2l0aCkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1t0aXB0YXAgd2Fybl06IFwicGFzdGVSdWxlTWF0Y2gucmVwbGFjZVdpdGhcIiBtdXN0IGJlIHBhcnQgb2YgXCJwYXN0ZVJ1bGVNYXRjaC50ZXh0XCIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQucHVzaChwYXN0ZVJ1bGVNYXRjaC5yZXBsYWNlV2l0aCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcbn07XG5mdW5jdGlvbiBydW4oY29uZmlnKSB7XG4gICAgY29uc3QgeyBlZGl0b3IsIHN0YXRlLCBmcm9tLCB0bywgcnVsZSwgcGFzdGVFdmVudCwgZHJvcEV2ZW50LCB9ID0gY29uZmlnO1xuICAgIGNvbnN0IHsgY29tbWFuZHMsIGNoYWluLCBjYW4gfSA9IG5ldyBDb21tYW5kTWFuYWdlcih7XG4gICAgICAgIGVkaXRvcixcbiAgICAgICAgc3RhdGUsXG4gICAgfSk7XG4gICAgY29uc3QgaGFuZGxlcnMgPSBbXTtcbiAgICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgIGlmICghbm9kZS5pc1RleHRibG9jayB8fCBub2RlLnR5cGUuc3BlYy5jb2RlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzb2x2ZWRGcm9tID0gTWF0aC5tYXgoZnJvbSwgcG9zKTtcbiAgICAgICAgY29uc3QgcmVzb2x2ZWRUbyA9IE1hdGgubWluKHRvLCBwb3MgKyBub2RlLmNvbnRlbnQuc2l6ZSk7XG4gICAgICAgIGNvbnN0IHRleHRUb01hdGNoID0gbm9kZS50ZXh0QmV0d2VlbihyZXNvbHZlZEZyb20gLSBwb3MsIHJlc29sdmVkVG8gLSBwb3MsIHVuZGVmaW5lZCwgJ1xcdWZmZmMnKTtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IHBhc3RlUnVsZU1hdGNoZXJIYW5kbGVyKHRleHRUb01hdGNoLCBydWxlLmZpbmQsIHBhc3RlRXZlbnQpO1xuICAgICAgICBtYXRjaGVzLmZvckVhY2gobWF0Y2ggPT4ge1xuICAgICAgICAgICAgaWYgKG1hdGNoLmluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IHJlc29sdmVkRnJvbSArIG1hdGNoLmluZGV4ICsgMTtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IHN0YXJ0ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgZnJvbTogc3RhdGUudHIubWFwcGluZy5tYXAoc3RhcnQpLFxuICAgICAgICAgICAgICAgIHRvOiBzdGF0ZS50ci5tYXBwaW5nLm1hcChlbmQpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSBydWxlLmhhbmRsZXIoe1xuICAgICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgICAgIHJhbmdlLFxuICAgICAgICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgICAgICAgIGNvbW1hbmRzLFxuICAgICAgICAgICAgICAgIGNoYWluLFxuICAgICAgICAgICAgICAgIGNhbixcbiAgICAgICAgICAgICAgICBwYXN0ZUV2ZW50LFxuICAgICAgICAgICAgICAgIGRyb3BFdmVudCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaGFuZGxlcnMucHVzaChoYW5kbGVyKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgY29uc3Qgc3VjY2VzcyA9IGhhbmRsZXJzLmV2ZXJ5KGhhbmRsZXIgPT4gaGFuZGxlciAhPT0gbnVsbCk7XG4gICAgcmV0dXJuIHN1Y2Nlc3M7XG59XG4vLyBXaGVuIGRyYWdnaW5nIGFjcm9zcyBlZGl0b3JzLCBtdXN0IGdldCBhbm90aGVyIGVkaXRvciBpbnN0YW5jZSB0byBkZWxldGUgc2VsZWN0aW9uIGNvbnRlbnQuXG5sZXQgdGlwdGFwRHJhZ0Zyb21PdGhlckVkaXRvciA9IG51bGw7XG5jb25zdCBjcmVhdGVDbGlwYm9hcmRQYXN0ZUV2ZW50ID0gKHRleHQpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgZXZlbnQgPSBuZXcgQ2xpcGJvYXJkRXZlbnQoJ3Bhc3RlJywge1xuICAgICAgICBjbGlwYm9hcmREYXRhOiBuZXcgRGF0YVRyYW5zZmVyKCksXG4gICAgfSk7XG4gICAgKF9hID0gZXZlbnQuY2xpcGJvYXJkRGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldERhdGEoJ3RleHQvaHRtbCcsIHRleHQpO1xuICAgIHJldHVybiBldmVudDtcbn07XG4vKipcbiAqIENyZWF0ZSBhbiBwYXN0ZSBydWxlcyBwbHVnaW4uIFdoZW4gZW5hYmxlZCwgaXQgd2lsbCBjYXVzZSBwYXN0ZWRcbiAqIHRleHQgdGhhdCBtYXRjaGVzIGFueSBvZiB0aGUgZ2l2ZW4gcnVsZXMgdG8gdHJpZ2dlciB0aGUgcnVsZeKAmXNcbiAqIGFjdGlvbi5cbiAqL1xuZnVuY3Rpb24gcGFzdGVSdWxlc1BsdWdpbihwcm9wcykge1xuICAgIGNvbnN0IHsgZWRpdG9yLCBydWxlcyB9ID0gcHJvcHM7XG4gICAgbGV0IGRyYWdTb3VyY2VFbGVtZW50ID0gbnVsbDtcbiAgICBsZXQgaXNQYXN0ZWRGcm9tUHJvc2VNaXJyb3IgPSBmYWxzZTtcbiAgICBsZXQgaXNEcm9wcGVkRnJvbVByb3NlTWlycm9yID0gZmFsc2U7XG4gICAgbGV0IHBhc3RlRXZlbnQgPSB0eXBlb2YgQ2xpcGJvYXJkRXZlbnQgIT09ICd1bmRlZmluZWQnID8gbmV3IENsaXBib2FyZEV2ZW50KCdwYXN0ZScpIDogbnVsbDtcbiAgICBsZXQgZHJvcEV2ZW50O1xuICAgIHRyeSB7XG4gICAgICAgIGRyb3BFdmVudCA9IHR5cGVvZiBEcmFnRXZlbnQgIT09ICd1bmRlZmluZWQnID8gbmV3IERyYWdFdmVudCgnZHJvcCcpIDogbnVsbDtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICBkcm9wRXZlbnQgPSBudWxsO1xuICAgIH1cbiAgICBjb25zdCBwcm9jZXNzRXZlbnQgPSAoeyBzdGF0ZSwgZnJvbSwgdG8sIHJ1bGUsIHBhc3RlRXZ0LCB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHRyID0gc3RhdGUudHI7XG4gICAgICAgIGNvbnN0IGNoYWluYWJsZVN0YXRlID0gY3JlYXRlQ2hhaW5hYmxlU3RhdGUoe1xuICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbjogdHIsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gcnVuKHtcbiAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgIHN0YXRlOiBjaGFpbmFibGVTdGF0ZSxcbiAgICAgICAgICAgIGZyb206IE1hdGgubWF4KGZyb20gLSAxLCAwKSxcbiAgICAgICAgICAgIHRvOiB0by5iIC0gMSxcbiAgICAgICAgICAgIHJ1bGUsXG4gICAgICAgICAgICBwYXN0ZUV2ZW50OiBwYXN0ZUV2dCxcbiAgICAgICAgICAgIGRyb3BFdmVudCxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghaGFuZGxlciB8fCAhdHIuc3RlcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRyb3BFdmVudCA9IHR5cGVvZiBEcmFnRXZlbnQgIT09ICd1bmRlZmluZWQnID8gbmV3IERyYWdFdmVudCgnZHJvcCcpIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICBkcm9wRXZlbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHBhc3RlRXZlbnQgPSB0eXBlb2YgQ2xpcGJvYXJkRXZlbnQgIT09ICd1bmRlZmluZWQnID8gbmV3IENsaXBib2FyZEV2ZW50KCdwYXN0ZScpIDogbnVsbDtcbiAgICAgICAgcmV0dXJuIHRyO1xuICAgIH07XG4gICAgY29uc3QgcGx1Z2lucyA9IHJ1bGVzLm1hcChydWxlID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQbHVnaW4oe1xuICAgICAgICAgICAgLy8gd2UgcmVnaXN0ZXIgYSBnbG9iYWwgZHJhZyBoYW5kbGVyIHRvIHRyYWNrIHRoZSBjdXJyZW50IGRyYWcgc291cmNlIGVsZW1lbnRcbiAgICAgICAgICAgIHZpZXcodmlldykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZURyYWdzdGFydCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdTb3VyY2VFbGVtZW50ID0gKChfYSA9IHZpZXcuZG9tLnBhcmVudEVsZW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250YWlucyhldmVudC50YXJnZXQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyB2aWV3LmRvbS5wYXJlbnRFbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkcmFnU291cmNlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGlwdGFwRHJhZ0Zyb21PdGhlckVkaXRvciA9IGVkaXRvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlRHJhZ2VuZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpcHRhcERyYWdGcm9tT3RoZXJFZGl0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpcHRhcERyYWdGcm9tT3RoZXJFZGl0b3IgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgaGFuZGxlRHJhZ3N0YXJ0KTtcbiAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ2VuZCcsIGhhbmRsZURyYWdlbmQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRlc3Ryb3koKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgaGFuZGxlRHJhZ3N0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdkcmFnZW5kJywgaGFuZGxlRHJhZ2VuZCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgIGhhbmRsZURPTUV2ZW50czoge1xuICAgICAgICAgICAgICAgICAgICBkcm9wOiAodmlldywgZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRHJvcHBlZEZyb21Qcm9zZU1pcnJvciA9IGRyYWdTb3VyY2VFbGVtZW50ID09PSB2aWV3LmRvbS5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgZHJvcEV2ZW50ID0gZXZlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRHJvcHBlZEZyb21Qcm9zZU1pcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRyYWdGcm9tT3RoZXJFZGl0b3IgPSB0aXB0YXBEcmFnRnJvbU90aGVyRWRpdG9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkcmFnRnJvbU90aGVyRWRpdG9yID09PSBudWxsIHx8IGRyYWdGcm9tT3RoZXJFZGl0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRyYWdGcm9tT3RoZXJFZGl0b3IuaXNFZGl0YWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXRUaW1lb3V0IHRvIGF2b2lkIHRoZSB3cm9uZyBjb250ZW50IGFmdGVyIGRyb3AsIHRpbWVvdXQgYXJnIGNhbid0IGJlIGVtcHR5IG9yIDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBkcmFnRnJvbU90aGVyRWRpdG9yLnN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcmFnRnJvbU90aGVyRWRpdG9yLmNvbW1hbmRzLmRlbGV0ZVJhbmdlKHsgZnJvbTogc2VsZWN0aW9uLmZyb20sIHRvOiBzZWxlY3Rpb24udG8gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHBhc3RlOiAoX3ZpZXcsIGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBodG1sID0gKF9hID0gZXZlbnQuY2xpcGJvYXJkRGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldERhdGEoJ3RleHQvaHRtbCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFzdGVFdmVudCA9IGV2ZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNQYXN0ZWRGcm9tUHJvc2VNaXJyb3IgPSAhIShodG1sID09PSBudWxsIHx8IGh0bWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGh0bWwuaW5jbHVkZXMoJ2RhdGEtcG0tc2xpY2UnKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcHBlbmRUcmFuc2FjdGlvbjogKHRyYW5zYWN0aW9ucywgb2xkU3RhdGUsIHN0YXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbnNbMF07XG4gICAgICAgICAgICAgICAgY29uc3QgaXNQYXN0ZSA9IHRyYW5zYWN0aW9uLmdldE1ldGEoJ3VpRXZlbnQnKSA9PT0gJ3Bhc3RlJyAmJiAhaXNQYXN0ZWRGcm9tUHJvc2VNaXJyb3I7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNEcm9wID0gdHJhbnNhY3Rpb24uZ2V0TWV0YSgndWlFdmVudCcpID09PSAnZHJvcCcgJiYgIWlzRHJvcHBlZEZyb21Qcm9zZU1pcnJvcjtcbiAgICAgICAgICAgICAgICAvLyBpZiBQYXN0ZVJ1bGUgaXMgdHJpZ2dlcmVkIGJ5IGluc2VydENvbnRlbnQoKVxuICAgICAgICAgICAgICAgIGNvbnN0IHNpbXVsYXRlZFBhc3RlTWV0YSA9IHRyYW5zYWN0aW9uLmdldE1ldGEoJ2FwcGx5UGFzdGVSdWxlcycpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzU2ltdWxhdGVkUGFzdGUgPSAhIXNpbXVsYXRlZFBhc3RlTWV0YTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzUGFzdGUgJiYgIWlzRHJvcCAmJiAhaXNTaW11bGF0ZWRQYXN0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBzaW11bGF0ZWQgcGFzdGVcbiAgICAgICAgICAgICAgICBpZiAoaXNTaW11bGF0ZWRQYXN0ZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeyB0ZXh0IH0gPSBzaW11bGF0ZWRQYXN0ZU1ldGE7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGV4dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA9IGdldEhUTUxGcm9tRnJhZ21lbnQoRnJhZ21lbnQuZnJvbSh0ZXh0KSwgc3RhdGUuc2NoZW1hKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGZyb20gfSA9IHNpbXVsYXRlZFBhc3RlTWV0YTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG8gPSBmcm9tICsgdGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhc3RlRXZ0ID0gY3JlYXRlQ2xpcGJvYXJkUGFzdGVFdmVudCh0ZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb2Nlc3NFdmVudCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBmcm9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG86IHsgYjogdG8gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhc3RlRXZ0LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaGFuZGxlIGFjdHVhbCBwYXN0ZS9kcm9wXG4gICAgICAgICAgICAgICAgY29uc3QgZnJvbSA9IG9sZFN0YXRlLmRvYy5jb250ZW50LmZpbmREaWZmU3RhcnQoc3RhdGUuZG9jLmNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvID0gb2xkU3RhdGUuZG9jLmNvbnRlbnQuZmluZERpZmZFbmQoc3RhdGUuZG9jLmNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIC8vIHN0b3AgaWYgdGhlcmUgaXMgbm8gY2hhbmdlZCByYW5nZVxuICAgICAgICAgICAgICAgIGlmICghaXNOdW1iZXIoZnJvbSkgfHwgIXRvIHx8IGZyb20gPT09IHRvLmIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvY2Vzc0V2ZW50KHtcbiAgICAgICAgICAgICAgICAgICAgcnVsZSxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIGZyb20sXG4gICAgICAgICAgICAgICAgICAgIHRvLFxuICAgICAgICAgICAgICAgICAgICBwYXN0ZUV2dDogcGFzdGVFdmVudCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBwbHVnaW5zO1xufVxuXG5mdW5jdGlvbiBmaW5kRHVwbGljYXRlcyhpdGVtcykge1xuICAgIGNvbnN0IGZpbHRlcmVkID0gaXRlbXMuZmlsdGVyKChlbCwgaW5kZXgpID0+IGl0ZW1zLmluZGV4T2YoZWwpICE9PSBpbmRleCk7XG4gICAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldChmaWx0ZXJlZCkpO1xufVxuXG5jbGFzcyBFeHRlbnNpb25NYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcihleHRlbnNpb25zLCBlZGl0b3IpIHtcbiAgICAgICAgdGhpcy5zcGxpdHRhYmxlTWFya3MgPSBbXTtcbiAgICAgICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9ucyA9IEV4dGVuc2lvbk1hbmFnZXIucmVzb2x2ZShleHRlbnNpb25zKTtcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBnZXRTY2hlbWFCeVJlc29sdmVkRXh0ZW5zaW9ucyh0aGlzLmV4dGVuc2lvbnMsIGVkaXRvcik7XG4gICAgICAgIHRoaXMuc2V0dXBFeHRlbnNpb25zKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBmbGF0dGVuZWQgYW5kIHNvcnRlZCBleHRlbnNpb24gbGlzdCB3aGlsZVxuICAgICAqIGFsc28gY2hlY2tpbmcgZm9yIGR1cGxpY2F0ZWQgZXh0ZW5zaW9ucyBhbmQgd2FybnMgdGhlIHVzZXIuXG4gICAgICogQHBhcmFtIGV4dGVuc2lvbnMgQW4gYXJyYXkgb2YgVGlwdGFwIGV4dGVuc2lvbnNcbiAgICAgKiBAcmV0dXJucyBBbiBmbGF0dGVuZWQgYW5kIHNvcnRlZCBhcnJheSBvZiBUaXB0YXAgZXh0ZW5zaW9uc1xuICAgICAqL1xuICAgIHN0YXRpYyByZXNvbHZlKGV4dGVuc2lvbnMpIHtcbiAgICAgICAgY29uc3QgcmVzb2x2ZWRFeHRlbnNpb25zID0gRXh0ZW5zaW9uTWFuYWdlci5zb3J0KEV4dGVuc2lvbk1hbmFnZXIuZmxhdHRlbihleHRlbnNpb25zKSk7XG4gICAgICAgIGNvbnN0IGR1cGxpY2F0ZWROYW1lcyA9IGZpbmREdXBsaWNhdGVzKHJlc29sdmVkRXh0ZW5zaW9ucy5tYXAoZXh0ZW5zaW9uID0+IGV4dGVuc2lvbi5uYW1lKSk7XG4gICAgICAgIGlmIChkdXBsaWNhdGVkTmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYFt0aXB0YXAgd2Fybl06IER1cGxpY2F0ZSBleHRlbnNpb24gbmFtZXMgZm91bmQ6IFske2R1cGxpY2F0ZWROYW1lc1xuICAgICAgICAgICAgICAgIC5tYXAoaXRlbSA9PiBgJyR7aXRlbX0nYClcbiAgICAgICAgICAgICAgICAuam9pbignLCAnKX1dLiBUaGlzIGNhbiBsZWFkIHRvIGlzc3Vlcy5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzb2x2ZWRFeHRlbnNpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBmbGF0dGVuZWQgYXJyYXkgb2YgZXh0ZW5zaW9ucyBieSB0cmF2ZXJzaW5nIHRoZSBgYWRkRXh0ZW5zaW9uc2AgZmllbGQuXG4gICAgICogQHBhcmFtIGV4dGVuc2lvbnMgQW4gYXJyYXkgb2YgVGlwdGFwIGV4dGVuc2lvbnNcbiAgICAgKiBAcmV0dXJucyBBIGZsYXR0ZW5lZCBhcnJheSBvZiBUaXB0YXAgZXh0ZW5zaW9uc1xuICAgICAqL1xuICAgIHN0YXRpYyBmbGF0dGVuKGV4dGVuc2lvbnMpIHtcbiAgICAgICAgcmV0dXJuIChleHRlbnNpb25zXG4gICAgICAgICAgICAubWFwKGV4dGVuc2lvbiA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICAgICAgICAgIHN0b3JhZ2U6IGV4dGVuc2lvbi5zdG9yYWdlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGFkZEV4dGVuc2lvbnMgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdhZGRFeHRlbnNpb25zJywgY29udGV4dCk7XG4gICAgICAgICAgICBpZiAoYWRkRXh0ZW5zaW9ucykge1xuICAgICAgICAgICAgICAgIHJldHVybiBbZXh0ZW5zaW9uLCAuLi50aGlzLmZsYXR0ZW4oYWRkRXh0ZW5zaW9ucygpKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXh0ZW5zaW9uO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLy8gYEluZmluaXR5YCB3aWxsIGJyZWFrIFR5cGVTY3JpcHQgc28gd2Ugc2V0IGEgbnVtYmVyIHRoYXQgaXMgcHJvYmFibHkgaGlnaCBlbm91Z2hcbiAgICAgICAgICAgIC5mbGF0KDEwKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNvcnQgZXh0ZW5zaW9ucyBieSBwcmlvcml0eS5cbiAgICAgKiBAcGFyYW0gZXh0ZW5zaW9ucyBBbiBhcnJheSBvZiBUaXB0YXAgZXh0ZW5zaW9uc1xuICAgICAqIEByZXR1cm5zIEEgc29ydGVkIGFycmF5IG9mIFRpcHRhcCBleHRlbnNpb25zIGJ5IHByaW9yaXR5XG4gICAgICovXG4gICAgc3RhdGljIHNvcnQoZXh0ZW5zaW9ucykge1xuICAgICAgICBjb25zdCBkZWZhdWx0UHJpb3JpdHkgPSAxMDA7XG4gICAgICAgIHJldHVybiBleHRlbnNpb25zLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHByaW9yaXR5QSA9IGdldEV4dGVuc2lvbkZpZWxkKGEsICdwcmlvcml0eScpIHx8IGRlZmF1bHRQcmlvcml0eTtcbiAgICAgICAgICAgIGNvbnN0IHByaW9yaXR5QiA9IGdldEV4dGVuc2lvbkZpZWxkKGIsICdwcmlvcml0eScpIHx8IGRlZmF1bHRQcmlvcml0eTtcbiAgICAgICAgICAgIGlmIChwcmlvcml0eUEgPiBwcmlvcml0eUIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJpb3JpdHlBIDwgcHJpb3JpdHlCKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgY29tbWFuZHMgZnJvbSB0aGUgZXh0ZW5zaW9ucy5cbiAgICAgKiBAcmV0dXJucyBBbiBvYmplY3Qgd2l0aCBhbGwgY29tbWFuZHMgd2hlcmUgdGhlIGtleSBpcyB0aGUgY29tbWFuZCBuYW1lIGFuZCB0aGUgdmFsdWUgaXMgdGhlIGNvbW1hbmQgZnVuY3Rpb25cbiAgICAgKi9cbiAgICBnZXQgY29tbWFuZHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4dGVuc2lvbnMucmVkdWNlKChjb21tYW5kcywgZXh0ZW5zaW9uKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICAgICAgICAgIHN0b3JhZ2U6IGV4dGVuc2lvbi5zdG9yYWdlLFxuICAgICAgICAgICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXG4gICAgICAgICAgICAgICAgdHlwZTogZ2V0U2NoZW1hVHlwZUJ5TmFtZShleHRlbnNpb24ubmFtZSwgdGhpcy5zY2hlbWEpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGFkZENvbW1hbmRzID0gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnYWRkQ29tbWFuZHMnLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGlmICghYWRkQ29tbWFuZHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLmNvbW1hbmRzLFxuICAgICAgICAgICAgICAgIC4uLmFkZENvbW1hbmRzKCksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB7fSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgcmVnaXN0ZXJlZCBQcm9zZW1pcnJvciBwbHVnaW5zIGZyb20gdGhlIGV4dGVuc2lvbnMuXG4gICAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgUHJvc2VtaXJyb3IgcGx1Z2luc1xuICAgICAqL1xuICAgIGdldCBwbHVnaW5zKCkge1xuICAgICAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcztcbiAgICAgICAgLy8gV2l0aCBQcm9zZU1pcnJvciwgZmlyc3QgcGx1Z2lucyB3aXRoaW4gYW4gYXJyYXkgYXJlIGV4ZWN1dGVkIGZpcnN0LlxuICAgICAgICAvLyBJbiBUaXB0YXAsIHdlIHByb3ZpZGUgdGhlIGFiaWxpdHkgdG8gb3ZlcnJpZGUgcGx1Z2lucyxcbiAgICAgICAgLy8gc28gaXQgZmVlbHMgbW9yZSBuYXR1cmFsIHRvIHJ1biBwbHVnaW5zIGF0IHRoZSBlbmQgb2YgYW4gYXJyYXkgZmlyc3QuXG4gICAgICAgIC8vIFRoYXTigJlzIHdoeSB3ZSBoYXZlIHRvIHJldmVyc2UgdGhlIGBleHRlbnNpb25zYCBhcnJheSBhbmQgc29ydCBhZ2FpblxuICAgICAgICAvLyBiYXNlZCBvbiB0aGUgYHByaW9yaXR5YCBvcHRpb24uXG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbnMgPSBFeHRlbnNpb25NYW5hZ2VyLnNvcnQoWy4uLnRoaXMuZXh0ZW5zaW9uc10ucmV2ZXJzZSgpKTtcbiAgICAgICAgY29uc3QgaW5wdXRSdWxlcyA9IFtdO1xuICAgICAgICBjb25zdCBwYXN0ZVJ1bGVzID0gW107XG4gICAgICAgIGNvbnN0IGFsbFBsdWdpbnMgPSBleHRlbnNpb25zXG4gICAgICAgICAgICAubWFwKGV4dGVuc2lvbiA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICAgICAgICAgIHN0b3JhZ2U6IGV4dGVuc2lvbi5zdG9yYWdlLFxuICAgICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgICB0eXBlOiBnZXRTY2hlbWFUeXBlQnlOYW1lKGV4dGVuc2lvbi5uYW1lLCB0aGlzLnNjaGVtYSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcGx1Z2lucyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgYWRkS2V5Ym9hcmRTaG9ydGN1dHMgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdhZGRLZXlib2FyZFNob3J0Y3V0cycsIGNvbnRleHQpO1xuICAgICAgICAgICAgbGV0IGRlZmF1bHRCaW5kaW5ncyA9IHt9O1xuICAgICAgICAgICAgLy8gYmluZCBleGl0IGhhbmRsaW5nXG4gICAgICAgICAgICBpZiAoZXh0ZW5zaW9uLnR5cGUgPT09ICdtYXJrJyAmJiBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdleGl0YWJsZScsIGNvbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdEJpbmRpbmdzLkFycm93UmlnaHQgPSAoKSA9PiBNYXJrLmhhbmRsZUV4aXQoeyBlZGl0b3IsIG1hcms6IGV4dGVuc2lvbiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhZGRLZXlib2FyZFNob3J0Y3V0cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJpbmRpbmdzID0gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKGFkZEtleWJvYXJkU2hvcnRjdXRzKCkpLm1hcCgoW3Nob3J0Y3V0LCBtZXRob2RdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbc2hvcnRjdXQsICgpID0+IG1ldGhvZCh7IGVkaXRvciB9KV07XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHRCaW5kaW5ncyA9IHsgLi4uZGVmYXVsdEJpbmRpbmdzLCAuLi5iaW5kaW5ncyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qga2V5TWFwUGx1Z2luID0ga2V5bWFwKGRlZmF1bHRCaW5kaW5ncyk7XG4gICAgICAgICAgICBwbHVnaW5zLnB1c2goa2V5TWFwUGx1Z2luKTtcbiAgICAgICAgICAgIGNvbnN0IGFkZElucHV0UnVsZXMgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdhZGRJbnB1dFJ1bGVzJywgY29udGV4dCk7XG4gICAgICAgICAgICBpZiAoaXNFeHRlbnNpb25SdWxlc0VuYWJsZWQoZXh0ZW5zaW9uLCBlZGl0b3Iub3B0aW9ucy5lbmFibGVJbnB1dFJ1bGVzKSAmJiBhZGRJbnB1dFJ1bGVzKSB7XG4gICAgICAgICAgICAgICAgaW5wdXRSdWxlcy5wdXNoKC4uLmFkZElucHV0UnVsZXMoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhZGRQYXN0ZVJ1bGVzID0gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnYWRkUGFzdGVSdWxlcycsIGNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKGlzRXh0ZW5zaW9uUnVsZXNFbmFibGVkKGV4dGVuc2lvbiwgZWRpdG9yLm9wdGlvbnMuZW5hYmxlUGFzdGVSdWxlcykgJiYgYWRkUGFzdGVSdWxlcykge1xuICAgICAgICAgICAgICAgIHBhc3RlUnVsZXMucHVzaCguLi5hZGRQYXN0ZVJ1bGVzKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYWRkUHJvc2VNaXJyb3JQbHVnaW5zID0gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnYWRkUHJvc2VNaXJyb3JQbHVnaW5zJywgY29udGV4dCk7XG4gICAgICAgICAgICBpZiAoYWRkUHJvc2VNaXJyb3JQbHVnaW5zKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvc2VNaXJyb3JQbHVnaW5zID0gYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCk7XG4gICAgICAgICAgICAgICAgcGx1Z2lucy5wdXNoKC4uLnByb3NlTWlycm9yUGx1Z2lucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGx1Z2lucztcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5mbGF0KCk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBpbnB1dFJ1bGVzUGx1Z2luKHtcbiAgICAgICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICAgICAgcnVsZXM6IGlucHV0UnVsZXMsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIC4uLnBhc3RlUnVsZXNQbHVnaW4oe1xuICAgICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgICBydWxlczogcGFzdGVSdWxlcyxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgLi4uYWxsUGx1Z2lucyxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBhdHRyaWJ1dGVzIGZyb20gdGhlIGV4dGVuc2lvbnMuXG4gICAgICogQHJldHVybnMgQW4gYXJyYXkgb2YgYXR0cmlidXRlc1xuICAgICAqL1xuICAgIGdldCBhdHRyaWJ1dGVzKCkge1xuICAgICAgICByZXR1cm4gZ2V0QXR0cmlidXRlc0Zyb21FeHRlbnNpb25zKHRoaXMuZXh0ZW5zaW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgbm9kZSB2aWV3cyBmcm9tIHRoZSBleHRlbnNpb25zLlxuICAgICAqIEByZXR1cm5zIEFuIG9iamVjdCB3aXRoIGFsbCBub2RlIHZpZXdzIHdoZXJlIHRoZSBrZXkgaXMgdGhlIG5vZGUgbmFtZSBhbmQgdGhlIHZhbHVlIGlzIHRoZSBub2RlIHZpZXcgZnVuY3Rpb25cbiAgICAgKi9cbiAgICBnZXQgbm9kZVZpZXdzKCkge1xuICAgICAgICBjb25zdCB7IGVkaXRvciB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgeyBub2RlRXh0ZW5zaW9ucyB9ID0gc3BsaXRFeHRlbnNpb25zKHRoaXMuZXh0ZW5zaW9ucyk7XG4gICAgICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMobm9kZUV4dGVuc2lvbnNcbiAgICAgICAgICAgIC5maWx0ZXIoZXh0ZW5zaW9uID0+ICEhZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnYWRkTm9kZVZpZXcnKSlcbiAgICAgICAgICAgIC5tYXAoZXh0ZW5zaW9uID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGV4dGVuc2lvbkF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXMuZmlsdGVyKGF0dHJpYnV0ZSA9PiBhdHRyaWJ1dGUudHlwZSA9PT0gZXh0ZW5zaW9uLm5hbWUpO1xuICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgICAgICAgICAgICBzdG9yYWdlOiBleHRlbnNpb24uc3RvcmFnZSxcbiAgICAgICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICAgICAgdHlwZTogZ2V0Tm9kZVR5cGUoZXh0ZW5zaW9uLm5hbWUsIHRoaXMuc2NoZW1hKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBhZGROb2RlVmlldyA9IGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2FkZE5vZGVWaWV3JywgY29udGV4dCk7XG4gICAgICAgICAgICBpZiAoIWFkZE5vZGVWaWV3KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgbm9kZXZpZXcgPSAobm9kZSwgdmlldywgZ2V0UG9zLCBkZWNvcmF0aW9ucywgaW5uZXJEZWNvcmF0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IEhUTUxBdHRyaWJ1dGVzID0gZ2V0UmVuZGVyZWRBdHRyaWJ1dGVzKG5vZGUsIGV4dGVuc2lvbkF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhZGROb2RlVmlldygpKHtcbiAgICAgICAgICAgICAgICAgICAgLy8gcGFzcy10aHJvdWdoXG4gICAgICAgICAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICAgICAgICAgIHZpZXcsXG4gICAgICAgICAgICAgICAgICAgIGdldFBvczogZ2V0UG9zLFxuICAgICAgICAgICAgICAgICAgICBkZWNvcmF0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgaW5uZXJEZWNvcmF0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgLy8gdGlwdGFwLXNwZWNpZmljXG4gICAgICAgICAgICAgICAgICAgIGVkaXRvcixcbiAgICAgICAgICAgICAgICAgICAgZXh0ZW5zaW9uLFxuICAgICAgICAgICAgICAgICAgICBIVE1MQXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gW2V4dGVuc2lvbi5uYW1lLCBub2Rldmlld107XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR28gdGhyb3VnaCBhbGwgZXh0ZW5zaW9ucywgY3JlYXRlIGV4dGVuc2lvbiBzdG9yYWdlcyAmIHNldHVwIG1hcmtzXG4gICAgICogJiBiaW5kIGVkaXRvciBldmVudCBsaXN0ZW5lci5cbiAgICAgKi9cbiAgICBzZXR1cEV4dGVuc2lvbnMoKSB7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9ucy5mb3JFYWNoKGV4dGVuc2lvbiA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAvLyBzdG9yZSBleHRlbnNpb24gc3RvcmFnZSBpbiBlZGl0b3JcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLmV4dGVuc2lvblN0b3JhZ2VbZXh0ZW5zaW9uLm5hbWVdID0gZXh0ZW5zaW9uLnN0b3JhZ2U7XG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGV4dGVuc2lvbi5vcHRpb25zLFxuICAgICAgICAgICAgICAgIHN0b3JhZ2U6IGV4dGVuc2lvbi5zdG9yYWdlLFxuICAgICAgICAgICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXG4gICAgICAgICAgICAgICAgdHlwZTogZ2V0U2NoZW1hVHlwZUJ5TmFtZShleHRlbnNpb24ubmFtZSwgdGhpcy5zY2hlbWEpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChleHRlbnNpb24udHlwZSA9PT0gJ21hcmsnKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2VlcE9uU3BsaXQgPSAoX2EgPSBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAna2VlcE9uU3BsaXQnLCBjb250ZXh0KSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKGtlZXBPblNwbGl0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3BsaXR0YWJsZU1hcmtzLnB1c2goZXh0ZW5zaW9uLm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9uQmVmb3JlQ3JlYXRlID0gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnb25CZWZvcmVDcmVhdGUnLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGNvbnN0IG9uQ3JlYXRlID0gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnb25DcmVhdGUnLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGNvbnN0IG9uVXBkYXRlID0gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnb25VcGRhdGUnLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGNvbnN0IG9uU2VsZWN0aW9uVXBkYXRlID0gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnb25TZWxlY3Rpb25VcGRhdGUnLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGNvbnN0IG9uVHJhbnNhY3Rpb24gPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdvblRyYW5zYWN0aW9uJywgY29udGV4dCk7XG4gICAgICAgICAgICBjb25zdCBvbkZvY3VzID0gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnb25Gb2N1cycsIGNvbnRleHQpO1xuICAgICAgICAgICAgY29uc3Qgb25CbHVyID0gZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnb25CbHVyJywgY29udGV4dCk7XG4gICAgICAgICAgICBjb25zdCBvbkRlc3Ryb3kgPSBnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdvbkRlc3Ryb3knLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGlmIChvbkJlZm9yZUNyZWF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZWRpdG9yLm9uKCdiZWZvcmVDcmVhdGUnLCBvbkJlZm9yZUNyZWF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25DcmVhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRvci5vbignY3JlYXRlJywgb25DcmVhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9uVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0b3Iub24oJ3VwZGF0ZScsIG9uVXBkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvblNlbGVjdGlvblVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZWRpdG9yLm9uKCdzZWxlY3Rpb25VcGRhdGUnLCBvblNlbGVjdGlvblVwZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25UcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuZWRpdG9yLm9uKCd0cmFuc2FjdGlvbicsIG9uVHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9uRm9jdXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRvci5vbignZm9jdXMnLCBvbkZvY3VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvbkJsdXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRvci5vbignYmx1cicsIG9uQmx1cik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25EZXN0cm95KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0b3Iub24oJ2Rlc3Ryb3knLCBvbkRlc3Ryb3kpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhlIEV4dGVuc2lvbiBjbGFzcyBpcyB0aGUgYmFzZSBjbGFzcyBmb3IgYWxsIGV4dGVuc2lvbnMuXG4gKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9hcGkvZXh0ZW5zaW9ucyNjcmVhdGUtYS1uZXctZXh0ZW5zaW9uXG4gKi9cbmNsYXNzIEV4dGVuc2lvbiB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICAgICAgdGhpcy50eXBlID0gJ2V4dGVuc2lvbic7XG4gICAgICAgIHRoaXMubmFtZSA9ICdleHRlbnNpb24nO1xuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuY2hpbGQgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgIGRlZmF1bHRPcHRpb25zOiB7fSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jb25maWcgPSB7XG4gICAgICAgICAgICAuLi50aGlzLmNvbmZpZyxcbiAgICAgICAgICAgIC4uLmNvbmZpZyxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5jb25maWcubmFtZTtcbiAgICAgICAgaWYgKGNvbmZpZy5kZWZhdWx0T3B0aW9ucyAmJiBPYmplY3Qua2V5cyhjb25maWcuZGVmYXVsdE9wdGlvbnMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgW3RpcHRhcCB3YXJuXTogQlJFQUtJTkcgQ0hBTkdFOiBcImRlZmF1bHRPcHRpb25zXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcImFkZE9wdGlvbnNcIiBpbnN0ZWFkLiBGb3VuZCBpbiBleHRlbnNpb246IFwiJHt0aGlzLm5hbWV9XCIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogcmVtb3ZlIGBhZGRPcHRpb25zYCBmYWxsYmFja1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB0aGlzLmNvbmZpZy5kZWZhdWx0T3B0aW9ucztcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmFkZE9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZCh0aGlzLCAnYWRkT3B0aW9ucycsIHtcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdG9yYWdlID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKHRoaXMsICdhZGRTdG9yYWdlJywge1xuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zLFxuICAgICAgICB9KSkgfHwge307XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUoY29uZmlnID0ge30pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFeHRlbnNpb24oY29uZmlnKTtcbiAgICB9XG4gICAgY29uZmlndXJlKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICAvLyByZXR1cm4gYSBuZXcgaW5zdGFuY2Ugc28gd2UgY2FuIHVzZSB0aGUgc2FtZSBleHRlbnNpb25cbiAgICAgICAgLy8gd2l0aCBkaWZmZXJlbnQgY2FsbHMgb2YgYGNvbmZpZ3VyZWBcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9uID0gdGhpcy5leHRlbmQoe1xuICAgICAgICAgICAgLi4udGhpcy5jb25maWcsXG4gICAgICAgICAgICBhZGRPcHRpb25zOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lcmdlRGVlcCh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEFsd2F5cyBwcmVzZXJ2ZSB0aGUgY3VycmVudCBuYW1lXG4gICAgICAgIGV4dGVuc2lvbi5uYW1lID0gdGhpcy5uYW1lO1xuICAgICAgICAvLyBTZXQgdGhlIHBhcmVudCB0byBiZSBvdXIgcGFyZW50XG4gICAgICAgIGV4dGVuc2lvbi5wYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgcmV0dXJuIGV4dGVuc2lvbjtcbiAgICB9XG4gICAgZXh0ZW5kKGV4dGVuZGVkQ29uZmlnID0ge30pIHtcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9uID0gbmV3IEV4dGVuc2lvbih7IC4uLnRoaXMuY29uZmlnLCAuLi5leHRlbmRlZENvbmZpZyB9KTtcbiAgICAgICAgZXh0ZW5zaW9uLnBhcmVudCA9IHRoaXM7XG4gICAgICAgIHRoaXMuY2hpbGQgPSBleHRlbnNpb247XG4gICAgICAgIGV4dGVuc2lvbi5uYW1lID0gZXh0ZW5kZWRDb25maWcubmFtZSA/IGV4dGVuZGVkQ29uZmlnLm5hbWUgOiBleHRlbnNpb24ucGFyZW50Lm5hbWU7XG4gICAgICAgIGlmIChleHRlbmRlZENvbmZpZy5kZWZhdWx0T3B0aW9ucyAmJiBPYmplY3Qua2V5cyhleHRlbmRlZENvbmZpZy5kZWZhdWx0T3B0aW9ucykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBbdGlwdGFwIHdhcm5dOiBCUkVBS0lORyBDSEFOR0U6IFwiZGVmYXVsdE9wdGlvbnNcIiBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIFwiYWRkT3B0aW9uc1wiIGluc3RlYWQuIEZvdW5kIGluIGV4dGVuc2lvbjogXCIke2V4dGVuc2lvbi5uYW1lfVwiLmApO1xuICAgICAgICB9XG4gICAgICAgIGV4dGVuc2lvbi5vcHRpb25zID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2FkZE9wdGlvbnMnLCB7XG4gICAgICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgfSkpO1xuICAgICAgICBleHRlbnNpb24uc3RvcmFnZSA9IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdhZGRTdG9yYWdlJywge1xuICAgICAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gZXh0ZW5zaW9uO1xuICAgIH1cbn1cblxuLyoqXG4gKiBHZXRzIHRoZSB0ZXh0IGJldHdlZW4gdHdvIHBvc2l0aW9ucyBpbiBhIFByb3NlbWlycm9yIG5vZGVcbiAqIGFuZCBzZXJpYWxpemVzIGl0IHVzaW5nIHRoZSBnaXZlbiB0ZXh0IHNlcmlhbGl6ZXJzIGFuZCBibG9jayBzZXBhcmF0b3IgKHNlZSBnZXRUZXh0KVxuICogQHBhcmFtIHN0YXJ0Tm9kZSBUaGUgUHJvc2VtaXJyb3Igbm9kZSB0byBzdGFydCBmcm9tXG4gKiBAcGFyYW0gcmFuZ2UgVGhlIHJhbmdlIG9mIHRoZSB0ZXh0IHRvIGdldFxuICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyBmb3IgdGhlIHRleHQgc2VyaWFsaXplciAmIGJsb2NrIHNlcGFyYXRvclxuICogQHJldHVybnMgVGhlIHRleHQgYmV0d2VlbiB0aGUgdHdvIHBvc2l0aW9uc1xuICovXG5mdW5jdGlvbiBnZXRUZXh0QmV0d2VlbihzdGFydE5vZGUsIHJhbmdlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBmcm9tLCB0byB9ID0gcmFuZ2U7XG4gICAgY29uc3QgeyBibG9ja1NlcGFyYXRvciA9ICdcXG5cXG4nLCB0ZXh0U2VyaWFsaXplcnMgPSB7fSB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgICBsZXQgdGV4dCA9ICcnO1xuICAgIHN0YXJ0Tm9kZS5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MsIHBhcmVudCwgaW5kZXgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAobm9kZS5pc0Jsb2NrICYmIHBvcyA+IGZyb20pIHtcbiAgICAgICAgICAgIHRleHQgKz0gYmxvY2tTZXBhcmF0b3I7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGV4dFNlcmlhbGl6ZXIgPSB0ZXh0U2VyaWFsaXplcnMgPT09IG51bGwgfHwgdGV4dFNlcmlhbGl6ZXJzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0ZXh0U2VyaWFsaXplcnNbbm9kZS50eXBlLm5hbWVdO1xuICAgICAgICBpZiAodGV4dFNlcmlhbGl6ZXIpIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ICs9IHRleHRTZXJpYWxpemVyKHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgcG9zLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgICAgICByYW5nZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGRvIG5vdCBkZXNjZW5kIGludG8gY2hpbGQgbm9kZXMgd2hlbiB0aGVyZSBleGlzdHMgYSBzZXJpYWxpemVyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuaXNUZXh0KSB7XG4gICAgICAgICAgICB0ZXh0ICs9IChfYSA9IG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZS50ZXh0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2xpY2UoTWF0aC5tYXgoZnJvbSwgcG9zKSAtIHBvcywgdG8gLSBwb3MpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdGV4dDtcbn1cblxuLyoqXG4gKiBGaW5kIHRleHQgc2VyaWFsaXplcnMgYHRvVGV4dGAgaW4gYSBQcm9zZW1pcnJvciBzY2hlbWFcbiAqIEBwYXJhbSBzY2hlbWEgVGhlIFByb3NlbWlycm9yIHNjaGVtYSB0byBzZWFyY2ggaW5cbiAqIEByZXR1cm5zIEEgcmVjb3JkIG9mIHRleHQgc2VyaWFsaXplcnMgYnkgbm9kZSBuYW1lXG4gKi9cbmZ1bmN0aW9uIGdldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEoc2NoZW1hKSB7XG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhPYmplY3QuZW50cmllcyhzY2hlbWEubm9kZXMpXG4gICAgICAgIC5maWx0ZXIoKFssIG5vZGVdKSA9PiBub2RlLnNwZWMudG9UZXh0KVxuICAgICAgICAubWFwKChbbmFtZSwgbm9kZV0pID0+IFtuYW1lLCBub2RlLnNwZWMudG9UZXh0XSkpO1xufVxuXG5jb25zdCBDbGlwYm9hcmRUZXh0U2VyaWFsaXplciA9IEV4dGVuc2lvbi5jcmVhdGUoe1xuICAgIG5hbWU6ICdjbGlwYm9hcmRUZXh0U2VyaWFsaXplcicsXG4gICAgYWRkT3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJsb2NrU2VwYXJhdG9yOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBuZXcgUGx1Z2luKHtcbiAgICAgICAgICAgICAgICBrZXk6IG5ldyBQbHVnaW5LZXkoJ2NsaXBib2FyZFRleHRTZXJpYWxpemVyJyksXG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgY2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXI6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgZWRpdG9yIH0gPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBzdGF0ZSwgc2NoZW1hIH0gPSBlZGl0b3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGRvYywgc2VsZWN0aW9uIH0gPSBzdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgcmFuZ2VzIH0gPSBzZWxlY3Rpb247XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmcm9tID0gTWF0aC5taW4oLi4ucmFuZ2VzLm1hcChyYW5nZSA9PiByYW5nZS4kZnJvbS5wb3MpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvID0gTWF0aC5tYXgoLi4ucmFuZ2VzLm1hcChyYW5nZSA9PiByYW5nZS4kdG8ucG9zKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0U2VyaWFsaXplcnMgPSBnZXRUZXh0U2VyaWFsaXplcnNGcm9tU2NoZW1hKHNjaGVtYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByYW5nZSA9IHsgZnJvbSwgdG8gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRUZXh0QmV0d2Vlbihkb2MsIHJhbmdlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uKHRoaXMub3B0aW9ucy5ibG9ja1NlcGFyYXRvciAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8geyBibG9ja1NlcGFyYXRvcjogdGhpcy5vcHRpb25zLmJsb2NrU2VwYXJhdG9yIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB7fSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dFNlcmlhbGl6ZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdO1xuICAgIH0sXG59KTtcblxuY29uc3QgYmx1ciA9ICgpID0+ICh7IGVkaXRvciwgdmlldyB9KSA9PiB7XG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIWVkaXRvci5pc0Rlc3Ryb3llZCkge1xuICAgICAgICAgICAgdmlldy5kb20uYmx1cigpO1xuICAgICAgICAgICAgLy8gQnJvd3NlcnMgc2hvdWxkIHJlbW92ZSB0aGUgY2FyZXQgb24gYmx1ciBidXQgc2FmYXJpIGRvZXMgbm90LlxuICAgICAgICAgICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vdWViZXJkb3Npcy90aXB0YXAvaXNzdWVzLzI0MDVcbiAgICAgICAgICAgIChfYSA9IHdpbmRvdyA9PT0gbnVsbCB8fCB3aW5kb3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdpbmRvdy5nZXRTZWxlY3Rpb24oKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCBjbGVhckNvbnRlbnQgPSAoZW1pdFVwZGF0ZSA9IGZhbHNlKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgcmV0dXJuIGNvbW1hbmRzLnNldENvbnRlbnQoJycsIGVtaXRVcGRhdGUpO1xufTtcblxuY29uc3QgY2xlYXJOb2RlcyA9ICgpID0+ICh7IHN0YXRlLCB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSB0cjtcbiAgICBjb25zdCB7IHJhbmdlcyB9ID0gc2VsZWN0aW9uO1xuICAgIGlmICghZGlzcGF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJhbmdlcy5mb3JFYWNoKCh7ICRmcm9tLCAkdG8gfSkgPT4ge1xuICAgICAgICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKCRmcm9tLnBvcywgJHRvLnBvcywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICAgICAgaWYgKG5vZGUudHlwZS5pc1RleHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGRvYywgbWFwcGluZyB9ID0gdHI7XG4gICAgICAgICAgICBjb25zdCAkbWFwcGVkRnJvbSA9IGRvYy5yZXNvbHZlKG1hcHBpbmcubWFwKHBvcykpO1xuICAgICAgICAgICAgY29uc3QgJG1hcHBlZFRvID0gZG9jLnJlc29sdmUobWFwcGluZy5tYXAocG9zICsgbm9kZS5ub2RlU2l6ZSkpO1xuICAgICAgICAgICAgY29uc3Qgbm9kZVJhbmdlID0gJG1hcHBlZEZyb20uYmxvY2tSYW5nZSgkbWFwcGVkVG8pO1xuICAgICAgICAgICAgaWYgKCFub2RlUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRMaWZ0RGVwdGggPSBsaWZ0VGFyZ2V0KG5vZGVSYW5nZSk7XG4gICAgICAgICAgICBpZiAobm9kZS50eXBlLmlzVGV4dGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkZWZhdWx0VHlwZSB9ID0gJG1hcHBlZEZyb20ucGFyZW50LmNvbnRlbnRNYXRjaEF0KCRtYXBwZWRGcm9tLmluZGV4KCkpO1xuICAgICAgICAgICAgICAgIHRyLnNldE5vZGVNYXJrdXAobm9kZVJhbmdlLnN0YXJ0LCBkZWZhdWx0VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGFyZ2V0TGlmdERlcHRoIHx8IHRhcmdldExpZnREZXB0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRyLmxpZnQobm9kZVJhbmdlLCB0YXJnZXRMaWZ0RGVwdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IGNvbW1hbmQgPSBmbiA9PiBwcm9wcyA9PiB7XG4gICAgcmV0dXJuIGZuKHByb3BzKTtcbn07XG5cbmNvbnN0IGNyZWF0ZVBhcmFncmFwaE5lYXIgPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIHJldHVybiBjcmVhdGVQYXJhZ3JhcGhOZWFyJDEoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbmNvbnN0IGN1dCA9IChvcmlnaW5SYW5nZSwgdGFyZ2V0UG9zKSA9PiAoeyBlZGl0b3IsIHRyIH0pID0+IHtcbiAgICBjb25zdCB7IHN0YXRlIH0gPSBlZGl0b3I7XG4gICAgY29uc3QgY29udGVudFNsaWNlID0gc3RhdGUuZG9jLnNsaWNlKG9yaWdpblJhbmdlLmZyb20sIG9yaWdpblJhbmdlLnRvKTtcbiAgICB0ci5kZWxldGVSYW5nZShvcmlnaW5SYW5nZS5mcm9tLCBvcmlnaW5SYW5nZS50byk7XG4gICAgY29uc3QgbmV3UG9zID0gdHIubWFwcGluZy5tYXAodGFyZ2V0UG9zKTtcbiAgICB0ci5pbnNlcnQobmV3UG9zLCBjb250ZW50U2xpY2UuY29udGVudCk7XG4gICAgdHIuc2V0U2VsZWN0aW9uKG5ldyBUZXh0U2VsZWN0aW9uKHRyLmRvYy5yZXNvbHZlKE1hdGgubWF4KG5ld1BvcyAtIDEsIDApKSkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcblxuY29uc3QgZGVsZXRlQ3VycmVudE5vZGUgPSAoKSA9PiAoeyB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSB0cjtcbiAgICBjb25zdCBjdXJyZW50Tm9kZSA9IHNlbGVjdGlvbi4kYW5jaG9yLm5vZGUoKTtcbiAgICAvLyBpZiB0aGVyZSBpcyBjb250ZW50IGluc2lkZSB0aGUgY3VycmVudCBub2RlLCBicmVhayBvdXQgb2YgdGhpcyBjb21tYW5kXG4gICAgaWYgKGN1cnJlbnROb2RlLmNvbnRlbnQuc2l6ZSA+IDApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCAkcG9zID0gdHIuc2VsZWN0aW9uLiRhbmNob3I7XG4gICAgZm9yIChsZXQgZGVwdGggPSAkcG9zLmRlcHRoOyBkZXB0aCA+IDA7IGRlcHRoIC09IDEpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9ICRwb3Mubm9kZShkZXB0aCk7XG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IGN1cnJlbnROb2RlLnR5cGUpIHtcbiAgICAgICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZyb20gPSAkcG9zLmJlZm9yZShkZXB0aCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdG8gPSAkcG9zLmFmdGVyKGRlcHRoKTtcbiAgICAgICAgICAgICAgICB0ci5kZWxldGUoZnJvbSwgdG8pLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5jb25zdCBkZWxldGVOb2RlID0gdHlwZU9yTmFtZSA9PiAoeyB0ciwgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgICBjb25zdCAkcG9zID0gdHIuc2VsZWN0aW9uLiRhbmNob3I7XG4gICAgZm9yIChsZXQgZGVwdGggPSAkcG9zLmRlcHRoOyBkZXB0aCA+IDA7IGRlcHRoIC09IDEpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9ICRwb3Mubm9kZShkZXB0aCk7XG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09IHR5cGUpIHtcbiAgICAgICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZyb20gPSAkcG9zLmJlZm9yZShkZXB0aCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdG8gPSAkcG9zLmFmdGVyKGRlcHRoKTtcbiAgICAgICAgICAgICAgICB0ci5kZWxldGUoZnJvbSwgdG8pLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5jb25zdCBkZWxldGVSYW5nZSA9IHJhbmdlID0+ICh7IHRyLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgY29uc3QgeyBmcm9tLCB0byB9ID0gcmFuZ2U7XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIHRyLmRlbGV0ZShmcm9tLCB0byk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuY29uc3QgZGVsZXRlU2VsZWN0aW9uID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICByZXR1cm4gZGVsZXRlU2VsZWN0aW9uJDEoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbmNvbnN0IGVudGVyID0gKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgIHJldHVybiBjb21tYW5kcy5rZXlib2FyZFNob3J0Y3V0KCdFbnRlcicpO1xufTtcblxuY29uc3QgZXhpdENvZGUgPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIHJldHVybiBleGl0Q29kZSQxKHN0YXRlLCBkaXNwYXRjaCk7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIG9iamVjdDEgaW5jbHVkZXMgb2JqZWN0MlxuICogQHBhcmFtIG9iamVjdDEgT2JqZWN0XG4gKiBAcGFyYW0gb2JqZWN0MiBPYmplY3RcbiAqL1xuZnVuY3Rpb24gb2JqZWN0SW5jbHVkZXMob2JqZWN0MSwgb2JqZWN0Miwgb3B0aW9ucyA9IHsgc3RyaWN0OiB0cnVlIH0pIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0Mik7XG4gICAgaWYgKCFrZXlzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGtleXMuZXZlcnkoa2V5ID0+IHtcbiAgICAgICAgaWYgKG9wdGlvbnMuc3RyaWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0MltrZXldID09PSBvYmplY3QxW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUmVnRXhwKG9iamVjdDJba2V5XSkpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3QyW2tleV0udGVzdChvYmplY3QxW2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3QyW2tleV0gPT09IG9iamVjdDFba2V5XTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gZmluZE1hcmtJblNldChtYXJrcywgdHlwZSwgYXR0cmlidXRlcyA9IHt9KSB7XG4gICAgcmV0dXJuIG1hcmtzLmZpbmQoaXRlbSA9PiB7XG4gICAgICAgIHJldHVybiAoaXRlbS50eXBlID09PSB0eXBlXG4gICAgICAgICAgICAmJiBvYmplY3RJbmNsdWRlcyhcbiAgICAgICAgICAgIC8vIE9ubHkgY2hlY2sgZXF1YWxpdHkgZm9yIHRoZSBhdHRyaWJ1dGVzIHRoYXQgYXJlIHByb3ZpZGVkXG4gICAgICAgICAgICBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmtleXMoYXR0cmlidXRlcykubWFwKGsgPT4gW2ssIGl0ZW0uYXR0cnNba11dKSksIGF0dHJpYnV0ZXMpKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGlzTWFya0luU2V0KG1hcmtzLCB0eXBlLCBhdHRyaWJ1dGVzID0ge30pIHtcbiAgICByZXR1cm4gISFmaW5kTWFya0luU2V0KG1hcmtzLCB0eXBlLCBhdHRyaWJ1dGVzKTtcbn1cbi8qKlxuICogR2V0IHRoZSByYW5nZSBvZiBhIG1hcmsgYXQgYSByZXNvbHZlZCBwb3NpdGlvbi5cbiAqL1xuZnVuY3Rpb24gZ2V0TWFya1JhbmdlKFxuLyoqXG4gKiBUaGUgcG9zaXRpb24gdG8gZ2V0IHRoZSBtYXJrIHJhbmdlIGZvci5cbiAqL1xuJHBvcywgXG4vKipcbiAqIFRoZSBtYXJrIHR5cGUgdG8gZ2V0IHRoZSByYW5nZSBmb3IuXG4gKi9cbnR5cGUsIFxuLyoqXG4gKiBUaGUgYXR0cmlidXRlcyB0byBtYXRjaCBhZ2FpbnN0LlxuICogSWYgbm90IHByb3ZpZGVkLCBvbmx5IHRoZSBmaXJzdCBtYXJrIGF0IHRoZSBwb3NpdGlvbiB3aWxsIGJlIG1hdGNoZWQuXG4gKi9cbmF0dHJpYnV0ZXMpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCEkcG9zIHx8ICF0eXBlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHN0YXJ0ID0gJHBvcy5wYXJlbnQuY2hpbGRBZnRlcigkcG9zLnBhcmVudE9mZnNldCk7XG4gICAgLy8gSWYgdGhlIGN1cnNvciBpcyBhdCB0aGUgc3RhcnQgb2YgYSB0ZXh0IG5vZGUgdGhhdCBkb2VzIG5vdCBoYXZlIHRoZSBtYXJrLCBsb29rIGJhY2t3YXJkXG4gICAgaWYgKCFzdGFydC5ub2RlIHx8ICFzdGFydC5ub2RlLm1hcmtzLnNvbWUobWFyayA9PiBtYXJrLnR5cGUgPT09IHR5cGUpKSB7XG4gICAgICAgIHN0YXJ0ID0gJHBvcy5wYXJlbnQuY2hpbGRCZWZvcmUoJHBvcy5wYXJlbnRPZmZzZXQpO1xuICAgIH1cbiAgICAvLyBJZiB0aGVyZSBpcyBubyB0ZXh0IG5vZGUgd2l0aCB0aGUgbWFyayBldmVuIGJhY2t3YXJkLCByZXR1cm4gdW5kZWZpbmVkXG4gICAgaWYgKCFzdGFydC5ub2RlIHx8ICFzdGFydC5ub2RlLm1hcmtzLnNvbWUobWFyayA9PiBtYXJrLnR5cGUgPT09IHR5cGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gRGVmYXVsdCB0byBvbmx5IG1hdGNoaW5nIGFnYWluc3QgdGhlIGZpcnN0IG1hcmsncyBhdHRyaWJ1dGVzXG4gICAgYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMgfHwgKChfYSA9IHN0YXJ0Lm5vZGUubWFya3NbMF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hdHRycyk7XG4gICAgLy8gV2Ugbm93IGtub3cgdGhhdCB0aGUgY3Vyc29yIGlzIGVpdGhlciBhdCB0aGUgc3RhcnQsIG1pZGRsZSBvciBlbmQgb2YgYSB0ZXh0IG5vZGUgd2l0aCB0aGUgc3BlY2lmaWVkIG1hcmtcbiAgICAvLyBzbyB3ZSBjYW4gbG9vayBpdCB1cCBvbiB0aGUgdGFyZ2V0ZWQgbWFya1xuICAgIGNvbnN0IG1hcmsgPSBmaW5kTWFya0luU2V0KFsuLi5zdGFydC5ub2RlLm1hcmtzXSwgdHlwZSwgYXR0cmlidXRlcyk7XG4gICAgaWYgKCFtYXJrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHN0YXJ0SW5kZXggPSBzdGFydC5pbmRleDtcbiAgICBsZXQgc3RhcnRQb3MgPSAkcG9zLnN0YXJ0KCkgKyBzdGFydC5vZmZzZXQ7XG4gICAgbGV0IGVuZEluZGV4ID0gc3RhcnRJbmRleCArIDE7XG4gICAgbGV0IGVuZFBvcyA9IHN0YXJ0UG9zICsgc3RhcnQubm9kZS5ub2RlU2l6ZTtcbiAgICB3aGlsZSAoc3RhcnRJbmRleCA+IDBcbiAgICAgICAgJiYgaXNNYXJrSW5TZXQoWy4uLiRwb3MucGFyZW50LmNoaWxkKHN0YXJ0SW5kZXggLSAxKS5tYXJrc10sIHR5cGUsIGF0dHJpYnV0ZXMpKSB7XG4gICAgICAgIHN0YXJ0SW5kZXggLT0gMTtcbiAgICAgICAgc3RhcnRQb3MgLT0gJHBvcy5wYXJlbnQuY2hpbGQoc3RhcnRJbmRleCkubm9kZVNpemU7XG4gICAgfVxuICAgIHdoaWxlIChlbmRJbmRleCA8ICRwb3MucGFyZW50LmNoaWxkQ291bnRcbiAgICAgICAgJiYgaXNNYXJrSW5TZXQoWy4uLiRwb3MucGFyZW50LmNoaWxkKGVuZEluZGV4KS5tYXJrc10sIHR5cGUsIGF0dHJpYnV0ZXMpKSB7XG4gICAgICAgIGVuZFBvcyArPSAkcG9zLnBhcmVudC5jaGlsZChlbmRJbmRleCkubm9kZVNpemU7XG4gICAgICAgIGVuZEluZGV4ICs9IDE7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGZyb206IHN0YXJ0UG9zLFxuICAgICAgICB0bzogZW5kUG9zLFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGdldE1hcmtUeXBlKG5hbWVPclR5cGUsIHNjaGVtYSkge1xuICAgIGlmICh0eXBlb2YgbmFtZU9yVHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKCFzY2hlbWEubWFya3NbbmFtZU9yVHlwZV0pIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBUaGVyZSBpcyBubyBtYXJrIHR5cGUgbmFtZWQgJyR7bmFtZU9yVHlwZX0nLiBNYXliZSB5b3UgZm9yZ290IHRvIGFkZCB0aGUgZXh0ZW5zaW9uP2ApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzY2hlbWEubWFya3NbbmFtZU9yVHlwZV07XG4gICAgfVxuICAgIHJldHVybiBuYW1lT3JUeXBlO1xufVxuXG5jb25zdCBleHRlbmRNYXJrUmFuZ2UgPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyB0ciwgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBjb25zdCB0eXBlID0gZ2V0TWFya1R5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgICBjb25zdCB7IGRvYywgc2VsZWN0aW9uIH0gPSB0cjtcbiAgICBjb25zdCB7ICRmcm9tLCBmcm9tLCB0byB9ID0gc2VsZWN0aW9uO1xuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICBjb25zdCByYW5nZSA9IGdldE1hcmtSYW5nZSgkZnJvbSwgdHlwZSwgYXR0cmlidXRlcyk7XG4gICAgICAgIGlmIChyYW5nZSAmJiByYW5nZS5mcm9tIDw9IGZyb20gJiYgcmFuZ2UudG8gPj0gdG8pIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1NlbGVjdGlvbiA9IFRleHRTZWxlY3Rpb24uY3JlYXRlKGRvYywgcmFuZ2UuZnJvbSwgcmFuZ2UudG8pO1xuICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKG5ld1NlbGVjdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCBmaXJzdCA9IGNvbW1hbmRzID0+IHByb3BzID0+IHtcbiAgICBjb25zdCBpdGVtcyA9IHR5cGVvZiBjb21tYW5kcyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IGNvbW1hbmRzKHByb3BzKVxuICAgICAgICA6IGNvbW1hbmRzO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGl0ZW1zW2ldKHByb3BzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuZnVuY3Rpb24gaXNUZXh0U2VsZWN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbjtcbn1cblxuZnVuY3Rpb24gbWluTWF4KHZhbHVlID0gMCwgbWluID0gMCwgbWF4ID0gMCkge1xuICAgIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh2YWx1ZSwgbWluKSwgbWF4KTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUZvY3VzUG9zaXRpb24oZG9jLCBwb3NpdGlvbiA9IG51bGwpIHtcbiAgICBpZiAoIXBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzZWxlY3Rpb25BdFN0YXJ0ID0gU2VsZWN0aW9uLmF0U3RhcnQoZG9jKTtcbiAgICBjb25zdCBzZWxlY3Rpb25BdEVuZCA9IFNlbGVjdGlvbi5hdEVuZChkb2MpO1xuICAgIGlmIChwb3NpdGlvbiA9PT0gJ3N0YXJ0JyB8fCBwb3NpdGlvbiA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gc2VsZWN0aW9uQXRTdGFydDtcbiAgICB9XG4gICAgaWYgKHBvc2l0aW9uID09PSAnZW5kJykge1xuICAgICAgICByZXR1cm4gc2VsZWN0aW9uQXRFbmQ7XG4gICAgfVxuICAgIGNvbnN0IG1pblBvcyA9IHNlbGVjdGlvbkF0U3RhcnQuZnJvbTtcbiAgICBjb25zdCBtYXhQb3MgPSBzZWxlY3Rpb25BdEVuZC50bztcbiAgICBpZiAocG9zaXRpb24gPT09ICdhbGwnKSB7XG4gICAgICAgIHJldHVybiBUZXh0U2VsZWN0aW9uLmNyZWF0ZShkb2MsIG1pbk1heCgwLCBtaW5Qb3MsIG1heFBvcyksIG1pbk1heChkb2MuY29udGVudC5zaXplLCBtaW5Qb3MsIG1heFBvcykpO1xuICAgIH1cbiAgICByZXR1cm4gVGV4dFNlbGVjdGlvbi5jcmVhdGUoZG9jLCBtaW5NYXgocG9zaXRpb24sIG1pblBvcywgbWF4UG9zKSwgbWluTWF4KHBvc2l0aW9uLCBtaW5Qb3MsIG1heFBvcykpO1xufVxuXG5mdW5jdGlvbiBpc0FuZHJvaWQoKSB7XG4gICAgcmV0dXJuIG5hdmlnYXRvci5wbGF0Zm9ybSA9PT0gJ0FuZHJvaWQnIHx8IC9hbmRyb2lkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbn1cblxuZnVuY3Rpb24gaXNpT1MoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgJ2lQYWQgU2ltdWxhdG9yJyxcbiAgICAgICAgJ2lQaG9uZSBTaW11bGF0b3InLFxuICAgICAgICAnaVBvZCBTaW11bGF0b3InLFxuICAgICAgICAnaVBhZCcsXG4gICAgICAgICdpUGhvbmUnLFxuICAgICAgICAnaVBvZCcsXG4gICAgXS5pbmNsdWRlcyhuYXZpZ2F0b3IucGxhdGZvcm0pXG4gICAgICAgIC8vIGlQYWQgb24gaU9TIDEzIGRldGVjdGlvblxuICAgICAgICB8fCAobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmNsdWRlcygnTWFjJykgJiYgJ29udG91Y2hlbmQnIGluIGRvY3VtZW50KTtcbn1cblxuY29uc3QgZm9jdXMgPSAocG9zaXRpb24gPSBudWxsLCBvcHRpb25zID0ge30pID0+ICh7IGVkaXRvciwgdmlldywgdHIsIGRpc3BhdGNoLCB9KSA9PiB7XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgICAgc2Nyb2xsSW50b1ZpZXc6IHRydWUsXG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgfTtcbiAgICBjb25zdCBkZWxheWVkRm9jdXMgPSAoKSA9PiB7XG4gICAgICAgIC8vIGZvY3VzIHdpdGhpbiBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCBicmVha3MgZm9jdXMgb24gaU9TIGFuZCBBbmRyb2lkXG4gICAgICAgIC8vIHNvIHdlIGhhdmUgdG8gY2FsbCB0aGlzXG4gICAgICAgIGlmIChpc2lPUygpIHx8IGlzQW5kcm9pZCgpKSB7XG4gICAgICAgICAgICB2aWV3LmRvbS5mb2N1cygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZvciBSZWFjdCB3ZSBoYXZlIHRvIGZvY3VzIGFzeW5jaHJvbm91c2x5LiBPdGhlcndpc2Ugd2lsZCB0aGluZ3MgaGFwcGVuLlxuICAgICAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS91ZWJlcmRvc2lzL3RpcHRhcC9pc3N1ZXMvMTUyMFxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFlZGl0b3IuaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zY3JvbGxJbnRvVmlldykge1xuICAgICAgICAgICAgICAgICAgICBlZGl0b3IuY29tbWFuZHMuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgaWYgKCh2aWV3Lmhhc0ZvY3VzKCkgJiYgcG9zaXRpb24gPT09IG51bGwpIHx8IHBvc2l0aW9uID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gd2UgZG9u4oCZdCB0cnkgdG8gcmVzb2x2ZSBhIE5vZGVTZWxlY3Rpb24gb3IgQ2VsbFNlbGVjdGlvblxuICAgIGlmIChkaXNwYXRjaCAmJiBwb3NpdGlvbiA9PT0gbnVsbCAmJiAhaXNUZXh0U2VsZWN0aW9uKGVkaXRvci5zdGF0ZS5zZWxlY3Rpb24pKSB7XG4gICAgICAgIGRlbGF5ZWRGb2N1cygpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gcGFzcyB0aHJvdWdoIHRyLmRvYyBpbnN0ZWFkIG9mIGVkaXRvci5zdGF0ZS5kb2NcbiAgICAvLyBzaW5jZSB0cmFuc2FjdGlvbnMgY291bGQgY2hhbmdlIHRoZSBlZGl0b3JzIHN0YXRlIGJlZm9yZSB0aGlzIGNvbW1hbmQgaGFzIGJlZW4gcnVuXG4gICAgY29uc3Qgc2VsZWN0aW9uID0gcmVzb2x2ZUZvY3VzUG9zaXRpb24odHIuZG9jLCBwb3NpdGlvbikgfHwgZWRpdG9yLnN0YXRlLnNlbGVjdGlvbjtcbiAgICBjb25zdCBpc1NhbWVTZWxlY3Rpb24gPSBlZGl0b3Iuc3RhdGUuc2VsZWN0aW9uLmVxKHNlbGVjdGlvbik7XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIGlmICghaXNTYW1lU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBgdHIuc2V0U2VsZWN0aW9uYCByZXNldHMgdGhlIHN0b3JlZCBtYXJrc1xuICAgICAgICAvLyBzbyB3ZeKAmWxsIHJlc3RvcmUgdGhlbSBpZiB0aGUgc2VsZWN0aW9uIGlzIHRoZSBzYW1lIGFzIGJlZm9yZVxuICAgICAgICBpZiAoaXNTYW1lU2VsZWN0aW9uICYmIHRyLnN0b3JlZE1hcmtzKSB7XG4gICAgICAgICAgICB0ci5zZXRTdG9yZWRNYXJrcyh0ci5zdG9yZWRNYXJrcyk7XG4gICAgICAgIH1cbiAgICAgICAgZGVsYXllZEZvY3VzKCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuY29uc3QgZm9yRWFjaCA9IChpdGVtcywgZm4pID0+IHByb3BzID0+IHtcbiAgICByZXR1cm4gaXRlbXMuZXZlcnkoKGl0ZW0sIGluZGV4KSA9PiBmbihpdGVtLCB7IC4uLnByb3BzLCBpbmRleCB9KSk7XG59O1xuXG5jb25zdCBpbnNlcnRDb250ZW50ID0gKHZhbHVlLCBvcHRpb25zKSA9PiAoeyB0ciwgY29tbWFuZHMgfSkgPT4ge1xuICAgIHJldHVybiBjb21tYW5kcy5pbnNlcnRDb250ZW50QXQoeyBmcm9tOiB0ci5zZWxlY3Rpb24uZnJvbSwgdG86IHRyLnNlbGVjdGlvbi50byB9LCB2YWx1ZSwgb3B0aW9ucyk7XG59O1xuXG5jb25zdCByZW1vdmVXaGl0ZXNwYWNlcyA9IChub2RlKSA9PiB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmNoaWxkTm9kZXM7XG4gICAgZm9yIChsZXQgaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgIGNvbnN0IGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gMyAmJiBjaGlsZC5ub2RlVmFsdWUgJiYgL14oXFxuXFxzXFxzfFxcbikkLy50ZXN0KGNoaWxkLm5vZGVWYWx1ZSkpIHtcbiAgICAgICAgICAgIG5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoaWxkLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgICByZW1vdmVXaGl0ZXNwYWNlcyhjaGlsZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG59O1xuZnVuY3Rpb24gZWxlbWVudEZyb21TdHJpbmcodmFsdWUpIHtcbiAgICAvLyBhZGQgYSB3cmFwcGVyIHRvIHByZXNlcnZlIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2VcbiAgICBjb25zdCB3cmFwcGVkVmFsdWUgPSBgPGJvZHk+JHt2YWx1ZX08L2JvZHk+YDtcbiAgICBjb25zdCBodG1sID0gbmV3IHdpbmRvdy5ET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcod3JhcHBlZFZhbHVlLCAndGV4dC9odG1sJykuYm9keTtcbiAgICByZXR1cm4gcmVtb3ZlV2hpdGVzcGFjZXMoaHRtbCk7XG59XG5cbi8qKlxuICogVGFrZXMgYSBKU09OIG9yIEhUTUwgY29udGVudCBhbmQgY3JlYXRlcyBhIFByb3NlbWlycm9yIG5vZGUgb3IgZnJhZ21lbnQgZnJvbSBpdC5cbiAqIEBwYXJhbSBjb250ZW50IFRoZSBKU09OIG9yIEhUTUwgY29udGVudCB0byBjcmVhdGUgdGhlIG5vZGUgZnJvbVxuICogQHBhcmFtIHNjaGVtYSBUaGUgUHJvc2VtaXJyb3Igc2NoZW1hIHRvIHVzZSBmb3IgdGhlIG5vZGVcbiAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgZm9yIHRoZSBwYXJzZXJcbiAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIFByb3NlbWlycm9yIG5vZGUgb3IgZnJhZ21lbnRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTm9kZUZyb21Db250ZW50KGNvbnRlbnQsIHNjaGVtYSwgb3B0aW9ucykge1xuICAgIGlmIChjb250ZW50IGluc3RhbmNlb2YgTm9kZSQxIHx8IGNvbnRlbnQgaW5zdGFuY2VvZiBGcmFnbWVudCkge1xuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICB9XG4gICAgb3B0aW9ucyA9IHtcbiAgICAgICAgc2xpY2U6IHRydWUsXG4gICAgICAgIHBhcnNlT3B0aW9uczoge30sXG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgfTtcbiAgICBjb25zdCBpc0pTT05Db250ZW50ID0gdHlwZW9mIGNvbnRlbnQgPT09ICdvYmplY3QnICYmIGNvbnRlbnQgIT09IG51bGw7XG4gICAgY29uc3QgaXNUZXh0Q29udGVudCA9IHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJztcbiAgICBpZiAoaXNKU09OQ29udGVudCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgaXNBcnJheUNvbnRlbnQgPSBBcnJheS5pc0FycmF5KGNvbnRlbnQpICYmIGNvbnRlbnQubGVuZ3RoID4gMDtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBKU09OIENvbnRlbnQgaXMgYW4gYXJyYXkgb2Ygbm9kZXMsIGNyZWF0ZSBhIGZyYWdtZW50IGZvciBlYWNoIG5vZGVcbiAgICAgICAgICAgIGlmIChpc0FycmF5Q29udGVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBGcmFnbWVudC5mcm9tQXJyYXkoY29udGVudC5tYXAoaXRlbSA9PiBzY2hlbWEubm9kZUZyb21KU09OKGl0ZW0pKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBub2RlID0gc2NoZW1hLm5vZGVGcm9tSlNPTihjb250ZW50KTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmVycm9yT25JbnZhbGlkQ29udGVudCkge1xuICAgICAgICAgICAgICAgIG5vZGUuY2hlY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZXJyb3JPbkludmFsaWRDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbdGlwdGFwIGVycm9yXTogSW52YWxpZCBKU09OIGNvbnRlbnQnLCB7IGNhdXNlOiBlcnJvciB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUud2FybignW3RpcHRhcCB3YXJuXTogSW52YWxpZCBjb250ZW50LicsICdQYXNzZWQgdmFsdWU6JywgY29udGVudCwgJ0Vycm9yOicsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVOb2RlRnJvbUNvbnRlbnQoJycsIHNjaGVtYSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzVGV4dENvbnRlbnQpIHtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGludmFsaWQgY29udGVudFxuICAgICAgICBpZiAob3B0aW9ucy5lcnJvck9uSW52YWxpZENvbnRlbnQpIHtcbiAgICAgICAgICAgIGxldCBoYXNJbnZhbGlkQ29udGVudCA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGludmFsaWRDb250ZW50ID0gJyc7XG4gICAgICAgICAgICAvLyBBIGNvcHkgb2YgdGhlIGN1cnJlbnQgc2NoZW1hIHdpdGggYSBjYXRjaC1hbGwgbm9kZSBhdCB0aGUgZW5kXG4gICAgICAgICAgICBjb25zdCBjb250ZW50Q2hlY2tTY2hlbWEgPSBuZXcgU2NoZW1hKHtcbiAgICAgICAgICAgICAgICB0b3BOb2RlOiBzY2hlbWEuc3BlYy50b3BOb2RlLFxuICAgICAgICAgICAgICAgIG1hcmtzOiBzY2hlbWEuc3BlYy5tYXJrcyxcbiAgICAgICAgICAgICAgICAvLyBQcm9zZW1pcnJvcidzIHNjaGVtYXMgYXJlIGV4ZWN1dGVkIHN1Y2ggdGhhdDogdGhlIGxhc3QgdG8gZXhlY3V0ZSwgbWF0Y2hlcyBsYXN0XG4gICAgICAgICAgICAgICAgLy8gVGhpcyBtZWFucyB0aGF0IHdlIGNhbiBhZGQgYSBjYXRjaC1hbGwgbm9kZSBhdCB0aGUgZW5kIG9mIHRoZSBzY2hlbWEgdG8gY2F0Y2ggYW55IGNvbnRlbnQgdGhhdCB3ZSBkb24ndCBrbm93IGhvdyB0byBoYW5kbGVcbiAgICAgICAgICAgICAgICBub2Rlczogc2NoZW1hLnNwZWMubm9kZXMuYXBwZW5kKHtcbiAgICAgICAgICAgICAgICAgICAgX190aXB0YXBfX3ByaXZhdGVfX3Vua25vd25fX2NhdGNoX19hbGxfX25vZGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6ICdpbmxpbmUqJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwOiAnYmxvY2snLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VET006IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZzogJyonLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRBdHRyczogZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGV2ZXIgY2FsbGVkLCB3ZSBrbm93IHRoYXQgdGhlIGNvbnRlbnQgaGFzIHNvbWV0aGluZyB0aGF0IHdlIGRvbid0IGtub3cgaG93IHRvIGhhbmRsZSBpbiB0aGUgc2NoZW1hXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNJbnZhbGlkQ29udGVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUcnkgdG8gc3RyaW5naWZ5IHRoZSBlbGVtZW50IGZvciBhIG1vcmUgaGVscGZ1bCBlcnJvciBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnZhbGlkQ29udGVudCA9IHR5cGVvZiBlID09PSAnc3RyaW5nJyA/IGUgOiBlLm91dGVySFRNTDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zbGljZSkge1xuICAgICAgICAgICAgICAgIERPTVBhcnNlci5mcm9tU2NoZW1hKGNvbnRlbnRDaGVja1NjaGVtYSkucGFyc2VTbGljZShlbGVtZW50RnJvbVN0cmluZyhjb250ZW50KSwgb3B0aW9ucy5wYXJzZU9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgRE9NUGFyc2VyLmZyb21TY2hlbWEoY29udGVudENoZWNrU2NoZW1hKS5wYXJzZShlbGVtZW50RnJvbVN0cmluZyhjb250ZW50KSwgb3B0aW9ucy5wYXJzZU9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZXJyb3JPbkludmFsaWRDb250ZW50ICYmIGhhc0ludmFsaWRDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbdGlwdGFwIGVycm9yXTogSW52YWxpZCBIVE1MIGNvbnRlbnQnLCB7IGNhdXNlOiBuZXcgRXJyb3IoYEludmFsaWQgZWxlbWVudCBmb3VuZDogJHtpbnZhbGlkQ29udGVudH1gKSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZXIgPSBET01QYXJzZXIuZnJvbVNjaGVtYShzY2hlbWEpO1xuICAgICAgICBpZiAob3B0aW9ucy5zbGljZSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlci5wYXJzZVNsaWNlKGVsZW1lbnRGcm9tU3RyaW5nKGNvbnRlbnQpLCBvcHRpb25zLnBhcnNlT3B0aW9ucykuY29udGVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VyLnBhcnNlKGVsZW1lbnRGcm9tU3RyaW5nKGNvbnRlbnQpLCBvcHRpb25zLnBhcnNlT3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVOb2RlRnJvbUNvbnRlbnQoJycsIHNjaGVtYSwgb3B0aW9ucyk7XG59XG5cbi8vIHNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL1Byb3NlTWlycm9yL3Byb3NlbWlycm9yLXN0YXRlL2Jsb2IvbWFzdGVyL3NyYy9zZWxlY3Rpb24uanMjTDQ2NlxuZnVuY3Rpb24gc2VsZWN0aW9uVG9JbnNlcnRpb25FbmQodHIsIHN0YXJ0TGVuLCBiaWFzKSB7XG4gICAgY29uc3QgbGFzdCA9IHRyLnN0ZXBzLmxlbmd0aCAtIDE7XG4gICAgaWYgKGxhc3QgPCBzdGFydExlbikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0ZXAgPSB0ci5zdGVwc1tsYXN0XTtcbiAgICBpZiAoIShzdGVwIGluc3RhbmNlb2YgUmVwbGFjZVN0ZXAgfHwgc3RlcCBpbnN0YW5jZW9mIFJlcGxhY2VBcm91bmRTdGVwKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1hcCA9IHRyLm1hcHBpbmcubWFwc1tsYXN0XTtcbiAgICBsZXQgZW5kID0gMDtcbiAgICBtYXAuZm9yRWFjaCgoX2Zyb20sIF90bywgX25ld0Zyb20sIG5ld1RvKSA9PiB7XG4gICAgICAgIGlmIChlbmQgPT09IDApIHtcbiAgICAgICAgICAgIGVuZCA9IG5ld1RvO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgdHIuc2V0U2VsZWN0aW9uKFNlbGVjdGlvbi5uZWFyKHRyLmRvYy5yZXNvbHZlKGVuZCksIGJpYXMpKTtcbn1cblxuY29uc3QgaXNGcmFnbWVudCA9IChub2RlT3JGcmFnbWVudCkgPT4ge1xuICAgIHJldHVybiAhKCd0eXBlJyBpbiBub2RlT3JGcmFnbWVudCk7XG59O1xuY29uc3QgaW5zZXJ0Q29udGVudEF0ID0gKHBvc2l0aW9uLCB2YWx1ZSwgb3B0aW9ucykgPT4gKHsgdHIsIGRpc3BhdGNoLCBlZGl0b3IgfSkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHBhcnNlT3B0aW9uczogZWRpdG9yLm9wdGlvbnMucGFyc2VPcHRpb25zLFxuICAgICAgICAgICAgdXBkYXRlU2VsZWN0aW9uOiB0cnVlLFxuICAgICAgICAgICAgYXBwbHlJbnB1dFJ1bGVzOiBmYWxzZSxcbiAgICAgICAgICAgIGFwcGx5UGFzdGVSdWxlczogZmFsc2UsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgY29udGVudDtcbiAgICAgICAgY29uc3QgZW1pdENvbnRlbnRFcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgZWRpdG9yLmVtaXQoJ2NvbnRlbnRFcnJvcicsIHtcbiAgICAgICAgICAgICAgICBlZGl0b3IsXG4gICAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgICAgZGlzYWJsZUNvbGxhYm9yYXRpb246ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVkaXRvci5zdG9yYWdlLmNvbGxhYm9yYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5zdG9yYWdlLmNvbGxhYm9yYXRpb24uaXNEaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHBhcnNlT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHByZXNlcnZlV2hpdGVzcGFjZTogJ2Z1bGwnLFxuICAgICAgICAgICAgLi4ub3B0aW9ucy5wYXJzZU9wdGlvbnMsXG4gICAgICAgIH07XG4gICAgICAgIC8vIElmIGBlbWl0Q29udGVudEVycm9yYCBpcyBlbmFibGVkLCB3ZSB3YW50IHRvIGNoZWNrIHRoZSBjb250ZW50IGZvciBlcnJvcnNcbiAgICAgICAgLy8gYnV0IGlnbm9yZSB0aGVtIChkbyBub3QgcmVtb3ZlIHRoZSBpbnZhbGlkIGNvbnRlbnQgZnJvbSB0aGUgZG9jdW1lbnQpXG4gICAgICAgIGlmICghb3B0aW9ucy5lcnJvck9uSW52YWxpZENvbnRlbnQgJiYgIWVkaXRvci5vcHRpb25zLmVuYWJsZUNvbnRlbnRDaGVjayAmJiBlZGl0b3Iub3B0aW9ucy5lbWl0Q29udGVudEVycm9yKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNyZWF0ZU5vZGVGcm9tQ29udGVudCh2YWx1ZSwgZWRpdG9yLnNjaGVtYSwge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZU9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yT25JbnZhbGlkQ29udGVudDogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgZW1pdENvbnRlbnRFcnJvcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29udGVudCA9IGNyZWF0ZU5vZGVGcm9tQ29udGVudCh2YWx1ZSwgZWRpdG9yLnNjaGVtYSwge1xuICAgICAgICAgICAgICAgIHBhcnNlT3B0aW9ucyxcbiAgICAgICAgICAgICAgICBlcnJvck9uSW52YWxpZENvbnRlbnQ6IChfYSA9IG9wdGlvbnMuZXJyb3JPbkludmFsaWRDb250ZW50KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBlZGl0b3Iub3B0aW9ucy5lbmFibGVDb250ZW50Q2hlY2ssXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZW1pdENvbnRlbnRFcnJvcihlKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gdHlwZW9mIHBvc2l0aW9uID09PSAnbnVtYmVyJyA/IHsgZnJvbTogcG9zaXRpb24sIHRvOiBwb3NpdGlvbiB9IDogeyBmcm9tOiBwb3NpdGlvbi5mcm9tLCB0bzogcG9zaXRpb24udG8gfTtcbiAgICAgICAgbGV0IGlzT25seVRleHRDb250ZW50ID0gdHJ1ZTtcbiAgICAgICAgbGV0IGlzT25seUJsb2NrQ29udGVudCA9IHRydWU7XG4gICAgICAgIGNvbnN0IG5vZGVzID0gaXNGcmFnbWVudChjb250ZW50KSA/IGNvbnRlbnQgOiBbY29udGVudF07XG4gICAgICAgIG5vZGVzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgICAvLyBjaGVjayBpZiBhZGRlZCBub2RlIGlzIHZhbGlkXG4gICAgICAgICAgICBub2RlLmNoZWNrKCk7XG4gICAgICAgICAgICBpc09ubHlUZXh0Q29udGVudCA9IGlzT25seVRleHRDb250ZW50ID8gbm9kZS5pc1RleHQgJiYgbm9kZS5tYXJrcy5sZW5ndGggPT09IDAgOiBmYWxzZTtcbiAgICAgICAgICAgIGlzT25seUJsb2NrQ29udGVudCA9IGlzT25seUJsb2NrQ29udGVudCA/IG5vZGUuaXNCbG9jayA6IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gY2hlY2sgaWYgd2UgY2FuIHJlcGxhY2UgdGhlIHdyYXBwaW5nIG5vZGUgYnlcbiAgICAgICAgLy8gdGhlIG5ld2x5IGluc2VydGVkIGNvbnRlbnRcbiAgICAgICAgLy8gZXhhbXBsZTpcbiAgICAgICAgLy8gcmVwbGFjZSBhbiBlbXB0eSBwYXJhZ3JhcGggYnkgYW4gaW5zZXJ0ZWQgaW1hZ2VcbiAgICAgICAgLy8gaW5zdGVhZCBvZiBpbnNlcnRpbmcgdGhlIGltYWdlIGJlbG93IHRoZSBwYXJhZ3JhcGhcbiAgICAgICAgaWYgKGZyb20gPT09IHRvICYmIGlzT25seUJsb2NrQ29udGVudCkge1xuICAgICAgICAgICAgY29uc3QgeyBwYXJlbnQgfSA9IHRyLmRvYy5yZXNvbHZlKGZyb20pO1xuICAgICAgICAgICAgY29uc3QgaXNFbXB0eVRleHRCbG9jayA9IHBhcmVudC5pc1RleHRibG9jayAmJiAhcGFyZW50LnR5cGUuc3BlYy5jb2RlICYmICFwYXJlbnQuY2hpbGRDb3VudDtcbiAgICAgICAgICAgIGlmIChpc0VtcHR5VGV4dEJsb2NrKSB7XG4gICAgICAgICAgICAgICAgZnJvbSAtPSAxO1xuICAgICAgICAgICAgICAgIHRvICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld0NvbnRlbnQ7XG4gICAgICAgIC8vIGlmIHRoZXJlIGlzIG9ubHkgcGxhaW4gdGV4dCB3ZSBoYXZlIHRvIHVzZSBgaW5zZXJ0VGV4dGBcbiAgICAgICAgLy8gYmVjYXVzZSB0aGlzIHdpbGwga2VlcCB0aGUgY3VycmVudCBtYXJrc1xuICAgICAgICBpZiAoaXNPbmx5VGV4dENvbnRlbnQpIHtcbiAgICAgICAgICAgIC8vIGlmIHZhbHVlIGlzIHN0cmluZywgd2UgY2FuIHVzZSBpdCBkaXJlY3RseVxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGlmIGl0IGlzIGFuIGFycmF5LCB3ZSBoYXZlIHRvIGpvaW4gaXRcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIG5ld0NvbnRlbnQgPSB2YWx1ZS5tYXAodiA9PiB2LnRleHQgfHwgJycpLmpvaW4oJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBGcmFnbWVudCkge1xuICAgICAgICAgICAgICAgIGxldCB0ZXh0ID0gJyc7XG4gICAgICAgICAgICAgICAgdmFsdWUuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUudGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCArPSBub2RlLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBuZXdDb250ZW50ID0gdGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgISF2YWx1ZSAmJiAhIXZhbHVlLnRleHQpIHtcbiAgICAgICAgICAgICAgICBuZXdDb250ZW50ID0gdmFsdWUudGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld0NvbnRlbnQgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyLmluc2VydFRleHQobmV3Q29udGVudCwgZnJvbSwgdG8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3Q29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgICAgICB0ci5yZXBsYWNlV2l0aChmcm9tLCB0bywgbmV3Q29udGVudCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IGN1cnNvciBhdCBlbmQgb2YgaW5zZXJ0ZWQgY29udGVudFxuICAgICAgICBpZiAob3B0aW9ucy51cGRhdGVTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHNlbGVjdGlvblRvSW5zZXJ0aW9uRW5kKHRyLCB0ci5zdGVwcy5sZW5ndGggLSAxLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuYXBwbHlJbnB1dFJ1bGVzKSB7XG4gICAgICAgICAgICB0ci5zZXRNZXRhKCdhcHBseUlucHV0UnVsZXMnLCB7IGZyb20sIHRleHQ6IG5ld0NvbnRlbnQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuYXBwbHlQYXN0ZVJ1bGVzKSB7XG4gICAgICAgICAgICB0ci5zZXRNZXRhKCdhcHBseVBhc3RlUnVsZXMnLCB7IGZyb20sIHRleHQ6IG5ld0NvbnRlbnQgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCBqb2luVXAgPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIHJldHVybiBqb2luVXAkMShzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcbmNvbnN0IGpvaW5Eb3duID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICByZXR1cm4gam9pbkRvd24kMShzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcbmNvbnN0IGpvaW5CYWNrd2FyZCA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgcmV0dXJuIGpvaW5CYWNrd2FyZCQxKHN0YXRlLCBkaXNwYXRjaCk7XG59O1xuY29uc3Qgam9pbkZvcndhcmQgPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIHJldHVybiBqb2luRm9yd2FyZCQxKHN0YXRlLCBkaXNwYXRjaCk7XG59O1xuXG5jb25zdCBqb2luSXRlbUJhY2t3YXJkID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoLCB0ciwgfSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHBvaW50ID0gam9pblBvaW50KHN0YXRlLmRvYywgc3RhdGUuc2VsZWN0aW9uLiRmcm9tLnBvcywgLTEpO1xuICAgICAgICBpZiAocG9pbnQgPT09IG51bGwgfHwgcG9pbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRyLmpvaW4ocG9pbnQsIDIpO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcblxuY29uc3Qgam9pbkl0ZW1Gb3J3YXJkID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoLCB0ciwgfSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHBvaW50ID0gam9pblBvaW50KHN0YXRlLmRvYywgc3RhdGUuc2VsZWN0aW9uLiRmcm9tLnBvcywgKzEpO1xuICAgICAgICBpZiAocG9pbnQgPT09IG51bGwgfHwgcG9pbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRyLmpvaW4ocG9pbnQsIDIpO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoKHRyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcblxuY29uc3Qgam9pblRleHRibG9ja0JhY2t3YXJkID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICByZXR1cm4gam9pblRleHRibG9ja0JhY2t3YXJkJDEoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbmNvbnN0IGpvaW5UZXh0YmxvY2tGb3J3YXJkID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICByZXR1cm4gam9pblRleHRibG9ja0ZvcndhcmQkMShzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcblxuZnVuY3Rpb24gaXNNYWNPUygpIHtcbiAgICByZXR1cm4gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyAvTWFjLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSlcbiAgICAgICAgOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplS2V5TmFtZShuYW1lKSB7XG4gICAgY29uc3QgcGFydHMgPSBuYW1lLnNwbGl0KC8tKD8hJCkvKTtcbiAgICBsZXQgcmVzdWx0ID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV07XG4gICAgaWYgKHJlc3VsdCA9PT0gJ1NwYWNlJykge1xuICAgICAgICByZXN1bHQgPSAnICc7XG4gICAgfVxuICAgIGxldCBhbHQ7XG4gICAgbGV0IGN0cmw7XG4gICAgbGV0IHNoaWZ0O1xuICAgIGxldCBtZXRhO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoIC0gMTsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IG1vZCA9IHBhcnRzW2ldO1xuICAgICAgICBpZiAoL14oY21kfG1ldGF8bSkkL2kudGVzdChtb2QpKSB7XG4gICAgICAgICAgICBtZXRhID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgvXmEobHQpPyQvaS50ZXN0KG1vZCkpIHtcbiAgICAgICAgICAgIGFsdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoL14oY3xjdHJsfGNvbnRyb2wpJC9pLnRlc3QobW9kKSkge1xuICAgICAgICAgICAgY3RybCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoL15zKGhpZnQpPyQvaS50ZXN0KG1vZCkpIHtcbiAgICAgICAgICAgIHNoaWZ0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgvXm1vZCQvaS50ZXN0KG1vZCkpIHtcbiAgICAgICAgICAgIGlmIChpc2lPUygpIHx8IGlzTWFjT1MoKSkge1xuICAgICAgICAgICAgICAgIG1ldGEgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3RybCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBtb2RpZmllciBuYW1lOiAke21vZH1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYWx0KSB7XG4gICAgICAgIHJlc3VsdCA9IGBBbHQtJHtyZXN1bHR9YDtcbiAgICB9XG4gICAgaWYgKGN0cmwpIHtcbiAgICAgICAgcmVzdWx0ID0gYEN0cmwtJHtyZXN1bHR9YDtcbiAgICB9XG4gICAgaWYgKG1ldGEpIHtcbiAgICAgICAgcmVzdWx0ID0gYE1ldGEtJHtyZXN1bHR9YDtcbiAgICB9XG4gICAgaWYgKHNoaWZ0KSB7XG4gICAgICAgIHJlc3VsdCA9IGBTaGlmdC0ke3Jlc3VsdH1gO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3Qga2V5Ym9hcmRTaG9ydGN1dCA9IG5hbWUgPT4gKHsgZWRpdG9yLCB2aWV3LCB0ciwgZGlzcGF0Y2gsIH0pID0+IHtcbiAgICBjb25zdCBrZXlzID0gbm9ybWFsaXplS2V5TmFtZShuYW1lKS5zcGxpdCgvLSg/ISQpLyk7XG4gICAgY29uc3Qga2V5ID0ga2V5cy5maW5kKGl0ZW0gPT4gIVsnQWx0JywgJ0N0cmwnLCAnTWV0YScsICdTaGlmdCddLmluY2x1ZGVzKGl0ZW0pKTtcbiAgICBjb25zdCBldmVudCA9IG5ldyBLZXlib2FyZEV2ZW50KCdrZXlkb3duJywge1xuICAgICAgICBrZXk6IGtleSA9PT0gJ1NwYWNlJ1xuICAgICAgICAgICAgPyAnICdcbiAgICAgICAgICAgIDoga2V5LFxuICAgICAgICBhbHRLZXk6IGtleXMuaW5jbHVkZXMoJ0FsdCcpLFxuICAgICAgICBjdHJsS2V5OiBrZXlzLmluY2x1ZGVzKCdDdHJsJyksXG4gICAgICAgIG1ldGFLZXk6IGtleXMuaW5jbHVkZXMoJ01ldGEnKSxcbiAgICAgICAgc2hpZnRLZXk6IGtleXMuaW5jbHVkZXMoJ1NoaWZ0JyksXG4gICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgfSk7XG4gICAgY29uc3QgY2FwdHVyZWRUcmFuc2FjdGlvbiA9IGVkaXRvci5jYXB0dXJlVHJhbnNhY3Rpb24oKCkgPT4ge1xuICAgICAgICB2aWV3LnNvbWVQcm9wKCdoYW5kbGVLZXlEb3duJywgZiA9PiBmKHZpZXcsIGV2ZW50KSk7XG4gICAgfSk7XG4gICAgY2FwdHVyZWRUcmFuc2FjdGlvbiA9PT0gbnVsbCB8fCBjYXB0dXJlZFRyYW5zYWN0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYXB0dXJlZFRyYW5zYWN0aW9uLnN0ZXBzLmZvckVhY2goc3RlcCA9PiB7XG4gICAgICAgIGNvbnN0IG5ld1N0ZXAgPSBzdGVwLm1hcCh0ci5tYXBwaW5nKTtcbiAgICAgICAgaWYgKG5ld1N0ZXAgJiYgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHRyLm1heWJlU3RlcChuZXdTdGVwKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gaXNOb2RlQWN0aXZlKHN0YXRlLCB0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pIHtcbiAgICBjb25zdCB7IGZyb20sIHRvLCBlbXB0eSB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGNvbnN0IHR5cGUgPSB0eXBlT3JOYW1lID8gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKSA6IG51bGw7XG4gICAgY29uc3Qgbm9kZVJhbmdlcyA9IFtdO1xuICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgaWYgKG5vZGUuaXNUZXh0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVsYXRpdmVGcm9tID0gTWF0aC5tYXgoZnJvbSwgcG9zKTtcbiAgICAgICAgY29uc3QgcmVsYXRpdmVUbyA9IE1hdGgubWluKHRvLCBwb3MgKyBub2RlLm5vZGVTaXplKTtcbiAgICAgICAgbm9kZVJhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgIG5vZGUsXG4gICAgICAgICAgICBmcm9tOiByZWxhdGl2ZUZyb20sXG4gICAgICAgICAgICB0bzogcmVsYXRpdmVUbyxcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgY29uc3Qgc2VsZWN0aW9uUmFuZ2UgPSB0byAtIGZyb207XG4gICAgY29uc3QgbWF0Y2hlZE5vZGVSYW5nZXMgPSBub2RlUmFuZ2VzXG4gICAgICAgIC5maWx0ZXIobm9kZVJhbmdlID0+IHtcbiAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZS5uYW1lID09PSBub2RlUmFuZ2Uubm9kZS50eXBlLm5hbWU7XG4gICAgfSlcbiAgICAgICAgLmZpbHRlcihub2RlUmFuZ2UgPT4gb2JqZWN0SW5jbHVkZXMobm9kZVJhbmdlLm5vZGUuYXR0cnMsIGF0dHJpYnV0ZXMsIHsgc3RyaWN0OiBmYWxzZSB9KSk7XG4gICAgaWYgKGVtcHR5KSB7XG4gICAgICAgIHJldHVybiAhIW1hdGNoZWROb2RlUmFuZ2VzLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgcmFuZ2UgPSBtYXRjaGVkTm9kZVJhbmdlcy5yZWR1Y2UoKHN1bSwgbm9kZVJhbmdlKSA9PiBzdW0gKyBub2RlUmFuZ2UudG8gLSBub2RlUmFuZ2UuZnJvbSwgMCk7XG4gICAgcmV0dXJuIHJhbmdlID49IHNlbGVjdGlvblJhbmdlO1xufVxuXG5jb25zdCBsaWZ0ID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgICBjb25zdCBpc0FjdGl2ZSA9IGlzTm9kZUFjdGl2ZShzdGF0ZSwgdHlwZSwgYXR0cmlidXRlcyk7XG4gICAgaWYgKCFpc0FjdGl2ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBsaWZ0JDEoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbmNvbnN0IGxpZnRFbXB0eUJsb2NrID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICByZXR1cm4gbGlmdEVtcHR5QmxvY2skMShzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcblxuY29uc3QgbGlmdExpc3RJdGVtID0gdHlwZU9yTmFtZSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICAgIHJldHVybiBsaWZ0TGlzdEl0ZW0kMSh0eXBlKShzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcblxuY29uc3QgbmV3bGluZUluQ29kZSA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgcmV0dXJuIG5ld2xpbmVJbkNvZGUkMShzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIHR5cGUgb2YgYSBzY2hlbWEgaXRlbSBieSBpdHMgbmFtZS5cbiAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBzY2hlbWEgaXRlbVxuICogQHBhcmFtIHNjaGVtYSBUaGUgUHJvc2VtaXJvciBzY2hlbWEgdG8gc2VhcmNoIGluXG4gKiBAcmV0dXJucyBUaGUgdHlwZSBvZiB0aGUgc2NoZW1hIGl0ZW0gKGBub2RlYCBvciBgbWFya2ApLCBvciBudWxsIGlmIGl0IGRvZXNuJ3QgZXhpc3RcbiAqL1xuZnVuY3Rpb24gZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUobmFtZSwgc2NoZW1hKSB7XG4gICAgaWYgKHNjaGVtYS5ub2Rlc1tuYW1lXSkge1xuICAgICAgICByZXR1cm4gJ25vZGUnO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hLm1hcmtzW25hbWVdKSB7XG4gICAgICAgIHJldHVybiAnbWFyayc7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFJlbW92ZSBhIHByb3BlcnR5IG9yIGFuIGFycmF5IG9mIHByb3BlcnRpZXMgZnJvbSBhbiBvYmplY3RcbiAqIEBwYXJhbSBvYmogT2JqZWN0XG4gKiBAcGFyYW0ga2V5IEtleSB0byByZW1vdmVcbiAqL1xuZnVuY3Rpb24gZGVsZXRlUHJvcHMob2JqLCBwcm9wT3JQcm9wcykge1xuICAgIGNvbnN0IHByb3BzID0gdHlwZW9mIHByb3BPclByb3BzID09PSAnc3RyaW5nJ1xuICAgICAgICA/IFtwcm9wT3JQcm9wc11cbiAgICAgICAgOiBwcm9wT3JQcm9wcztcbiAgICByZXR1cm4gT2JqZWN0XG4gICAgICAgIC5rZXlzKG9iailcbiAgICAgICAgLnJlZHVjZSgobmV3T2JqLCBwcm9wKSA9PiB7XG4gICAgICAgIGlmICghcHJvcHMuaW5jbHVkZXMocHJvcCkpIHtcbiAgICAgICAgICAgIG5ld09ialtwcm9wXSA9IG9ialtwcm9wXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3T2JqO1xuICAgIH0sIHt9KTtcbn1cblxuY29uc3QgcmVzZXRBdHRyaWJ1dGVzID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMpID0+ICh7IHRyLCBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGxldCBub2RlVHlwZSA9IG51bGw7XG4gICAgbGV0IG1hcmtUeXBlID0gbnVsbDtcbiAgICBjb25zdCBzY2hlbWFUeXBlID0gZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUodHlwZW9mIHR5cGVPck5hbWUgPT09ICdzdHJpbmcnID8gdHlwZU9yTmFtZSA6IHR5cGVPck5hbWUubmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgICBpZiAoIXNjaGVtYVR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hVHlwZSA9PT0gJ25vZGUnKSB7XG4gICAgICAgIG5vZGVUeXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYVR5cGUgPT09ICdtYXJrJykge1xuICAgICAgICBtYXJrVHlwZSA9IGdldE1hcmtUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gICAgfVxuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICB0ci5zZWxlY3Rpb24ucmFuZ2VzLmZvckVhY2gocmFuZ2UgPT4ge1xuICAgICAgICAgICAgc3RhdGUuZG9jLm5vZGVzQmV0d2VlbihyYW5nZS4kZnJvbS5wb3MsIHJhbmdlLiR0by5wb3MsIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZVR5cGUgJiYgbm9kZVR5cGUgPT09IG5vZGUudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICB0ci5zZXROb2RlTWFya3VwKHBvcywgdW5kZWZpbmVkLCBkZWxldGVQcm9wcyhub2RlLmF0dHJzLCBhdHRyaWJ1dGVzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtYXJrVHlwZSAmJiBub2RlLm1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLm1hcmtzLmZvckVhY2gobWFyayA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFya1R5cGUgPT09IG1hcmsudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyLmFkZE1hcmsocG9zLCBwb3MgKyBub2RlLm5vZGVTaXplLCBtYXJrVHlwZS5jcmVhdGUoZGVsZXRlUHJvcHMobWFyay5hdHRycywgYXR0cmlidXRlcykpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IHNjcm9sbEludG9WaWV3ID0gKCkgPT4gKHsgdHIsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgdHIuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCBzZWxlY3RBbGwgPSAoKSA9PiAoeyB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBuZXcgQWxsU2VsZWN0aW9uKHRyLmRvYyk7XG4gICAgICAgIHRyLnNldFNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IHNlbGVjdE5vZGVCYWNrd2FyZCA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgcmV0dXJuIHNlbGVjdE5vZGVCYWNrd2FyZCQxKHN0YXRlLCBkaXNwYXRjaCk7XG59O1xuXG5jb25zdCBzZWxlY3ROb2RlRm9yd2FyZCA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgcmV0dXJuIHNlbGVjdE5vZGVGb3J3YXJkJDEoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbmNvbnN0IHNlbGVjdFBhcmVudE5vZGUgPSAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIHJldHVybiBzZWxlY3RQYXJlbnROb2RlJDEoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbi8vIEB0cy1pZ25vcmVcbi8vIFRPRE86IGFkZCB0eXBlcyB0byBAdHlwZXMvcHJvc2VtaXJyb3ItY29tbWFuZHNcbmNvbnN0IHNlbGVjdFRleHRibG9ja0VuZCA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgcmV0dXJuIHNlbGVjdFRleHRibG9ja0VuZCQxKHN0YXRlLCBkaXNwYXRjaCk7XG59O1xuXG4vLyBAdHMtaWdub3JlXG4vLyBUT0RPOiBhZGQgdHlwZXMgdG8gQHR5cGVzL3Byb3NlbWlycm9yLWNvbW1hbmRzXG5jb25zdCBzZWxlY3RUZXh0YmxvY2tTdGFydCA9ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgcmV0dXJuIHNlbGVjdFRleHRibG9ja1N0YXJ0JDEoc3RhdGUsIGRpc3BhdGNoKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IFByb3NlbWlycm9yIGRvY3VtZW50IG5vZGUgZnJvbSBjb250ZW50LlxuICogQHBhcmFtIGNvbnRlbnQgVGhlIEpTT04gb3IgSFRNTCBjb250ZW50IHRvIGNyZWF0ZSB0aGUgZG9jdW1lbnQgZnJvbVxuICogQHBhcmFtIHNjaGVtYSBUaGUgUHJvc2VtaXJyb3Igc2NoZW1hIHRvIHVzZSBmb3IgdGhlIGRvY3VtZW50XG4gKiBAcGFyYW0gcGFyc2VPcHRpb25zIE9wdGlvbnMgZm9yIHRoZSBwYXJzZXJcbiAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIFByb3NlbWlycm9yIGRvY3VtZW50IG5vZGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRG9jdW1lbnQoY29udGVudCwgc2NoZW1hLCBwYXJzZU9wdGlvbnMgPSB7fSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIGNyZWF0ZU5vZGVGcm9tQ29udGVudChjb250ZW50LCBzY2hlbWEsIHtcbiAgICAgICAgc2xpY2U6IGZhbHNlLFxuICAgICAgICBwYXJzZU9wdGlvbnMsXG4gICAgICAgIGVycm9yT25JbnZhbGlkQ29udGVudDogb3B0aW9ucy5lcnJvck9uSW52YWxpZENvbnRlbnQsXG4gICAgfSk7XG59XG5cbmNvbnN0IHNldENvbnRlbnQgPSAoY29udGVudCwgZW1pdFVwZGF0ZSA9IGZhbHNlLCBwYXJzZU9wdGlvbnMgPSB7fSwgb3B0aW9ucyA9IHt9KSA9PiAoeyBlZGl0b3IsIHRyLCBkaXNwYXRjaCwgY29tbWFuZHMsIH0pID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IHsgZG9jIH0gPSB0cjtcbiAgICAvLyBUaGlzIGlzIHRvIGtlZXAgYmFja3dhcmQgY29tcGF0aWJpbGl0eSB3aXRoIHRoZSBwcmV2aW91cyBiZWhhdmlvclxuICAgIC8vIFRPRE8gcmVtb3ZlIHRoaXMgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvblxuICAgIGlmIChwYXJzZU9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlICE9PSAnZnVsbCcpIHtcbiAgICAgICAgY29uc3QgZG9jdW1lbnQgPSBjcmVhdGVEb2N1bWVudChjb250ZW50LCBlZGl0b3Iuc2NoZW1hLCBwYXJzZU9wdGlvbnMsIHtcbiAgICAgICAgICAgIGVycm9yT25JbnZhbGlkQ29udGVudDogKF9hID0gb3B0aW9ucy5lcnJvck9uSW52YWxpZENvbnRlbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGVkaXRvci5vcHRpb25zLmVuYWJsZUNvbnRlbnRDaGVjayxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgdHIucmVwbGFjZVdpdGgoMCwgZG9jLmNvbnRlbnQuc2l6ZSwgZG9jdW1lbnQpLnNldE1ldGEoJ3ByZXZlbnRVcGRhdGUnLCAhZW1pdFVwZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICB0ci5zZXRNZXRhKCdwcmV2ZW50VXBkYXRlJywgIWVtaXRVcGRhdGUpO1xuICAgIH1cbiAgICByZXR1cm4gY29tbWFuZHMuaW5zZXJ0Q29udGVudEF0KHsgZnJvbTogMCwgdG86IGRvYy5jb250ZW50LnNpemUgfSwgY29udGVudCwge1xuICAgICAgICBwYXJzZU9wdGlvbnMsXG4gICAgICAgIGVycm9yT25JbnZhbGlkQ29udGVudDogKF9iID0gb3B0aW9ucy5lcnJvck9uSW52YWxpZENvbnRlbnQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGVkaXRvci5vcHRpb25zLmVuYWJsZUNvbnRlbnRDaGVjayxcbiAgICB9KTtcbn07XG5cbmZ1bmN0aW9uIGdldE1hcmtBdHRyaWJ1dGVzKHN0YXRlLCB0eXBlT3JOYW1lKSB7XG4gICAgY29uc3QgdHlwZSA9IGdldE1hcmtUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gICAgY29uc3QgeyBmcm9tLCB0bywgZW1wdHkgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBjb25zdCBtYXJrcyA9IFtdO1xuICAgIGlmIChlbXB0eSkge1xuICAgICAgICBpZiAoc3RhdGUuc3RvcmVkTWFya3MpIHtcbiAgICAgICAgICAgIG1hcmtzLnB1c2goLi4uc3RhdGUuc3RvcmVkTWFya3MpO1xuICAgICAgICB9XG4gICAgICAgIG1hcmtzLnB1c2goLi4uc3RhdGUuc2VsZWN0aW9uLiRoZWFkLm1hcmtzKCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgbm9kZSA9PiB7XG4gICAgICAgICAgICBtYXJrcy5wdXNoKC4uLm5vZGUubWFya3MpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgbWFyayA9IG1hcmtzLmZpbmQobWFya0l0ZW0gPT4gbWFya0l0ZW0udHlwZS5uYW1lID09PSB0eXBlLm5hbWUpO1xuICAgIGlmICghbWFyaykge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIHJldHVybiB7IC4uLm1hcmsuYXR0cnMgfTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgbmV3IGBUcmFuc2Zvcm1gIGJhc2VkIG9uIGFsbCBzdGVwcyBvZiB0aGUgcGFzc2VkIHRyYW5zYWN0aW9ucy5cbiAqIEBwYXJhbSBvbGREb2MgVGhlIFByb3NlbWlycm9yIG5vZGUgdG8gc3RhcnQgZnJvbVxuICogQHBhcmFtIHRyYW5zYWN0aW9ucyBUaGUgdHJhbnNhY3Rpb25zIHRvIGNvbWJpbmVcbiAqIEByZXR1cm5zIEEgbmV3IGBUcmFuc2Zvcm1gIHdpdGggYWxsIHN0ZXBzIG9mIHRoZSBwYXNzZWQgdHJhbnNhY3Rpb25zXG4gKi9cbmZ1bmN0aW9uIGNvbWJpbmVUcmFuc2FjdGlvblN0ZXBzKG9sZERvYywgdHJhbnNhY3Rpb25zKSB7XG4gICAgY29uc3QgdHJhbnNmb3JtID0gbmV3IFRyYW5zZm9ybShvbGREb2MpO1xuICAgIHRyYW5zYWN0aW9ucy5mb3JFYWNoKHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgdHJhbnNhY3Rpb24uc3RlcHMuZm9yRWFjaChzdGVwID0+IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybS5zdGVwKHN0ZXApO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gdHJhbnNmb3JtO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIGRlZmF1bHQgYmxvY2sgdHlwZSBhdCBhIGdpdmVuIG1hdGNoXG4gKiBAcGFyYW0gbWF0Y2ggVGhlIGNvbnRlbnQgbWF0Y2ggdG8gZ2V0IHRoZSBkZWZhdWx0IGJsb2NrIHR5cGUgZnJvbVxuICogQHJldHVybnMgVGhlIGRlZmF1bHQgYmxvY2sgdHlwZSBvciBudWxsXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRCbG9ja0F0KG1hdGNoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaC5lZGdlQ291bnQ7IGkgKz0gMSkge1xuICAgICAgICBjb25zdCB7IHR5cGUgfSA9IG1hdGNoLmVkZ2UoaSk7XG4gICAgICAgIGlmICh0eXBlLmlzVGV4dGJsb2NrICYmICF0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogRmluZCBjaGlsZHJlbiBpbnNpZGUgYSBQcm9zZW1pcnJvciBub2RlIHRoYXQgbWF0Y2ggYSBwcmVkaWNhdGUuXG4gKiBAcGFyYW0gbm9kZSBUaGUgUHJvc2VtaXJyb3Igbm9kZSB0byBzZWFyY2ggaW5cbiAqIEBwYXJhbSBwcmVkaWNhdGUgVGhlIHByZWRpY2F0ZSB0byBtYXRjaFxuICogQHJldHVybnMgQW4gYXJyYXkgb2Ygbm9kZXMgd2l0aCB0aGVpciBwb3NpdGlvbnNcbiAqL1xuZnVuY3Rpb24gZmluZENoaWxkcmVuKG5vZGUsIHByZWRpY2F0ZSkge1xuICAgIGNvbnN0IG5vZGVzV2l0aFBvcyA9IFtdO1xuICAgIG5vZGUuZGVzY2VuZGFudHMoKGNoaWxkLCBwb3MpID0+IHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZShjaGlsZCkpIHtcbiAgICAgICAgICAgIG5vZGVzV2l0aFBvcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBub2RlOiBjaGlsZCxcbiAgICAgICAgICAgICAgICBwb3MsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBub2Rlc1dpdGhQb3M7XG59XG5cbi8qKlxuICogU2FtZSBhcyBgZmluZENoaWxkcmVuYCBidXQgc2VhcmNoZXMgb25seSB3aXRoaW4gYSBgcmFuZ2VgLlxuICogQHBhcmFtIG5vZGUgVGhlIFByb3NlbWlycm9yIG5vZGUgdG8gc2VhcmNoIGluXG4gKiBAcGFyYW0gcmFuZ2UgVGhlIHJhbmdlIHRvIHNlYXJjaCBpblxuICogQHBhcmFtIHByZWRpY2F0ZSBUaGUgcHJlZGljYXRlIHRvIG1hdGNoXG4gKiBAcmV0dXJucyBBbiBhcnJheSBvZiBub2RlcyB3aXRoIHRoZWlyIHBvc2l0aW9uc1xuICovXG5mdW5jdGlvbiBmaW5kQ2hpbGRyZW5JblJhbmdlKG5vZGUsIHJhbmdlLCBwcmVkaWNhdGUpIHtcbiAgICBjb25zdCBub2Rlc1dpdGhQb3MgPSBbXTtcbiAgICAvLyBpZiAocmFuZ2UuZnJvbSA9PT0gcmFuZ2UudG8pIHtcbiAgICAvLyAgIGNvbnN0IG5vZGVBdCA9IG5vZGUubm9kZUF0KHJhbmdlLmZyb20pXG4gICAgLy8gICBpZiAobm9kZUF0KSB7XG4gICAgLy8gICAgIG5vZGVzV2l0aFBvcy5wdXNoKHtcbiAgICAvLyAgICAgICBub2RlOiBub2RlQXQsXG4gICAgLy8gICAgICAgcG9zOiByYW5nZS5mcm9tLFxuICAgIC8vICAgICB9KVxuICAgIC8vICAgfVxuICAgIC8vIH1cbiAgICBub2RlLm5vZGVzQmV0d2VlbihyYW5nZS5mcm9tLCByYW5nZS50bywgKGNoaWxkLCBwb3MpID0+IHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZShjaGlsZCkpIHtcbiAgICAgICAgICAgIG5vZGVzV2l0aFBvcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBub2RlOiBjaGlsZCxcbiAgICAgICAgICAgICAgICBwb3MsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBub2Rlc1dpdGhQb3M7XG59XG5cbi8qKlxuICogRmluZHMgdGhlIGNsb3Nlc3QgcGFyZW50IG5vZGUgdG8gYSByZXNvbHZlZCBwb3NpdGlvbiB0aGF0IG1hdGNoZXMgYSBwcmVkaWNhdGUuXG4gKiBAcGFyYW0gJHBvcyBUaGUgcmVzb2x2ZWQgcG9zaXRpb24gdG8gc2VhcmNoIGZyb21cbiAqIEBwYXJhbSBwcmVkaWNhdGUgVGhlIHByZWRpY2F0ZSB0byBtYXRjaFxuICogQHJldHVybnMgVGhlIGNsb3Nlc3QgcGFyZW50IG5vZGUgdG8gdGhlIHJlc29sdmVkIHBvc2l0aW9uIHRoYXQgbWF0Y2hlcyB0aGUgcHJlZGljYXRlXG4gKiBAZXhhbXBsZSBgYGBqc1xuICogZmluZFBhcmVudE5vZGVDbG9zZXN0VG9Qb3MoJGZyb20sIG5vZGUgPT4gbm9kZS50eXBlLm5hbWUgPT09ICdwYXJhZ3JhcGgnKVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGZpbmRQYXJlbnROb2RlQ2xvc2VzdFRvUG9zKCRwb3MsIHByZWRpY2F0ZSkge1xuICAgIGZvciAobGV0IGkgPSAkcG9zLmRlcHRoOyBpID4gMDsgaSAtPSAxKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSAkcG9zLm5vZGUoaSk7XG4gICAgICAgIGlmIChwcmVkaWNhdGUobm9kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcG9zOiBpID4gMCA/ICRwb3MuYmVmb3JlKGkpIDogMCxcbiAgICAgICAgICAgICAgICBzdGFydDogJHBvcy5zdGFydChpKSxcbiAgICAgICAgICAgICAgICBkZXB0aDogaSxcbiAgICAgICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBGaW5kcyB0aGUgY2xvc2VzdCBwYXJlbnQgbm9kZSB0byB0aGUgY3VycmVudCBzZWxlY3Rpb24gdGhhdCBtYXRjaGVzIGEgcHJlZGljYXRlLlxuICogQHBhcmFtIHByZWRpY2F0ZSBUaGUgcHJlZGljYXRlIHRvIG1hdGNoXG4gKiBAcmV0dXJucyBBIGNvbW1hbmQgdGhhdCBmaW5kcyB0aGUgY2xvc2VzdCBwYXJlbnQgbm9kZSB0byB0aGUgY3VycmVudCBzZWxlY3Rpb24gdGhhdCBtYXRjaGVzIHRoZSBwcmVkaWNhdGVcbiAqIEBleGFtcGxlIGBgYGpzXG4gKiBmaW5kUGFyZW50Tm9kZShub2RlID0+IG5vZGUudHlwZS5uYW1lID09PSAncGFyYWdyYXBoJylcbiAqIGBgYFxuICovXG5mdW5jdGlvbiBmaW5kUGFyZW50Tm9kZShwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gKHNlbGVjdGlvbikgPT4gZmluZFBhcmVudE5vZGVDbG9zZXN0VG9Qb3Moc2VsZWN0aW9uLiRmcm9tLCBwcmVkaWNhdGUpO1xufVxuXG5mdW5jdGlvbiBnZXRTY2hlbWEoZXh0ZW5zaW9ucywgZWRpdG9yKSB7XG4gICAgY29uc3QgcmVzb2x2ZWRFeHRlbnNpb25zID0gRXh0ZW5zaW9uTWFuYWdlci5yZXNvbHZlKGV4dGVuc2lvbnMpO1xuICAgIHJldHVybiBnZXRTY2hlbWFCeVJlc29sdmVkRXh0ZW5zaW9ucyhyZXNvbHZlZEV4dGVuc2lvbnMsIGVkaXRvcik7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgSFRNTCBmcm9tIGEgSlNPTkNvbnRlbnRcbiAqIEBwYXJhbSBkb2MgVGhlIEpTT05Db250ZW50IHRvIGdlbmVyYXRlIEhUTUwgZnJvbVxuICogQHBhcmFtIGV4dGVuc2lvbnMgVGhlIGV4dGVuc2lvbnMgdG8gdXNlIGZvciB0aGUgc2NoZW1hXG4gKiBAcmV0dXJucyBUaGUgZ2VuZXJhdGVkIEhUTUxcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVIVE1MKGRvYywgZXh0ZW5zaW9ucykge1xuICAgIGNvbnN0IHNjaGVtYSA9IGdldFNjaGVtYShleHRlbnNpb25zKTtcbiAgICBjb25zdCBjb250ZW50Tm9kZSA9IE5vZGUkMS5mcm9tSlNPTihzY2hlbWEsIGRvYyk7XG4gICAgcmV0dXJuIGdldEhUTUxGcm9tRnJhZ21lbnQoY29udGVudE5vZGUuY29udGVudCwgc2NoZW1hKTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBKU09OQ29udGVudCBmcm9tIEhUTUxcbiAqIEBwYXJhbSBodG1sIFRoZSBIVE1MIHRvIGdlbmVyYXRlIEpTT05Db250ZW50IGZyb21cbiAqIEBwYXJhbSBleHRlbnNpb25zIFRoZSBleHRlbnNpb25zIHRvIHVzZSBmb3IgdGhlIHNjaGVtYVxuICogQHJldHVybnMgVGhlIGdlbmVyYXRlZCBKU09OQ29udGVudFxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZUpTT04oaHRtbCwgZXh0ZW5zaW9ucykge1xuICAgIGNvbnN0IHNjaGVtYSA9IGdldFNjaGVtYShleHRlbnNpb25zKTtcbiAgICBjb25zdCBkb20gPSBlbGVtZW50RnJvbVN0cmluZyhodG1sKTtcbiAgICByZXR1cm4gRE9NUGFyc2VyLmZyb21TY2hlbWEoc2NoZW1hKS5wYXJzZShkb20pLnRvSlNPTigpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHRleHQgb2YgYSBQcm9zZW1pcnJvciBub2RlXG4gKiBAcGFyYW0gbm9kZSBUaGUgUHJvc2VtaXJyb3Igbm9kZVxuICogQHBhcmFtIG9wdGlvbnMgT3B0aW9ucyBmb3IgdGhlIHRleHQgc2VyaWFsaXplciAmIGJsb2NrIHNlcGFyYXRvclxuICogQHJldHVybnMgVGhlIHRleHQgb2YgdGhlIG5vZGVcbiAqIEBleGFtcGxlIGBgYGpzXG4gKiBjb25zdCB0ZXh0ID0gZ2V0VGV4dChub2RlLCB7IGJsb2NrU2VwYXJhdG9yOiAnXFxuJyB9KVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGdldFRleHQobm9kZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IHJhbmdlID0ge1xuICAgICAgICBmcm9tOiAwLFxuICAgICAgICB0bzogbm9kZS5jb250ZW50LnNpemUsXG4gICAgfTtcbiAgICByZXR1cm4gZ2V0VGV4dEJldHdlZW4obm9kZSwgcmFuZ2UsIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIHJhdyB0ZXh0IGZyb20gYSBKU09OQ29udGVudFxuICogQHBhcmFtIGRvYyBUaGUgSlNPTkNvbnRlbnQgdG8gZ2VuZXJhdGUgdGV4dCBmcm9tXG4gKiBAcGFyYW0gZXh0ZW5zaW9ucyBUaGUgZXh0ZW5zaW9ucyB0byB1c2UgZm9yIHRoZSBzY2hlbWFcbiAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgZm9yIHRoZSB0ZXh0IGdlbmVyYXRpb24gZi5lLiBibG9ja1NlcGFyYXRvciBvciB0ZXh0U2VyaWFsaXplcnNcbiAqIEByZXR1cm5zIFRoZSBnZW5lcmF0ZWQgdGV4dFxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZVRleHQoZG9jLCBleHRlbnNpb25zLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBibG9ja1NlcGFyYXRvciA9ICdcXG5cXG4nLCB0ZXh0U2VyaWFsaXplcnMgPSB7fSB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCBzY2hlbWEgPSBnZXRTY2hlbWEoZXh0ZW5zaW9ucyk7XG4gICAgY29uc3QgY29udGVudE5vZGUgPSBOb2RlJDEuZnJvbUpTT04oc2NoZW1hLCBkb2MpO1xuICAgIHJldHVybiBnZXRUZXh0KGNvbnRlbnROb2RlLCB7XG4gICAgICAgIGJsb2NrU2VwYXJhdG9yLFxuICAgICAgICB0ZXh0U2VyaWFsaXplcnM6IHtcbiAgICAgICAgICAgIC4uLmdldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEoc2NoZW1hKSxcbiAgICAgICAgICAgIC4uLnRleHRTZXJpYWxpemVycyxcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0Tm9kZUF0dHJpYnV0ZXMoc3RhdGUsIHR5cGVPck5hbWUpIHtcbiAgICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgICBjb25zdCB7IGZyb20sIHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCBub2RlID0+IHtcbiAgICAgICAgbm9kZXMucHVzaChub2RlKTtcbiAgICB9KTtcbiAgICBjb25zdCBub2RlID0gbm9kZXMucmV2ZXJzZSgpLmZpbmQobm9kZUl0ZW0gPT4gbm9kZUl0ZW0udHlwZS5uYW1lID09PSB0eXBlLm5hbWUpO1xuICAgIGlmICghbm9kZSkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIHJldHVybiB7IC4uLm5vZGUuYXR0cnMgfTtcbn1cblxuLyoqXG4gKiBHZXQgbm9kZSBvciBtYXJrIGF0dHJpYnV0ZXMgYnkgdHlwZSBvciBuYW1lIG9uIHRoZSBjdXJyZW50IGVkaXRvciBzdGF0ZVxuICogQHBhcmFtIHN0YXRlIFRoZSBjdXJyZW50IGVkaXRvciBzdGF0ZVxuICogQHBhcmFtIHR5cGVPck5hbWUgVGhlIG5vZGUgb3IgbWFyayB0eXBlIG9yIG5hbWVcbiAqIEByZXR1cm5zIFRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBub2RlIG9yIG1hcmsgb3IgYW4gZW1wdHkgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGdldEF0dHJpYnV0ZXMoc3RhdGUsIHR5cGVPck5hbWUpIHtcbiAgICBjb25zdCBzY2hlbWFUeXBlID0gZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUodHlwZW9mIHR5cGVPck5hbWUgPT09ICdzdHJpbmcnID8gdHlwZU9yTmFtZSA6IHR5cGVPck5hbWUubmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgICBpZiAoc2NoZW1hVHlwZSA9PT0gJ25vZGUnKSB7XG4gICAgICAgIHJldHVybiBnZXROb2RlQXR0cmlidXRlcyhzdGF0ZSwgdHlwZU9yTmFtZSk7XG4gICAgfVxuICAgIGlmIChzY2hlbWFUeXBlID09PSAnbWFyaycpIHtcbiAgICAgICAgcmV0dXJuIGdldE1hcmtBdHRyaWJ1dGVzKHN0YXRlLCB0eXBlT3JOYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHt9O1xufVxuXG4vKipcbiAqIFJlbW92ZXMgZHVwbGljYXRlZCB2YWx1ZXMgd2l0aGluIGFuIGFycmF5LlxuICogU3VwcG9ydHMgbnVtYmVycywgc3RyaW5ncyBhbmQgb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlRHVwbGljYXRlcyhhcnJheSwgYnkgPSBKU09OLnN0cmluZ2lmeSkge1xuICAgIGNvbnN0IHNlZW4gPSB7fTtcbiAgICByZXR1cm4gYXJyYXkuZmlsdGVyKGl0ZW0gPT4ge1xuICAgICAgICBjb25zdCBrZXkgPSBieShpdGVtKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzZWVuLCBrZXkpXG4gICAgICAgICAgICA/IGZhbHNlXG4gICAgICAgICAgICA6IChzZWVuW2tleV0gPSB0cnVlKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGR1cGxpY2F0ZWQgcmFuZ2VzIGFuZCByYW5nZXMgdGhhdCBhcmVcbiAqIGZ1bGx5IGNhcHR1cmVkIGJ5IG90aGVyIHJhbmdlcy5cbiAqL1xuZnVuY3Rpb24gc2ltcGxpZnlDaGFuZ2VkUmFuZ2VzKGNoYW5nZXMpIHtcbiAgICBjb25zdCB1bmlxdWVDaGFuZ2VzID0gcmVtb3ZlRHVwbGljYXRlcyhjaGFuZ2VzKTtcbiAgICByZXR1cm4gdW5pcXVlQ2hhbmdlcy5sZW5ndGggPT09IDFcbiAgICAgICAgPyB1bmlxdWVDaGFuZ2VzXG4gICAgICAgIDogdW5pcXVlQ2hhbmdlcy5maWx0ZXIoKGNoYW5nZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3QgPSB1bmlxdWVDaGFuZ2VzLmZpbHRlcigoXywgaSkgPT4gaSAhPT0gaW5kZXgpO1xuICAgICAgICAgICAgcmV0dXJuICFyZXN0LnNvbWUob3RoZXJDaGFuZ2UgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGFuZ2Uub2xkUmFuZ2UuZnJvbSA+PSBvdGhlckNoYW5nZS5vbGRSYW5nZS5mcm9tXG4gICAgICAgICAgICAgICAgICAgICYmIGNoYW5nZS5vbGRSYW5nZS50byA8PSBvdGhlckNoYW5nZS5vbGRSYW5nZS50b1xuICAgICAgICAgICAgICAgICAgICAmJiBjaGFuZ2UubmV3UmFuZ2UuZnJvbSA+PSBvdGhlckNoYW5nZS5uZXdSYW5nZS5mcm9tXG4gICAgICAgICAgICAgICAgICAgICYmIGNoYW5nZS5uZXdSYW5nZS50byA8PSBvdGhlckNoYW5nZS5uZXdSYW5nZS50bztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbn1cbi8qKlxuICogUmV0dXJucyBhIGxpc3Qgb2YgY2hhbmdlZCByYW5nZXNcbiAqIGJhc2VkIG9uIHRoZSBmaXJzdCBhbmQgbGFzdCBzdGF0ZSBvZiBhbGwgc3RlcHMuXG4gKi9cbmZ1bmN0aW9uIGdldENoYW5nZWRSYW5nZXModHJhbnNmb3JtKSB7XG4gICAgY29uc3QgeyBtYXBwaW5nLCBzdGVwcyB9ID0gdHJhbnNmb3JtO1xuICAgIGNvbnN0IGNoYW5nZXMgPSBbXTtcbiAgICBtYXBwaW5nLm1hcHMuZm9yRWFjaCgoc3RlcE1hcCwgaW5kZXgpID0+IHtcbiAgICAgICAgY29uc3QgcmFuZ2VzID0gW107XG4gICAgICAgIC8vIFRoaXMgYWNjb3VudHMgZm9yIHN0ZXAgY2hhbmdlcyB3aGVyZSBubyByYW5nZSB3YXMgYWN0dWFsbHkgYWx0ZXJlZFxuICAgICAgICAvLyBlLmcuIHdoZW4gc2V0dGluZyBhIG1hcmssIG5vZGUgYXR0cmlidXRlLCBldGMuXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKCFzdGVwTWFwLnJhbmdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZnJvbSwgdG8gfSA9IHN0ZXBzW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChmcm9tID09PSB1bmRlZmluZWQgfHwgdG8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKHsgZnJvbSwgdG8gfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGVwTWFwLmZvckVhY2goKGZyb20sIHRvKSA9PiB7XG4gICAgICAgICAgICAgICAgcmFuZ2VzLnB1c2goeyBmcm9tLCB0byB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJhbmdlcy5mb3JFYWNoKCh7IGZyb20sIHRvIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1N0YXJ0ID0gbWFwcGluZy5zbGljZShpbmRleCkubWFwKGZyb20sIC0xKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0VuZCA9IG1hcHBpbmcuc2xpY2UoaW5kZXgpLm1hcCh0byk7XG4gICAgICAgICAgICBjb25zdCBvbGRTdGFydCA9IG1hcHBpbmcuaW52ZXJ0KCkubWFwKG5ld1N0YXJ0LCAtMSk7XG4gICAgICAgICAgICBjb25zdCBvbGRFbmQgPSBtYXBwaW5nLmludmVydCgpLm1hcChuZXdFbmQpO1xuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBvbGRSYW5nZToge1xuICAgICAgICAgICAgICAgICAgICBmcm9tOiBvbGRTdGFydCxcbiAgICAgICAgICAgICAgICAgICAgdG86IG9sZEVuZCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG5ld1JhbmdlOiB7XG4gICAgICAgICAgICAgICAgICAgIGZyb206IG5ld1N0YXJ0LFxuICAgICAgICAgICAgICAgICAgICB0bzogbmV3RW5kLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNpbXBsaWZ5Q2hhbmdlZFJhbmdlcyhjaGFuZ2VzKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGVidWdKU09OKG5vZGUsIHN0YXJ0T2Zmc2V0ID0gMCkge1xuICAgIGNvbnN0IGlzVG9wTm9kZSA9IG5vZGUudHlwZSA9PT0gbm9kZS50eXBlLnNjaGVtYS50b3BOb2RlVHlwZTtcbiAgICBjb25zdCBpbmNyZW1lbnQgPSBpc1RvcE5vZGUgPyAwIDogMTtcbiAgICBjb25zdCBmcm9tID0gc3RhcnRPZmZzZXQ7XG4gICAgY29uc3QgdG8gPSBmcm9tICsgbm9kZS5ub2RlU2l6ZTtcbiAgICBjb25zdCBtYXJrcyA9IG5vZGUubWFya3MubWFwKG1hcmsgPT4ge1xuICAgICAgICBjb25zdCBvdXRwdXQgPSB7XG4gICAgICAgICAgICB0eXBlOiBtYXJrLnR5cGUubmFtZSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKG1hcmsuYXR0cnMpLmxlbmd0aCkge1xuICAgICAgICAgICAgb3V0cHV0LmF0dHJzID0geyAuLi5tYXJrLmF0dHJzIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9KTtcbiAgICBjb25zdCBhdHRycyA9IHsgLi4ubm9kZS5hdHRycyB9O1xuICAgIGNvbnN0IG91dHB1dCA9IHtcbiAgICAgICAgdHlwZTogbm9kZS50eXBlLm5hbWUsXG4gICAgICAgIGZyb20sXG4gICAgICAgIHRvLFxuICAgIH07XG4gICAgaWYgKE9iamVjdC5rZXlzKGF0dHJzKS5sZW5ndGgpIHtcbiAgICAgICAgb3V0cHV0LmF0dHJzID0gYXR0cnM7XG4gICAgfVxuICAgIGlmIChtYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgb3V0cHV0Lm1hcmtzID0gbWFya3M7XG4gICAgfVxuICAgIGlmIChub2RlLmNvbnRlbnQuY2hpbGRDb3VudCkge1xuICAgICAgICBvdXRwdXQuY29udGVudCA9IFtdO1xuICAgICAgICBub2RlLmZvckVhY2goKGNoaWxkLCBvZmZzZXQpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIChfYSA9IG91dHB1dC5jb250ZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHVzaChnZXREZWJ1Z0pTT04oY2hpbGQsIHN0YXJ0T2Zmc2V0ICsgb2Zmc2V0ICsgaW5jcmVtZW50KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAobm9kZS50ZXh0KSB7XG4gICAgICAgIG91dHB1dC50ZXh0ID0gbm9kZS50ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xufVxuXG5mdW5jdGlvbiBnZXRNYXJrc0JldHdlZW4oZnJvbSwgdG8sIGRvYykge1xuICAgIGNvbnN0IG1hcmtzID0gW107XG4gICAgLy8gZ2V0IGFsbCBpbmNsdXNpdmUgbWFya3Mgb24gZW1wdHkgc2VsZWN0aW9uXG4gICAgaWYgKGZyb20gPT09IHRvKSB7XG4gICAgICAgIGRvY1xuICAgICAgICAgICAgLnJlc29sdmUoZnJvbSlcbiAgICAgICAgICAgIC5tYXJrcygpXG4gICAgICAgICAgICAuZm9yRWFjaChtYXJrID0+IHtcbiAgICAgICAgICAgIGNvbnN0ICRwb3MgPSBkb2MucmVzb2x2ZShmcm9tKTtcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gZ2V0TWFya1JhbmdlKCRwb3MsIG1hcmsudHlwZSk7XG4gICAgICAgICAgICBpZiAoIXJhbmdlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWFya3MucHVzaCh7XG4gICAgICAgICAgICAgICAgbWFyayxcbiAgICAgICAgICAgICAgICAuLi5yYW5nZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgICAgIGlmICghbm9kZSB8fCAobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlLm5vZGVTaXplKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWFya3MucHVzaCguLi5ub2RlLm1hcmtzLm1hcChtYXJrID0+ICh7XG4gICAgICAgICAgICAgICAgZnJvbTogcG9zLFxuICAgICAgICAgICAgICAgIHRvOiBwb3MgKyBub2RlLm5vZGVTaXplLFxuICAgICAgICAgICAgICAgIG1hcmssXG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1hcmtzO1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSBmaXJzdCBub2RlIG9mIGEgZ2l2ZW4gdHlwZSBvciBuYW1lIGluIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAqIEBwYXJhbSBzdGF0ZSBUaGUgZWRpdG9yIHN0YXRlLlxuICogQHBhcmFtIHR5cGVPck5hbWUgVGhlIG5vZGUgdHlwZSBvciBuYW1lLlxuICogQHBhcmFtIHBvcyBUaGUgcG9zaXRpb24gdG8gc3RhcnQgc2VhcmNoaW5nIGZyb20uXG4gKiBAcGFyYW0gbWF4RGVwdGggVGhlIG1heGltdW0gZGVwdGggdG8gc2VhcmNoLlxuICogQHJldHVybnMgVGhlIG5vZGUgYW5kIHRoZSBkZXB0aCBhcyBhbiBhcnJheS5cbiAqL1xuY29uc3QgZ2V0Tm9kZUF0UG9zaXRpb24gPSAoc3RhdGUsIHR5cGVPck5hbWUsIHBvcywgbWF4RGVwdGggPSAyMCkgPT4ge1xuICAgIGNvbnN0ICRwb3MgPSBzdGF0ZS5kb2MucmVzb2x2ZShwb3MpO1xuICAgIGxldCBjdXJyZW50RGVwdGggPSBtYXhEZXB0aDtcbiAgICBsZXQgbm9kZSA9IG51bGw7XG4gICAgd2hpbGUgKGN1cnJlbnREZXB0aCA+IDAgJiYgbm9kZSA9PT0gbnVsbCkge1xuICAgICAgICBjb25zdCBjdXJyZW50Tm9kZSA9ICRwb3Mubm9kZShjdXJyZW50RGVwdGgpO1xuICAgICAgICBpZiAoKGN1cnJlbnROb2RlID09PSBudWxsIHx8IGN1cnJlbnROb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50Tm9kZS50eXBlLm5hbWUpID09PSB0eXBlT3JOYW1lKSB7XG4gICAgICAgICAgICBub2RlID0gY3VycmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjdXJyZW50RGVwdGggLT0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW25vZGUsIGN1cnJlbnREZXB0aF07XG59O1xuXG4vKipcbiAqIFJldHVybiBhdHRyaWJ1dGVzIG9mIGFuIGV4dGVuc2lvbiB0aGF0IHNob3VsZCBiZSBzcGxpdHRlZCBieSBrZWVwT25TcGxpdCBmbGFnXG4gKiBAcGFyYW0gZXh0ZW5zaW9uQXR0cmlidXRlcyBBcnJheSBvZiBleHRlbnNpb24gYXR0cmlidXRlc1xuICogQHBhcmFtIHR5cGVOYW1lIFRoZSB0eXBlIG9mIHRoZSBleHRlbnNpb25cbiAqIEBwYXJhbSBhdHRyaWJ1dGVzIFRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBleHRlbnNpb25cbiAqIEByZXR1cm5zIFRoZSBzcGxpdHRlZCBhdHRyaWJ1dGVzXG4gKi9cbmZ1bmN0aW9uIGdldFNwbGl0dGVkQXR0cmlidXRlcyhleHRlbnNpb25BdHRyaWJ1dGVzLCB0eXBlTmFtZSwgYXR0cmlidXRlcykge1xuICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0XG4gICAgICAgIC5lbnRyaWVzKGF0dHJpYnV0ZXMpXG4gICAgICAgIC5maWx0ZXIoKFtuYW1lXSkgPT4ge1xuICAgICAgICBjb25zdCBleHRlbnNpb25BdHRyaWJ1dGUgPSBleHRlbnNpb25BdHRyaWJ1dGVzLmZpbmQoaXRlbSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbS50eXBlID09PSB0eXBlTmFtZSAmJiBpdGVtLm5hbWUgPT09IG5hbWU7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWV4dGVuc2lvbkF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHRlbnNpb25BdHRyaWJ1dGUuYXR0cmlidXRlLmtlZXBPblNwbGl0O1xuICAgIH0pKTtcbn1cblxuZnVuY3Rpb24gaXNNYXJrQWN0aXZlKHN0YXRlLCB0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pIHtcbiAgICBjb25zdCB7IGVtcHR5LCByYW5nZXMgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBjb25zdCB0eXBlID0gdHlwZU9yTmFtZSA/IGdldE1hcmtUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSkgOiBudWxsO1xuICAgIGlmIChlbXB0eSkge1xuICAgICAgICByZXR1cm4gISEoc3RhdGUuc3RvcmVkTWFya3MgfHwgc3RhdGUuc2VsZWN0aW9uLiRmcm9tLm1hcmtzKCkpXG4gICAgICAgICAgICAuZmlsdGVyKG1hcmsgPT4ge1xuICAgICAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHlwZS5uYW1lID09PSBtYXJrLnR5cGUubmFtZTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5maW5kKG1hcmsgPT4gb2JqZWN0SW5jbHVkZXMobWFyay5hdHRycywgYXR0cmlidXRlcywgeyBzdHJpY3Q6IGZhbHNlIH0pKTtcbiAgICB9XG4gICAgbGV0IHNlbGVjdGlvblJhbmdlID0gMDtcbiAgICBjb25zdCBtYXJrUmFuZ2VzID0gW107XG4gICAgcmFuZ2VzLmZvckVhY2goKHsgJGZyb20sICR0byB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGZyb20gPSAkZnJvbS5wb3M7XG4gICAgICAgIGNvbnN0IHRvID0gJHRvLnBvcztcbiAgICAgICAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICAgICAgaWYgKCFub2RlLmlzVGV4dCAmJiAhbm9kZS5tYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZWxhdGl2ZUZyb20gPSBNYXRoLm1heChmcm9tLCBwb3MpO1xuICAgICAgICAgICAgY29uc3QgcmVsYXRpdmVUbyA9IE1hdGgubWluKHRvLCBwb3MgKyBub2RlLm5vZGVTaXplKTtcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gcmVsYXRpdmVUbyAtIHJlbGF0aXZlRnJvbTtcbiAgICAgICAgICAgIHNlbGVjdGlvblJhbmdlICs9IHJhbmdlO1xuICAgICAgICAgICAgbWFya1Jhbmdlcy5wdXNoKC4uLm5vZGUubWFya3MubWFwKG1hcmsgPT4gKHtcbiAgICAgICAgICAgICAgICBtYXJrLFxuICAgICAgICAgICAgICAgIGZyb206IHJlbGF0aXZlRnJvbSxcbiAgICAgICAgICAgICAgICB0bzogcmVsYXRpdmVUbyxcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIGlmIChzZWxlY3Rpb25SYW5nZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIGNhbGN1bGF0ZSByYW5nZSBvZiBtYXRjaGVkIG1hcmtcbiAgICBjb25zdCBtYXRjaGVkUmFuZ2UgPSBtYXJrUmFuZ2VzXG4gICAgICAgIC5maWx0ZXIobWFya1JhbmdlID0+IHtcbiAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZS5uYW1lID09PSBtYXJrUmFuZ2UubWFyay50eXBlLm5hbWU7XG4gICAgfSlcbiAgICAgICAgLmZpbHRlcihtYXJrUmFuZ2UgPT4gb2JqZWN0SW5jbHVkZXMobWFya1JhbmdlLm1hcmsuYXR0cnMsIGF0dHJpYnV0ZXMsIHsgc3RyaWN0OiBmYWxzZSB9KSlcbiAgICAgICAgLnJlZHVjZSgoc3VtLCBtYXJrUmFuZ2UpID0+IHN1bSArIG1hcmtSYW5nZS50byAtIG1hcmtSYW5nZS5mcm9tLCAwKTtcbiAgICAvLyBjYWxjdWxhdGUgcmFuZ2Ugb2YgbWFya3MgdGhhdCBleGNsdWRlcyB0aGUgc2VhcmNoZWQgbWFya1xuICAgIC8vIGZvciBleGFtcGxlIGBjb2RlYCBkb2VzbuKAmXQgYWxsb3cgYW55IG90aGVyIG1hcmtzXG4gICAgY29uc3QgZXhjbHVkZWRSYW5nZSA9IG1hcmtSYW5nZXNcbiAgICAgICAgLmZpbHRlcihtYXJrUmFuZ2UgPT4ge1xuICAgICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXJrUmFuZ2UubWFyay50eXBlICE9PSB0eXBlICYmIG1hcmtSYW5nZS5tYXJrLnR5cGUuZXhjbHVkZXModHlwZSk7XG4gICAgfSlcbiAgICAgICAgLnJlZHVjZSgoc3VtLCBtYXJrUmFuZ2UpID0+IHN1bSArIG1hcmtSYW5nZS50byAtIG1hcmtSYW5nZS5mcm9tLCAwKTtcbiAgICAvLyB3ZSBvbmx5IGluY2x1ZGUgdGhlIHJlc3VsdCBvZiBgZXhjbHVkZWRSYW5nZWBcbiAgICAvLyBpZiB0aGVyZSBpcyBhIG1hdGNoIGF0IGFsbFxuICAgIGNvbnN0IHJhbmdlID0gbWF0Y2hlZFJhbmdlID4gMCA/IG1hdGNoZWRSYW5nZSArIGV4Y2x1ZGVkUmFuZ2UgOiBtYXRjaGVkUmFuZ2U7XG4gICAgcmV0dXJuIHJhbmdlID49IHNlbGVjdGlvblJhbmdlO1xufVxuXG5mdW5jdGlvbiBpc0FjdGl2ZShzdGF0ZSwgbmFtZSwgYXR0cmlidXRlcyA9IHt9KSB7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICAgIHJldHVybiBpc05vZGVBY3RpdmUoc3RhdGUsIG51bGwsIGF0dHJpYnV0ZXMpIHx8IGlzTWFya0FjdGl2ZShzdGF0ZSwgbnVsbCwgYXR0cmlidXRlcyk7XG4gICAgfVxuICAgIGNvbnN0IHNjaGVtYVR5cGUgPSBnZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZShuYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICAgIGlmIChzY2hlbWFUeXBlID09PSAnbm9kZScpIHtcbiAgICAgICAgcmV0dXJuIGlzTm9kZUFjdGl2ZShzdGF0ZSwgbmFtZSwgYXR0cmlidXRlcyk7XG4gICAgfVxuICAgIGlmIChzY2hlbWFUeXBlID09PSAnbWFyaycpIHtcbiAgICAgICAgcmV0dXJuIGlzTWFya0FjdGl2ZShzdGF0ZSwgbmFtZSwgYXR0cmlidXRlcyk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuY29uc3QgaXNBdEVuZE9mTm9kZSA9IChzdGF0ZSwgbm9kZVR5cGUpID0+IHtcbiAgICBjb25zdCB7ICRmcm9tLCAkdG8sICRhbmNob3IgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAobm9kZVR5cGUpIHtcbiAgICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IGZpbmRQYXJlbnROb2RlKG5vZGUgPT4gbm9kZS50eXBlLm5hbWUgPT09IG5vZGVUeXBlKShzdGF0ZS5zZWxlY3Rpb24pO1xuICAgICAgICBpZiAoIXBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCAkcGFyZW50UG9zID0gc3RhdGUuZG9jLnJlc29sdmUocGFyZW50Tm9kZS5wb3MgKyAxKTtcbiAgICAgICAgaWYgKCRhbmNob3IucG9zICsgMSA9PT0gJHBhcmVudFBvcy5lbmQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoJHRvLnBhcmVudE9mZnNldCA8ICR0by5wYXJlbnQubm9kZVNpemUgLSAyIHx8ICRmcm9tLnBvcyAhPT0gJHRvLnBvcykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuY29uc3QgaXNBdFN0YXJ0T2ZOb2RlID0gKHN0YXRlKSA9PiB7XG4gICAgY29uc3QgeyAkZnJvbSwgJHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCRmcm9tLnBhcmVudE9mZnNldCA+IDAgfHwgJGZyb20ucG9zICE9PSAkdG8ucG9zKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBpc0xpc3QobmFtZSwgZXh0ZW5zaW9ucykge1xuICAgIGNvbnN0IHsgbm9kZUV4dGVuc2lvbnMgfSA9IHNwbGl0RXh0ZW5zaW9ucyhleHRlbnNpb25zKTtcbiAgICBjb25zdCBleHRlbnNpb24gPSBub2RlRXh0ZW5zaW9ucy5maW5kKGl0ZW0gPT4gaXRlbS5uYW1lID09PSBuYW1lKTtcbiAgICBpZiAoIWV4dGVuc2lvbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgICAgc3RvcmFnZTogZXh0ZW5zaW9uLnN0b3JhZ2UsXG4gICAgfTtcbiAgICBjb25zdCBncm91cCA9IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdncm91cCcsIGNvbnRleHQpKTtcbiAgICBpZiAodHlwZW9mIGdyb3VwICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBncm91cC5zcGxpdCgnICcpLmluY2x1ZGVzKCdsaXN0Jyk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBwcm9zZW1pcnJvciBub2RlIGlzIGVtcHR5LlxuICovXG5mdW5jdGlvbiBpc05vZGVFbXB0eShub2RlLCB7IGNoZWNrQ2hpbGRyZW4gPSB0cnVlLCBpZ25vcmVXaGl0ZXNwYWNlID0gZmFsc2UsIH0gPSB7fSkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoaWdub3JlV2hpdGVzcGFjZSkge1xuICAgICAgICBpZiAobm9kZS50eXBlLm5hbWUgPT09ICdoYXJkQnJlYWsnKSB7XG4gICAgICAgICAgICAvLyBIYXJkIGJyZWFrcyBhcmUgY29uc2lkZXJlZCBlbXB0eVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuaXNUZXh0KSB7XG4gICAgICAgICAgICByZXR1cm4gL15cXHMqJC9tLnRlc3QoKF9hID0gbm9kZS50ZXh0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUuaXNUZXh0KSB7XG4gICAgICAgIHJldHVybiAhbm9kZS50ZXh0O1xuICAgIH1cbiAgICBpZiAobm9kZS5pc0F0b20gfHwgbm9kZS5pc0xlYWYpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAobm9kZS5jb250ZW50LmNoaWxkQ291bnQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChjaGVja0NoaWxkcmVuKSB7XG4gICAgICAgIGxldCBpc0NvbnRlbnRFbXB0eSA9IHRydWU7XG4gICAgICAgIG5vZGUuY29udGVudC5mb3JFYWNoKGNoaWxkTm9kZSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNDb250ZW50RW1wdHkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgLy8gRXhpdCBlYXJseSBmb3IgcGVyZlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNOb2RlRW1wdHkoY2hpbGROb2RlLCB7IGlnbm9yZVdoaXRlc3BhY2UsIGNoZWNrQ2hpbGRyZW4gfSkpIHtcbiAgICAgICAgICAgICAgICBpc0NvbnRlbnRFbXB0eSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGlzQ29udGVudEVtcHR5O1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGlzTm9kZVNlbGVjdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb247XG59XG5cbmZ1bmN0aW9uIHBvc1RvRE9NUmVjdCh2aWV3LCBmcm9tLCB0bykge1xuICAgIGNvbnN0IG1pblBvcyA9IDA7XG4gICAgY29uc3QgbWF4UG9zID0gdmlldy5zdGF0ZS5kb2MuY29udGVudC5zaXplO1xuICAgIGNvbnN0IHJlc29sdmVkRnJvbSA9IG1pbk1heChmcm9tLCBtaW5Qb3MsIG1heFBvcyk7XG4gICAgY29uc3QgcmVzb2x2ZWRFbmQgPSBtaW5NYXgodG8sIG1pblBvcywgbWF4UG9zKTtcbiAgICBjb25zdCBzdGFydCA9IHZpZXcuY29vcmRzQXRQb3MocmVzb2x2ZWRGcm9tKTtcbiAgICBjb25zdCBlbmQgPSB2aWV3LmNvb3Jkc0F0UG9zKHJlc29sdmVkRW5kLCAtMSk7XG4gICAgY29uc3QgdG9wID0gTWF0aC5taW4oc3RhcnQudG9wLCBlbmQudG9wKTtcbiAgICBjb25zdCBib3R0b20gPSBNYXRoLm1heChzdGFydC5ib3R0b20sIGVuZC5ib3R0b20pO1xuICAgIGNvbnN0IGxlZnQgPSBNYXRoLm1pbihzdGFydC5sZWZ0LCBlbmQubGVmdCk7XG4gICAgY29uc3QgcmlnaHQgPSBNYXRoLm1heChzdGFydC5yaWdodCwgZW5kLnJpZ2h0KTtcbiAgICBjb25zdCB3aWR0aCA9IHJpZ2h0IC0gbGVmdDtcbiAgICBjb25zdCBoZWlnaHQgPSBib3R0b20gLSB0b3A7XG4gICAgY29uc3QgeCA9IGxlZnQ7XG4gICAgY29uc3QgeSA9IHRvcDtcbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICB0b3AsXG4gICAgICAgIGJvdHRvbSxcbiAgICAgICAgbGVmdCxcbiAgICAgICAgcmlnaHQsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIHgsXG4gICAgICAgIHksXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5kYXRhLFxuICAgICAgICB0b0pTT046ICgpID0+IGRhdGEsXG4gICAgfTtcbn1cblxuLyoqXG4gKiBUaGUgYWN0dWFsIGltcGxlbWVudGF0aW9uIG9mIHRoZSByZXdyaXRlVW5rbm93bkNvbnRlbnQgZnVuY3Rpb25cbiAqL1xuZnVuY3Rpb24gcmV3cml0ZVVua25vd25Db250ZW50SW5uZXIoeyBqc29uLCB2YWxpZE1hcmtzLCB2YWxpZE5vZGVzLCBvcHRpb25zLCByZXdyaXR0ZW5Db250ZW50ID0gW10sIH0pIHtcbiAgICBpZiAoanNvbi5tYXJrcyAmJiBBcnJheS5pc0FycmF5KGpzb24ubWFya3MpKSB7XG4gICAgICAgIGpzb24ubWFya3MgPSBqc29uLm1hcmtzLmZpbHRlcihtYXJrID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSB0eXBlb2YgbWFyayA9PT0gJ3N0cmluZycgPyBtYXJrIDogbWFyay50eXBlO1xuICAgICAgICAgICAgaWYgKHZhbGlkTWFya3MuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXdyaXR0ZW5Db250ZW50LnB1c2goe1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsOiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG1hcmspKSxcbiAgICAgICAgICAgICAgICB1bnN1cHBvcnRlZDogbmFtZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gSnVzdCBpZ25vcmUgYW55IHVua25vd24gbWFya3NcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChqc29uLmNvbnRlbnQgJiYgQXJyYXkuaXNBcnJheShqc29uLmNvbnRlbnQpKSB7XG4gICAgICAgIGpzb24uY29udGVudCA9IGpzb24uY29udGVudFxuICAgICAgICAgICAgLm1hcCh2YWx1ZSA9PiByZXdyaXRlVW5rbm93bkNvbnRlbnRJbm5lcih7XG4gICAgICAgICAgICBqc29uOiB2YWx1ZSxcbiAgICAgICAgICAgIHZhbGlkTWFya3MsXG4gICAgICAgICAgICB2YWxpZE5vZGVzLFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIHJld3JpdHRlbkNvbnRlbnQsXG4gICAgICAgIH0pLmpzb24pXG4gICAgICAgICAgICAuZmlsdGVyKGEgPT4gYSAhPT0gbnVsbCAmJiBhICE9PSB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBpZiAoanNvbi50eXBlICYmICF2YWxpZE5vZGVzLmhhcyhqc29uLnR5cGUpKSB7XG4gICAgICAgIHJld3JpdHRlbkNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgICBvcmlnaW5hbDogSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShqc29uKSksXG4gICAgICAgICAgICB1bnN1cHBvcnRlZDoganNvbi50eXBlLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGpzb24uY29udGVudCAmJiBBcnJheS5pc0FycmF5KGpzb24uY29udGVudCkgJiYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZmFsbGJhY2tUb1BhcmFncmFwaCkgIT09IGZhbHNlKSkge1xuICAgICAgICAgICAgLy8gSnVzdCB0cmVhdCBpdCBsaWtlIGEgcGFyYWdyYXBoIGFuZCBob3BlIGZvciB0aGUgYmVzdFxuICAgICAgICAgICAganNvbi50eXBlID0gJ3BhcmFncmFwaCc7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGpzb24sXG4gICAgICAgICAgICAgICAgcmV3cml0dGVuQ29udGVudCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3IganVzdCBvbWl0IGl0IGVudGlyZWx5XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBqc29uOiBudWxsLFxuICAgICAgICAgICAgcmV3cml0dGVuQ29udGVudCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsganNvbiwgcmV3cml0dGVuQ29udGVudCB9O1xufVxuLyoqXG4gKiBSZXdyaXRlIHVua25vd24gbm9kZXMgYW5kIG1hcmtzIHdpdGhpbiBKU09OIGNvbnRlbnRcbiAqIEFsbG93aW5nIGZvciB1c2VyIHdpdGhpbiB0aGUgZWRpdG9yXG4gKi9cbmZ1bmN0aW9uIHJld3JpdGVVbmtub3duQ29udGVudChcbi8qKlxuICogVGhlIEpTT04gY29udGVudCB0byBjbGVhbiBvZiB1bmtub3duIG5vZGVzIGFuZCBtYXJrc1xuICovXG5qc29uLCBcbi8qKlxuICogVGhlIHNjaGVtYSB0byB1c2UgZm9yIHZhbGlkYXRpb25cbiAqL1xuc2NoZW1hLCBcbi8qKlxuICogT3B0aW9ucyBmb3IgdGhlIGNsZWFuaW5nIHByb2Nlc3NcbiAqL1xub3B0aW9ucykge1xuICAgIHJldHVybiByZXdyaXRlVW5rbm93bkNvbnRlbnRJbm5lcih7XG4gICAgICAgIGpzb24sXG4gICAgICAgIHZhbGlkTm9kZXM6IG5ldyBTZXQoT2JqZWN0LmtleXMoc2NoZW1hLm5vZGVzKSksXG4gICAgICAgIHZhbGlkTWFya3M6IG5ldyBTZXQoT2JqZWN0LmtleXMoc2NoZW1hLm1hcmtzKSksXG4gICAgICAgIG9wdGlvbnMsXG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGNhblNldE1hcmsoc3RhdGUsIHRyLCBuZXdNYXJrVHlwZSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gdHI7XG4gICAgbGV0IGN1cnNvciA9IG51bGw7XG4gICAgaWYgKGlzVGV4dFNlbGVjdGlvbihzZWxlY3Rpb24pKSB7XG4gICAgICAgIGN1cnNvciA9IHNlbGVjdGlvbi4kY3Vyc29yO1xuICAgIH1cbiAgICBpZiAoY3Vyc29yKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRNYXJrcyA9IChfYSA9IHN0YXRlLnN0b3JlZE1hcmtzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjdXJzb3IubWFya3MoKTtcbiAgICAgICAgLy8gVGhlcmUgY2FuIGJlIG5vIGN1cnJlbnQgbWFya3MgdGhhdCBleGNsdWRlIHRoZSBuZXcgbWFya1xuICAgICAgICByZXR1cm4gKCEhbmV3TWFya1R5cGUuaXNJblNldChjdXJyZW50TWFya3MpXG4gICAgICAgICAgICB8fCAhY3VycmVudE1hcmtzLnNvbWUobWFyayA9PiBtYXJrLnR5cGUuZXhjbHVkZXMobmV3TWFya1R5cGUpKSk7XG4gICAgfVxuICAgIGNvbnN0IHsgcmFuZ2VzIH0gPSBzZWxlY3Rpb247XG4gICAgcmV0dXJuIHJhbmdlcy5zb21lKCh7ICRmcm9tLCAkdG8gfSkgPT4ge1xuICAgICAgICBsZXQgc29tZU5vZGVTdXBwb3J0c01hcmsgPSAkZnJvbS5kZXB0aCA9PT0gMFxuICAgICAgICAgICAgPyBzdGF0ZS5kb2MuaW5saW5lQ29udGVudCAmJiBzdGF0ZS5kb2MudHlwZS5hbGxvd3NNYXJrVHlwZShuZXdNYXJrVHlwZSlcbiAgICAgICAgICAgIDogZmFsc2U7XG4gICAgICAgIHN0YXRlLmRvYy5ub2Rlc0JldHdlZW4oJGZyb20ucG9zLCAkdG8ucG9zLCAobm9kZSwgX3BvcywgcGFyZW50KSA9PiB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBhbHJlYWR5IGZvdW5kIGEgbWFyayB0aGF0IHdlIGNhbiBlbmFibGUsIHJldHVybiBmYWxzZSB0byBieXBhc3MgdGhlIHJlbWFpbmluZyBzZWFyY2hcbiAgICAgICAgICAgIGlmIChzb21lTm9kZVN1cHBvcnRzTWFyaykge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub2RlLmlzSW5saW5lKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50QWxsb3dzTWFya1R5cGUgPSAhcGFyZW50IHx8IHBhcmVudC50eXBlLmFsbG93c01hcmtUeXBlKG5ld01hcmtUeXBlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50TWFya3NBbGxvd01hcmtUeXBlID0gISFuZXdNYXJrVHlwZS5pc0luU2V0KG5vZGUubWFya3MpXG4gICAgICAgICAgICAgICAgICAgIHx8ICFub2RlLm1hcmtzLnNvbWUob3RoZXJNYXJrID0+IG90aGVyTWFyay50eXBlLmV4Y2x1ZGVzKG5ld01hcmtUeXBlKSk7XG4gICAgICAgICAgICAgICAgc29tZU5vZGVTdXBwb3J0c01hcmsgPSBwYXJlbnRBbGxvd3NNYXJrVHlwZSAmJiBjdXJyZW50TWFya3NBbGxvd01hcmtUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICFzb21lTm9kZVN1cHBvcnRzTWFyaztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzb21lTm9kZVN1cHBvcnRzTWFyaztcbiAgICB9KTtcbn1cbmNvbnN0IHNldE1hcmsgPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyB0ciwgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gdHI7XG4gICAgY29uc3QgeyBlbXB0eSwgcmFuZ2VzIH0gPSBzZWxlY3Rpb247XG4gICAgY29uc3QgdHlwZSA9IGdldE1hcmtUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIGlmIChlbXB0eSkge1xuICAgICAgICAgICAgY29uc3Qgb2xkQXR0cmlidXRlcyA9IGdldE1hcmtBdHRyaWJ1dGVzKHN0YXRlLCB0eXBlKTtcbiAgICAgICAgICAgIHRyLmFkZFN0b3JlZE1hcmsodHlwZS5jcmVhdGUoe1xuICAgICAgICAgICAgICAgIC4uLm9sZEF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgLi4uYXR0cmlidXRlcyxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJhbmdlcy5mb3JFYWNoKHJhbmdlID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmcm9tID0gcmFuZ2UuJGZyb20ucG9zO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvID0gcmFuZ2UuJHRvLnBvcztcbiAgICAgICAgICAgICAgICBzdGF0ZS5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyaW1tZWRGcm9tID0gTWF0aC5tYXgocG9zLCBmcm9tKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJpbW1lZFRvID0gTWF0aC5taW4ocG9zICsgbm9kZS5ub2RlU2l6ZSwgdG8pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzb21lSGFzTWFyayA9IG5vZGUubWFya3MuZmluZChtYXJrID0+IG1hcmsudHlwZSA9PT0gdHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGFscmVhZHkgYSBtYXJrIG9mIHRoaXMgdHlwZVxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBrbm93IHRoYXQgd2UgaGF2ZSB0byBtZXJnZSBpdHMgYXR0cmlidXRlc1xuICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2Ugd2UgYWRkIGEgZnJlc2ggbmV3IG1hcmtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvbWVIYXNNYXJrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLm1hcmtzLmZvckVhY2gobWFyayA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IG1hcmsudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ci5hZGRNYXJrKHRyaW1tZWRGcm9tLCB0cmltbWVkVG8sIHR5cGUuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLm1hcmsuYXR0cnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ci5hZGRNYXJrKHRyaW1tZWRGcm9tLCB0cmltbWVkVG8sIHR5cGUuY3JlYXRlKGF0dHJpYnV0ZXMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNhblNldE1hcmsoc3RhdGUsIHRyLCB0eXBlKTtcbn07XG5cbmNvbnN0IHNldE1ldGEgPSAoa2V5LCB2YWx1ZSkgPT4gKHsgdHIgfSkgPT4ge1xuICAgIHRyLnNldE1ldGEoa2V5LCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCBzZXROb2RlID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoLCBjaGFpbiB9KSA9PiB7XG4gICAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gICAgbGV0IGF0dHJpYnV0ZXNUb0NvcHk7XG4gICAgaWYgKHN0YXRlLnNlbGVjdGlvbi4kYW5jaG9yLnNhbWVQYXJlbnQoc3RhdGUuc2VsZWN0aW9uLiRoZWFkKSkge1xuICAgICAgICAvLyBvbmx5IGNvcHkgYXR0cmlidXRlcyBpZiB0aGUgc2VsZWN0aW9uIGlzIHBvaW50aW5nIHRvIGEgbm9kZSBvZiB0aGUgc2FtZSB0eXBlXG4gICAgICAgIGF0dHJpYnV0ZXNUb0NvcHkgPSBzdGF0ZS5zZWxlY3Rpb24uJGFuY2hvci5wYXJlbnQuYXR0cnM7XG4gICAgfVxuICAgIC8vIFRPRE86IHVzZSBhIGZhbGxiYWNrIGxpa2UgaW5zZXJ0Q29udGVudD9cbiAgICBpZiAoIXR5cGUuaXNUZXh0YmxvY2spIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdbdGlwdGFwIHdhcm5dOiBDdXJyZW50bHkgXCJzZXROb2RlKClcIiBvbmx5IHN1cHBvcnRzIHRleHQgYmxvY2sgbm9kZXMuJyk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIChjaGFpbigpXG4gICAgICAgIC8vIHRyeSB0byBjb252ZXJ0IG5vZGUgdG8gZGVmYXVsdCBub2RlIGlmIG5lZWRlZFxuICAgICAgICAuY29tbWFuZCgoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgIGNvbnN0IGNhblNldEJsb2NrID0gc2V0QmxvY2tUeXBlKHR5cGUsIHsgLi4uYXR0cmlidXRlc1RvQ29weSwgLi4uYXR0cmlidXRlcyB9KShzdGF0ZSk7XG4gICAgICAgIGlmIChjYW5TZXRCbG9jaykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLmNsZWFyTm9kZXMoKTtcbiAgICB9KVxuICAgICAgICAuY29tbWFuZCgoeyBzdGF0ZTogdXBkYXRlZFN0YXRlIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIHNldEJsb2NrVHlwZSh0eXBlLCB7IC4uLmF0dHJpYnV0ZXNUb0NvcHksIC4uLmF0dHJpYnV0ZXMgfSkodXBkYXRlZFN0YXRlLCBkaXNwYXRjaCk7XG4gICAgfSlcbiAgICAgICAgLnJ1bigpKTtcbn07XG5cbmNvbnN0IHNldE5vZGVTZWxlY3Rpb24gPSBwb3NpdGlvbiA9PiAoeyB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICBjb25zdCB7IGRvYyB9ID0gdHI7XG4gICAgICAgIGNvbnN0IGZyb20gPSBtaW5NYXgocG9zaXRpb24sIDAsIGRvYy5jb250ZW50LnNpemUpO1xuICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBOb2RlU2VsZWN0aW9uLmNyZWF0ZShkb2MsIGZyb20pO1xuICAgICAgICB0ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCBzZXRUZXh0U2VsZWN0aW9uID0gcG9zaXRpb24gPT4gKHsgdHIsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgY29uc3QgeyBkb2MgfSA9IHRyO1xuICAgICAgICBjb25zdCB7IGZyb20sIHRvIH0gPSB0eXBlb2YgcG9zaXRpb24gPT09ICdudW1iZXInID8geyBmcm9tOiBwb3NpdGlvbiwgdG86IHBvc2l0aW9uIH0gOiBwb3NpdGlvbjtcbiAgICAgICAgY29uc3QgbWluUG9zID0gVGV4dFNlbGVjdGlvbi5hdFN0YXJ0KGRvYykuZnJvbTtcbiAgICAgICAgY29uc3QgbWF4UG9zID0gVGV4dFNlbGVjdGlvbi5hdEVuZChkb2MpLnRvO1xuICAgICAgICBjb25zdCByZXNvbHZlZEZyb20gPSBtaW5NYXgoZnJvbSwgbWluUG9zLCBtYXhQb3MpO1xuICAgICAgICBjb25zdCByZXNvbHZlZEVuZCA9IG1pbk1heCh0bywgbWluUG9zLCBtYXhQb3MpO1xuICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBUZXh0U2VsZWN0aW9uLmNyZWF0ZShkb2MsIHJlc29sdmVkRnJvbSwgcmVzb2x2ZWRFbmQpO1xuICAgICAgICB0ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCBzaW5rTGlzdEl0ZW0gPSB0eXBlT3JOYW1lID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gICAgcmV0dXJuIHNpbmtMaXN0SXRlbSQxKHR5cGUpKHN0YXRlLCBkaXNwYXRjaCk7XG59O1xuXG5mdW5jdGlvbiBlbnN1cmVNYXJrcyhzdGF0ZSwgc3BsaXR0YWJsZU1hcmtzKSB7XG4gICAgY29uc3QgbWFya3MgPSBzdGF0ZS5zdG9yZWRNYXJrcyB8fCAoc3RhdGUuc2VsZWN0aW9uLiR0by5wYXJlbnRPZmZzZXQgJiYgc3RhdGUuc2VsZWN0aW9uLiRmcm9tLm1hcmtzKCkpO1xuICAgIGlmIChtYXJrcykge1xuICAgICAgICBjb25zdCBmaWx0ZXJlZE1hcmtzID0gbWFya3MuZmlsdGVyKG1hcmsgPT4gc3BsaXR0YWJsZU1hcmtzID09PSBudWxsIHx8IHNwbGl0dGFibGVNYXJrcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3BsaXR0YWJsZU1hcmtzLmluY2x1ZGVzKG1hcmsudHlwZS5uYW1lKSk7XG4gICAgICAgIHN0YXRlLnRyLmVuc3VyZU1hcmtzKGZpbHRlcmVkTWFya3MpO1xuICAgIH1cbn1cbmNvbnN0IHNwbGl0QmxvY2sgPSAoeyBrZWVwTWFya3MgPSB0cnVlIH0gPSB7fSkgPT4gKHsgdHIsIHN0YXRlLCBkaXNwYXRjaCwgZWRpdG9yLCB9KSA9PiB7XG4gICAgY29uc3QgeyBzZWxlY3Rpb24sIGRvYyB9ID0gdHI7XG4gICAgY29uc3QgeyAkZnJvbSwgJHRvIH0gPSBzZWxlY3Rpb247XG4gICAgY29uc3QgZXh0ZW5zaW9uQXR0cmlidXRlcyA9IGVkaXRvci5leHRlbnNpb25NYW5hZ2VyLmF0dHJpYnV0ZXM7XG4gICAgY29uc3QgbmV3QXR0cmlidXRlcyA9IGdldFNwbGl0dGVkQXR0cmlidXRlcyhleHRlbnNpb25BdHRyaWJ1dGVzLCAkZnJvbS5ub2RlKCkudHlwZS5uYW1lLCAkZnJvbS5ub2RlKCkuYXR0cnMpO1xuICAgIGlmIChzZWxlY3Rpb24gaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uICYmIHNlbGVjdGlvbi5ub2RlLmlzQmxvY2spIHtcbiAgICAgICAgaWYgKCEkZnJvbS5wYXJlbnRPZmZzZXQgfHwgIWNhblNwbGl0KGRvYywgJGZyb20ucG9zKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgaWYgKGtlZXBNYXJrcykge1xuICAgICAgICAgICAgICAgIGVuc3VyZU1hcmtzKHN0YXRlLCBlZGl0b3IuZXh0ZW5zaW9uTWFuYWdlci5zcGxpdHRhYmxlTWFya3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHIuc3BsaXQoJGZyb20ucG9zKS5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoISRmcm9tLnBhcmVudC5pc0Jsb2NrKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgYXRFbmQgPSAkdG8ucGFyZW50T2Zmc2V0ID09PSAkdG8ucGFyZW50LmNvbnRlbnQuc2l6ZTtcbiAgICBjb25zdCBkZWZsdCA9ICRmcm9tLmRlcHRoID09PSAwXG4gICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgIDogZGVmYXVsdEJsb2NrQXQoJGZyb20ubm9kZSgtMSkuY29udGVudE1hdGNoQXQoJGZyb20uaW5kZXhBZnRlcigtMSkpKTtcbiAgICBsZXQgdHlwZXMgPSBhdEVuZCAmJiBkZWZsdFxuICAgICAgICA/IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBkZWZsdCxcbiAgICAgICAgICAgICAgICBhdHRyczogbmV3QXR0cmlidXRlcyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgbGV0IGNhbiA9IGNhblNwbGl0KHRyLmRvYywgdHIubWFwcGluZy5tYXAoJGZyb20ucG9zKSwgMSwgdHlwZXMpO1xuICAgIGlmICghdHlwZXNcbiAgICAgICAgJiYgIWNhblxuICAgICAgICAmJiBjYW5TcGxpdCh0ci5kb2MsIHRyLm1hcHBpbmcubWFwKCRmcm9tLnBvcyksIDEsIGRlZmx0ID8gW3sgdHlwZTogZGVmbHQgfV0gOiB1bmRlZmluZWQpKSB7XG4gICAgICAgIGNhbiA9IHRydWU7XG4gICAgICAgIHR5cGVzID0gZGVmbHRcbiAgICAgICAgICAgID8gW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogZGVmbHQsXG4gICAgICAgICAgICAgICAgICAgIGF0dHJzOiBuZXdBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIGlmIChjYW4pIHtcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24gaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdHIuZGVsZXRlU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ci5zcGxpdCh0ci5tYXBwaW5nLm1hcCgkZnJvbS5wb3MpLCAxLCB0eXBlcyk7XG4gICAgICAgICAgICBpZiAoZGVmbHQgJiYgIWF0RW5kICYmICEkZnJvbS5wYXJlbnRPZmZzZXQgJiYgJGZyb20ucGFyZW50LnR5cGUgIT09IGRlZmx0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlyc3QgPSB0ci5tYXBwaW5nLm1hcCgkZnJvbS5iZWZvcmUoKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgJGZpcnN0ID0gdHIuZG9jLnJlc29sdmUoZmlyc3QpO1xuICAgICAgICAgICAgICAgIGlmICgkZnJvbS5ub2RlKC0xKS5jYW5SZXBsYWNlV2l0aCgkZmlyc3QuaW5kZXgoKSwgJGZpcnN0LmluZGV4KCkgKyAxLCBkZWZsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cCh0ci5tYXBwaW5nLm1hcCgkZnJvbS5iZWZvcmUoKSksIGRlZmx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGtlZXBNYXJrcykge1xuICAgICAgICAgICAgZW5zdXJlTWFya3Moc3RhdGUsIGVkaXRvci5leHRlbnNpb25NYW5hZ2VyLnNwbGl0dGFibGVNYXJrcyk7XG4gICAgICAgIH1cbiAgICAgICAgdHIuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbjtcbn07XG5cbmNvbnN0IHNwbGl0TGlzdEl0ZW0gPSAodHlwZU9yTmFtZSwgb3ZlcnJpZGVBdHRycyA9IHt9KSA9PiAoeyB0ciwgc3RhdGUsIGRpc3BhdGNoLCBlZGl0b3IsIH0pID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gICAgY29uc3QgeyAkZnJvbSwgJHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgIGNvbnN0IG5vZGUgPSBzdGF0ZS5zZWxlY3Rpb24ubm9kZTtcbiAgICBpZiAoKG5vZGUgJiYgbm9kZS5pc0Jsb2NrKSB8fCAkZnJvbS5kZXB0aCA8IDIgfHwgISRmcm9tLnNhbWVQYXJlbnQoJHRvKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IGdyYW5kUGFyZW50ID0gJGZyb20ubm9kZSgtMSk7XG4gICAgaWYgKGdyYW5kUGFyZW50LnR5cGUgIT09IHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBleHRlbnNpb25BdHRyaWJ1dGVzID0gZWRpdG9yLmV4dGVuc2lvbk1hbmFnZXIuYXR0cmlidXRlcztcbiAgICBpZiAoJGZyb20ucGFyZW50LmNvbnRlbnQuc2l6ZSA9PT0gMCAmJiAkZnJvbS5ub2RlKC0xKS5jaGlsZENvdW50ID09PSAkZnJvbS5pbmRleEFmdGVyKC0xKSkge1xuICAgICAgICAvLyBJbiBhbiBlbXB0eSBibG9jay4gSWYgdGhpcyBpcyBhIG5lc3RlZCBsaXN0LCB0aGUgd3JhcHBpbmdcbiAgICAgICAgLy8gbGlzdCBpdGVtIHNob3VsZCBiZSBzcGxpdC4gT3RoZXJ3aXNlLCBiYWlsIG91dCBhbmQgbGV0IG5leHRcbiAgICAgICAgLy8gY29tbWFuZCBoYW5kbGUgbGlmdGluZy5cbiAgICAgICAgaWYgKCRmcm9tLmRlcHRoID09PSAyXG4gICAgICAgICAgICB8fCAkZnJvbS5ub2RlKC0zKS50eXBlICE9PSB0eXBlXG4gICAgICAgICAgICB8fCAkZnJvbS5pbmRleCgtMikgIT09ICRmcm9tLm5vZGUoLTIpLmNoaWxkQ291bnQgLSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICBsZXQgd3JhcCA9IEZyYWdtZW50LmVtcHR5O1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICBjb25zdCBkZXB0aEJlZm9yZSA9ICRmcm9tLmluZGV4KC0xKSA/IDEgOiAkZnJvbS5pbmRleCgtMikgPyAyIDogMztcbiAgICAgICAgICAgIC8vIEJ1aWxkIGEgZnJhZ21lbnQgY29udGFpbmluZyBlbXB0eSB2ZXJzaW9ucyBvZiB0aGUgc3RydWN0dXJlXG4gICAgICAgICAgICAvLyBmcm9tIHRoZSBvdXRlciBsaXN0IGl0ZW0gdG8gdGhlIHBhcmVudCBub2RlIG9mIHRoZSBjdXJzb3JcbiAgICAgICAgICAgIGZvciAobGV0IGQgPSAkZnJvbS5kZXB0aCAtIGRlcHRoQmVmb3JlOyBkID49ICRmcm9tLmRlcHRoIC0gMzsgZCAtPSAxKSB7XG4gICAgICAgICAgICAgICAgd3JhcCA9IEZyYWdtZW50LmZyb20oJGZyb20ubm9kZShkKS5jb3B5KHdyYXApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICAgICAgY29uc3QgZGVwdGhBZnRlciA9ICRmcm9tLmluZGV4QWZ0ZXIoLTEpIDwgJGZyb20ubm9kZSgtMikuY2hpbGRDb3VudCA/IDEgOiAkZnJvbS5pbmRleEFmdGVyKC0yKSA8ICRmcm9tLm5vZGUoLTMpLmNoaWxkQ291bnQgPyAyIDogMztcbiAgICAgICAgICAgIC8vIEFkZCBhIHNlY29uZCBsaXN0IGl0ZW0gd2l0aCBhbiBlbXB0eSBkZWZhdWx0IHN0YXJ0IG5vZGVcbiAgICAgICAgICAgIGNvbnN0IG5ld05leHRUeXBlQXR0cmlidXRlcyA9IHtcbiAgICAgICAgICAgICAgICAuLi5nZXRTcGxpdHRlZEF0dHJpYnV0ZXMoZXh0ZW5zaW9uQXR0cmlidXRlcywgJGZyb20ubm9kZSgpLnR5cGUubmFtZSwgJGZyb20ubm9kZSgpLmF0dHJzKSxcbiAgICAgICAgICAgICAgICAuLi5vdmVycmlkZUF0dHJzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IG5leHRUeXBlID0gKChfYSA9IHR5cGUuY29udGVudE1hdGNoLmRlZmF1bHRUeXBlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY3JlYXRlQW5kRmlsbChuZXdOZXh0VHlwZUF0dHJpYnV0ZXMpKSB8fCB1bmRlZmluZWQ7XG4gICAgICAgICAgICB3cmFwID0gd3JhcC5hcHBlbmQoRnJhZ21lbnQuZnJvbSh0eXBlLmNyZWF0ZUFuZEZpbGwobnVsbCwgbmV4dFR5cGUpIHx8IHVuZGVmaW5lZCkpO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSAkZnJvbS5iZWZvcmUoJGZyb20uZGVwdGggLSAoZGVwdGhCZWZvcmUgLSAxKSk7XG4gICAgICAgICAgICB0ci5yZXBsYWNlKHN0YXJ0LCAkZnJvbS5hZnRlcigtZGVwdGhBZnRlciksIG5ldyBTbGljZSh3cmFwLCA0IC0gZGVwdGhCZWZvcmUsIDApKTtcbiAgICAgICAgICAgIGxldCBzZWwgPSAtMTtcbiAgICAgICAgICAgIHRyLmRvYy5ub2Rlc0JldHdlZW4oc3RhcnQsIHRyLmRvYy5jb250ZW50LnNpemUsIChuLCBwb3MpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoc2VsID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobi5pc1RleHRibG9jayAmJiBuLmNvbnRlbnQuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzZWwgPSBwb3MgKyAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHNlbCA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24ubmVhcih0ci5kb2MucmVzb2x2ZShzZWwpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ci5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBuZXh0VHlwZSA9ICR0by5wb3MgPT09ICRmcm9tLmVuZCgpID8gZ3JhbmRQYXJlbnQuY29udGVudE1hdGNoQXQoMCkuZGVmYXVsdFR5cGUgOiBudWxsO1xuICAgIGNvbnN0IG5ld1R5cGVBdHRyaWJ1dGVzID0ge1xuICAgICAgICAuLi5nZXRTcGxpdHRlZEF0dHJpYnV0ZXMoZXh0ZW5zaW9uQXR0cmlidXRlcywgZ3JhbmRQYXJlbnQudHlwZS5uYW1lLCBncmFuZFBhcmVudC5hdHRycyksXG4gICAgICAgIC4uLm92ZXJyaWRlQXR0cnMsXG4gICAgfTtcbiAgICBjb25zdCBuZXdOZXh0VHlwZUF0dHJpYnV0ZXMgPSB7XG4gICAgICAgIC4uLmdldFNwbGl0dGVkQXR0cmlidXRlcyhleHRlbnNpb25BdHRyaWJ1dGVzLCAkZnJvbS5ub2RlKCkudHlwZS5uYW1lLCAkZnJvbS5ub2RlKCkuYXR0cnMpLFxuICAgICAgICAuLi5vdmVycmlkZUF0dHJzLFxuICAgIH07XG4gICAgdHIuZGVsZXRlKCRmcm9tLnBvcywgJHRvLnBvcyk7XG4gICAgY29uc3QgdHlwZXMgPSBuZXh0VHlwZVxuICAgICAgICA/IFtcbiAgICAgICAgICAgIHsgdHlwZSwgYXR0cnM6IG5ld1R5cGVBdHRyaWJ1dGVzIH0sXG4gICAgICAgICAgICB7IHR5cGU6IG5leHRUeXBlLCBhdHRyczogbmV3TmV4dFR5cGVBdHRyaWJ1dGVzIH0sXG4gICAgICAgIF1cbiAgICAgICAgOiBbeyB0eXBlLCBhdHRyczogbmV3VHlwZUF0dHJpYnV0ZXMgfV07XG4gICAgaWYgKCFjYW5TcGxpdCh0ci5kb2MsICRmcm9tLnBvcywgMikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgY29uc3QgeyBzZWxlY3Rpb24sIHN0b3JlZE1hcmtzIH0gPSBzdGF0ZTtcbiAgICAgICAgY29uc3QgeyBzcGxpdHRhYmxlTWFya3MgfSA9IGVkaXRvci5leHRlbnNpb25NYW5hZ2VyO1xuICAgICAgICBjb25zdCBtYXJrcyA9IHN0b3JlZE1hcmtzIHx8IChzZWxlY3Rpb24uJHRvLnBhcmVudE9mZnNldCAmJiBzZWxlY3Rpb24uJGZyb20ubWFya3MoKSk7XG4gICAgICAgIHRyLnNwbGl0KCRmcm9tLnBvcywgMiwgdHlwZXMpLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgIGlmICghbWFya3MgfHwgIWRpc3BhdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaWx0ZXJlZE1hcmtzID0gbWFya3MuZmlsdGVyKG1hcmsgPT4gc3BsaXR0YWJsZU1hcmtzLmluY2x1ZGVzKG1hcmsudHlwZS5uYW1lKSk7XG4gICAgICAgIHRyLmVuc3VyZU1hcmtzKGZpbHRlcmVkTWFya3MpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbmNvbnN0IGpvaW5MaXN0QmFja3dhcmRzID0gKHRyLCBsaXN0VHlwZSkgPT4ge1xuICAgIGNvbnN0IGxpc3QgPSBmaW5kUGFyZW50Tm9kZShub2RlID0+IG5vZGUudHlwZSA9PT0gbGlzdFR5cGUpKHRyLnNlbGVjdGlvbik7XG4gICAgaWYgKCFsaXN0KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBiZWZvcmUgPSB0ci5kb2MucmVzb2x2ZShNYXRoLm1heCgwLCBsaXN0LnBvcyAtIDEpKS5iZWZvcmUobGlzdC5kZXB0aCk7XG4gICAgaWYgKGJlZm9yZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBub2RlQmVmb3JlID0gdHIuZG9jLm5vZGVBdChiZWZvcmUpO1xuICAgIGNvbnN0IGNhbkpvaW5CYWNrd2FyZHMgPSBsaXN0Lm5vZGUudHlwZSA9PT0gKG5vZGVCZWZvcmUgPT09IG51bGwgfHwgbm9kZUJlZm9yZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZUJlZm9yZS50eXBlKSAmJiBjYW5Kb2luKHRyLmRvYywgbGlzdC5wb3MpO1xuICAgIGlmICghY2FuSm9pbkJhY2t3YXJkcykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdHIuam9pbihsaXN0LnBvcyk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuY29uc3Qgam9pbkxpc3RGb3J3YXJkcyA9ICh0ciwgbGlzdFR5cGUpID0+IHtcbiAgICBjb25zdCBsaXN0ID0gZmluZFBhcmVudE5vZGUobm9kZSA9PiBub2RlLnR5cGUgPT09IGxpc3RUeXBlKSh0ci5zZWxlY3Rpb24pO1xuICAgIGlmICghbGlzdCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgYWZ0ZXIgPSB0ci5kb2MucmVzb2x2ZShsaXN0LnN0YXJ0KS5hZnRlcihsaXN0LmRlcHRoKTtcbiAgICBpZiAoYWZ0ZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3Qgbm9kZUFmdGVyID0gdHIuZG9jLm5vZGVBdChhZnRlcik7XG4gICAgY29uc3QgY2FuSm9pbkZvcndhcmRzID0gbGlzdC5ub2RlLnR5cGUgPT09IChub2RlQWZ0ZXIgPT09IG51bGwgfHwgbm9kZUFmdGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlQWZ0ZXIudHlwZSkgJiYgY2FuSm9pbih0ci5kb2MsIGFmdGVyKTtcbiAgICBpZiAoIWNhbkpvaW5Gb3J3YXJkcykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdHIuam9pbihhZnRlcik7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuY29uc3QgdG9nZ2xlTGlzdCA9IChsaXN0VHlwZU9yTmFtZSwgaXRlbVR5cGVPck5hbWUsIGtlZXBNYXJrcywgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyBlZGl0b3IsIHRyLCBzdGF0ZSwgZGlzcGF0Y2gsIGNoYWluLCBjb21tYW5kcywgY2FuLCB9KSA9PiB7XG4gICAgY29uc3QgeyBleHRlbnNpb25zLCBzcGxpdHRhYmxlTWFya3MgfSA9IGVkaXRvci5leHRlbnNpb25NYW5hZ2VyO1xuICAgIGNvbnN0IGxpc3RUeXBlID0gZ2V0Tm9kZVR5cGUobGlzdFR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gICAgY29uc3QgaXRlbVR5cGUgPSBnZXROb2RlVHlwZShpdGVtVHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgICBjb25zdCB7IHNlbGVjdGlvbiwgc3RvcmVkTWFya3MgfSA9IHN0YXRlO1xuICAgIGNvbnN0IHsgJGZyb20sICR0byB9ID0gc2VsZWN0aW9uO1xuICAgIGNvbnN0IHJhbmdlID0gJGZyb20uYmxvY2tSYW5nZSgkdG8pO1xuICAgIGNvbnN0IG1hcmtzID0gc3RvcmVkTWFya3MgfHwgKHNlbGVjdGlvbi4kdG8ucGFyZW50T2Zmc2V0ICYmIHNlbGVjdGlvbi4kZnJvbS5tYXJrcygpKTtcbiAgICBpZiAoIXJhbmdlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgcGFyZW50TGlzdCA9IGZpbmRQYXJlbnROb2RlKG5vZGUgPT4gaXNMaXN0KG5vZGUudHlwZS5uYW1lLCBleHRlbnNpb25zKSkoc2VsZWN0aW9uKTtcbiAgICBpZiAocmFuZ2UuZGVwdGggPj0gMSAmJiBwYXJlbnRMaXN0ICYmIHJhbmdlLmRlcHRoIC0gcGFyZW50TGlzdC5kZXB0aCA8PSAxKSB7XG4gICAgICAgIC8vIHJlbW92ZSBsaXN0XG4gICAgICAgIGlmIChwYXJlbnRMaXN0Lm5vZGUudHlwZSA9PT0gbGlzdFR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy5saWZ0TGlzdEl0ZW0oaXRlbVR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNoYW5nZSBsaXN0IHR5cGVcbiAgICAgICAgaWYgKGlzTGlzdChwYXJlbnRMaXN0Lm5vZGUudHlwZS5uYW1lLCBleHRlbnNpb25zKVxuICAgICAgICAgICAgJiYgbGlzdFR5cGUudmFsaWRDb250ZW50KHBhcmVudExpc3Qubm9kZS5jb250ZW50KVxuICAgICAgICAgICAgJiYgZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGFpbigpXG4gICAgICAgICAgICAgICAgLmNvbW1hbmQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyLnNldE5vZGVNYXJrdXAocGFyZW50TGlzdC5wb3MsIGxpc3RUeXBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNvbW1hbmQoKCkgPT4gam9pbkxpc3RCYWNrd2FyZHModHIsIGxpc3RUeXBlKSlcbiAgICAgICAgICAgICAgICAuY29tbWFuZCgoKSA9PiBqb2luTGlzdEZvcndhcmRzKHRyLCBsaXN0VHlwZSkpXG4gICAgICAgICAgICAgICAgLnJ1bigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICgha2VlcE1hcmtzIHx8ICFtYXJrcyB8fCAhZGlzcGF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIGNoYWluKClcbiAgICAgICAgICAgIC8vIHRyeSB0byBjb252ZXJ0IG5vZGUgdG8gZGVmYXVsdCBub2RlIGlmIG5lZWRlZFxuICAgICAgICAgICAgLmNvbW1hbmQoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2FuV3JhcEluTGlzdCA9IGNhbigpLndyYXBJbkxpc3QobGlzdFR5cGUsIGF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgaWYgKGNhbldyYXBJbkxpc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy5jbGVhck5vZGVzKCk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAud3JhcEluTGlzdChsaXN0VHlwZSwgYXR0cmlidXRlcylcbiAgICAgICAgICAgIC5jb21tYW5kKCgpID0+IGpvaW5MaXN0QmFja3dhcmRzKHRyLCBsaXN0VHlwZSkpXG4gICAgICAgICAgICAuY29tbWFuZCgoKSA9PiBqb2luTGlzdEZvcndhcmRzKHRyLCBsaXN0VHlwZSkpXG4gICAgICAgICAgICAucnVuKCk7XG4gICAgfVxuICAgIHJldHVybiAoY2hhaW4oKVxuICAgICAgICAvLyB0cnkgdG8gY29udmVydCBub2RlIHRvIGRlZmF1bHQgbm9kZSBpZiBuZWVkZWRcbiAgICAgICAgLmNvbW1hbmQoKCkgPT4ge1xuICAgICAgICBjb25zdCBjYW5XcmFwSW5MaXN0ID0gY2FuKCkud3JhcEluTGlzdChsaXN0VHlwZSwgYXR0cmlidXRlcyk7XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkTWFya3MgPSBtYXJrcy5maWx0ZXIobWFyayA9PiBzcGxpdHRhYmxlTWFya3MuaW5jbHVkZXMobWFyay50eXBlLm5hbWUpKTtcbiAgICAgICAgdHIuZW5zdXJlTWFya3MoZmlsdGVyZWRNYXJrcyk7XG4gICAgICAgIGlmIChjYW5XcmFwSW5MaXN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tbWFuZHMuY2xlYXJOb2RlcygpO1xuICAgIH0pXG4gICAgICAgIC53cmFwSW5MaXN0KGxpc3RUeXBlLCBhdHRyaWJ1dGVzKVxuICAgICAgICAuY29tbWFuZCgoKSA9PiBqb2luTGlzdEJhY2t3YXJkcyh0ciwgbGlzdFR5cGUpKVxuICAgICAgICAuY29tbWFuZCgoKSA9PiBqb2luTGlzdEZvcndhcmRzKHRyLCBsaXN0VHlwZSkpXG4gICAgICAgIC5ydW4oKSk7XG59O1xuXG5jb25zdCB0b2dnbGVNYXJrID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSwgb3B0aW9ucyA9IHt9KSA9PiAoeyBzdGF0ZSwgY29tbWFuZHMgfSkgPT4ge1xuICAgIGNvbnN0IHsgZXh0ZW5kRW1wdHlNYXJrUmFuZ2UgPSBmYWxzZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCB0eXBlID0gZ2V0TWFya1R5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgICBjb25zdCBpc0FjdGl2ZSA9IGlzTWFya0FjdGl2ZShzdGF0ZSwgdHlwZSwgYXR0cmlidXRlcyk7XG4gICAgaWYgKGlzQWN0aXZlKSB7XG4gICAgICAgIHJldHVybiBjb21tYW5kcy51bnNldE1hcmsodHlwZSwgeyBleHRlbmRFbXB0eU1hcmtSYW5nZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbW1hbmRzLnNldE1hcmsodHlwZSwgYXR0cmlidXRlcyk7XG59O1xuXG5jb25zdCB0b2dnbGVOb2RlID0gKHR5cGVPck5hbWUsIHRvZ2dsZVR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkgPT4gKHsgc3RhdGUsIGNvbW1hbmRzIH0pID0+IHtcbiAgICBjb25zdCB0eXBlID0gZ2V0Tm9kZVR5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgICBjb25zdCB0b2dnbGVUeXBlID0gZ2V0Tm9kZVR5cGUodG9nZ2xlVHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgICBjb25zdCBpc0FjdGl2ZSA9IGlzTm9kZUFjdGl2ZShzdGF0ZSwgdHlwZSwgYXR0cmlidXRlcyk7XG4gICAgbGV0IGF0dHJpYnV0ZXNUb0NvcHk7XG4gICAgaWYgKHN0YXRlLnNlbGVjdGlvbi4kYW5jaG9yLnNhbWVQYXJlbnQoc3RhdGUuc2VsZWN0aW9uLiRoZWFkKSkge1xuICAgICAgICAvLyBvbmx5IGNvcHkgYXR0cmlidXRlcyBpZiB0aGUgc2VsZWN0aW9uIGlzIHBvaW50aW5nIHRvIGEgbm9kZSBvZiB0aGUgc2FtZSB0eXBlXG4gICAgICAgIGF0dHJpYnV0ZXNUb0NvcHkgPSBzdGF0ZS5zZWxlY3Rpb24uJGFuY2hvci5wYXJlbnQuYXR0cnM7XG4gICAgfVxuICAgIGlmIChpc0FjdGl2ZSkge1xuICAgICAgICByZXR1cm4gY29tbWFuZHMuc2V0Tm9kZSh0b2dnbGVUeXBlLCBhdHRyaWJ1dGVzVG9Db3B5KTtcbiAgICB9XG4gICAgLy8gSWYgdGhlIG5vZGUgaXMgbm90IGFjdGl2ZSwgd2Ugd2FudCB0byBzZXQgdGhlIG5ldyBub2RlIHR5cGUgd2l0aCB0aGUgZ2l2ZW4gYXR0cmlidXRlc1xuICAgIC8vIENvcHlpbmcgb3ZlciB0aGUgYXR0cmlidXRlcyBmcm9tIHRoZSBjdXJyZW50IG5vZGUgaWYgdGhlIHNlbGVjdGlvbiBpcyBwb2ludGluZyB0byBhIG5vZGUgb2YgdGhlIHNhbWUgdHlwZVxuICAgIHJldHVybiBjb21tYW5kcy5zZXROb2RlKHR5cGUsIHsgLi4uYXR0cmlidXRlc1RvQ29weSwgLi4uYXR0cmlidXRlcyB9KTtcbn07XG5cbmNvbnN0IHRvZ2dsZVdyYXAgPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyBzdGF0ZSwgY29tbWFuZHMgfSkgPT4ge1xuICAgIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICAgIGNvbnN0IGlzQWN0aXZlID0gaXNOb2RlQWN0aXZlKHN0YXRlLCB0eXBlLCBhdHRyaWJ1dGVzKTtcbiAgICBpZiAoaXNBY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLmxpZnQodHlwZSk7XG4gICAgfVxuICAgIHJldHVybiBjb21tYW5kcy53cmFwSW4odHlwZSwgYXR0cmlidXRlcyk7XG59O1xuXG5jb25zdCB1bmRvSW5wdXRSdWxlID0gKCkgPT4gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBjb25zdCBwbHVnaW5zID0gc3RhdGUucGx1Z2lucztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3QgcGx1Z2luID0gcGx1Z2luc1tpXTtcbiAgICAgICAgbGV0IHVuZG9hYmxlO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgICBpZiAocGx1Z2luLnNwZWMuaXNJbnB1dFJ1bGVzICYmICh1bmRvYWJsZSA9IHBsdWdpbi5nZXRTdGF0ZShzdGF0ZSkpKSB7XG4gICAgICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ciA9IHN0YXRlLnRyO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvVW5kbyA9IHVuZG9hYmxlLnRyYW5zZm9ybTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gdG9VbmRvLnN0ZXBzLmxlbmd0aCAtIDE7IGogPj0gMDsgaiAtPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyLnN0ZXAodG9VbmRvLnN0ZXBzW2pdLmludmVydCh0b1VuZG8uZG9jc1tqXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodW5kb2FibGUudGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXJrcyA9IHRyLmRvYy5yZXNvbHZlKHVuZG9hYmxlLmZyb20pLm1hcmtzKCk7XG4gICAgICAgICAgICAgICAgICAgIHRyLnJlcGxhY2VXaXRoKHVuZG9hYmxlLmZyb20sIHVuZG9hYmxlLnRvLCBzdGF0ZS5zY2hlbWEudGV4dCh1bmRvYWJsZS50ZXh0LCBtYXJrcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdHIuZGVsZXRlKHVuZG9hYmxlLmZyb20sIHVuZG9hYmxlLnRvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5jb25zdCB1bnNldEFsbE1hcmtzID0gKCkgPT4gKHsgdHIsIGRpc3BhdGNoIH0pID0+IHtcbiAgICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gdHI7XG4gICAgY29uc3QgeyBlbXB0eSwgcmFuZ2VzIH0gPSBzZWxlY3Rpb247XG4gICAgaWYgKGVtcHR5KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgcmFuZ2VzLmZvckVhY2gocmFuZ2UgPT4ge1xuICAgICAgICAgICAgdHIucmVtb3ZlTWFyayhyYW5nZS4kZnJvbS5wb3MsIHJhbmdlLiR0by5wb3MpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCB1bnNldE1hcmsgPSAodHlwZU9yTmFtZSwgb3B0aW9ucyA9IHt9KSA9PiAoeyB0ciwgc3RhdGUsIGRpc3BhdGNoIH0pID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBleHRlbmRFbXB0eU1hcmtSYW5nZSA9IGZhbHNlIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSB0cjtcbiAgICBjb25zdCB0eXBlID0gZ2V0TWFya1R5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgICBjb25zdCB7ICRmcm9tLCBlbXB0eSwgcmFuZ2VzIH0gPSBzZWxlY3Rpb247XG4gICAgaWYgKCFkaXNwYXRjaCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGVtcHR5ICYmIGV4dGVuZEVtcHR5TWFya1JhbmdlKSB7XG4gICAgICAgIGxldCB7IGZyb20sIHRvIH0gPSBzZWxlY3Rpb247XG4gICAgICAgIGNvbnN0IGF0dHJzID0gKF9hID0gJGZyb20ubWFya3MoKS5maW5kKG1hcmsgPT4gbWFyay50eXBlID09PSB0eXBlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmF0dHJzO1xuICAgICAgICBjb25zdCByYW5nZSA9IGdldE1hcmtSYW5nZSgkZnJvbSwgdHlwZSwgYXR0cnMpO1xuICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgIGZyb20gPSByYW5nZS5mcm9tO1xuICAgICAgICAgICAgdG8gPSByYW5nZS50bztcbiAgICAgICAgfVxuICAgICAgICB0ci5yZW1vdmVNYXJrKGZyb20sIHRvLCB0eXBlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJhbmdlcy5mb3JFYWNoKHJhbmdlID0+IHtcbiAgICAgICAgICAgIHRyLnJlbW92ZU1hcmsocmFuZ2UuJGZyb20ucG9zLCByYW5nZS4kdG8ucG9zLCB0eXBlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRyLnJlbW92ZVN0b3JlZE1hcmsodHlwZSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCB1cGRhdGVBdHRyaWJ1dGVzID0gKHR5cGVPck5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkgPT4gKHsgdHIsIHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgbGV0IG5vZGVUeXBlID0gbnVsbDtcbiAgICBsZXQgbWFya1R5cGUgPSBudWxsO1xuICAgIGNvbnN0IHNjaGVtYVR5cGUgPSBnZXRTY2hlbWFUeXBlTmFtZUJ5TmFtZSh0eXBlb2YgdHlwZU9yTmFtZSA9PT0gJ3N0cmluZycgPyB0eXBlT3JOYW1lIDogdHlwZU9yTmFtZS5uYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICAgIGlmICghc2NoZW1hVHlwZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChzY2hlbWFUeXBlID09PSAnbm9kZScpIHtcbiAgICAgICAgbm9kZVR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hVHlwZSA9PT0gJ21hcmsnKSB7XG4gICAgICAgIG1hcmtUeXBlID0gZ2V0TWFya1R5cGUodHlwZU9yTmFtZSwgc3RhdGUuc2NoZW1hKTtcbiAgICB9XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIHRyLnNlbGVjdGlvbi5yYW5nZXMuZm9yRWFjaCgocmFuZ2UpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZyb20gPSByYW5nZS4kZnJvbS5wb3M7XG4gICAgICAgICAgICBjb25zdCB0byA9IHJhbmdlLiR0by5wb3M7XG4gICAgICAgICAgICBsZXQgbGFzdFBvcztcbiAgICAgICAgICAgIGxldCBsYXN0Tm9kZTtcbiAgICAgICAgICAgIGxldCB0cmltbWVkRnJvbTtcbiAgICAgICAgICAgIGxldCB0cmltbWVkVG87XG4gICAgICAgICAgICBpZiAodHIuc2VsZWN0aW9uLmVtcHR5KSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZVR5cGUgJiYgbm9kZVR5cGUgPT09IG5vZGUudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJpbW1lZEZyb20gPSBNYXRoLm1heChwb3MsIGZyb20pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJpbW1lZFRvID0gTWF0aC5taW4ocG9zICsgbm9kZS5ub2RlU2l6ZSwgdG8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdFBvcyA9IHBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3ROb2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zIDwgZnJvbSAmJiBub2RlVHlwZSAmJiBub2RlVHlwZSA9PT0gbm9kZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmltbWVkRnJvbSA9IE1hdGgubWF4KHBvcywgZnJvbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmltbWVkVG8gPSBNYXRoLm1pbihwb3MgKyBub2RlLm5vZGVTaXplLCB0byk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0UG9zID0gcG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdE5vZGUgPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPj0gZnJvbSAmJiBwb3MgPD0gdG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlVHlwZSAmJiBub2RlVHlwZSA9PT0gbm9kZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cChwb3MsIHVuZGVmaW5lZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5ub2RlLmF0dHJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hcmtUeXBlICYmIG5vZGUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5tYXJrcy5mb3JFYWNoKChtYXJrKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXJrVHlwZSA9PT0gbWFyay50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmltbWVkRnJvbTIgPSBNYXRoLm1heChwb3MsIGZyb20pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJpbW1lZFRvMiA9IE1hdGgubWluKHBvcyArIG5vZGUubm9kZVNpemUsIHRvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyLmFkZE1hcmsodHJpbW1lZEZyb20yLCB0cmltbWVkVG8yLCBtYXJrVHlwZS5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLm1hcmsuYXR0cnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGFzdE5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFzdFBvcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyLnNldE5vZGVNYXJrdXAobGFzdFBvcywgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5sYXN0Tm9kZS5hdHRycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobWFya1R5cGUgJiYgbGFzdE5vZGUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3ROb2RlLm1hcmtzLmZvckVhY2goKG1hcmspID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXJrVHlwZSA9PT0gbWFyay50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHIuYWRkTWFyayh0cmltbWVkRnJvbSwgdHJpbW1lZFRvLCBtYXJrVHlwZS5jcmVhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5tYXJrLmF0dHJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5jb25zdCB3cmFwSW4gPSAodHlwZU9yTmFtZSwgYXR0cmlidXRlcyA9IHt9KSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgIGNvbnN0IHR5cGUgPSBnZXROb2RlVHlwZSh0eXBlT3JOYW1lLCBzdGF0ZS5zY2hlbWEpO1xuICAgIHJldHVybiB3cmFwSW4kMSh0eXBlLCBhdHRyaWJ1dGVzKShzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcblxuY29uc3Qgd3JhcEluTGlzdCA9ICh0eXBlT3JOYW1lLCBhdHRyaWJ1dGVzID0ge30pID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgY29uc3QgdHlwZSA9IGdldE5vZGVUeXBlKHR5cGVPck5hbWUsIHN0YXRlLnNjaGVtYSk7XG4gICAgcmV0dXJuIHdyYXBJbkxpc3QkMSh0eXBlLCBhdHRyaWJ1dGVzKShzdGF0ZSwgZGlzcGF0Y2gpO1xufTtcblxudmFyIGNvbW1hbmRzID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIGJsdXI6IGJsdXIsXG4gIGNsZWFyQ29udGVudDogY2xlYXJDb250ZW50LFxuICBjbGVhck5vZGVzOiBjbGVhck5vZGVzLFxuICBjb21tYW5kOiBjb21tYW5kLFxuICBjcmVhdGVQYXJhZ3JhcGhOZWFyOiBjcmVhdGVQYXJhZ3JhcGhOZWFyLFxuICBjdXQ6IGN1dCxcbiAgZGVsZXRlQ3VycmVudE5vZGU6IGRlbGV0ZUN1cnJlbnROb2RlLFxuICBkZWxldGVOb2RlOiBkZWxldGVOb2RlLFxuICBkZWxldGVSYW5nZTogZGVsZXRlUmFuZ2UsXG4gIGRlbGV0ZVNlbGVjdGlvbjogZGVsZXRlU2VsZWN0aW9uLFxuICBlbnRlcjogZW50ZXIsXG4gIGV4aXRDb2RlOiBleGl0Q29kZSxcbiAgZXh0ZW5kTWFya1JhbmdlOiBleHRlbmRNYXJrUmFuZ2UsXG4gIGZpcnN0OiBmaXJzdCxcbiAgZm9jdXM6IGZvY3VzLFxuICBmb3JFYWNoOiBmb3JFYWNoLFxuICBpbnNlcnRDb250ZW50OiBpbnNlcnRDb250ZW50LFxuICBpbnNlcnRDb250ZW50QXQ6IGluc2VydENvbnRlbnRBdCxcbiAgam9pbkJhY2t3YXJkOiBqb2luQmFja3dhcmQsXG4gIGpvaW5Eb3duOiBqb2luRG93bixcbiAgam9pbkZvcndhcmQ6IGpvaW5Gb3J3YXJkLFxuICBqb2luSXRlbUJhY2t3YXJkOiBqb2luSXRlbUJhY2t3YXJkLFxuICBqb2luSXRlbUZvcndhcmQ6IGpvaW5JdGVtRm9yd2FyZCxcbiAgam9pblRleHRibG9ja0JhY2t3YXJkOiBqb2luVGV4dGJsb2NrQmFja3dhcmQsXG4gIGpvaW5UZXh0YmxvY2tGb3J3YXJkOiBqb2luVGV4dGJsb2NrRm9yd2FyZCxcbiAgam9pblVwOiBqb2luVXAsXG4gIGtleWJvYXJkU2hvcnRjdXQ6IGtleWJvYXJkU2hvcnRjdXQsXG4gIGxpZnQ6IGxpZnQsXG4gIGxpZnRFbXB0eUJsb2NrOiBsaWZ0RW1wdHlCbG9jayxcbiAgbGlmdExpc3RJdGVtOiBsaWZ0TGlzdEl0ZW0sXG4gIG5ld2xpbmVJbkNvZGU6IG5ld2xpbmVJbkNvZGUsXG4gIHJlc2V0QXR0cmlidXRlczogcmVzZXRBdHRyaWJ1dGVzLFxuICBzY3JvbGxJbnRvVmlldzogc2Nyb2xsSW50b1ZpZXcsXG4gIHNlbGVjdEFsbDogc2VsZWN0QWxsLFxuICBzZWxlY3ROb2RlQmFja3dhcmQ6IHNlbGVjdE5vZGVCYWNrd2FyZCxcbiAgc2VsZWN0Tm9kZUZvcndhcmQ6IHNlbGVjdE5vZGVGb3J3YXJkLFxuICBzZWxlY3RQYXJlbnROb2RlOiBzZWxlY3RQYXJlbnROb2RlLFxuICBzZWxlY3RUZXh0YmxvY2tFbmQ6IHNlbGVjdFRleHRibG9ja0VuZCxcbiAgc2VsZWN0VGV4dGJsb2NrU3RhcnQ6IHNlbGVjdFRleHRibG9ja1N0YXJ0LFxuICBzZXRDb250ZW50OiBzZXRDb250ZW50LFxuICBzZXRNYXJrOiBzZXRNYXJrLFxuICBzZXRNZXRhOiBzZXRNZXRhLFxuICBzZXROb2RlOiBzZXROb2RlLFxuICBzZXROb2RlU2VsZWN0aW9uOiBzZXROb2RlU2VsZWN0aW9uLFxuICBzZXRUZXh0U2VsZWN0aW9uOiBzZXRUZXh0U2VsZWN0aW9uLFxuICBzaW5rTGlzdEl0ZW06IHNpbmtMaXN0SXRlbSxcbiAgc3BsaXRCbG9jazogc3BsaXRCbG9jayxcbiAgc3BsaXRMaXN0SXRlbTogc3BsaXRMaXN0SXRlbSxcbiAgdG9nZ2xlTGlzdDogdG9nZ2xlTGlzdCxcbiAgdG9nZ2xlTWFyazogdG9nZ2xlTWFyayxcbiAgdG9nZ2xlTm9kZTogdG9nZ2xlTm9kZSxcbiAgdG9nZ2xlV3JhcDogdG9nZ2xlV3JhcCxcbiAgdW5kb0lucHV0UnVsZTogdW5kb0lucHV0UnVsZSxcbiAgdW5zZXRBbGxNYXJrczogdW5zZXRBbGxNYXJrcyxcbiAgdW5zZXRNYXJrOiB1bnNldE1hcmssXG4gIHVwZGF0ZUF0dHJpYnV0ZXM6IHVwZGF0ZUF0dHJpYnV0ZXMsXG4gIHdyYXBJbjogd3JhcEluLFxuICB3cmFwSW5MaXN0OiB3cmFwSW5MaXN0XG59KTtcblxuY29uc3QgQ29tbWFuZHMgPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgICBuYW1lOiAnY29tbWFuZHMnLFxuICAgIGFkZENvbW1hbmRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uY29tbWFuZHMsXG4gICAgICAgIH07XG4gICAgfSxcbn0pO1xuXG5jb25zdCBEcm9wID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gICAgbmFtZTogJ2Ryb3AnLFxuICAgIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG5ldyBQbHVnaW4oe1xuICAgICAgICAgICAgICAgIGtleTogbmV3IFBsdWdpbktleSgndGlwdGFwRHJvcCcpLFxuICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZURyb3A6IChfLCBlLCBzbGljZSwgbW92ZWQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZWRpdG9yLmVtaXQoJ2Ryb3AnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudDogZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbGljZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3ZlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgXTtcbiAgICB9LFxufSk7XG5cbmNvbnN0IEVkaXRhYmxlID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gICAgbmFtZTogJ2VkaXRhYmxlJyxcbiAgICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBuZXcgUGx1Z2luKHtcbiAgICAgICAgICAgICAgICBrZXk6IG5ldyBQbHVnaW5LZXkoJ2VkaXRhYmxlJyksXG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgZWRpdGFibGU6ICgpID0+IHRoaXMuZWRpdG9yLm9wdGlvbnMuZWRpdGFibGUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdO1xuICAgIH0sXG59KTtcblxuY29uc3QgZm9jdXNFdmVudHNQbHVnaW5LZXkgPSBuZXcgUGx1Z2luS2V5KCdmb2N1c0V2ZW50cycpO1xuY29uc3QgRm9jdXNFdmVudHMgPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgICBuYW1lOiAnZm9jdXNFdmVudHMnLFxuICAgIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICAgICAgY29uc3QgeyBlZGl0b3IgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBuZXcgUGx1Z2luKHtcbiAgICAgICAgICAgICAgICBrZXk6IGZvY3VzRXZlbnRzUGx1Z2luS2V5LFxuICAgICAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZURPTUV2ZW50czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXM6ICh2aWV3LCBldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvci5pc0ZvY3VzZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gZWRpdG9yLnN0YXRlLnRyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRNZXRhKCdmb2N1cycsIHsgZXZlbnQgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnNldE1ldGEoJ2FkZFRvSGlzdG9yeScsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgYmx1cjogKHZpZXcsIGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yLmlzRm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gZWRpdG9yLnN0YXRlLnRyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zZXRNZXRhKCdibHVyJywgeyBldmVudCB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc2V0TWV0YSgnYWRkVG9IaXN0b3J5JywgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdO1xuICAgIH0sXG59KTtcblxuY29uc3QgS2V5bWFwID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gICAgbmFtZTogJ2tleW1hcCcsXG4gICAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZUJhY2tzcGFjZSA9ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLmZpcnN0KCh7IGNvbW1hbmRzIH0pID0+IFtcbiAgICAgICAgICAgICgpID0+IGNvbW1hbmRzLnVuZG9JbnB1dFJ1bGUoKSxcbiAgICAgICAgICAgIC8vIG1heWJlIGNvbnZlcnQgZmlyc3QgdGV4dCBibG9jayBub2RlIHRvIGRlZmF1bHQgbm9kZVxuICAgICAgICAgICAgKCkgPT4gY29tbWFuZHMuY29tbWFuZCgoeyB0ciB9KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzZWxlY3Rpb24sIGRvYyB9ID0gdHI7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBlbXB0eSwgJGFuY2hvciB9ID0gc2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcG9zLCBwYXJlbnQgfSA9ICRhbmNob3I7XG4gICAgICAgICAgICAgICAgY29uc3QgJHBhcmVudFBvcyA9ICRhbmNob3IucGFyZW50LmlzVGV4dGJsb2NrICYmIHBvcyA+IDAgPyB0ci5kb2MucmVzb2x2ZShwb3MgLSAxKSA6ICRhbmNob3I7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50SXNJc29sYXRpbmcgPSAkcGFyZW50UG9zLnBhcmVudC50eXBlLnNwZWMuaXNvbGF0aW5nO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudFBvcyA9ICRhbmNob3IucG9zIC0gJGFuY2hvci5wYXJlbnRPZmZzZXQ7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNBdFN0YXJ0ID0gKHBhcmVudElzSXNvbGF0aW5nICYmICRwYXJlbnRQb3MucGFyZW50LmNoaWxkQ291bnQgPT09IDEpXG4gICAgICAgICAgICAgICAgICAgID8gcGFyZW50UG9zID09PSAkYW5jaG9yLnBvc1xuICAgICAgICAgICAgICAgICAgICA6IFNlbGVjdGlvbi5hdFN0YXJ0KGRvYykuZnJvbSA9PT0gcG9zO1xuICAgICAgICAgICAgICAgIGlmICghZW1wdHlcbiAgICAgICAgICAgICAgICAgICAgfHwgIXBhcmVudC50eXBlLmlzVGV4dGJsb2NrXG4gICAgICAgICAgICAgICAgICAgIHx8IHBhcmVudC50ZXh0Q29udGVudC5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgfHwgIWlzQXRTdGFydFxuICAgICAgICAgICAgICAgICAgICB8fCAoaXNBdFN0YXJ0ICYmICRhbmNob3IucGFyZW50LnR5cGUubmFtZSA9PT0gJ3BhcmFncmFwaCcpIC8vIHByZXZlbnQgY2xlYXJOb2RlcyB3aGVuIG5vIG5vZGVzIHRvIGNsZWFyLCBvdGhlcndpc2UgaGlzdG9yeSBzdGFjayBpcyBhcHBlbmRlZFxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy5jbGVhck5vZGVzKCk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICgpID0+IGNvbW1hbmRzLmRlbGV0ZVNlbGVjdGlvbigpLFxuICAgICAgICAgICAgKCkgPT4gY29tbWFuZHMuam9pbkJhY2t3YXJkKCksXG4gICAgICAgICAgICAoKSA9PiBjb21tYW5kcy5zZWxlY3ROb2RlQmFja3dhcmQoKSxcbiAgICAgICAgXSk7XG4gICAgICAgIGNvbnN0IGhhbmRsZURlbGV0ZSA9ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLmZpcnN0KCh7IGNvbW1hbmRzIH0pID0+IFtcbiAgICAgICAgICAgICgpID0+IGNvbW1hbmRzLmRlbGV0ZVNlbGVjdGlvbigpLFxuICAgICAgICAgICAgKCkgPT4gY29tbWFuZHMuZGVsZXRlQ3VycmVudE5vZGUoKSxcbiAgICAgICAgICAgICgpID0+IGNvbW1hbmRzLmpvaW5Gb3J3YXJkKCksXG4gICAgICAgICAgICAoKSA9PiBjb21tYW5kcy5zZWxlY3ROb2RlRm9yd2FyZCgpLFxuICAgICAgICBdKTtcbiAgICAgICAgY29uc3QgaGFuZGxlRW50ZXIgPSAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5maXJzdCgoeyBjb21tYW5kcyB9KSA9PiBbXG4gICAgICAgICAgICAoKSA9PiBjb21tYW5kcy5uZXdsaW5lSW5Db2RlKCksXG4gICAgICAgICAgICAoKSA9PiBjb21tYW5kcy5jcmVhdGVQYXJhZ3JhcGhOZWFyKCksXG4gICAgICAgICAgICAoKSA9PiBjb21tYW5kcy5saWZ0RW1wdHlCbG9jaygpLFxuICAgICAgICAgICAgKCkgPT4gY29tbWFuZHMuc3BsaXRCbG9jaygpLFxuICAgICAgICBdKTtcbiAgICAgICAgY29uc3QgYmFzZUtleW1hcCA9IHtcbiAgICAgICAgICAgIEVudGVyOiBoYW5kbGVFbnRlcixcbiAgICAgICAgICAgICdNb2QtRW50ZXInOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5leGl0Q29kZSgpLFxuICAgICAgICAgICAgQmFja3NwYWNlOiBoYW5kbGVCYWNrc3BhY2UsXG4gICAgICAgICAgICAnTW9kLUJhY2tzcGFjZSc6IGhhbmRsZUJhY2tzcGFjZSxcbiAgICAgICAgICAgICdTaGlmdC1CYWNrc3BhY2UnOiBoYW5kbGVCYWNrc3BhY2UsXG4gICAgICAgICAgICBEZWxldGU6IGhhbmRsZURlbGV0ZSxcbiAgICAgICAgICAgICdNb2QtRGVsZXRlJzogaGFuZGxlRGVsZXRlLFxuICAgICAgICAgICAgJ01vZC1hJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2VsZWN0QWxsKCksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHBjS2V5bWFwID0ge1xuICAgICAgICAgICAgLi4uYmFzZUtleW1hcCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbWFjS2V5bWFwID0ge1xuICAgICAgICAgICAgLi4uYmFzZUtleW1hcCxcbiAgICAgICAgICAgICdDdHJsLWgnOiBoYW5kbGVCYWNrc3BhY2UsXG4gICAgICAgICAgICAnQWx0LUJhY2tzcGFjZSc6IGhhbmRsZUJhY2tzcGFjZSxcbiAgICAgICAgICAgICdDdHJsLWQnOiBoYW5kbGVEZWxldGUsXG4gICAgICAgICAgICAnQ3RybC1BbHQtQmFja3NwYWNlJzogaGFuZGxlRGVsZXRlLFxuICAgICAgICAgICAgJ0FsdC1EZWxldGUnOiBoYW5kbGVEZWxldGUsXG4gICAgICAgICAgICAnQWx0LWQnOiBoYW5kbGVEZWxldGUsXG4gICAgICAgICAgICAnQ3RybC1hJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2VsZWN0VGV4dGJsb2NrU3RhcnQoKSxcbiAgICAgICAgICAgICdDdHJsLWUnOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zZWxlY3RUZXh0YmxvY2tFbmQoKSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGlzaU9TKCkgfHwgaXNNYWNPUygpKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFjS2V5bWFwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwY0tleW1hcDtcbiAgICB9LFxuICAgIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIC8vIFdpdGggdGhpcyBwbHVnaW4gd2UgY2hlY2sgaWYgdGhlIHdob2xlIGRvY3VtZW50IHdhcyBzZWxlY3RlZCBhbmQgZGVsZXRlZC5cbiAgICAgICAgICAgIC8vIEluIHRoaXMgY2FzZSB3ZSB3aWxsIGFkZGl0aW9uYWxseSBjYWxsIGBjbGVhck5vZGVzKClgIHRvIGNvbnZlcnQgZS5nLiBhIGhlYWRpbmdcbiAgICAgICAgICAgIC8vIHRvIGEgcGFyYWdyYXBoIGlmIG5lY2Vzc2FyeS5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYW4gYWx0ZXJuYXRpdmUgdG8gUHJvc2VNaXJyb3IncyBgQWxsU2VsZWN0aW9uYCwgd2hpY2ggZG9lc27igJl0IHdvcmsgd2VsbFxuICAgICAgICAgICAgLy8gd2l0aCBtYW55IG90aGVyIGNvbW1hbmRzLlxuICAgICAgICAgICAgbmV3IFBsdWdpbih7XG4gICAgICAgICAgICAgICAga2V5OiBuZXcgUGx1Z2luS2V5KCdjbGVhckRvY3VtZW50JyksXG4gICAgICAgICAgICAgICAgYXBwZW5kVHJhbnNhY3Rpb246ICh0cmFuc2FjdGlvbnMsIG9sZFN0YXRlLCBuZXdTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNhY3Rpb25zLnNvbWUodHIgPT4gdHIuZ2V0TWV0YSgnY29tcG9zaXRpb24nKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBkb2NDaGFuZ2VzID0gdHJhbnNhY3Rpb25zLnNvbWUodHJhbnNhY3Rpb24gPT4gdHJhbnNhY3Rpb24uZG9jQ2hhbmdlZClcbiAgICAgICAgICAgICAgICAgICAgICAgICYmICFvbGRTdGF0ZS5kb2MuZXEobmV3U3RhdGUuZG9jKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaWdub3JlVHIgPSB0cmFuc2FjdGlvbnMuc29tZSh0cmFuc2FjdGlvbiA9PiB0cmFuc2FjdGlvbi5nZXRNZXRhKCdwcmV2ZW50Q2xlYXJEb2N1bWVudCcpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkb2NDaGFuZ2VzIHx8IGlnbm9yZVRyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBlbXB0eSwgZnJvbSwgdG8gfSA9IG9sZFN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWxsRnJvbSA9IFNlbGVjdGlvbi5hdFN0YXJ0KG9sZFN0YXRlLmRvYykuZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWxsRW5kID0gU2VsZWN0aW9uLmF0RW5kKG9sZFN0YXRlLmRvYykudG87XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFsbFdhc1NlbGVjdGVkID0gZnJvbSA9PT0gYWxsRnJvbSAmJiB0byA9PT0gYWxsRW5kO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW1wdHkgfHwgIWFsbFdhc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNFbXB0eSA9IGlzTm9kZUVtcHR5KG5ld1N0YXRlLmRvYyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNFbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyID0gbmV3U3RhdGUudHI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gY3JlYXRlQ2hhaW5hYmxlU3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGU6IG5ld1N0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IHRyLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBjb21tYW5kcyB9ID0gbmV3IENvbW1hbmRNYW5hZ2VyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmRzLmNsZWFyTm9kZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0ci5zdGVwcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHI7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdO1xuICAgIH0sXG59KTtcblxuY29uc3QgUGFzdGUgPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgICBuYW1lOiAncGFzdGUnLFxuICAgIGFkZFByb3NlTWlycm9yUGx1Z2lucygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG5ldyBQbHVnaW4oe1xuICAgICAgICAgICAgICAgIGtleTogbmV3IFBsdWdpbktleSgndGlwdGFwUGFzdGUnKSxcbiAgICAgICAgICAgICAgICBwcm9wczoge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVQYXN0ZTogKF92aWV3LCBlLCBzbGljZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lZGl0b3IuZW1pdCgncGFzdGUnLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudDogZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzbGljZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgXTtcbiAgICB9LFxufSk7XG5cbmNvbnN0IFRhYmluZGV4ID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gICAgbmFtZTogJ3RhYmluZGV4JyxcbiAgICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBuZXcgUGx1Z2luKHtcbiAgICAgICAgICAgICAgICBrZXk6IG5ldyBQbHVnaW5LZXkoJ3RhYmluZGV4JyksXG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczogKCkgPT4gKHRoaXMuZWRpdG9yLmlzRWRpdGFibGUgPyB7IHRhYmluZGV4OiAnMCcgfSA6IHt9KSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSksXG4gICAgICAgIF07XG4gICAgfSxcbn0pO1xuXG52YXIgaW5kZXggPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgQ2xpcGJvYXJkVGV4dFNlcmlhbGl6ZXI6IENsaXBib2FyZFRleHRTZXJpYWxpemVyLFxuICBDb21tYW5kczogQ29tbWFuZHMsXG4gIERyb3A6IERyb3AsXG4gIEVkaXRhYmxlOiBFZGl0YWJsZSxcbiAgRm9jdXNFdmVudHM6IEZvY3VzRXZlbnRzLFxuICBLZXltYXA6IEtleW1hcCxcbiAgUGFzdGU6IFBhc3RlLFxuICBUYWJpbmRleDogVGFiaW5kZXgsXG4gIGZvY3VzRXZlbnRzUGx1Z2luS2V5OiBmb2N1c0V2ZW50c1BsdWdpbktleVxufSk7XG5cbmNsYXNzIE5vZGVQb3Mge1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlLnR5cGUubmFtZTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IocG9zLCBlZGl0b3IsIGlzQmxvY2sgPSBmYWxzZSwgbm9kZSA9IG51bGwpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50Tm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuYWN0dWFsRGVwdGggPSBudWxsO1xuICAgICAgICB0aGlzLmlzQmxvY2sgPSBpc0Jsb2NrO1xuICAgICAgICB0aGlzLnJlc29sdmVkUG9zID0gcG9zO1xuICAgICAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcbiAgICAgICAgdGhpcy5jdXJyZW50Tm9kZSA9IG5vZGU7XG4gICAgfVxuICAgIGdldCBub2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50Tm9kZSB8fCB0aGlzLnJlc29sdmVkUG9zLm5vZGUoKTtcbiAgICB9XG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVkaXRvci52aWV3LmRvbUF0UG9zKHRoaXMucG9zKS5ub2RlO1xuICAgIH1cbiAgICBnZXQgZGVwdGgoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuYWN0dWFsRGVwdGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMucmVzb2x2ZWRQb3MuZGVwdGg7XG4gICAgfVxuICAgIGdldCBwb3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVkUG9zLnBvcztcbiAgICB9XG4gICAgZ2V0IGNvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGUuY29udGVudDtcbiAgICB9XG4gICAgc2V0IGNvbnRlbnQoY29udGVudCkge1xuICAgICAgICBsZXQgZnJvbSA9IHRoaXMuZnJvbTtcbiAgICAgICAgbGV0IHRvID0gdGhpcy50bztcbiAgICAgICAgaWYgKHRoaXMuaXNCbG9jaykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29udGVudC5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgWW91IGNhbuKAmXQgc2V0IGNvbnRlbnQgb24gYSBibG9jayBub2RlLiBUcmllZCB0byBzZXQgY29udGVudCBvbiAke3RoaXMubmFtZX0gYXQgJHt0aGlzLnBvc31gKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmcm9tID0gdGhpcy5mcm9tICsgMTtcbiAgICAgICAgICAgIHRvID0gdGhpcy50byAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lZGl0b3IuY29tbWFuZHMuaW5zZXJ0Q29udGVudEF0KHsgZnJvbSwgdG8gfSwgY29udGVudCk7XG4gICAgfVxuICAgIGdldCBhdHRyaWJ1dGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlLmF0dHJzO1xuICAgIH1cbiAgICBnZXQgdGV4dENvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGUudGV4dENvbnRlbnQ7XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ub2RlLm5vZGVTaXplO1xuICAgIH1cbiAgICBnZXQgZnJvbSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNCbG9jaykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9zO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVkUG9zLnN0YXJ0KHRoaXMucmVzb2x2ZWRQb3MuZGVwdGgpO1xuICAgIH1cbiAgICBnZXQgcmFuZ2UoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmcm9tOiB0aGlzLmZyb20sXG4gICAgICAgICAgICB0bzogdGhpcy50byxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0IHRvKCkge1xuICAgICAgICBpZiAodGhpcy5pc0Jsb2NrKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wb3MgKyB0aGlzLnNpemU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZWRQb3MuZW5kKHRoaXMucmVzb2x2ZWRQb3MuZGVwdGgpICsgKHRoaXMubm9kZS5pc1RleHQgPyAwIDogMSk7XG4gICAgfVxuICAgIGdldCBwYXJlbnQoKSB7XG4gICAgICAgIGlmICh0aGlzLmRlcHRoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJlbnRQb3MgPSB0aGlzLnJlc29sdmVkUG9zLnN0YXJ0KHRoaXMucmVzb2x2ZWRQb3MuZGVwdGggLSAxKTtcbiAgICAgICAgY29uc3QgJHBvcyA9IHRoaXMucmVzb2x2ZWRQb3MuZG9jLnJlc29sdmUocGFyZW50UG9zKTtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlUG9zKCRwb3MsIHRoaXMuZWRpdG9yKTtcbiAgICB9XG4gICAgZ2V0IGJlZm9yZSgpIHtcbiAgICAgICAgbGV0ICRwb3MgPSB0aGlzLnJlc29sdmVkUG9zLmRvYy5yZXNvbHZlKHRoaXMuZnJvbSAtICh0aGlzLmlzQmxvY2sgPyAxIDogMikpO1xuICAgICAgICBpZiAoJHBvcy5kZXB0aCAhPT0gdGhpcy5kZXB0aCkge1xuICAgICAgICAgICAgJHBvcyA9IHRoaXMucmVzb2x2ZWRQb3MuZG9jLnJlc29sdmUodGhpcy5mcm9tIC0gMyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlUG9zKCRwb3MsIHRoaXMuZWRpdG9yKTtcbiAgICB9XG4gICAgZ2V0IGFmdGVyKCkge1xuICAgICAgICBsZXQgJHBvcyA9IHRoaXMucmVzb2x2ZWRQb3MuZG9jLnJlc29sdmUodGhpcy50byArICh0aGlzLmlzQmxvY2sgPyAyIDogMSkpO1xuICAgICAgICBpZiAoJHBvcy5kZXB0aCAhPT0gdGhpcy5kZXB0aCkge1xuICAgICAgICAgICAgJHBvcyA9IHRoaXMucmVzb2x2ZWRQb3MuZG9jLnJlc29sdmUodGhpcy50byArIDMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgTm9kZVBvcygkcG9zLCB0aGlzLmVkaXRvcik7XG4gICAgfVxuICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgdGhpcy5ub2RlLmNvbnRlbnQuZm9yRWFjaCgobm9kZSwgb2Zmc2V0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpc0Jsb2NrID0gbm9kZS5pc0Jsb2NrICYmICFub2RlLmlzVGV4dGJsb2NrO1xuICAgICAgICAgICAgY29uc3QgaXNOb25UZXh0QXRvbSA9IG5vZGUuaXNBdG9tICYmICFub2RlLmlzVGV4dDtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldFBvcyA9IHRoaXMucG9zICsgb2Zmc2V0ICsgKGlzTm9uVGV4dEF0b20gPyAwIDogMSk7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0YXJnZXRQb3MgaXMgd2l0aGluIHZhbGlkIGRvY3VtZW50IHJhbmdlXG4gICAgICAgICAgICBpZiAodGFyZ2V0UG9zIDwgMCB8fCB0YXJnZXRQb3MgPiB0aGlzLnJlc29sdmVkUG9zLmRvYy5ub2RlU2l6ZSAtIDIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCAkcG9zID0gdGhpcy5yZXNvbHZlZFBvcy5kb2MucmVzb2x2ZSh0YXJnZXRQb3MpO1xuICAgICAgICAgICAgaWYgKCFpc0Jsb2NrICYmICRwb3MuZGVwdGggPD0gdGhpcy5kZXB0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNoaWxkTm9kZVBvcyA9IG5ldyBOb2RlUG9zKCRwb3MsIHRoaXMuZWRpdG9yLCBpc0Jsb2NrLCBpc0Jsb2NrID8gbm9kZSA6IG51bGwpO1xuICAgICAgICAgICAgaWYgKGlzQmxvY2spIHtcbiAgICAgICAgICAgICAgICBjaGlsZE5vZGVQb3MuYWN0dWFsRGVwdGggPSB0aGlzLmRlcHRoICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gobmV3IE5vZGVQb3MoJHBvcywgdGhpcy5lZGl0b3IsIGlzQmxvY2ssIGlzQmxvY2sgPyBub2RlIDogbnVsbCkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xuICAgIH1cbiAgICBnZXQgZmlyc3RDaGlsZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hpbGRyZW5bMF0gfHwgbnVsbDtcbiAgICB9XG4gICAgZ2V0IGxhc3RDaGlsZCgpIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgICAgICByZXR1cm4gY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0gfHwgbnVsbDtcbiAgICB9XG4gICAgY2xvc2VzdChzZWxlY3RvciwgYXR0cmlidXRlcyA9IHt9KSB7XG4gICAgICAgIGxldCBub2RlID0gbnVsbDtcbiAgICAgICAgbGV0IGN1cnJlbnROb2RlID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgIHdoaWxlIChjdXJyZW50Tm9kZSAmJiAhbm9kZSkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnROb2RlLm5vZGUudHlwZS5uYW1lID09PSBzZWxlY3Rvcikge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVBdHRyaWJ1dGVzID0gY3VycmVudE5vZGUubm9kZS5hdHRycztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXR0cktleXMgPSBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGF0dHJLZXlzLmxlbmd0aDsgaW5kZXggKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gYXR0cktleXNbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGVBdHRyaWJ1dGVzW2tleV0gIT09IGF0dHJpYnV0ZXNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gY3VycmVudE5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5wYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIHF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IsIGF0dHJpYnV0ZXMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yLCBhdHRyaWJ1dGVzLCB0cnVlKVswXSB8fCBudWxsO1xuICAgIH1cbiAgICBxdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yLCBhdHRyaWJ1dGVzID0ge30sIGZpcnN0SXRlbU9ubHkgPSBmYWxzZSkge1xuICAgICAgICBsZXQgbm9kZXMgPSBbXTtcbiAgICAgICAgaWYgKCF0aGlzLmNoaWxkcmVuIHx8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXR0cktleXMgPSBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpbmRzIGFsbCBjaGlsZHJlbiByZWN1cnNpdmVseSB0aGF0IG1hdGNoIHRoZSBzZWxlY3RvciBhbmQgYXR0cmlidXRlc1xuICAgICAgICAgKiBJZiBmaXJzdEl0ZW1Pbmx5IGlzIHRydWUsIGl0IHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBpdGVtIGZvdW5kXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goY2hpbGRQb3MgPT4ge1xuICAgICAgICAgICAgLy8gSWYgd2UgYWxyZWFkeSBmb3VuZCBhIG5vZGUgYW5kIHdlIG9ubHkgd2FudCB0aGUgZmlyc3QgaXRlbSwgd2UgZG9udCBuZWVkIHRvIGtlZXAgZ29pbmdcbiAgICAgICAgICAgIGlmIChmaXJzdEl0ZW1Pbmx5ICYmIG5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2hpbGRQb3Mubm9kZS50eXBlLm5hbWUgPT09IHNlbGVjdG9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZG9lc0FsbEF0dHJpYnV0ZXNNYXRjaCA9IGF0dHJLZXlzLmV2ZXJ5KGtleSA9PiBhdHRyaWJ1dGVzW2tleV0gPT09IGNoaWxkUG9zLm5vZGUuYXR0cnNba2V5XSk7XG4gICAgICAgICAgICAgICAgaWYgKGRvZXNBbGxBdHRyaWJ1dGVzTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMucHVzaChjaGlsZFBvcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgd2UgYWxyZWFkeSBmb3VuZCBhIG5vZGUgYW5kIHdlIG9ubHkgd2FudCB0aGUgZmlyc3QgaXRlbSwgd2UgY2FuIHN0b3AgaGVyZSBhbmQgc2tpcCB0aGUgcmVjdXJzaW9uXG4gICAgICAgICAgICBpZiAoZmlyc3RJdGVtT25seSAmJiBub2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZXMgPSBub2Rlcy5jb25jYXQoY2hpbGRQb3MucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvciwgYXR0cmlidXRlcywgZmlyc3RJdGVtT25seSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH1cbiAgICBzZXRBdHRyaWJ1dGUoYXR0cmlidXRlcykge1xuICAgICAgICBjb25zdCB7IHRyIH0gPSB0aGlzLmVkaXRvci5zdGF0ZTtcbiAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cCh0aGlzLmZyb20sIHVuZGVmaW5lZCwge1xuICAgICAgICAgICAgLi4udGhpcy5ub2RlLmF0dHJzLFxuICAgICAgICAgICAgLi4uYXR0cmlidXRlcyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZWRpdG9yLnZpZXcuZGlzcGF0Y2godHIpO1xuICAgIH1cbn1cblxuY29uc3Qgc3R5bGUgPSBgLlByb3NlTWlycm9yIHtcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xufVxuXG4uUHJvc2VNaXJyb3Ige1xuICB3b3JkLXdyYXA6IGJyZWFrLXdvcmQ7XG4gIHdoaXRlLXNwYWNlOiBwcmUtd3JhcDtcbiAgd2hpdGUtc3BhY2U6IGJyZWFrLXNwYWNlcztcbiAgLXdlYmtpdC1mb250LXZhcmlhbnQtbGlnYXR1cmVzOiBub25lO1xuICBmb250LXZhcmlhbnQtbGlnYXR1cmVzOiBub25lO1xuICBmb250LWZlYXR1cmUtc2V0dGluZ3M6IFwibGlnYVwiIDA7IC8qIHRoZSBhYm92ZSBkb2Vzbid0IHNlZW0gdG8gd29yayBpbiBFZGdlICovXG59XG5cbi5Qcm9zZU1pcnJvciBbY29udGVudGVkaXRhYmxlPVwiZmFsc2VcIl0ge1xuICB3aGl0ZS1zcGFjZTogbm9ybWFsO1xufVxuXG4uUHJvc2VNaXJyb3IgW2NvbnRlbnRlZGl0YWJsZT1cImZhbHNlXCJdIFtjb250ZW50ZWRpdGFibGU9XCJ0cnVlXCJdIHtcbiAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xufVxuXG4uUHJvc2VNaXJyb3IgcHJlIHtcbiAgd2hpdGUtc3BhY2U6IHByZS13cmFwO1xufVxuXG5pbWcuUHJvc2VNaXJyb3Itc2VwYXJhdG9yIHtcbiAgZGlzcGxheTogaW5saW5lICFpbXBvcnRhbnQ7XG4gIGJvcmRlcjogbm9uZSAhaW1wb3J0YW50O1xuICBtYXJnaW46IDAgIWltcG9ydGFudDtcbiAgd2lkdGg6IDAgIWltcG9ydGFudDtcbiAgaGVpZ2h0OiAwICFpbXBvcnRhbnQ7XG59XG5cbi5Qcm9zZU1pcnJvci1nYXBjdXJzb3Ige1xuICBkaXNwbGF5OiBub25lO1xuICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICBtYXJnaW46IDA7XG59XG5cbi5Qcm9zZU1pcnJvci1nYXBjdXJzb3I6YWZ0ZXIge1xuICBjb250ZW50OiBcIlwiO1xuICBkaXNwbGF5OiBibG9jaztcbiAgcG9zaXRpb246IGFic29sdXRlO1xuICB0b3A6IC0ycHg7XG4gIHdpZHRoOiAyMHB4O1xuICBib3JkZXItdG9wOiAxcHggc29saWQgYmxhY2s7XG4gIGFuaW1hdGlvbjogUHJvc2VNaXJyb3ItY3Vyc29yLWJsaW5rIDEuMXMgc3RlcHMoMiwgc3RhcnQpIGluZmluaXRlO1xufVxuXG5Aa2V5ZnJhbWVzIFByb3NlTWlycm9yLWN1cnNvci1ibGluayB7XG4gIHRvIHtcbiAgICB2aXNpYmlsaXR5OiBoaWRkZW47XG4gIH1cbn1cblxuLlByb3NlTWlycm9yLWhpZGVzZWxlY3Rpb24gKjo6c2VsZWN0aW9uIHtcbiAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG59XG5cbi5Qcm9zZU1pcnJvci1oaWRlc2VsZWN0aW9uICo6Oi1tb3otc2VsZWN0aW9uIHtcbiAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG59XG5cbi5Qcm9zZU1pcnJvci1oaWRlc2VsZWN0aW9uICoge1xuICBjYXJldC1jb2xvcjogdHJhbnNwYXJlbnQ7XG59XG5cbi5Qcm9zZU1pcnJvci1mb2N1c2VkIC5Qcm9zZU1pcnJvci1nYXBjdXJzb3Ige1xuICBkaXNwbGF5OiBibG9jaztcbn1cblxuLnRpcHB5LWJveFtkYXRhLWFuaW1hdGlvbj1mYWRlXVtkYXRhLXN0YXRlPWhpZGRlbl0ge1xuICBvcGFjaXR5OiAwXG59YDtcblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVUYWcoc3R5bGUsIG5vbmNlLCBzdWZmaXgpIHtcbiAgICBjb25zdCB0aXB0YXBTdHlsZVRhZyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYHN0eWxlW2RhdGEtdGlwdGFwLXN0eWxlJHtzdWZmaXggPyBgLSR7c3VmZml4fWAgOiAnJ31dYCk7XG4gICAgaWYgKHRpcHRhcFN0eWxlVGFnICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aXB0YXBTdHlsZVRhZztcbiAgICB9XG4gICAgY29uc3Qgc3R5bGVOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICBpZiAobm9uY2UpIHtcbiAgICAgICAgc3R5bGVOb2RlLnNldEF0dHJpYnV0ZSgnbm9uY2UnLCBub25jZSk7XG4gICAgfVxuICAgIHN0eWxlTm9kZS5zZXRBdHRyaWJ1dGUoYGRhdGEtdGlwdGFwLXN0eWxlJHtzdWZmaXggPyBgLSR7c3VmZml4fWAgOiAnJ31gLCAnJyk7XG4gICAgc3R5bGVOb2RlLmlubmVySFRNTCA9IHN0eWxlO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF0uYXBwZW5kQ2hpbGQoc3R5bGVOb2RlKTtcbiAgICByZXR1cm4gc3R5bGVOb2RlO1xufVxuXG5jbGFzcyBFZGl0b3IgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmlzRm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGVkaXRvciBpcyBjb25zaWRlcmVkIGluaXRpYWxpemVkIGFmdGVyIHRoZSBgY3JlYXRlYCBldmVudCBoYXMgYmVlbiBlbWl0dGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pc0luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9uU3RvcmFnZSA9IHt9O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAgICAgICBlbGVtZW50OiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICAgICAgICAgIGNvbnRlbnQ6ICcnLFxuICAgICAgICAgICAgaW5qZWN0Q1NTOiB0cnVlLFxuICAgICAgICAgICAgaW5qZWN0Tm9uY2U6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGV4dGVuc2lvbnM6IFtdLFxuICAgICAgICAgICAgYXV0b2ZvY3VzOiBmYWxzZSxcbiAgICAgICAgICAgIGVkaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZWRpdG9yUHJvcHM6IHt9LFxuICAgICAgICAgICAgcGFyc2VPcHRpb25zOiB7fSxcbiAgICAgICAgICAgIGNvcmVFeHRlbnNpb25PcHRpb25zOiB7fSxcbiAgICAgICAgICAgIGVuYWJsZUlucHV0UnVsZXM6IHRydWUsXG4gICAgICAgICAgICBlbmFibGVQYXN0ZVJ1bGVzOiB0cnVlLFxuICAgICAgICAgICAgZW5hYmxlQ29yZUV4dGVuc2lvbnM6IHRydWUsXG4gICAgICAgICAgICBlbmFibGVDb250ZW50Q2hlY2s6IGZhbHNlLFxuICAgICAgICAgICAgZW1pdENvbnRlbnRFcnJvcjogZmFsc2UsXG4gICAgICAgICAgICBvbkJlZm9yZUNyZWF0ZTogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgIG9uQ3JlYXRlOiAoKSA9PiBudWxsLFxuICAgICAgICAgICAgb25VcGRhdGU6ICgpID0+IG51bGwsXG4gICAgICAgICAgICBvblNlbGVjdGlvblVwZGF0ZTogKCkgPT4gbnVsbCxcbiAgICAgICAgICAgIG9uVHJhbnNhY3Rpb246ICgpID0+IG51bGwsXG4gICAgICAgICAgICBvbkZvY3VzOiAoKSA9PiBudWxsLFxuICAgICAgICAgICAgb25CbHVyOiAoKSA9PiBudWxsLFxuICAgICAgICAgICAgb25EZXN0cm95OiAoKSA9PiBudWxsLFxuICAgICAgICAgICAgb25Db250ZW50RXJyb3I6ICh7IGVycm9yIH0pID0+IHsgdGhyb3cgZXJyb3I7IH0sXG4gICAgICAgICAgICBvblBhc3RlOiAoKSA9PiBudWxsLFxuICAgICAgICAgICAgb25Ecm9wOiAoKSA9PiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmlzQ2FwdHVyaW5nVHJhbnNhY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jYXB0dXJlZFRyYW5zYWN0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmNyZWF0ZUV4dGVuc2lvbk1hbmFnZXIoKTtcbiAgICAgICAgdGhpcy5jcmVhdGVDb21tYW5kTWFuYWdlcigpO1xuICAgICAgICB0aGlzLmNyZWF0ZVNjaGVtYSgpO1xuICAgICAgICB0aGlzLm9uKCdiZWZvcmVDcmVhdGUnLCB0aGlzLm9wdGlvbnMub25CZWZvcmVDcmVhdGUpO1xuICAgICAgICB0aGlzLmVtaXQoJ2JlZm9yZUNyZWF0ZScsIHsgZWRpdG9yOiB0aGlzIH0pO1xuICAgICAgICB0aGlzLm9uKCdjb250ZW50RXJyb3InLCB0aGlzLm9wdGlvbnMub25Db250ZW50RXJyb3IpO1xuICAgICAgICB0aGlzLmNyZWF0ZVZpZXcoKTtcbiAgICAgICAgdGhpcy5pbmplY3RDU1MoKTtcbiAgICAgICAgdGhpcy5vbignY3JlYXRlJywgdGhpcy5vcHRpb25zLm9uQ3JlYXRlKTtcbiAgICAgICAgdGhpcy5vbigndXBkYXRlJywgdGhpcy5vcHRpb25zLm9uVXBkYXRlKTtcbiAgICAgICAgdGhpcy5vbignc2VsZWN0aW9uVXBkYXRlJywgdGhpcy5vcHRpb25zLm9uU2VsZWN0aW9uVXBkYXRlKTtcbiAgICAgICAgdGhpcy5vbigndHJhbnNhY3Rpb24nLCB0aGlzLm9wdGlvbnMub25UcmFuc2FjdGlvbik7XG4gICAgICAgIHRoaXMub24oJ2ZvY3VzJywgdGhpcy5vcHRpb25zLm9uRm9jdXMpO1xuICAgICAgICB0aGlzLm9uKCdibHVyJywgdGhpcy5vcHRpb25zLm9uQmx1cik7XG4gICAgICAgIHRoaXMub24oJ2Rlc3Ryb3knLCB0aGlzLm9wdGlvbnMub25EZXN0cm95KTtcbiAgICAgICAgdGhpcy5vbignZHJvcCcsICh7IGV2ZW50LCBzbGljZSwgbW92ZWQgfSkgPT4gdGhpcy5vcHRpb25zLm9uRHJvcChldmVudCwgc2xpY2UsIG1vdmVkKSk7XG4gICAgICAgIHRoaXMub24oJ3Bhc3RlJywgKHsgZXZlbnQsIHNsaWNlIH0pID0+IHRoaXMub3B0aW9ucy5vblBhc3RlKGV2ZW50LCBzbGljZSkpO1xuICAgICAgICB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0Rlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29tbWFuZHMuZm9jdXModGhpcy5vcHRpb25zLmF1dG9mb2N1cyk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2NyZWF0ZScsIHsgZWRpdG9yOiB0aGlzIH0pO1xuICAgICAgICAgICAgdGhpcy5pc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgfSwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGVkaXRvciBzdG9yYWdlLlxuICAgICAqL1xuICAgIGdldCBzdG9yYWdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5leHRlbnNpb25TdG9yYWdlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbiBvYmplY3Qgb2YgYWxsIHJlZ2lzdGVyZWQgY29tbWFuZHMuXG4gICAgICovXG4gICAgZ2V0IGNvbW1hbmRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb21tYW5kTWFuYWdlci5jb21tYW5kcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgY29tbWFuZCBjaGFpbiB0byBjYWxsIG11bHRpcGxlIGNvbW1hbmRzIGF0IG9uY2UuXG4gICAgICovXG4gICAgY2hhaW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbW1hbmRNYW5hZ2VyLmNoYWluKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIGEgY29tbWFuZCBvciBhIGNvbW1hbmQgY2hhaW4gY2FuIGJlIGV4ZWN1dGVkLiBXaXRob3V0IGV4ZWN1dGluZyBpdC5cbiAgICAgKi9cbiAgICBjYW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbW1hbmRNYW5hZ2VyLmNhbigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbmplY3QgQ1NTIHN0eWxlcy5cbiAgICAgKi9cbiAgICBpbmplY3RDU1MoKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaW5qZWN0Q1NTICYmIGRvY3VtZW50KSB7XG4gICAgICAgICAgICB0aGlzLmNzcyA9IGNyZWF0ZVN0eWxlVGFnKHN0eWxlLCB0aGlzLm9wdGlvbnMuaW5qZWN0Tm9uY2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBlZGl0b3Igb3B0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIEEgbGlzdCBvZiBvcHRpb25zXG4gICAgICovXG4gICAgc2V0T3B0aW9ucyhvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgICAgICAgLi4udGhpcy5vcHRpb25zLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCF0aGlzLnZpZXcgfHwgIXRoaXMuc3RhdGUgfHwgdGhpcy5pc0Rlc3Ryb3llZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZWRpdG9yUHJvcHMpIHtcbiAgICAgICAgICAgIHRoaXMudmlldy5zZXRQcm9wcyh0aGlzLm9wdGlvbnMuZWRpdG9yUHJvcHMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmlldy51cGRhdGVTdGF0ZSh0aGlzLnN0YXRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIGVkaXRhYmxlIHN0YXRlIG9mIHRoZSBlZGl0b3IuXG4gICAgICovXG4gICAgc2V0RWRpdGFibGUoZWRpdGFibGUsIGVtaXRVcGRhdGUgPSB0cnVlKSB7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9ucyh7IGVkaXRhYmxlIH0pO1xuICAgICAgICBpZiAoZW1pdFVwZGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCd1cGRhdGUnLCB7IGVkaXRvcjogdGhpcywgdHJhbnNhY3Rpb246IHRoaXMuc3RhdGUudHIgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBlZGl0b3IgaXMgZWRpdGFibGUuXG4gICAgICovXG4gICAgZ2V0IGlzRWRpdGFibGUoKSB7XG4gICAgICAgIC8vIHNpbmNlIHBsdWdpbnMgYXJlIGFwcGxpZWQgYWZ0ZXIgY3JlYXRpbmcgdGhlIHZpZXdcbiAgICAgICAgLy8gYGVkaXRhYmxlYCBpcyBhbHdheXMgYHRydWVgIGZvciBvbmUgdGljay5cbiAgICAgICAgLy8gdGhhdOKAmXMgd2h5IHdlIGFsc28gaGF2ZSB0byBjaGVjayBmb3IgYG9wdGlvbnMuZWRpdGFibGVgXG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZWRpdGFibGUgJiYgdGhpcy52aWV3ICYmIHRoaXMudmlldy5lZGl0YWJsZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZWRpdG9yIHN0YXRlLlxuICAgICAqL1xuICAgIGdldCBzdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlldy5zdGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYSBQcm9zZU1pcnJvciBwbHVnaW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGx1Z2luIEEgUHJvc2VNaXJyb3IgcGx1Z2luXG4gICAgICogQHBhcmFtIGhhbmRsZVBsdWdpbnMgQ29udHJvbCBob3cgdG8gbWVyZ2UgdGhlIHBsdWdpbiBpbnRvIHRoZSBleGlzdGluZyBwbHVnaW5zLlxuICAgICAqIEByZXR1cm5zIFRoZSBuZXcgZWRpdG9yIHN0YXRlXG4gICAgICovXG4gICAgcmVnaXN0ZXJQbHVnaW4ocGx1Z2luLCBoYW5kbGVQbHVnaW5zKSB7XG4gICAgICAgIGNvbnN0IHBsdWdpbnMgPSBpc0Z1bmN0aW9uKGhhbmRsZVBsdWdpbnMpXG4gICAgICAgICAgICA/IGhhbmRsZVBsdWdpbnMocGx1Z2luLCBbLi4udGhpcy5zdGF0ZS5wbHVnaW5zXSlcbiAgICAgICAgICAgIDogWy4uLnRoaXMuc3RhdGUucGx1Z2lucywgcGx1Z2luXTtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlLnJlY29uZmlndXJlKHsgcGx1Z2lucyB9KTtcbiAgICAgICAgdGhpcy52aWV3LnVwZGF0ZVN0YXRlKHN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbnJlZ2lzdGVyIGEgUHJvc2VNaXJyb3IgcGx1Z2luLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWVPclBsdWdpbktleVRvUmVtb3ZlIFRoZSBwbHVnaW5zIG5hbWVcbiAgICAgKiBAcmV0dXJucyBUaGUgbmV3IGVkaXRvciBzdGF0ZSBvciB1bmRlZmluZWQgaWYgdGhlIGVkaXRvciBpcyBkZXN0cm95ZWRcbiAgICAgKi9cbiAgICB1bnJlZ2lzdGVyUGx1Z2luKG5hbWVPclBsdWdpbktleVRvUmVtb3ZlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRGVzdHJveWVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZXZQbHVnaW5zID0gdGhpcy5zdGF0ZS5wbHVnaW5zO1xuICAgICAgICBsZXQgcGx1Z2lucyA9IHByZXZQbHVnaW5zO1xuICAgICAgICBbXS5jb25jYXQobmFtZU9yUGx1Z2luS2V5VG9SZW1vdmUpLmZvckVhY2gobmFtZU9yUGx1Z2luS2V5ID0+IHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSB0eXBlb2YgbmFtZU9yUGx1Z2luS2V5ID09PSAnc3RyaW5nJyA/IGAke25hbWVPclBsdWdpbktleX0kYCA6IG5hbWVPclBsdWdpbktleS5rZXk7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBwbHVnaW5zID0gcGx1Z2lucy5maWx0ZXIocGx1Z2luID0+ICFwbHVnaW4ua2V5LnN0YXJ0c1dpdGgobmFtZSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHByZXZQbHVnaW5zLmxlbmd0aCA9PT0gcGx1Z2lucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIE5vIHBsdWdpbiB3YXMgcmVtb3ZlZCwgc28gd2UgZG9u4oCZdCBuZWVkIHRvIHVwZGF0ZSB0aGUgc3RhdGVcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlLnJlY29uZmlndXJlKHtcbiAgICAgICAgICAgIHBsdWdpbnMsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnZpZXcudXBkYXRlU3RhdGUoc3RhdGUpO1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gZXh0ZW5zaW9uIG1hbmFnZXIuXG4gICAgICovXG4gICAgY3JlYXRlRXh0ZW5zaW9uTWFuYWdlcigpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3QgY29yZUV4dGVuc2lvbnMgPSB0aGlzLm9wdGlvbnMuZW5hYmxlQ29yZUV4dGVuc2lvbnMgPyBbXG4gICAgICAgICAgICBFZGl0YWJsZSxcbiAgICAgICAgICAgIENsaXBib2FyZFRleHRTZXJpYWxpemVyLmNvbmZpZ3VyZSh7XG4gICAgICAgICAgICAgICAgYmxvY2tTZXBhcmF0b3I6IChfYiA9IChfYSA9IHRoaXMub3B0aW9ucy5jb3JlRXh0ZW5zaW9uT3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsaXBib2FyZFRleHRTZXJpYWxpemVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYmxvY2tTZXBhcmF0b3IsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIENvbW1hbmRzLFxuICAgICAgICAgICAgRm9jdXNFdmVudHMsXG4gICAgICAgICAgICBLZXltYXAsXG4gICAgICAgICAgICBUYWJpbmRleCxcbiAgICAgICAgICAgIERyb3AsXG4gICAgICAgICAgICBQYXN0ZSxcbiAgICAgICAgXS5maWx0ZXIoZXh0ID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmVuYWJsZUNvcmVFeHRlbnNpb25zID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZW5hYmxlQ29yZUV4dGVuc2lvbnNbZXh0Lm5hbWVdICE9PSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KSA6IFtdO1xuICAgICAgICBjb25zdCBhbGxFeHRlbnNpb25zID0gWy4uLmNvcmVFeHRlbnNpb25zLCAuLi50aGlzLm9wdGlvbnMuZXh0ZW5zaW9uc10uZmlsdGVyKGV4dGVuc2lvbiA9PiB7XG4gICAgICAgICAgICByZXR1cm4gWydleHRlbnNpb24nLCAnbm9kZScsICdtYXJrJ10uaW5jbHVkZXMoZXh0ZW5zaW9uID09PSBudWxsIHx8IGV4dGVuc2lvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXh0ZW5zaW9uLnR5cGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5leHRlbnNpb25NYW5hZ2VyID0gbmV3IEV4dGVuc2lvbk1hbmFnZXIoYWxsRXh0ZW5zaW9ucywgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gY29tbWFuZCBtYW5hZ2VyLlxuICAgICAqL1xuICAgIGNyZWF0ZUNvbW1hbmRNYW5hZ2VyKCkge1xuICAgICAgICB0aGlzLmNvbW1hbmRNYW5hZ2VyID0gbmV3IENvbW1hbmRNYW5hZ2VyKHtcbiAgICAgICAgICAgIGVkaXRvcjogdGhpcyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBQcm9zZU1pcnJvciBzY2hlbWEuXG4gICAgICovXG4gICAgY3JlYXRlU2NoZW1hKCkge1xuICAgICAgICB0aGlzLnNjaGVtYSA9IHRoaXMuZXh0ZW5zaW9uTWFuYWdlci5zY2hlbWE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBQcm9zZU1pcnJvciB2aWV3LlxuICAgICAqL1xuICAgIGNyZWF0ZVZpZXcoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IGRvYztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRvYyA9IGNyZWF0ZURvY3VtZW50KHRoaXMub3B0aW9ucy5jb250ZW50LCB0aGlzLnNjaGVtYSwgdGhpcy5vcHRpb25zLnBhcnNlT3B0aW9ucywgeyBlcnJvck9uSW52YWxpZENvbnRlbnQ6IHRoaXMub3B0aW9ucy5lbmFibGVDb250ZW50Q2hlY2sgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmICghKGUgaW5zdGFuY2VvZiBFcnJvcikgfHwgIVsnW3RpcHRhcCBlcnJvcl06IEludmFsaWQgSlNPTiBjb250ZW50JywgJ1t0aXB0YXAgZXJyb3JdOiBJbnZhbGlkIEhUTUwgY29udGVudCddLmluY2x1ZGVzKGUubWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBOb3QgdGhlIGNvbnRlbnQgZXJyb3Igd2Ugd2VyZSBleHBlY3RpbmdcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdjb250ZW50RXJyb3InLCB7XG4gICAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLFxuICAgICAgICAgICAgICAgIGVycm9yOiBlLFxuICAgICAgICAgICAgICAgIGRpc2FibGVDb2xsYWJvcmF0aW9uOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0b3JhZ2UuY29sbGFib3JhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9yYWdlLmNvbGxhYm9yYXRpb24uaXNEaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gVG8gYXZvaWQgc3luY2luZyBiYWNrIGludmFsaWQgY29udGVudCwgcmVpbml0aWFsaXplIHRoZSBleHRlbnNpb25zIHdpdGhvdXQgdGhlIGNvbGxhYm9yYXRpb24gZXh0ZW5zaW9uXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5leHRlbnNpb25zID0gdGhpcy5vcHRpb25zLmV4dGVuc2lvbnMuZmlsdGVyKGV4dGVuc2lvbiA9PiBleHRlbnNpb24ubmFtZSAhPT0gJ2NvbGxhYm9yYXRpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzdGFydCB0aGUgaW5pdGlhbGl6YXRpb24gcHJvY2VzcyBieSByZWNyZWF0aW5nIHRoZSBleHRlbnNpb24gbWFuYWdlciB3aXRoIHRoZSBuZXcgc2V0IG9mIGV4dGVuc2lvbnNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVFeHRlbnNpb25NYW5hZ2VyKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQ29udGVudCBpcyBpbnZhbGlkLCBidXQgYXR0ZW1wdCB0byBjcmVhdGUgaXQgYW55d2F5LCBzdHJpcHBpbmcgb3V0IHRoZSBpbnZhbGlkIHBhcnRzXG4gICAgICAgICAgICBkb2MgPSBjcmVhdGVEb2N1bWVudCh0aGlzLm9wdGlvbnMuY29udGVudCwgdGhpcy5zY2hlbWEsIHRoaXMub3B0aW9ucy5wYXJzZU9wdGlvbnMsIHsgZXJyb3JPbkludmFsaWRDb250ZW50OiBmYWxzZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSByZXNvbHZlRm9jdXNQb3NpdGlvbihkb2MsIHRoaXMub3B0aW9ucy5hdXRvZm9jdXMpO1xuICAgICAgICB0aGlzLnZpZXcgPSBuZXcgRWRpdG9yVmlldyh0aGlzLm9wdGlvbnMuZWxlbWVudCwge1xuICAgICAgICAgICAgLi4udGhpcy5vcHRpb25zLmVkaXRvclByb3BzLFxuICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgIC8vIGFkZCBgcm9sZT1cInRleHRib3hcImAgdG8gdGhlIGVkaXRvciBlbGVtZW50XG4gICAgICAgICAgICAgICAgcm9sZTogJ3RleHRib3gnLFxuICAgICAgICAgICAgICAgIC4uLihfYSA9IHRoaXMub3B0aW9ucy5lZGl0b3JQcm9wcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGlzcGF0Y2hUcmFuc2FjdGlvbjogdGhpcy5kaXNwYXRjaFRyYW5zYWN0aW9uLmJpbmQodGhpcyksXG4gICAgICAgICAgICBzdGF0ZTogRWRpdG9yU3RhdGUuY3JlYXRlKHtcbiAgICAgICAgICAgICAgICBkb2MsXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uOiBzZWxlY3Rpb24gfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBgZWRpdG9yLnZpZXdgIGlzIG5vdCB5ZXQgYXZhaWxhYmxlIGF0IHRoaXMgdGltZS5cbiAgICAgICAgLy8gVGhlcmVmb3JlIHdlIHdpbGwgYWRkIGFsbCBwbHVnaW5zIGFuZCBub2RlIHZpZXdzIGRpcmVjdGx5IGFmdGVyd2FyZHMuXG4gICAgICAgIGNvbnN0IG5ld1N0YXRlID0gdGhpcy5zdGF0ZS5yZWNvbmZpZ3VyZSh7XG4gICAgICAgICAgICBwbHVnaW5zOiB0aGlzLmV4dGVuc2lvbk1hbmFnZXIucGx1Z2lucyxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudmlldy51cGRhdGVTdGF0ZShuZXdTdGF0ZSk7XG4gICAgICAgIHRoaXMuY3JlYXRlTm9kZVZpZXdzKCk7XG4gICAgICAgIHRoaXMucHJlcGVuZENsYXNzKCk7XG4gICAgICAgIC8vIExldOKAmXMgc3RvcmUgdGhlIGVkaXRvciBpbnN0YW5jZSBpbiB0aGUgRE9NIGVsZW1lbnQuXG4gICAgICAgIC8vIFNvIHdl4oCZbGwgaGF2ZSBhY2Nlc3MgdG8gaXQgZm9yIHRlc3RzLlxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGNvbnN0IGRvbSA9IHRoaXMudmlldy5kb207XG4gICAgICAgIGRvbS5lZGl0b3IgPSB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFsbCBub2RlIHZpZXdzLlxuICAgICAqL1xuICAgIGNyZWF0ZU5vZGVWaWV3cygpIHtcbiAgICAgICAgaWYgKHRoaXMudmlldy5pc0Rlc3Ryb3llZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmlldy5zZXRQcm9wcyh7XG4gICAgICAgICAgICBub2RlVmlld3M6IHRoaXMuZXh0ZW5zaW9uTWFuYWdlci5ub2RlVmlld3MsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmVwZW5kIGNsYXNzIG5hbWUgdG8gZWxlbWVudC5cbiAgICAgKi9cbiAgICBwcmVwZW5kQ2xhc3MoKSB7XG4gICAgICAgIHRoaXMudmlldy5kb20uY2xhc3NOYW1lID0gYHRpcHRhcCAke3RoaXMudmlldy5kb20uY2xhc3NOYW1lfWA7XG4gICAgfVxuICAgIGNhcHR1cmVUcmFuc2FjdGlvbihmbikge1xuICAgICAgICB0aGlzLmlzQ2FwdHVyaW5nVHJhbnNhY3Rpb24gPSB0cnVlO1xuICAgICAgICBmbigpO1xuICAgICAgICB0aGlzLmlzQ2FwdHVyaW5nVHJhbnNhY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgY29uc3QgdHIgPSB0aGlzLmNhcHR1cmVkVHJhbnNhY3Rpb247XG4gICAgICAgIHRoaXMuY2FwdHVyZWRUcmFuc2FjdGlvbiA9IG51bGw7XG4gICAgICAgIHJldHVybiB0cjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGNhbGxiYWNrIG92ZXIgd2hpY2ggdG8gc2VuZCB0cmFuc2FjdGlvbnMgKHN0YXRlIHVwZGF0ZXMpIHByb2R1Y2VkIGJ5IHRoZSB2aWV3LlxuICAgICAqXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uIEFuIGVkaXRvciBzdGF0ZSB0cmFuc2FjdGlvblxuICAgICAqL1xuICAgIGRpc3BhdGNoVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICAgICAgLy8gaWYgdGhlIGVkaXRvciAvIHRoZSB2aWV3IG9mIHRoZSBlZGl0b3Igd2FzIGRlc3Ryb3llZFxuICAgICAgICAvLyB0aGUgdHJhbnNhY3Rpb24gc2hvdWxkIG5vdCBiZSBkaXNwYXRjaGVkIGFzIHRoZXJlIGlzIG5vIHZpZXcgYW55bW9yZS5cbiAgICAgICAgaWYgKHRoaXMudmlldy5pc0Rlc3Ryb3llZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzQ2FwdHVyaW5nVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jYXB0dXJlZFRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYXB0dXJlZFRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb247XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhbnNhY3Rpb24uc3RlcHMuZm9yRWFjaChzdGVwID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gdGhpcy5jYXB0dXJlZFRyYW5zYWN0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RlcChzdGVwKTsgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLnN0YXRlLmFwcGx5KHRyYW5zYWN0aW9uKTtcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uSGFzQ2hhbmdlZCA9ICF0aGlzLnN0YXRlLnNlbGVjdGlvbi5lcShzdGF0ZS5zZWxlY3Rpb24pO1xuICAgICAgICB0aGlzLmVtaXQoJ2JlZm9yZVRyYW5zYWN0aW9uJywge1xuICAgICAgICAgICAgZWRpdG9yOiB0aGlzLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICAgICAgICBuZXh0U3RhdGU6IHN0YXRlLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy52aWV3LnVwZGF0ZVN0YXRlKHN0YXRlKTtcbiAgICAgICAgdGhpcy5lbWl0KCd0cmFuc2FjdGlvbicsIHtcbiAgICAgICAgICAgIGVkaXRvcjogdGhpcyxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHNlbGVjdGlvbkhhc0NoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnc2VsZWN0aW9uVXBkYXRlJywge1xuICAgICAgICAgICAgICAgIGVkaXRvcjogdGhpcyxcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvY3VzID0gdHJhbnNhY3Rpb24uZ2V0TWV0YSgnZm9jdXMnKTtcbiAgICAgICAgY29uc3QgYmx1ciA9IHRyYW5zYWN0aW9uLmdldE1ldGEoJ2JsdXInKTtcbiAgICAgICAgaWYgKGZvY3VzKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2ZvY3VzJywge1xuICAgICAgICAgICAgICAgIGVkaXRvcjogdGhpcyxcbiAgICAgICAgICAgICAgICBldmVudDogZm9jdXMuZXZlbnQsXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmx1cikge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdibHVyJywge1xuICAgICAgICAgICAgICAgIGVkaXRvcjogdGhpcyxcbiAgICAgICAgICAgICAgICBldmVudDogYmx1ci5ldmVudCxcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdHJhbnNhY3Rpb24uZG9jQ2hhbmdlZCB8fCB0cmFuc2FjdGlvbi5nZXRNZXRhKCdwcmV2ZW50VXBkYXRlJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIHtcbiAgICAgICAgICAgIGVkaXRvcjogdGhpcyxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGF0dHJpYnV0ZXMgb2YgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBub2RlIG9yIG1hcmsuXG4gICAgICovXG4gICAgZ2V0QXR0cmlidXRlcyhuYW1lT3JUeXBlKSB7XG4gICAgICAgIHJldHVybiBnZXRBdHRyaWJ1dGVzKHRoaXMuc3RhdGUsIG5hbWVPclR5cGUpO1xuICAgIH1cbiAgICBpc0FjdGl2ZShuYW1lT3JBdHRyaWJ1dGVzLCBhdHRyaWJ1dGVzT3JVbmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IHR5cGVvZiBuYW1lT3JBdHRyaWJ1dGVzID09PSAnc3RyaW5nJyA/IG5hbWVPckF0dHJpYnV0ZXMgOiBudWxsO1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gdHlwZW9mIG5hbWVPckF0dHJpYnV0ZXMgPT09ICdzdHJpbmcnID8gYXR0cmlidXRlc09yVW5kZWZpbmVkIDogbmFtZU9yQXR0cmlidXRlcztcbiAgICAgICAgcmV0dXJuIGlzQWN0aXZlKHRoaXMuc3RhdGUsIG5hbWUsIGF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGRvY3VtZW50IGFzIEpTT04uXG4gICAgICovXG4gICAgZ2V0SlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuZG9jLnRvSlNPTigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGRvY3VtZW50IGFzIEhUTUwuXG4gICAgICovXG4gICAgZ2V0SFRNTCgpIHtcbiAgICAgICAgcmV0dXJuIGdldEhUTUxGcm9tRnJhZ21lbnQodGhpcy5zdGF0ZS5kb2MuY29udGVudCwgdGhpcy5zY2hlbWEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGRvY3VtZW50IGFzIHRleHQuXG4gICAgICovXG4gICAgZ2V0VGV4dChvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tTZXBhcmF0b3IgPSAnXFxuXFxuJywgdGV4dFNlcmlhbGl6ZXJzID0ge30gfSA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHJldHVybiBnZXRUZXh0KHRoaXMuc3RhdGUuZG9jLCB7XG4gICAgICAgICAgICBibG9ja1NlcGFyYXRvcixcbiAgICAgICAgICAgIHRleHRTZXJpYWxpemVyczoge1xuICAgICAgICAgICAgICAgIC4uLmdldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEodGhpcy5zY2hlbWEpLFxuICAgICAgICAgICAgICAgIC4uLnRleHRTZXJpYWxpemVycyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiB0aGVyZSBpcyBubyBjb250ZW50LlxuICAgICAqL1xuICAgIGdldCBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gaXNOb2RlRW1wdHkodGhpcy5zdGF0ZS5kb2MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGZvciB0aGUgY3VycmVudCBkb2N1bWVudC5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgZ2V0Q2hhcmFjdGVyQ291bnQoKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignW3RpcHRhcCB3YXJuXTogXCJlZGl0b3IuZ2V0Q2hhcmFjdGVyQ291bnQoKVwiIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgXCJlZGl0b3Iuc3RvcmFnZS5jaGFyYWN0ZXJDb3VudC5jaGFyYWN0ZXJzKClcIiBpbnN0ZWFkLicpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5kb2MuY29udGVudC5zaXplIC0gMjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVzdHJveSB0aGUgZWRpdG9yLlxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZGVzdHJveScpO1xuICAgICAgICBpZiAodGhpcy52aWV3KSB7XG4gICAgICAgICAgICAvLyBDbGVhbnVwIG91ciByZWZlcmVuY2UgdG8gcHJldmVudCBjaXJjdWxhciByZWZlcmVuY2VzIHdoaWNoIGNhdXNlZCBtZW1vcnkgbGVha3NcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IGRvbSA9IHRoaXMudmlldy5kb207XG4gICAgICAgICAgICBpZiAoZG9tICYmIGRvbS5lZGl0b3IpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgZG9tLmVkaXRvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudmlldy5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIGVkaXRvciBpcyBhbHJlYWR5IGRlc3Ryb3llZC5cbiAgICAgKi9cbiAgICBnZXQgaXNEZXN0cm95ZWQoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gISgoX2EgPSB0aGlzLnZpZXcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kb2NWaWV3KTtcbiAgICB9XG4gICAgJG5vZGUoc2VsZWN0b3IsIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IHRoaXMuJGRvYykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IsIGF0dHJpYnV0ZXMpKSB8fCBudWxsO1xuICAgIH1cbiAgICAkbm9kZXMoc2VsZWN0b3IsIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IHRoaXMuJGRvYykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IsIGF0dHJpYnV0ZXMpKSB8fCBudWxsO1xuICAgIH1cbiAgICAkcG9zKHBvcykge1xuICAgICAgICBjb25zdCAkcG9zID0gdGhpcy5zdGF0ZS5kb2MucmVzb2x2ZShwb3MpO1xuICAgICAgICByZXR1cm4gbmV3IE5vZGVQb3MoJHBvcywgdGhpcyk7XG4gICAgfVxuICAgIGdldCAkZG9jKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4kcG9zKDApO1xuICAgIH1cbn1cblxuLyoqXG4gKiBCdWlsZCBhbiBpbnB1dCBydWxlIHRoYXQgYWRkcyBhIG1hcmsgd2hlbiB0aGVcbiAqIG1hdGNoZWQgdGV4dCBpcyB0eXBlZCBpbnRvIGl0LlxuICogQHNlZSBodHRwczovL3RpcHRhcC5kZXYvZG9jcy9lZGl0b3IvZXh0ZW5zaW9ucy9jdXN0b20tZXh0ZW5zaW9ucy9leHRlbmQtZXhpc3RpbmcjaW5wdXQtcnVsZXNcbiAqL1xuZnVuY3Rpb24gbWFya0lucHV0UnVsZShjb25maWcpIHtcbiAgICByZXR1cm4gbmV3IElucHV0UnVsZSh7XG4gICAgICAgIGZpbmQ6IGNvbmZpZy5maW5kLFxuICAgICAgICBoYW5kbGVyOiAoeyBzdGF0ZSwgcmFuZ2UsIG1hdGNoIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBjYWxsT3JSZXR1cm4oY29uZmlnLmdldEF0dHJpYnV0ZXMsIHVuZGVmaW5lZCwgbWF0Y2gpO1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXMgPT09IGZhbHNlIHx8IGF0dHJpYnV0ZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgdHIgfSA9IHN0YXRlO1xuICAgICAgICAgICAgY29uc3QgY2FwdHVyZUdyb3VwID0gbWF0Y2hbbWF0Y2gubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBjb25zdCBmdWxsTWF0Y2ggPSBtYXRjaFswXTtcbiAgICAgICAgICAgIGlmIChjYXB0dXJlR3JvdXApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydFNwYWNlcyA9IGZ1bGxNYXRjaC5zZWFyY2goL1xcUy8pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRleHRTdGFydCA9IHJhbmdlLmZyb20gKyBmdWxsTWF0Y2guaW5kZXhPZihjYXB0dXJlR3JvdXApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRleHRFbmQgPSB0ZXh0U3RhcnQgKyBjYXB0dXJlR3JvdXAubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4Y2x1ZGVkTWFya3MgPSBnZXRNYXJrc0JldHdlZW4ocmFuZ2UuZnJvbSwgcmFuZ2UudG8sIHN0YXRlLmRvYylcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihpdGVtID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBleGNsdWRlZCA9IGl0ZW0ubWFyay50eXBlLmV4Y2x1ZGVkO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhjbHVkZWQuZmluZCh0eXBlID0+IHR5cGUgPT09IGNvbmZpZy50eXBlICYmIHR5cGUgIT09IGl0ZW0ubWFyay50eXBlKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGl0ZW0gPT4gaXRlbS50byA+IHRleHRTdGFydCk7XG4gICAgICAgICAgICAgICAgaWYgKGV4Y2x1ZGVkTWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGV4dEVuZCA8IHJhbmdlLnRvKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyLmRlbGV0ZSh0ZXh0RW5kLCByYW5nZS50byk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0ZXh0U3RhcnQgPiByYW5nZS5mcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyLmRlbGV0ZShyYW5nZS5mcm9tICsgc3RhcnRTcGFjZXMsIHRleHRTdGFydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG1hcmtFbmQgPSByYW5nZS5mcm9tICsgc3RhcnRTcGFjZXMgKyBjYXB0dXJlR3JvdXAubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHRyLmFkZE1hcmsocmFuZ2UuZnJvbSArIHN0YXJ0U3BhY2VzLCBtYXJrRW5kLCBjb25maWcudHlwZS5jcmVhdGUoYXR0cmlidXRlcyB8fCB7fSkpO1xuICAgICAgICAgICAgICAgIHRyLnJlbW92ZVN0b3JlZE1hcmsoY29uZmlnLnR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0pO1xufVxuXG4vKipcbiAqIEJ1aWxkIGFuIGlucHV0IHJ1bGUgdGhhdCBhZGRzIGEgbm9kZSB3aGVuIHRoZVxuICogbWF0Y2hlZCB0ZXh0IGlzIHR5cGVkIGludG8gaXQuXG4gKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9kb2NzL2VkaXRvci9leHRlbnNpb25zL2N1c3RvbS1leHRlbnNpb25zL2V4dGVuZC1leGlzdGluZyNpbnB1dC1ydWxlc1xuICovXG5mdW5jdGlvbiBub2RlSW5wdXRSdWxlKGNvbmZpZykge1xuICAgIHJldHVybiBuZXcgSW5wdXRSdWxlKHtcbiAgICAgICAgZmluZDogY29uZmlnLmZpbmQsXG4gICAgICAgIGhhbmRsZXI6ICh7IHN0YXRlLCByYW5nZSwgbWF0Y2ggfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGNhbGxPclJldHVybihjb25maWcuZ2V0QXR0cmlidXRlcywgdW5kZWZpbmVkLCBtYXRjaCkgfHwge307XG4gICAgICAgICAgICBjb25zdCB7IHRyIH0gPSBzdGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gcmFuZ2UuZnJvbTtcbiAgICAgICAgICAgIGxldCBlbmQgPSByYW5nZS50bztcbiAgICAgICAgICAgIGNvbnN0IG5ld05vZGUgPSBjb25maWcudHlwZS5jcmVhdGUoYXR0cmlidXRlcyk7XG4gICAgICAgICAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQgPSBtYXRjaFswXS5sYXN0SW5kZXhPZihtYXRjaFsxXSk7XG4gICAgICAgICAgICAgICAgbGV0IG1hdGNoU3RhcnQgPSBzdGFydCArIG9mZnNldDtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hTdGFydCA+IGVuZCkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaFN0YXJ0ID0gZW5kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kID0gbWF0Y2hTdGFydCArIG1hdGNoWzFdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaW5zZXJ0IGxhc3QgdHlwZWQgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdENoYXIgPSBtYXRjaFswXVttYXRjaFswXS5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICB0ci5pbnNlcnRUZXh0KGxhc3RDaGFyLCBzdGFydCArIG1hdGNoWzBdLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgICAgIC8vIGluc2VydCBub2RlIGZyb20gaW5wdXQgcnVsZVxuICAgICAgICAgICAgICAgIHRyLnJlcGxhY2VXaXRoKG1hdGNoU3RhcnQsIGVuZCwgbmV3Tm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtYXRjaFswXSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluc2VydGlvblN0YXJ0ID0gY29uZmlnLnR5cGUuaXNJbmxpbmUgPyBzdGFydCA6IHN0YXJ0IC0gMTtcbiAgICAgICAgICAgICAgICB0ci5pbnNlcnQoaW5zZXJ0aW9uU3RhcnQsIGNvbmZpZy50eXBlLmNyZWF0ZShhdHRyaWJ1dGVzKSkuZGVsZXRlKHRyLm1hcHBpbmcubWFwKHN0YXJ0KSwgdHIubWFwcGluZy5tYXAoZW5kKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ci5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuXG4vKipcbiAqIEJ1aWxkIGFuIGlucHV0IHJ1bGUgdGhhdCBjaGFuZ2VzIHRoZSB0eXBlIG9mIGEgdGV4dGJsb2NrIHdoZW4gdGhlXG4gKiBtYXRjaGVkIHRleHQgaXMgdHlwZWQgaW50byBpdC4gV2hlbiB1c2luZyBhIHJlZ3VsYXIgZXhwcmVzaW9uIHlvdeKAmWxsXG4gKiBwcm9iYWJseSB3YW50IHRoZSByZWdleHAgdG8gc3RhcnQgd2l0aCBgXmAsIHNvIHRoYXQgdGhlIHBhdHRlcm4gY2FuXG4gKiBvbmx5IG9jY3VyIGF0IHRoZSBzdGFydCBvZiBhIHRleHRibG9jay5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2RvY3MvZWRpdG9yL2V4dGVuc2lvbnMvY3VzdG9tLWV4dGVuc2lvbnMvZXh0ZW5kLWV4aXN0aW5nI2lucHV0LXJ1bGVzXG4gKi9cbmZ1bmN0aW9uIHRleHRibG9ja1R5cGVJbnB1dFJ1bGUoY29uZmlnKSB7XG4gICAgcmV0dXJuIG5ldyBJbnB1dFJ1bGUoe1xuICAgICAgICBmaW5kOiBjb25maWcuZmluZCxcbiAgICAgICAgaGFuZGxlcjogKHsgc3RhdGUsIHJhbmdlLCBtYXRjaCB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCAkc3RhcnQgPSBzdGF0ZS5kb2MucmVzb2x2ZShyYW5nZS5mcm9tKTtcbiAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBjYWxsT3JSZXR1cm4oY29uZmlnLmdldEF0dHJpYnV0ZXMsIHVuZGVmaW5lZCwgbWF0Y2gpIHx8IHt9O1xuICAgICAgICAgICAgaWYgKCEkc3RhcnQubm9kZSgtMSkuY2FuUmVwbGFjZVdpdGgoJHN0YXJ0LmluZGV4KC0xKSwgJHN0YXJ0LmluZGV4QWZ0ZXIoLTEpLCBjb25maWcudHlwZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXRlLnRyXG4gICAgICAgICAgICAgICAgLmRlbGV0ZShyYW5nZS5mcm9tLCByYW5nZS50bylcbiAgICAgICAgICAgICAgICAuc2V0QmxvY2tUeXBlKHJhbmdlLmZyb20sIHJhbmdlLmZyb20sIGNvbmZpZy50eXBlLCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBCdWlsZCBhbiBpbnB1dCBydWxlIHRoYXQgcmVwbGFjZXMgdGV4dCB3aGVuIHRoZVxuICogbWF0Y2hlZCB0ZXh0IGlzIHR5cGVkIGludG8gaXQuXG4gKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9kb2NzL2VkaXRvci9leHRlbnNpb25zL2N1c3RvbS1leHRlbnNpb25zL2V4dGVuZC1leGlzdGluZyNpbnB1dC1ydWxlc1xuICovXG5mdW5jdGlvbiB0ZXh0SW5wdXRSdWxlKGNvbmZpZykge1xuICAgIHJldHVybiBuZXcgSW5wdXRSdWxlKHtcbiAgICAgICAgZmluZDogY29uZmlnLmZpbmQsXG4gICAgICAgIGhhbmRsZXI6ICh7IHN0YXRlLCByYW5nZSwgbWF0Y2ggfSkgPT4ge1xuICAgICAgICAgICAgbGV0IGluc2VydCA9IGNvbmZpZy5yZXBsYWNlO1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gcmFuZ2UuZnJvbTtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IHJhbmdlLnRvO1xuICAgICAgICAgICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gbWF0Y2hbMF0ubGFzdEluZGV4T2YobWF0Y2hbMV0pO1xuICAgICAgICAgICAgICAgIGluc2VydCArPSBtYXRjaFswXS5zbGljZShvZmZzZXQgKyBtYXRjaFsxXS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHN0YXJ0ICs9IG9mZnNldDtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXRPZmYgPSBzdGFydCAtIGVuZDtcbiAgICAgICAgICAgICAgICBpZiAoY3V0T2ZmID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnQgPSBtYXRjaFswXS5zbGljZShvZmZzZXQgLSBjdXRPZmYsIG9mZnNldCkgKyBpbnNlcnQ7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gZW5kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXRlLnRyLmluc2VydFRleHQoaW5zZXJ0LCBzdGFydCwgZW5kKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBCdWlsZCBhbiBpbnB1dCBydWxlIGZvciBhdXRvbWF0aWNhbGx5IHdyYXBwaW5nIGEgdGV4dGJsb2NrIHdoZW4gYVxuICogZ2l2ZW4gc3RyaW5nIGlzIHR5cGVkLiBXaGVuIHVzaW5nIGEgcmVndWxhciBleHByZXNpb24geW914oCZbGxcbiAqIHByb2JhYmx5IHdhbnQgdGhlIHJlZ2V4cCB0byBzdGFydCB3aXRoIGBeYCwgc28gdGhhdCB0aGUgcGF0dGVybiBjYW5cbiAqIG9ubHkgb2NjdXIgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dGJsb2NrLlxuICpcbiAqIGB0eXBlYCBpcyB0aGUgdHlwZSBvZiBub2RlIHRvIHdyYXAgaW4uXG4gKlxuICogQnkgZGVmYXVsdCwgaWYgdGhlcmXigJlzIGEgbm9kZSB3aXRoIHRoZSBzYW1lIHR5cGUgYWJvdmUgdGhlIG5ld2x5XG4gKiB3cmFwcGVkIG5vZGUsIHRoZSBydWxlIHdpbGwgdHJ5IHRvIGpvaW4gdGhvc2VcbiAqIHR3byBub2Rlcy4gWW91IGNhbiBwYXNzIGEgam9pbiBwcmVkaWNhdGUsIHdoaWNoIHRha2VzIGEgcmVndWxhclxuICogZXhwcmVzc2lvbiBtYXRjaCBhbmQgdGhlIG5vZGUgYmVmb3JlIHRoZSB3cmFwcGVkIG5vZGUsIGFuZCBjYW5cbiAqIHJldHVybiBhIGJvb2xlYW4gdG8gaW5kaWNhdGUgd2hldGhlciBhIGpvaW4gc2hvdWxkIGhhcHBlbi5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2RvY3MvZWRpdG9yL2V4dGVuc2lvbnMvY3VzdG9tLWV4dGVuc2lvbnMvZXh0ZW5kLWV4aXN0aW5nI2lucHV0LXJ1bGVzXG4gKi9cbmZ1bmN0aW9uIHdyYXBwaW5nSW5wdXRSdWxlKGNvbmZpZykge1xuICAgIHJldHVybiBuZXcgSW5wdXRSdWxlKHtcbiAgICAgICAgZmluZDogY29uZmlnLmZpbmQsXG4gICAgICAgIGhhbmRsZXI6ICh7IHN0YXRlLCByYW5nZSwgbWF0Y2gsIGNoYWluLCB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gY2FsbE9yUmV0dXJuKGNvbmZpZy5nZXRBdHRyaWJ1dGVzLCB1bmRlZmluZWQsIG1hdGNoKSB8fCB7fTtcbiAgICAgICAgICAgIGNvbnN0IHRyID0gc3RhdGUudHIuZGVsZXRlKHJhbmdlLmZyb20sIHJhbmdlLnRvKTtcbiAgICAgICAgICAgIGNvbnN0ICRzdGFydCA9IHRyLmRvYy5yZXNvbHZlKHJhbmdlLmZyb20pO1xuICAgICAgICAgICAgY29uc3QgYmxvY2tSYW5nZSA9ICRzdGFydC5ibG9ja1JhbmdlKCk7XG4gICAgICAgICAgICBjb25zdCB3cmFwcGluZyA9IGJsb2NrUmFuZ2UgJiYgZmluZFdyYXBwaW5nKGJsb2NrUmFuZ2UsIGNvbmZpZy50eXBlLCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIGlmICghd3JhcHBpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyLndyYXAoYmxvY2tSYW5nZSwgd3JhcHBpbmcpO1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5rZWVwTWFya3MgJiYgY29uZmlnLmVkaXRvcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uLCBzdG9yZWRNYXJrcyB9ID0gc3RhdGU7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzcGxpdHRhYmxlTWFya3MgfSA9IGNvbmZpZy5lZGl0b3IuZXh0ZW5zaW9uTWFuYWdlcjtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXJrcyA9IHN0b3JlZE1hcmtzIHx8IChzZWxlY3Rpb24uJHRvLnBhcmVudE9mZnNldCAmJiBzZWxlY3Rpb24uJGZyb20ubWFya3MoKSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hcmtzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlcmVkTWFya3MgPSBtYXJrcy5maWx0ZXIobWFyayA9PiBzcGxpdHRhYmxlTWFya3MuaW5jbHVkZXMobWFyay50eXBlLm5hbWUpKTtcbiAgICAgICAgICAgICAgICAgICAgdHIuZW5zdXJlTWFya3MoZmlsdGVyZWRNYXJrcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZy5rZWVwQXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgIC8qKiBJZiB0aGUgbm9kZVR5cGUgaXMgYGJ1bGxldExpc3RgIG9yIGBvcmRlcmVkTGlzdGAgc2V0IHRoZSBgbm9kZVR5cGVgIGFzIGBsaXN0SXRlbWAgKi9cbiAgICAgICAgICAgICAgICBjb25zdCBub2RlVHlwZSA9IGNvbmZpZy50eXBlLm5hbWUgPT09ICdidWxsZXRMaXN0JyB8fCBjb25maWcudHlwZS5uYW1lID09PSAnb3JkZXJlZExpc3QnID8gJ2xpc3RJdGVtJyA6ICd0YXNrTGlzdCc7XG4gICAgICAgICAgICAgICAgY2hhaW4oKS51cGRhdGVBdHRyaWJ1dGVzKG5vZGVUeXBlLCBhdHRyaWJ1dGVzKS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJlZm9yZSA9IHRyLmRvYy5yZXNvbHZlKHJhbmdlLmZyb20gLSAxKS5ub2RlQmVmb3JlO1xuICAgICAgICAgICAgaWYgKGJlZm9yZVxuICAgICAgICAgICAgICAgICYmIGJlZm9yZS50eXBlID09PSBjb25maWcudHlwZVxuICAgICAgICAgICAgICAgICYmIGNhbkpvaW4odHIuZG9jLCByYW5nZS5mcm9tIC0gMSlcbiAgICAgICAgICAgICAgICAmJiAoIWNvbmZpZy5qb2luUHJlZGljYXRlIHx8IGNvbmZpZy5qb2luUHJlZGljYXRlKG1hdGNoLCBiZWZvcmUpKSkge1xuICAgICAgICAgICAgICAgIHRyLmpvaW4ocmFuZ2UuZnJvbSAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0pO1xufVxuXG4vKipcbiAqIFRoZSBOb2RlIGNsYXNzIGlzIHVzZWQgdG8gY3JlYXRlIGN1c3RvbSBub2RlIGV4dGVuc2lvbnMuXG4gKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9hcGkvZXh0ZW5zaW9ucyNjcmVhdGUtYS1uZXctZXh0ZW5zaW9uXG4gKi9cbmNsYXNzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHRoaXMudHlwZSA9ICdub2RlJztcbiAgICAgICAgdGhpcy5uYW1lID0gJ25vZGUnO1xuICAgICAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgICAgIHRoaXMuY2hpbGQgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgIGRlZmF1bHRPcHRpb25zOiB7fSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jb25maWcgPSB7XG4gICAgICAgICAgICAuLi50aGlzLmNvbmZpZyxcbiAgICAgICAgICAgIC4uLmNvbmZpZyxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5jb25maWcubmFtZTtcbiAgICAgICAgaWYgKGNvbmZpZy5kZWZhdWx0T3B0aW9ucyAmJiBPYmplY3Qua2V5cyhjb25maWcuZGVmYXVsdE9wdGlvbnMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgW3RpcHRhcCB3YXJuXTogQlJFQUtJTkcgQ0hBTkdFOiBcImRlZmF1bHRPcHRpb25zXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcImFkZE9wdGlvbnNcIiBpbnN0ZWFkLiBGb3VuZCBpbiBleHRlbnNpb246IFwiJHt0aGlzLm5hbWV9XCIuYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogcmVtb3ZlIGBhZGRPcHRpb25zYCBmYWxsYmFja1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB0aGlzLmNvbmZpZy5kZWZhdWx0T3B0aW9ucztcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLmFkZE9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZCh0aGlzLCAnYWRkT3B0aW9ucycsIHtcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdG9yYWdlID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKHRoaXMsICdhZGRTdG9yYWdlJywge1xuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgb3B0aW9uczogdGhpcy5vcHRpb25zLFxuICAgICAgICB9KSkgfHwge307XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUoY29uZmlnID0ge30pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlKGNvbmZpZyk7XG4gICAgfVxuICAgIGNvbmZpZ3VyZShvcHRpb25zID0ge30pIHtcbiAgICAgICAgLy8gcmV0dXJuIGEgbmV3IGluc3RhbmNlIHNvIHdlIGNhbiB1c2UgdGhlIHNhbWUgZXh0ZW5zaW9uXG4gICAgICAgIC8vIHdpdGggZGlmZmVyZW50IGNhbGxzIG9mIGBjb25maWd1cmVgXG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbiA9IHRoaXMuZXh0ZW5kKHtcbiAgICAgICAgICAgIC4uLnRoaXMuY29uZmlnLFxuICAgICAgICAgICAgYWRkT3B0aW9uczogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXJnZURlZXAodGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBBbHdheXMgcHJlc2VydmUgdGhlIGN1cnJlbnQgbmFtZVxuICAgICAgICBleHRlbnNpb24ubmFtZSA9IHRoaXMubmFtZTtcbiAgICAgICAgLy8gU2V0IHRoZSBwYXJlbnQgdG8gYmUgb3VyIHBhcmVudFxuICAgICAgICBleHRlbnNpb24ucGFyZW50ID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgIHJldHVybiBleHRlbnNpb247XG4gICAgfVxuICAgIGV4dGVuZChleHRlbmRlZENvbmZpZyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IGV4dGVuc2lvbiA9IG5ldyBOb2RlKGV4dGVuZGVkQ29uZmlnKTtcbiAgICAgICAgZXh0ZW5zaW9uLnBhcmVudCA9IHRoaXM7XG4gICAgICAgIHRoaXMuY2hpbGQgPSBleHRlbnNpb247XG4gICAgICAgIGV4dGVuc2lvbi5uYW1lID0gZXh0ZW5kZWRDb25maWcubmFtZSA/IGV4dGVuZGVkQ29uZmlnLm5hbWUgOiBleHRlbnNpb24ucGFyZW50Lm5hbWU7XG4gICAgICAgIGlmIChleHRlbmRlZENvbmZpZy5kZWZhdWx0T3B0aW9ucyAmJiBPYmplY3Qua2V5cyhleHRlbmRlZENvbmZpZy5kZWZhdWx0T3B0aW9ucykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBbdGlwdGFwIHdhcm5dOiBCUkVBS0lORyBDSEFOR0U6IFwiZGVmYXVsdE9wdGlvbnNcIiBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIFwiYWRkT3B0aW9uc1wiIGluc3RlYWQuIEZvdW5kIGluIGV4dGVuc2lvbjogXCIke2V4dGVuc2lvbi5uYW1lfVwiLmApO1xuICAgICAgICB9XG4gICAgICAgIGV4dGVuc2lvbi5vcHRpb25zID0gY2FsbE9yUmV0dXJuKGdldEV4dGVuc2lvbkZpZWxkKGV4dGVuc2lvbiwgJ2FkZE9wdGlvbnMnLCB7XG4gICAgICAgICAgICBuYW1lOiBleHRlbnNpb24ubmFtZSxcbiAgICAgICAgfSkpO1xuICAgICAgICBleHRlbnNpb24uc3RvcmFnZSA9IGNhbGxPclJldHVybihnZXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24sICdhZGRTdG9yYWdlJywge1xuICAgICAgICAgICAgbmFtZTogZXh0ZW5zaW9uLm5hbWUsXG4gICAgICAgICAgICBvcHRpb25zOiBleHRlbnNpb24ub3B0aW9ucyxcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gZXh0ZW5zaW9uO1xuICAgIH1cbn1cblxuLyoqXG4gKiBOb2RlIHZpZXdzIGFyZSB1c2VkIHRvIGN1c3RvbWl6ZSB0aGUgcmVuZGVyZWQgRE9NIHN0cnVjdHVyZSBvZiBhIG5vZGUuXG4gKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9ndWlkZS9ub2RlLXZpZXdzXG4gKi9cbmNsYXNzIE5vZGVWaWV3IHtcbiAgICBjb25zdHJ1Y3Rvcihjb21wb25lbnQsIHByb3BzLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IGNvbXBvbmVudDtcbiAgICAgICAgdGhpcy5lZGl0b3IgPSBwcm9wcy5lZGl0b3I7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHN0b3BFdmVudDogbnVsbCxcbiAgICAgICAgICAgIGlnbm9yZU11dGF0aW9uOiBudWxsLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5leHRlbnNpb24gPSBwcm9wcy5leHRlbnNpb247XG4gICAgICAgIHRoaXMubm9kZSA9IHByb3BzLm5vZGU7XG4gICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSBwcm9wcy5kZWNvcmF0aW9ucztcbiAgICAgICAgdGhpcy5pbm5lckRlY29yYXRpb25zID0gcHJvcHMuaW5uZXJEZWNvcmF0aW9ucztcbiAgICAgICAgdGhpcy52aWV3ID0gcHJvcHMudmlldztcbiAgICAgICAgdGhpcy5IVE1MQXR0cmlidXRlcyA9IHByb3BzLkhUTUxBdHRyaWJ1dGVzO1xuICAgICAgICB0aGlzLmdldFBvcyA9IHByb3BzLmdldFBvcztcbiAgICAgICAgdGhpcy5tb3VudCgpO1xuICAgIH1cbiAgICBtb3VudCgpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZ2V0IGRvbSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWRpdG9yLnZpZXcuZG9tO1xuICAgIH1cbiAgICBnZXQgY29udGVudERPTSgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIG9uRHJhZ1N0YXJ0KGV2ZW50KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZztcbiAgICAgICAgY29uc3QgeyB2aWV3IH0gPSB0aGlzLmVkaXRvcjtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICAvLyBnZXQgdGhlIGRyYWcgaGFuZGxlIGVsZW1lbnRcbiAgICAgICAgLy8gYGNsb3Nlc3RgIGlzIG5vdCBhdmFpbGFibGUgZm9yIHRleHQgbm9kZXMgc28gd2UgbWF5IGhhdmUgdG8gdXNlIGl0cyBwYXJlbnRcbiAgICAgICAgY29uc3QgZHJhZ0hhbmRsZSA9IHRhcmdldC5ub2RlVHlwZSA9PT0gM1xuICAgICAgICAgICAgPyAoX2EgPSB0YXJnZXQucGFyZW50RWxlbWVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsb3Nlc3QoJ1tkYXRhLWRyYWctaGFuZGxlXScpXG4gICAgICAgICAgICA6IHRhcmdldC5jbG9zZXN0KCdbZGF0YS1kcmFnLWhhbmRsZV0nKTtcbiAgICAgICAgaWYgKCF0aGlzLmRvbSB8fCAoKF9iID0gdGhpcy5jb250ZW50RE9NKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY29udGFpbnModGFyZ2V0KSkgfHwgIWRyYWdIYW5kbGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgeCA9IDA7XG4gICAgICAgIGxldCB5ID0gMDtcbiAgICAgICAgLy8gY2FsY3VsYXRlIG9mZnNldCBmb3IgZHJhZyBlbGVtZW50IGlmIHdlIHVzZSBhIGRpZmZlcmVudCBkcmFnIGhhbmRsZSBlbGVtZW50XG4gICAgICAgIGlmICh0aGlzLmRvbSAhPT0gZHJhZ0hhbmRsZSkge1xuICAgICAgICAgICAgY29uc3QgZG9tQm94ID0gdGhpcy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVCb3ggPSBkcmFnSGFuZGxlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgLy8gSW4gUmVhY3QsIHdlIGhhdmUgdG8gZ28gdGhyb3VnaCBuYXRpdmVFdmVudCB0byByZWFjaCBvZmZzZXRYL29mZnNldFkuXG4gICAgICAgICAgICBjb25zdCBvZmZzZXRYID0gKF9jID0gZXZlbnQub2Zmc2V0WCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogKF9kID0gZXZlbnQubmF0aXZlRXZlbnQpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5vZmZzZXRYO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0WSA9IChfZSA9IGV2ZW50Lm9mZnNldFkpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IChfZiA9IGV2ZW50Lm5hdGl2ZUV2ZW50KSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Yub2Zmc2V0WTtcbiAgICAgICAgICAgIHggPSBoYW5kbGVCb3gueCAtIGRvbUJveC54ICsgb2Zmc2V0WDtcbiAgICAgICAgICAgIHkgPSBoYW5kbGVCb3gueSAtIGRvbUJveC55ICsgb2Zmc2V0WTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjbG9uZWROb2RlID0gdGhpcy5kb20uY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICAoX2cgPSBldmVudC5kYXRhVHJhbnNmZXIpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5zZXREcmFnSW1hZ2UoY2xvbmVkTm9kZSwgeCwgeSk7XG4gICAgICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0UG9zKCk7XG4gICAgICAgIGlmICh0eXBlb2YgcG9zICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdlIG5lZWQgdG8gdGVsbCBQcm9zZU1pcnJvciB0aGF0IHdlIHdhbnQgdG8gbW92ZSB0aGUgd2hvbGUgbm9kZVxuICAgICAgICAvLyBzbyB3ZSBjcmVhdGUgYSBOb2RlU2VsZWN0aW9uXG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IE5vZGVTZWxlY3Rpb24uY3JlYXRlKHZpZXcuc3RhdGUuZG9jLCBwb3MpO1xuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHZpZXcuc3RhdGUudHIuc2V0U2VsZWN0aW9uKHNlbGVjdGlvbik7XG4gICAgICAgIHZpZXcuZGlzcGF0Y2godHJhbnNhY3Rpb24pO1xuICAgIH1cbiAgICBzdG9wRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIXRoaXMuZG9tKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuc3RvcEV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnN0b3BFdmVudCh7IGV2ZW50IH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgY29uc3QgaXNJbkVsZW1lbnQgPSB0aGlzLmRvbS5jb250YWlucyh0YXJnZXQpICYmICEoKF9hID0gdGhpcy5jb250ZW50RE9NKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29udGFpbnModGFyZ2V0KSk7XG4gICAgICAgIC8vIGFueSBldmVudCBmcm9tIGNoaWxkIG5vZGVzIHNob3VsZCBiZSBoYW5kbGVkIGJ5IFByb3NlTWlycm9yXG4gICAgICAgIGlmICghaXNJbkVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc0RyYWdFdmVudCA9IGV2ZW50LnR5cGUuc3RhcnRzV2l0aCgnZHJhZycpO1xuICAgICAgICBjb25zdCBpc0Ryb3BFdmVudCA9IGV2ZW50LnR5cGUgPT09ICdkcm9wJztcbiAgICAgICAgY29uc3QgaXNJbnB1dCA9IFsnSU5QVVQnLCAnQlVUVE9OJywgJ1NFTEVDVCcsICdURVhUQVJFQSddLmluY2x1ZGVzKHRhcmdldC50YWdOYW1lKSB8fCB0YXJnZXQuaXNDb250ZW50RWRpdGFibGU7XG4gICAgICAgIC8vIGFueSBpbnB1dCBldmVudCB3aXRoaW4gbm9kZSB2aWV3cyBzaG91bGQgYmUgaWdub3JlZCBieSBQcm9zZU1pcnJvclxuICAgICAgICBpZiAoaXNJbnB1dCAmJiAhaXNEcm9wRXZlbnQgJiYgIWlzRHJhZ0V2ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGlzRWRpdGFibGUgfSA9IHRoaXMuZWRpdG9yO1xuICAgICAgICBjb25zdCB7IGlzRHJhZ2dpbmcgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGlzRHJhZ2dhYmxlID0gISF0aGlzLm5vZGUudHlwZS5zcGVjLmRyYWdnYWJsZTtcbiAgICAgICAgY29uc3QgaXNTZWxlY3RhYmxlID0gTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUodGhpcy5ub2RlKTtcbiAgICAgICAgY29uc3QgaXNDb3B5RXZlbnQgPSBldmVudC50eXBlID09PSAnY29weSc7XG4gICAgICAgIGNvbnN0IGlzUGFzdGVFdmVudCA9IGV2ZW50LnR5cGUgPT09ICdwYXN0ZSc7XG4gICAgICAgIGNvbnN0IGlzQ3V0RXZlbnQgPSBldmVudC50eXBlID09PSAnY3V0JztcbiAgICAgICAgY29uc3QgaXNDbGlja0V2ZW50ID0gZXZlbnQudHlwZSA9PT0gJ21vdXNlZG93bic7XG4gICAgICAgIC8vIFByb3NlTWlycm9yIHRyaWVzIHRvIGRyYWcgc2VsZWN0YWJsZSBub2Rlc1xuICAgICAgICAvLyBldmVuIGlmIGBkcmFnZ2FibGVgIGlzIHNldCB0byBgZmFsc2VgXG4gICAgICAgIC8vIHRoaXMgZml4IHByZXZlbnRzIHRoYXRcbiAgICAgICAgaWYgKCFpc0RyYWdnYWJsZSAmJiBpc1NlbGVjdGFibGUgJiYgaXNEcmFnRXZlbnQgJiYgZXZlbnQudGFyZ2V0ID09PSB0aGlzLmRvbSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNEcmFnZ2FibGUgJiYgaXNEcmFnRXZlbnQgJiYgIWlzRHJhZ2dpbmcgJiYgZXZlbnQudGFyZ2V0ID09PSB0aGlzLmRvbSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyB3ZSBoYXZlIHRvIHN0b3JlIHRoYXQgZHJhZ2dpbmcgc3RhcnRlZFxuICAgICAgICBpZiAoaXNEcmFnZ2FibGUgJiYgaXNFZGl0YWJsZSAmJiAhaXNEcmFnZ2luZyAmJiBpc0NsaWNrRXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRyYWdIYW5kbGUgPSB0YXJnZXQuY2xvc2VzdCgnW2RhdGEtZHJhZy1oYW5kbGVdJyk7XG4gICAgICAgICAgICBjb25zdCBpc1ZhbGlkRHJhZ0hhbmRsZSA9IGRyYWdIYW5kbGUgJiYgKHRoaXMuZG9tID09PSBkcmFnSGFuZGxlIHx8IHRoaXMuZG9tLmNvbnRhaW5zKGRyYWdIYW5kbGUpKTtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRHJhZ0hhbmRsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ2VuZCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSwgeyBvbmNlOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2Ryb3AnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0sIHsgb25jZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9LCB7IG9uY2U6IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhlc2UgZXZlbnRzIGFyZSBoYW5kbGVkIGJ5IHByb3NlbWlycm9yXG4gICAgICAgIGlmIChpc0RyYWdnaW5nXG4gICAgICAgICAgICB8fCBpc0Ryb3BFdmVudFxuICAgICAgICAgICAgfHwgaXNDb3B5RXZlbnRcbiAgICAgICAgICAgIHx8IGlzUGFzdGVFdmVudFxuICAgICAgICAgICAgfHwgaXNDdXRFdmVudFxuICAgICAgICAgICAgfHwgKGlzQ2xpY2tFdmVudCAmJiBpc1NlbGVjdGFibGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIGEgRE9NIFttdXRhdGlvbl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL011dGF0aW9uT2JzZXJ2ZXIpIG9yIGEgc2VsZWN0aW9uIGNoYW5nZSBoYXBwZW5zIHdpdGhpbiB0aGUgdmlldy5cbiAgICAgKiBAcmV0dXJuIGBmYWxzZWAgaWYgdGhlIGVkaXRvciBzaG91bGQgcmUtcmVhZCB0aGUgc2VsZWN0aW9uIG9yIHJlLXBhcnNlIHRoZSByYW5nZSBhcm91bmQgdGhlIG11dGF0aW9uXG4gICAgICogQHJldHVybiBgdHJ1ZWAgaWYgaXQgY2FuIHNhZmVseSBiZSBpZ25vcmVkLlxuICAgICAqL1xuICAgIGlnbm9yZU11dGF0aW9uKG11dGF0aW9uKSB7XG4gICAgICAgIGlmICghdGhpcy5kb20gfHwgIXRoaXMuY29udGVudERPTSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuaWdub3JlTXV0YXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuaWdub3JlTXV0YXRpb24oeyBtdXRhdGlvbiB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhIGxlYWYvYXRvbSBub2RlIGlzIGxpa2UgYSBibGFjayBib3ggZm9yIFByb3NlTWlycm9yXG4gICAgICAgIC8vIGFuZCBzaG91bGQgYmUgZnVsbHkgaGFuZGxlZCBieSB0aGUgbm9kZSB2aWV3XG4gICAgICAgIGlmICh0aGlzLm5vZGUuaXNMZWFmIHx8IHRoaXMubm9kZS5pc0F0b20pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByb3NlTWlycm9yIHNob3VsZCBoYW5kbGUgYW55IHNlbGVjdGlvbnNcbiAgICAgICAgaWYgKG11dGF0aW9uLnR5cGUgPT09ICdzZWxlY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdHJ5IHRvIHByZXZlbnQgYSBidWcgb24gaU9TIGFuZCBBbmRyb2lkIHRoYXQgd2lsbCBicmVhayBub2RlIHZpZXdzIG9uIGVudGVyXG4gICAgICAgIC8vIHRoaXMgaXMgYmVjYXVzZSBQcm9zZU1pcnJvciBjYW7igJl0IHByZXZlbnREaXNwYXRjaCBvbiBlbnRlclxuICAgICAgICAvLyB0aGlzIHdpbGwgbGVhZCB0byBhIHJlLXJlbmRlciBvZiB0aGUgbm9kZSB2aWV3IG9uIGVudGVyXG4gICAgICAgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL3VlYmVyZG9zaXMvdGlwdGFwL2lzc3Vlcy8xMjE0XG4gICAgICAgIC8vIHNlZTogaHR0cHM6Ly9naXRodWIuY29tL3VlYmVyZG9zaXMvdGlwdGFwL2lzc3Vlcy8yNTM0XG4gICAgICAgIGlmICh0aGlzLmRvbS5jb250YWlucyhtdXRhdGlvbi50YXJnZXQpXG4gICAgICAgICAgICAmJiBtdXRhdGlvbi50eXBlID09PSAnY2hpbGRMaXN0J1xuICAgICAgICAgICAgJiYgKGlzaU9TKCkgfHwgaXNBbmRyb2lkKCkpXG4gICAgICAgICAgICAmJiB0aGlzLmVkaXRvci5pc0ZvY3VzZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZWROb2RlcyA9IFtcbiAgICAgICAgICAgICAgICAuLi5BcnJheS5mcm9tKG11dGF0aW9uLmFkZGVkTm9kZXMpLFxuICAgICAgICAgICAgICAgIC4uLkFycmF5LmZyb20obXV0YXRpb24ucmVtb3ZlZE5vZGVzKSxcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICAvLyB3ZeKAmWxsIGNoZWNrIGlmIGV2ZXJ5IGNoYW5nZWQgbm9kZSBpcyBjb250ZW50RWRpdGFibGVcbiAgICAgICAgICAgIC8vIHRvIG1ha2Ugc3VyZSBpdOKAmXMgcHJvYmFibHkgbXV0YXRlZCBieSBQcm9zZU1pcnJvclxuICAgICAgICAgICAgaWYgKGNoYW5nZWROb2Rlcy5ldmVyeShub2RlID0+IG5vZGUuaXNDb250ZW50RWRpdGFibGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHdlIHdpbGwgYWxsb3cgbXV0YXRpb24gY29udGVudERPTSB3aXRoIGF0dHJpYnV0ZXNcbiAgICAgICAgLy8gc28gd2UgY2FuIGZvciBleGFtcGxlIGFkZGluZyBjbGFzc2VzIHdpdGhpbiBvdXIgbm9kZSB2aWV3XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRET00gPT09IG11dGF0aW9uLnRhcmdldCAmJiBtdXRhdGlvbi50eXBlID09PSAnYXR0cmlidXRlcycpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByb3NlTWlycm9yIHNob3VsZCBoYW5kbGUgYW55IGNoYW5nZXMgd2l0aGluIGNvbnRlbnRET01cbiAgICAgICAgaWYgKHRoaXMuY29udGVudERPTS5jb250YWlucyhtdXRhdGlvbi50YXJnZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgYXR0cmlidXRlcyBvZiB0aGUgcHJvc2VtaXJyb3Igbm9kZS5cbiAgICAgKi9cbiAgICB1cGRhdGVBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgdGhpcy5lZGl0b3IuY29tbWFuZHMuY29tbWFuZCgoeyB0ciB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwb3MgPSB0aGlzLmdldFBvcygpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwb3MgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cChwb3MsIHVuZGVmaW5lZCwge1xuICAgICAgICAgICAgICAgIC4uLnRoaXMubm9kZS5hdHRycyxcbiAgICAgICAgICAgICAgICAuLi5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlbGV0ZSB0aGUgbm9kZS5cbiAgICAgKi9cbiAgICBkZWxldGVOb2RlKCkge1xuICAgICAgICBjb25zdCBmcm9tID0gdGhpcy5nZXRQb3MoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBmcm9tICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvID0gZnJvbSArIHRoaXMubm9kZS5ub2RlU2l6ZTtcbiAgICAgICAgdGhpcy5lZGl0b3IuY29tbWFuZHMuZGVsZXRlUmFuZ2UoeyBmcm9tLCB0byB9KTtcbiAgICB9XG59XG5cbi8qKlxuICogQnVpbGQgYW4gcGFzdGUgcnVsZSB0aGF0IGFkZHMgYSBtYXJrIHdoZW4gdGhlXG4gKiBtYXRjaGVkIHRleHQgaXMgcGFzdGVkIGludG8gaXQuXG4gKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9kb2NzL2VkaXRvci9leHRlbnNpb25zL2N1c3RvbS1leHRlbnNpb25zL2V4dGVuZC1leGlzdGluZyNwYXN0ZS1ydWxlc1xuICovXG5mdW5jdGlvbiBtYXJrUGFzdGVSdWxlKGNvbmZpZykge1xuICAgIHJldHVybiBuZXcgUGFzdGVSdWxlKHtcbiAgICAgICAgZmluZDogY29uZmlnLmZpbmQsXG4gICAgICAgIGhhbmRsZXI6ICh7IHN0YXRlLCByYW5nZSwgbWF0Y2gsIHBhc3RlRXZlbnQsIH0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBjYWxsT3JSZXR1cm4oY29uZmlnLmdldEF0dHJpYnV0ZXMsIHVuZGVmaW5lZCwgbWF0Y2gsIHBhc3RlRXZlbnQpO1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXMgPT09IGZhbHNlIHx8IGF0dHJpYnV0ZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgdHIgfSA9IHN0YXRlO1xuICAgICAgICAgICAgY29uc3QgY2FwdHVyZUdyb3VwID0gbWF0Y2hbbWF0Y2gubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBjb25zdCBmdWxsTWF0Y2ggPSBtYXRjaFswXTtcbiAgICAgICAgICAgIGxldCBtYXJrRW5kID0gcmFuZ2UudG87XG4gICAgICAgICAgICBpZiAoY2FwdHVyZUdyb3VwKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnRTcGFjZXMgPSBmdWxsTWF0Y2guc2VhcmNoKC9cXFMvKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0U3RhcnQgPSByYW5nZS5mcm9tICsgZnVsbE1hdGNoLmluZGV4T2YoY2FwdHVyZUdyb3VwKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0RW5kID0gdGV4dFN0YXJ0ICsgY2FwdHVyZUdyb3VwLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjb25zdCBleGNsdWRlZE1hcmtzID0gZ2V0TWFya3NCZXR3ZWVuKHJhbmdlLmZyb20sIHJhbmdlLnRvLCBzdGF0ZS5kb2MpXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhjbHVkZWQgPSBpdGVtLm1hcmsudHlwZS5leGNsdWRlZDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4Y2x1ZGVkLmZpbmQodHlwZSA9PiB0eXBlID09PSBjb25maWcudHlwZSAmJiB0eXBlICE9PSBpdGVtLm1hcmsudHlwZSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihpdGVtID0+IGl0ZW0udG8gPiB0ZXh0U3RhcnQpO1xuICAgICAgICAgICAgICAgIGlmIChleGNsdWRlZE1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRleHRFbmQgPCByYW5nZS50bykge1xuICAgICAgICAgICAgICAgICAgICB0ci5kZWxldGUodGV4dEVuZCwgcmFuZ2UudG8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGV4dFN0YXJ0ID4gcmFuZ2UuZnJvbSkge1xuICAgICAgICAgICAgICAgICAgICB0ci5kZWxldGUocmFuZ2UuZnJvbSArIHN0YXJ0U3BhY2VzLCB0ZXh0U3RhcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYXJrRW5kID0gcmFuZ2UuZnJvbSArIHN0YXJ0U3BhY2VzICsgY2FwdHVyZUdyb3VwLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB0ci5hZGRNYXJrKHJhbmdlLmZyb20gKyBzdGFydFNwYWNlcywgbWFya0VuZCwgY29uZmlnLnR5cGUuY3JlYXRlKGF0dHJpYnV0ZXMgfHwge30pKTtcbiAgICAgICAgICAgICAgICB0ci5yZW1vdmVTdG9yZWRNYXJrKGNvbmZpZy50eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gY2FuSW5zZXJ0Tm9kZShzdGF0ZSwgbm9kZVR5cGUpIHtcbiAgICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gc3RhdGU7XG4gICAgY29uc3QgeyAkZnJvbSB9ID0gc2VsZWN0aW9uO1xuICAgIC8vIFNwZWNpYWwgaGFuZGxpbmcgZm9yIE5vZGVTZWxlY3Rpb25cbiAgICBpZiAoc2VsZWN0aW9uIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbikge1xuICAgICAgICBjb25zdCBpbmRleCA9ICRmcm9tLmluZGV4KCk7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9ICRmcm9tLnBhcmVudDtcbiAgICAgICAgLy8gQ2FuIHdlIHJlcGxhY2UgdGhlIHNlbGVjdGVkIG5vZGUgd2l0aCB0aGUgaG9yaXpvbnRhbCBydWxlP1xuICAgICAgICByZXR1cm4gcGFyZW50LmNhblJlcGxhY2VXaXRoKGluZGV4LCBpbmRleCArIDEsIG5vZGVUeXBlKTtcbiAgICB9XG4gICAgLy8gRGVmYXVsdDogY2hlY2sgaWYgd2UgY2FuIGluc2VydCBhdCB0aGUgY3VycmVudCBwb3NpdGlvblxuICAgIGxldCBkZXB0aCA9ICRmcm9tLmRlcHRoO1xuICAgIHdoaWxlIChkZXB0aCA+PSAwKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gJGZyb20uaW5kZXgoZGVwdGgpO1xuICAgICAgICBjb25zdCBwYXJlbnQgPSAkZnJvbS5ub2RlKGRlcHRoKTtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBwYXJlbnQuY29udGVudE1hdGNoQXQoaW5kZXgpO1xuICAgICAgICBpZiAobWF0Y2gubWF0Y2hUeXBlKG5vZGVUeXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZGVwdGggLT0gMTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBzb3VyY2U6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS82OTY5NDg2XG5mdW5jdGlvbiBlc2NhcGVGb3JSZWdFeChzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoL1stL1xcXFxeJCorPy4oKXxbXFxde31dL2csICdcXFxcJCYnKTtcbn1cblxuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbn1cblxuLyoqXG4gKiBCdWlsZCBhbiBwYXN0ZSBydWxlIHRoYXQgYWRkcyBhIG5vZGUgd2hlbiB0aGVcbiAqIG1hdGNoZWQgdGV4dCBpcyBwYXN0ZWQgaW50byBpdC5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2RvY3MvZWRpdG9yL2V4dGVuc2lvbnMvY3VzdG9tLWV4dGVuc2lvbnMvZXh0ZW5kLWV4aXN0aW5nI3Bhc3RlLXJ1bGVzXG4gKi9cbmZ1bmN0aW9uIG5vZGVQYXN0ZVJ1bGUoY29uZmlnKSB7XG4gICAgcmV0dXJuIG5ldyBQYXN0ZVJ1bGUoe1xuICAgICAgICBmaW5kOiBjb25maWcuZmluZCxcbiAgICAgICAgaGFuZGxlcih7IG1hdGNoLCBjaGFpbiwgcmFuZ2UsIHBhc3RlRXZlbnQsIH0pIHtcbiAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBjYWxsT3JSZXR1cm4oY29uZmlnLmdldEF0dHJpYnV0ZXMsIHVuZGVmaW5lZCwgbWF0Y2gsIHBhc3RlRXZlbnQpO1xuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGNhbGxPclJldHVybihjb25maWcuZ2V0Q29udGVudCwgdW5kZWZpbmVkLCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVzID09PSBmYWxzZSB8fCBhdHRyaWJ1dGVzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBub2RlID0geyB0eXBlOiBjb25maWcudHlwZS5uYW1lLCBhdHRyczogYXR0cmlidXRlcyB9O1xuICAgICAgICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICBub2RlLmNvbnRlbnQgPSBjb250ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1hdGNoLmlucHV0KSB7XG4gICAgICAgICAgICAgICAgY2hhaW4oKS5kZWxldGVSYW5nZShyYW5nZSkuaW5zZXJ0Q29udGVudEF0KHJhbmdlLmZyb20sIG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH0pO1xufVxuXG4vKipcbiAqIEJ1aWxkIGFuIHBhc3RlIHJ1bGUgdGhhdCByZXBsYWNlcyB0ZXh0IHdoZW4gdGhlXG4gKiBtYXRjaGVkIHRleHQgaXMgcGFzdGVkIGludG8gaXQuXG4gKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9kb2NzL2VkaXRvci9leHRlbnNpb25zL2N1c3RvbS1leHRlbnNpb25zL2V4dGVuZC1leGlzdGluZyNwYXN0ZS1ydWxlc1xuICovXG5mdW5jdGlvbiB0ZXh0UGFzdGVSdWxlKGNvbmZpZykge1xuICAgIHJldHVybiBuZXcgUGFzdGVSdWxlKHtcbiAgICAgICAgZmluZDogY29uZmlnLmZpbmQsXG4gICAgICAgIGhhbmRsZXI6ICh7IHN0YXRlLCByYW5nZSwgbWF0Y2ggfSkgPT4ge1xuICAgICAgICAgICAgbGV0IGluc2VydCA9IGNvbmZpZy5yZXBsYWNlO1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gcmFuZ2UuZnJvbTtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IHJhbmdlLnRvO1xuICAgICAgICAgICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gbWF0Y2hbMF0ubGFzdEluZGV4T2YobWF0Y2hbMV0pO1xuICAgICAgICAgICAgICAgIGluc2VydCArPSBtYXRjaFswXS5zbGljZShvZmZzZXQgKyBtYXRjaFsxXS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIHN0YXJ0ICs9IG9mZnNldDtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXRPZmYgPSBzdGFydCAtIGVuZDtcbiAgICAgICAgICAgICAgICBpZiAoY3V0T2ZmID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnQgPSBtYXRjaFswXS5zbGljZShvZmZzZXQgLSBjdXRPZmYsIG9mZnNldCkgKyBpbnNlcnQ7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gZW5kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXRlLnRyLmluc2VydFRleHQoaW5zZXJ0LCBzdGFydCwgZW5kKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cblxuY2xhc3MgVHJhY2tlciB7XG4gICAgY29uc3RydWN0b3IodHJhbnNhY3Rpb24pIHtcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uO1xuICAgICAgICB0aGlzLmN1cnJlbnRTdGVwID0gdGhpcy50cmFuc2FjdGlvbi5zdGVwcy5sZW5ndGg7XG4gICAgfVxuICAgIG1hcChwb3NpdGlvbikge1xuICAgICAgICBsZXQgZGVsZXRlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBtYXBwZWRQb3NpdGlvbiA9IHRoaXMudHJhbnNhY3Rpb24uc3RlcHNcbiAgICAgICAgICAgIC5zbGljZSh0aGlzLmN1cnJlbnRTdGVwKVxuICAgICAgICAgICAgLnJlZHVjZSgobmV3UG9zaXRpb24sIHN0ZXApID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1hcFJlc3VsdCA9IHN0ZXAuZ2V0TWFwKCkubWFwUmVzdWx0KG5ld1Bvc2l0aW9uKTtcbiAgICAgICAgICAgIGlmIChtYXBSZXN1bHQuZGVsZXRlZCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hcFJlc3VsdC5wb3M7XG4gICAgICAgIH0sIHBvc2l0aW9uKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBtYXBwZWRQb3NpdGlvbixcbiAgICAgICAgICAgIGRlbGV0ZWQsXG4gICAgICAgIH07XG4gICAgfVxufVxuXG5leHBvcnQgeyBDb21tYW5kTWFuYWdlciwgRWRpdG9yLCBFeHRlbnNpb24sIElucHV0UnVsZSwgTWFyaywgTm9kZSwgTm9kZVBvcywgTm9kZVZpZXcsIFBhc3RlUnVsZSwgVHJhY2tlciwgY2FsbE9yUmV0dXJuLCBjYW5JbnNlcnROb2RlLCBjb21iaW5lVHJhbnNhY3Rpb25TdGVwcywgY3JlYXRlQ2hhaW5hYmxlU3RhdGUsIGNyZWF0ZURvY3VtZW50LCBjcmVhdGVOb2RlRnJvbUNvbnRlbnQsIGNyZWF0ZVN0eWxlVGFnLCBkZWZhdWx0QmxvY2tBdCwgZGVsZXRlUHJvcHMsIGVsZW1lbnRGcm9tU3RyaW5nLCBlc2NhcGVGb3JSZWdFeCwgaW5kZXggYXMgZXh0ZW5zaW9ucywgZmluZENoaWxkcmVuLCBmaW5kQ2hpbGRyZW5JblJhbmdlLCBmaW5kRHVwbGljYXRlcywgZmluZFBhcmVudE5vZGUsIGZpbmRQYXJlbnROb2RlQ2xvc2VzdFRvUG9zLCBmcm9tU3RyaW5nLCBnZW5lcmF0ZUhUTUwsIGdlbmVyYXRlSlNPTiwgZ2VuZXJhdGVUZXh0LCBnZXRBdHRyaWJ1dGVzLCBnZXRBdHRyaWJ1dGVzRnJvbUV4dGVuc2lvbnMsIGdldENoYW5nZWRSYW5nZXMsIGdldERlYnVnSlNPTiwgZ2V0RXh0ZW5zaW9uRmllbGQsIGdldEhUTUxGcm9tRnJhZ21lbnQsIGdldE1hcmtBdHRyaWJ1dGVzLCBnZXRNYXJrUmFuZ2UsIGdldE1hcmtUeXBlLCBnZXRNYXJrc0JldHdlZW4sIGdldE5vZGVBdFBvc2l0aW9uLCBnZXROb2RlQXR0cmlidXRlcywgZ2V0Tm9kZVR5cGUsIGdldFJlbmRlcmVkQXR0cmlidXRlcywgZ2V0U2NoZW1hLCBnZXRTY2hlbWFCeVJlc29sdmVkRXh0ZW5zaW9ucywgZ2V0U2NoZW1hVHlwZUJ5TmFtZSwgZ2V0U2NoZW1hVHlwZU5hbWVCeU5hbWUsIGdldFNwbGl0dGVkQXR0cmlidXRlcywgZ2V0VGV4dCwgZ2V0VGV4dEJldHdlZW4sIGdldFRleHRDb250ZW50RnJvbU5vZGVzLCBnZXRUZXh0U2VyaWFsaXplcnNGcm9tU2NoZW1hLCBpbmplY3RFeHRlbnNpb25BdHRyaWJ1dGVzVG9QYXJzZVJ1bGUsIGlucHV0UnVsZXNQbHVnaW4sIGlzQWN0aXZlLCBpc0F0RW5kT2ZOb2RlLCBpc0F0U3RhcnRPZk5vZGUsIGlzRW1wdHlPYmplY3QsIGlzRXh0ZW5zaW9uUnVsZXNFbmFibGVkLCBpc0Z1bmN0aW9uLCBpc0xpc3QsIGlzTWFjT1MsIGlzTWFya0FjdGl2ZSwgaXNOb2RlQWN0aXZlLCBpc05vZGVFbXB0eSwgaXNOb2RlU2VsZWN0aW9uLCBpc051bWJlciwgaXNQbGFpbk9iamVjdCwgaXNSZWdFeHAsIGlzU3RyaW5nLCBpc1RleHRTZWxlY3Rpb24sIGlzaU9TLCBtYXJrSW5wdXRSdWxlLCBtYXJrUGFzdGVSdWxlLCBtZXJnZUF0dHJpYnV0ZXMsIG1lcmdlRGVlcCwgbWluTWF4LCBub2RlSW5wdXRSdWxlLCBub2RlUGFzdGVSdWxlLCBvYmplY3RJbmNsdWRlcywgcGFzdGVSdWxlc1BsdWdpbiwgcG9zVG9ET01SZWN0LCByZW1vdmVEdXBsaWNhdGVzLCByZXNvbHZlRm9jdXNQb3NpdGlvbiwgcmV3cml0ZVVua25vd25Db250ZW50LCBzZWxlY3Rpb25Ub0luc2VydGlvbkVuZCwgc3BsaXRFeHRlbnNpb25zLCB0ZXh0SW5wdXRSdWxlLCB0ZXh0UGFzdGVSdWxlLCB0ZXh0YmxvY2tUeXBlSW5wdXRSdWxlLCB3cmFwcGluZ0lucHV0UnVsZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/core/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/extension-blockquote/dist/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-blockquote/dist/index.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Blockquote: function() { return /* binding */ Blockquote; },\n/* harmony export */   \"default\": function() { return /* binding */ Blockquote; },\n/* harmony export */   inputRegex: function() { return /* binding */ inputRegex; }\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(app-pages-browser)/./node_modules/@tiptap/core/dist/index.js\");\n\n\n/**\n * Matches a blockquote to a `>` as input.\n */\nconst inputRegex = /^\\s*>\\s$/;\n/**\n * This extension allows you to create blockquotes.\n * @see https://tiptap.dev/api/nodes/blockquote\n */\nconst Blockquote = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: 'blockquote',\n    addOptions() {\n        return {\n            HTMLAttributes: {},\n        };\n    },\n    content: 'block+',\n    group: 'block',\n    defining: true,\n    parseHTML() {\n        return [\n            { tag: 'blockquote' },\n        ];\n    },\n    renderHTML({ HTMLAttributes }) {\n        return ['blockquote', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n    },\n    addCommands() {\n        return {\n            setBlockquote: () => ({ commands }) => {\n                return commands.wrapIn(this.name);\n            },\n            toggleBlockquote: () => ({ commands }) => {\n                return commands.toggleWrap(this.name);\n            },\n            unsetBlockquote: () => ({ commands }) => {\n                return commands.lift(this.name);\n            },\n        };\n    },\n    addKeyboardShortcuts() {\n        return {\n            'Mod-Shift-b': () => this.editor.commands.toggleBlockquote(),\n        };\n    },\n    addInputRules() {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\n                find: inputRegex,\n                type: this.type,\n            }),\n        ];\n    },\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1ibG9ja3F1b3RlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUF3RTs7QUFFeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw4Q0FBSTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQW1CO0FBQ2pDO0FBQ0EsS0FBSztBQUNMLGlCQUFpQixnQkFBZ0I7QUFDakMsOEJBQThCLDZEQUFlO0FBQzdDLEtBQUs7QUFDTDtBQUNBO0FBQ0Esb0NBQW9DLFVBQVU7QUFDOUM7QUFDQSxhQUFhO0FBQ2IsdUNBQXVDLFVBQVU7QUFDakQ7QUFDQSxhQUFhO0FBQ2Isc0NBQXNDLFVBQVU7QUFDaEQ7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVksK0RBQWlCO0FBQzdCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFd0Q7QUFDekQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWJsb2NrcXVvdGUvZGlzdC9pbmRleC5qcz9iOWI5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5vZGUsIG1lcmdlQXR0cmlidXRlcywgd3JhcHBpbmdJbnB1dFJ1bGUgfSBmcm9tICdAdGlwdGFwL2NvcmUnO1xuXG4vKipcbiAqIE1hdGNoZXMgYSBibG9ja3F1b3RlIHRvIGEgYD5gIGFzIGlucHV0LlxuICovXG5jb25zdCBpbnB1dFJlZ2V4ID0gL15cXHMqPlxccyQvO1xuLyoqXG4gKiBUaGlzIGV4dGVuc2lvbiBhbGxvd3MgeW91IHRvIGNyZWF0ZSBibG9ja3F1b3Rlcy5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2FwaS9ub2Rlcy9ibG9ja3F1b3RlXG4gKi9cbmNvbnN0IEJsb2NrcXVvdGUgPSBOb2RlLmNyZWF0ZSh7XG4gICAgbmFtZTogJ2Jsb2NrcXVvdGUnLFxuICAgIGFkZE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBjb250ZW50OiAnYmxvY2srJyxcbiAgICBncm91cDogJ2Jsb2NrJyxcbiAgICBkZWZpbmluZzogdHJ1ZSxcbiAgICBwYXJzZUhUTUwoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7IHRhZzogJ2Jsb2NrcXVvdGUnIH0sXG4gICAgICAgIF07XG4gICAgfSxcbiAgICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgICAgICByZXR1cm4gWydibG9ja3F1b3RlJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXTtcbiAgICB9LFxuICAgIGFkZENvbW1hbmRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2V0QmxvY2txdW90ZTogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy53cmFwSW4odGhpcy5uYW1lKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b2dnbGVCbG9ja3F1b3RlOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZVdyYXAodGhpcy5uYW1lKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1bnNldEJsb2NrcXVvdGU6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZHMubGlmdCh0aGlzLm5hbWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ01vZC1TaGlmdC1iJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlQmxvY2txdW90ZSgpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYWRkSW5wdXRSdWxlcygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHdyYXBwaW5nSW5wdXRSdWxlKHtcbiAgICAgICAgICAgICAgICBmaW5kOiBpbnB1dFJlZ2V4LFxuICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdO1xuICAgIH0sXG59KTtcblxuZXhwb3J0IHsgQmxvY2txdW90ZSwgQmxvY2txdW90ZSBhcyBkZWZhdWx0LCBpbnB1dFJlZ2V4IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/extension-blockquote/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/extension-bold/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/extension-bold/dist/index.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Bold: function() { return /* binding */ Bold; },\n/* harmony export */   \"default\": function() { return /* binding */ Bold; },\n/* harmony export */   starInputRegex: function() { return /* binding */ starInputRegex; },\n/* harmony export */   starPasteRegex: function() { return /* binding */ starPasteRegex; },\n/* harmony export */   underscoreInputRegex: function() { return /* binding */ underscoreInputRegex; },\n/* harmony export */   underscorePasteRegex: function() { return /* binding */ underscorePasteRegex; }\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(app-pages-browser)/./node_modules/@tiptap/core/dist/index.js\");\n\n\n/**\n * Matches bold text via `**` as input.\n */\nconst starInputRegex = /(?:^|\\s)(\\*\\*(?!\\s+\\*\\*)((?:[^*]+))\\*\\*(?!\\s+\\*\\*))$/;\n/**\n * Matches bold text via `**` while pasting.\n */\nconst starPasteRegex = /(?:^|\\s)(\\*\\*(?!\\s+\\*\\*)((?:[^*]+))\\*\\*(?!\\s+\\*\\*))/g;\n/**\n * Matches bold text via `__` as input.\n */\nconst underscoreInputRegex = /(?:^|\\s)(__(?!\\s+__)((?:[^_]+))__(?!\\s+__))$/;\n/**\n * Matches bold text via `__` while pasting.\n */\nconst underscorePasteRegex = /(?:^|\\s)(__(?!\\s+__)((?:[^_]+))__(?!\\s+__))/g;\n/**\n * This extension allows you to mark text as bold.\n * @see https://tiptap.dev/api/marks/bold\n */\nconst Bold = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\n    name: 'bold',\n    addOptions() {\n        return {\n            HTMLAttributes: {},\n        };\n    },\n    parseHTML() {\n        return [\n            {\n                tag: 'strong',\n            },\n            {\n                tag: 'b',\n                getAttrs: node => node.style.fontWeight !== 'normal' && null,\n            },\n            {\n                style: 'font-weight=400',\n                clearMark: mark => mark.type.name === this.name,\n            },\n            {\n                style: 'font-weight',\n                getAttrs: value => /^(bold(er)?|[5-9]\\d{2,})$/.test(value) && null,\n            },\n        ];\n    },\n    renderHTML({ HTMLAttributes }) {\n        return ['strong', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n    },\n    addCommands() {\n        return {\n            setBold: () => ({ commands }) => {\n                return commands.setMark(this.name);\n            },\n            toggleBold: () => ({ commands }) => {\n                return commands.toggleMark(this.name);\n            },\n            unsetBold: () => ({ commands }) => {\n                return commands.unsetMark(this.name);\n            },\n        };\n    },\n    addKeyboardShortcuts() {\n        return {\n            'Mod-b': () => this.editor.commands.toggleBold(),\n            'Mod-B': () => this.editor.commands.toggleBold(),\n        };\n    },\n    addInputRules() {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n                find: starInputRegex,\n                type: this.type,\n            }),\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n                find: underscoreInputRegex,\n                type: this.type,\n            }),\n        ];\n    },\n    addPasteRules() {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n                find: starPasteRegex,\n                type: this.type,\n            }),\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n                find: underscorePasteRegex,\n                type: this.type,\n            }),\n        ];\n    },\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1ib2xkL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFtRjs7QUFFbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsOENBQUk7QUFDakI7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHdEQUF3RCxHQUFHO0FBQzNELGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTCxpQkFBaUIsZ0JBQWdCO0FBQ2pDLDBCQUEwQiw2REFBZTtBQUN6QyxLQUFLO0FBQ0w7QUFDQTtBQUNBLDhCQUE4QixVQUFVO0FBQ3hDO0FBQ0EsYUFBYTtBQUNiLGlDQUFpQyxVQUFVO0FBQzNDO0FBQ0EsYUFBYTtBQUNiLGdDQUFnQyxVQUFVO0FBQzFDO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVksMkRBQWE7QUFDekI7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZLDJEQUFhO0FBQ3pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVksMkRBQWE7QUFDekI7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZLDJEQUFhO0FBQ3pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFNEc7QUFDN0ciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWJvbGQvZGlzdC9pbmRleC5qcz8zOWE1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1hcmssIG1lcmdlQXR0cmlidXRlcywgbWFya0lucHV0UnVsZSwgbWFya1Bhc3RlUnVsZSB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5cbi8qKlxuICogTWF0Y2hlcyBib2xkIHRleHQgdmlhIGAqKmAgYXMgaW5wdXQuXG4gKi9cbmNvbnN0IHN0YXJJbnB1dFJlZ2V4ID0gLyg/Ol58XFxzKShcXCpcXCooPyFcXHMrXFwqXFwqKSgoPzpbXipdKykpXFwqXFwqKD8hXFxzK1xcKlxcKikpJC87XG4vKipcbiAqIE1hdGNoZXMgYm9sZCB0ZXh0IHZpYSBgKipgIHdoaWxlIHBhc3RpbmcuXG4gKi9cbmNvbnN0IHN0YXJQYXN0ZVJlZ2V4ID0gLyg/Ol58XFxzKShcXCpcXCooPyFcXHMrXFwqXFwqKSgoPzpbXipdKykpXFwqXFwqKD8hXFxzK1xcKlxcKikpL2c7XG4vKipcbiAqIE1hdGNoZXMgYm9sZCB0ZXh0IHZpYSBgX19gIGFzIGlucHV0LlxuICovXG5jb25zdCB1bmRlcnNjb3JlSW5wdXRSZWdleCA9IC8oPzpefFxccykoX18oPyFcXHMrX18pKCg/OlteX10rKSlfXyg/IVxccytfXykpJC87XG4vKipcbiAqIE1hdGNoZXMgYm9sZCB0ZXh0IHZpYSBgX19gIHdoaWxlIHBhc3RpbmcuXG4gKi9cbmNvbnN0IHVuZGVyc2NvcmVQYXN0ZVJlZ2V4ID0gLyg/Ol58XFxzKShfXyg/IVxccytfXykoKD86W15fXSspKV9fKD8hXFxzK19fKSkvZztcbi8qKlxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBtYXJrIHRleHQgYXMgYm9sZC5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2FwaS9tYXJrcy9ib2xkXG4gKi9cbmNvbnN0IEJvbGQgPSBNYXJrLmNyZWF0ZSh7XG4gICAgbmFtZTogJ2JvbGQnLFxuICAgIGFkZE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBwYXJzZUhUTUwoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGFnOiAnc3Ryb25nJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGFnOiAnYicsXG4gICAgICAgICAgICAgICAgZ2V0QXR0cnM6IG5vZGUgPT4gbm9kZS5zdHlsZS5mb250V2VpZ2h0ICE9PSAnbm9ybWFsJyAmJiBudWxsLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdHlsZTogJ2ZvbnQtd2VpZ2h0PTQwMCcsXG4gICAgICAgICAgICAgICAgY2xlYXJNYXJrOiBtYXJrID0+IG1hcmsudHlwZS5uYW1lID09PSB0aGlzLm5hbWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHN0eWxlOiAnZm9udC13ZWlnaHQnLFxuICAgICAgICAgICAgICAgIGdldEF0dHJzOiB2YWx1ZSA9PiAvXihib2xkKGVyKT98WzUtOV1cXGR7Mix9KSQvLnRlc3QodmFsdWUpICYmIG51bGwsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgIH0sXG4gICAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICAgICAgcmV0dXJuIFsnc3Ryb25nJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXTtcbiAgICB9LFxuICAgIGFkZENvbW1hbmRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2V0Qm9sZDogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy5zZXRNYXJrKHRoaXMubmFtZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG9nZ2xlQm9sZDogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy50b2dnbGVNYXJrKHRoaXMubmFtZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdW5zZXRCb2xkOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnVuc2V0TWFyayh0aGlzLm5hbWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ01vZC1iJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlQm9sZCgpLFxuICAgICAgICAgICAgJ01vZC1CJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlQm9sZCgpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYWRkSW5wdXRSdWxlcygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG1hcmtJbnB1dFJ1bGUoe1xuICAgICAgICAgICAgICAgIGZpbmQ6IHN0YXJJbnB1dFJlZ2V4LFxuICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgbWFya0lucHV0UnVsZSh7XG4gICAgICAgICAgICAgICAgZmluZDogdW5kZXJzY29yZUlucHV0UmVnZXgsXG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIF07XG4gICAgfSxcbiAgICBhZGRQYXN0ZVJ1bGVzKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbWFya1Bhc3RlUnVsZSh7XG4gICAgICAgICAgICAgICAgZmluZDogc3RhclBhc3RlUmVnZXgsXG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBtYXJrUGFzdGVSdWxlKHtcbiAgICAgICAgICAgICAgICBmaW5kOiB1bmRlcnNjb3JlUGFzdGVSZWdleCxcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgXTtcbiAgICB9LFxufSk7XG5cbmV4cG9ydCB7IEJvbGQsIEJvbGQgYXMgZGVmYXVsdCwgc3RhcklucHV0UmVnZXgsIHN0YXJQYXN0ZVJlZ2V4LCB1bmRlcnNjb3JlSW5wdXRSZWdleCwgdW5kZXJzY29yZVBhc3RlUmVnZXggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/extension-bold/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/extension-bubble-menu/dist/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@tiptap/extension-bubble-menu/dist/index.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BubbleMenu: function() { return /* binding */ BubbleMenu; },\n/* harmony export */   BubbleMenuPlugin: function() { return /* binding */ BubbleMenuPlugin; },\n/* harmony export */   BubbleMenuView: function() { return /* binding */ BubbleMenuView; },\n/* harmony export */   \"default\": function() { return /* binding */ BubbleMenu; }\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ \"(app-pages-browser)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ \"(app-pages-browser)/./node_modules/@tiptap/pm/state/dist/index.js\");\n/* harmony import */ var tippy_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tippy.js */ \"(app-pages-browser)/./node_modules/tippy.js/dist/tippy.esm.js\");\n\n\n\n\nclass BubbleMenuView {\n    constructor({ editor, element, view, tippyOptions = {}, updateDelay = 250, shouldShow, }) {\n        this.preventHide = false;\n        this.shouldShow = ({ view, state, from, to, }) => {\n            const { doc, selection } = state;\n            const { empty } = selection;\n            // Sometime check for `empty` is not enough.\n            // Doubleclick an empty paragraph returns a node size of 2.\n            // So we check also for an empty text size.\n            const isEmptyTextBlock = !doc.textBetween(from, to).length && (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.isTextSelection)(state.selection);\n            // When clicking on a element inside the bubble menu the editor \"blur\" event\n            // is called and the bubble menu item is focussed. In this case we should\n            // consider the menu as part of the editor and keep showing the menu\n            const isChildOfMenu = this.element.contains(document.activeElement);\n            const hasEditorFocus = view.hasFocus() || isChildOfMenu;\n            if (!hasEditorFocus || empty || isEmptyTextBlock || !this.editor.isEditable) {\n                return false;\n            }\n            return true;\n        };\n        this.mousedownHandler = () => {\n            this.preventHide = true;\n        };\n        this.dragstartHandler = () => {\n            this.hide();\n        };\n        this.focusHandler = () => {\n            // we use `setTimeout` to make sure `selection` is already updated\n            setTimeout(() => this.update(this.editor.view));\n        };\n        this.blurHandler = ({ event }) => {\n            var _a;\n            if (this.preventHide) {\n                this.preventHide = false;\n                return;\n            }\n            if ((event === null || event === void 0 ? void 0 : event.relatedTarget) && ((_a = this.element.parentNode) === null || _a === void 0 ? void 0 : _a.contains(event.relatedTarget))) {\n                return;\n            }\n            if ((event === null || event === void 0 ? void 0 : event.relatedTarget) === this.editor.view.dom) {\n                return;\n            }\n            this.hide();\n        };\n        this.tippyBlurHandler = (event) => {\n            this.blurHandler({ event });\n        };\n        this.handleDebouncedUpdate = (view, oldState) => {\n            const selectionChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.selection.eq(view.state.selection));\n            const docChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.doc.eq(view.state.doc));\n            if (!selectionChanged && !docChanged) {\n                return;\n            }\n            if (this.updateDebounceTimer) {\n                clearTimeout(this.updateDebounceTimer);\n            }\n            this.updateDebounceTimer = window.setTimeout(() => {\n                this.updateHandler(view, selectionChanged, docChanged, oldState);\n            }, this.updateDelay);\n        };\n        this.updateHandler = (view, selectionChanged, docChanged, oldState) => {\n            var _a, _b, _c;\n            const { state, composing } = view;\n            const { selection } = state;\n            const isSame = !selectionChanged && !docChanged;\n            if (composing || isSame) {\n                return;\n            }\n            this.createTooltip();\n            // support for CellSelections\n            const { ranges } = selection;\n            const from = Math.min(...ranges.map(range => range.$from.pos));\n            const to = Math.max(...ranges.map(range => range.$to.pos));\n            const shouldShow = (_a = this.shouldShow) === null || _a === void 0 ? void 0 : _a.call(this, {\n                editor: this.editor,\n                element: this.element,\n                view,\n                state,\n                oldState,\n                from,\n                to,\n            });\n            if (!shouldShow) {\n                this.hide();\n                return;\n            }\n            (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.setProps({\n                getReferenceClientRect: ((_c = this.tippyOptions) === null || _c === void 0 ? void 0 : _c.getReferenceClientRect)\n                    || (() => {\n                        if ((0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.isNodeSelection)(state.selection)) {\n                            let node = view.nodeDOM(from);\n                            if (node) {\n                                const nodeViewWrapper = node.dataset.nodeViewWrapper ? node : node.querySelector('[data-node-view-wrapper]');\n                                if (nodeViewWrapper) {\n                                    node = nodeViewWrapper.firstChild;\n                                }\n                                if (node) {\n                                    return node.getBoundingClientRect();\n                                }\n                            }\n                        }\n                        return (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.posToDOMRect)(view, from, to);\n                    }),\n            });\n            this.show();\n        };\n        this.editor = editor;\n        this.element = element;\n        this.view = view;\n        this.updateDelay = updateDelay;\n        if (shouldShow) {\n            this.shouldShow = shouldShow;\n        }\n        this.element.addEventListener('mousedown', this.mousedownHandler, { capture: true });\n        this.view.dom.addEventListener('dragstart', this.dragstartHandler);\n        this.editor.on('focus', this.focusHandler);\n        this.editor.on('blur', this.blurHandler);\n        this.tippyOptions = tippyOptions;\n        // Detaches menu content from its current parent\n        this.element.remove();\n        this.element.style.visibility = 'visible';\n    }\n    createTooltip() {\n        const { element: editorElement } = this.editor.options;\n        const editorIsAttached = !!editorElement.parentElement;\n        this.element.tabIndex = 0;\n        if (this.tippy || !editorIsAttached) {\n            return;\n        }\n        this.tippy = (0,tippy_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(editorElement, {\n            duration: 0,\n            getReferenceClientRect: null,\n            content: this.element,\n            interactive: true,\n            trigger: 'manual',\n            placement: 'top',\n            hideOnClick: 'toggle',\n            ...this.tippyOptions,\n        });\n        // maybe we have to hide tippy on its own blur event as well\n        if (this.tippy.popper.firstChild) {\n            this.tippy.popper.firstChild.addEventListener('blur', this.tippyBlurHandler);\n        }\n    }\n    update(view, oldState) {\n        const { state } = view;\n        const hasValidSelection = state.selection.from !== state.selection.to;\n        if (this.updateDelay > 0 && hasValidSelection) {\n            this.handleDebouncedUpdate(view, oldState);\n            return;\n        }\n        const selectionChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.selection.eq(view.state.selection));\n        const docChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.doc.eq(view.state.doc));\n        this.updateHandler(view, selectionChanged, docChanged, oldState);\n    }\n    show() {\n        var _a;\n        (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.show();\n    }\n    hide() {\n        var _a;\n        (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.hide();\n    }\n    destroy() {\n        var _a, _b;\n        if ((_a = this.tippy) === null || _a === void 0 ? void 0 : _a.popper.firstChild) {\n            this.tippy.popper.firstChild.removeEventListener('blur', this.tippyBlurHandler);\n        }\n        (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.destroy();\n        this.element.removeEventListener('mousedown', this.mousedownHandler, { capture: true });\n        this.view.dom.removeEventListener('dragstart', this.dragstartHandler);\n        this.editor.off('focus', this.focusHandler);\n        this.editor.off('blur', this.blurHandler);\n    }\n}\nconst BubbleMenuPlugin = (options) => {\n    return new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        key: typeof options.pluginKey === 'string' ? new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(options.pluginKey) : options.pluginKey,\n        view: view => new BubbleMenuView({ view, ...options }),\n    });\n};\n\n/**\n * This extension allows you to create a bubble menu.\n * @see https://tiptap.dev/api/extensions/bubble-menu\n */\nconst BubbleMenu = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n    name: 'bubbleMenu',\n    addOptions() {\n        return {\n            element: null,\n            tippyOptions: {},\n            pluginKey: 'bubbleMenu',\n            updateDelay: undefined,\n            shouldShow: null,\n        };\n    },\n    addProseMirrorPlugins() {\n        if (!this.options.element) {\n            return [];\n        }\n        return [\n            BubbleMenuPlugin({\n                pluginKey: this.options.pluginKey,\n                editor: this.editor,\n                element: this.options.element,\n                tippyOptions: this.options.tippyOptions,\n                updateDelay: this.options.updateDelay,\n                shouldShow: this.options.shouldShow,\n            }),\n        ];\n    },\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1idWJibGUtbWVudS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBeUY7QUFDcEM7QUFDeEI7O0FBRTdCO0FBQ0Esa0JBQWtCLHdDQUF3QyxrQ0FBa0M7QUFDNUY7QUFDQSw2QkFBNkIsd0JBQXdCO0FBQ3JELG9CQUFvQixpQkFBaUI7QUFDckMsb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLDZEQUFlO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsT0FBTztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE9BQU87QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkMsb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNkRBQWU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwwREFBWTtBQUMzQyxxQkFBcUI7QUFDckIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxlQUFlO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvREFBSztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsZUFBZTtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9EQUFNO0FBQ3JCLHlEQUF5RCx1REFBUztBQUNsRSwyQ0FBMkMsa0JBQWtCO0FBQzdELEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtREFBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFOEU7QUFDL0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWJ1YmJsZS1tZW51L2Rpc3QvaW5kZXguanM/OWZkMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc1RleHRTZWxlY3Rpb24sIGlzTm9kZVNlbGVjdGlvbiwgcG9zVG9ET01SZWN0LCBFeHRlbnNpb24gfSBmcm9tICdAdGlwdGFwL2NvcmUnO1xuaW1wb3J0IHsgUGx1Z2luLCBQbHVnaW5LZXkgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJztcbmltcG9ydCB0aXBweSBmcm9tICd0aXBweS5qcyc7XG5cbmNsYXNzIEJ1YmJsZU1lbnVWaWV3IHtcbiAgICBjb25zdHJ1Y3Rvcih7IGVkaXRvciwgZWxlbWVudCwgdmlldywgdGlwcHlPcHRpb25zID0ge30sIHVwZGF0ZURlbGF5ID0gMjUwLCBzaG91bGRTaG93LCB9KSB7XG4gICAgICAgIHRoaXMucHJldmVudEhpZGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zaG91bGRTaG93ID0gKHsgdmlldywgc3RhdGUsIGZyb20sIHRvLCB9KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGRvYywgc2VsZWN0aW9uIH0gPSBzdGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IHsgZW1wdHkgfSA9IHNlbGVjdGlvbjtcbiAgICAgICAgICAgIC8vIFNvbWV0aW1lIGNoZWNrIGZvciBgZW1wdHlgIGlzIG5vdCBlbm91Z2guXG4gICAgICAgICAgICAvLyBEb3VibGVjbGljayBhbiBlbXB0eSBwYXJhZ3JhcGggcmV0dXJucyBhIG5vZGUgc2l6ZSBvZiAyLlxuICAgICAgICAgICAgLy8gU28gd2UgY2hlY2sgYWxzbyBmb3IgYW4gZW1wdHkgdGV4dCBzaXplLlxuICAgICAgICAgICAgY29uc3QgaXNFbXB0eVRleHRCbG9jayA9ICFkb2MudGV4dEJldHdlZW4oZnJvbSwgdG8pLmxlbmd0aCAmJiBpc1RleHRTZWxlY3Rpb24oc3RhdGUuc2VsZWN0aW9uKTtcbiAgICAgICAgICAgIC8vIFdoZW4gY2xpY2tpbmcgb24gYSBlbGVtZW50IGluc2lkZSB0aGUgYnViYmxlIG1lbnUgdGhlIGVkaXRvciBcImJsdXJcIiBldmVudFxuICAgICAgICAgICAgLy8gaXMgY2FsbGVkIGFuZCB0aGUgYnViYmxlIG1lbnUgaXRlbSBpcyBmb2N1c3NlZC4gSW4gdGhpcyBjYXNlIHdlIHNob3VsZFxuICAgICAgICAgICAgLy8gY29uc2lkZXIgdGhlIG1lbnUgYXMgcGFydCBvZiB0aGUgZWRpdG9yIGFuZCBrZWVwIHNob3dpbmcgdGhlIG1lbnVcbiAgICAgICAgICAgIGNvbnN0IGlzQ2hpbGRPZk1lbnUgPSB0aGlzLmVsZW1lbnQuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCk7XG4gICAgICAgICAgICBjb25zdCBoYXNFZGl0b3JGb2N1cyA9IHZpZXcuaGFzRm9jdXMoKSB8fCBpc0NoaWxkT2ZNZW51O1xuICAgICAgICAgICAgaWYgKCFoYXNFZGl0b3JGb2N1cyB8fCBlbXB0eSB8fCBpc0VtcHR5VGV4dEJsb2NrIHx8ICF0aGlzLmVkaXRvci5pc0VkaXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubW91c2Vkb3duSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucHJldmVudEhpZGUgPSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRyYWdzdGFydEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5mb2N1c0hhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICAvLyB3ZSB1c2UgYHNldFRpbWVvdXRgIHRvIG1ha2Ugc3VyZSBgc2VsZWN0aW9uYCBpcyBhbHJlYWR5IHVwZGF0ZWRcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy51cGRhdGUodGhpcy5lZGl0b3IudmlldykpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmJsdXJIYW5kbGVyID0gKHsgZXZlbnQgfSkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldmVudEhpZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByZXZlbnRIaWRlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChldmVudCA9PT0gbnVsbCB8fCBldmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXZlbnQucmVsYXRlZFRhcmdldCkgJiYgKChfYSA9IHRoaXMuZWxlbWVudC5wYXJlbnROb2RlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29udGFpbnMoZXZlbnQucmVsYXRlZFRhcmdldCkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChldmVudCA9PT0gbnVsbCB8fCBldmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXZlbnQucmVsYXRlZFRhcmdldCkgPT09IHRoaXMuZWRpdG9yLnZpZXcuZG9tKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudGlwcHlCbHVySGFuZGxlciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5ibHVySGFuZGxlcih7IGV2ZW50IH0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZURlYm91bmNlZFVwZGF0ZSA9ICh2aWV3LCBvbGRTdGF0ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uQ2hhbmdlZCA9ICEob2xkU3RhdGUgPT09IG51bGwgfHwgb2xkU3RhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9sZFN0YXRlLnNlbGVjdGlvbi5lcSh2aWV3LnN0YXRlLnNlbGVjdGlvbikpO1xuICAgICAgICAgICAgY29uc3QgZG9jQ2hhbmdlZCA9ICEob2xkU3RhdGUgPT09IG51bGwgfHwgb2xkU3RhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9sZFN0YXRlLmRvYy5lcSh2aWV3LnN0YXRlLmRvYykpO1xuICAgICAgICAgICAgaWYgKCFzZWxlY3Rpb25DaGFuZ2VkICYmICFkb2NDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMudXBkYXRlRGVib3VuY2VUaW1lcikge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnVwZGF0ZURlYm91bmNlVGltZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51cGRhdGVEZWJvdW5jZVRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlSGFuZGxlcih2aWV3LCBzZWxlY3Rpb25DaGFuZ2VkLCBkb2NDaGFuZ2VkLCBvbGRTdGF0ZSk7XG4gICAgICAgICAgICB9LCB0aGlzLnVwZGF0ZURlbGF5KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51cGRhdGVIYW5kbGVyID0gKHZpZXcsIHNlbGVjdGlvbkNoYW5nZWQsIGRvY0NoYW5nZWQsIG9sZFN0YXRlKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgIGNvbnN0IHsgc3RhdGUsIGNvbXBvc2luZyB9ID0gdmlldztcbiAgICAgICAgICAgIGNvbnN0IHsgc2VsZWN0aW9uIH0gPSBzdGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IGlzU2FtZSA9ICFzZWxlY3Rpb25DaGFuZ2VkICYmICFkb2NDaGFuZ2VkO1xuICAgICAgICAgICAgaWYgKGNvbXBvc2luZyB8fCBpc1NhbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZVRvb2x0aXAoKTtcbiAgICAgICAgICAgIC8vIHN1cHBvcnQgZm9yIENlbGxTZWxlY3Rpb25zXG4gICAgICAgICAgICBjb25zdCB7IHJhbmdlcyB9ID0gc2VsZWN0aW9uO1xuICAgICAgICAgICAgY29uc3QgZnJvbSA9IE1hdGgubWluKC4uLnJhbmdlcy5tYXAocmFuZ2UgPT4gcmFuZ2UuJGZyb20ucG9zKSk7XG4gICAgICAgICAgICBjb25zdCB0byA9IE1hdGgubWF4KC4uLnJhbmdlcy5tYXAocmFuZ2UgPT4gcmFuZ2UuJHRvLnBvcykpO1xuICAgICAgICAgICAgY29uc3Qgc2hvdWxkU2hvdyA9IChfYSA9IHRoaXMuc2hvdWxkU2hvdykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywge1xuICAgICAgICAgICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXG4gICAgICAgICAgICAgICAgZWxlbWVudDogdGhpcy5lbGVtZW50LFxuICAgICAgICAgICAgICAgIHZpZXcsXG4gICAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgICAgb2xkU3RhdGUsXG4gICAgICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgICAgICB0byxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFzaG91bGRTaG93KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKF9iID0gdGhpcy50aXBweSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNldFByb3BzKHtcbiAgICAgICAgICAgICAgICBnZXRSZWZlcmVuY2VDbGllbnRSZWN0OiAoKF9jID0gdGhpcy50aXBweU9wdGlvbnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5nZXRSZWZlcmVuY2VDbGllbnRSZWN0KVxuICAgICAgICAgICAgICAgICAgICB8fCAoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTm9kZVNlbGVjdGlvbihzdGF0ZS5zZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGUgPSB2aWV3Lm5vZGVET00oZnJvbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZVZpZXdXcmFwcGVyID0gbm9kZS5kYXRhc2V0Lm5vZGVWaWV3V3JhcHBlciA/IG5vZGUgOiBub2RlLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLW5vZGUtdmlldy13cmFwcGVyXScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZVZpZXdXcmFwcGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gbm9kZVZpZXdXcmFwcGVyLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvc1RvRE9NUmVjdCh2aWV3LCBmcm9tLCB0byk7XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMudXBkYXRlRGVsYXkgPSB1cGRhdGVEZWxheTtcbiAgICAgICAgaWYgKHNob3VsZFNob3cpIHtcbiAgICAgICAgICAgIHRoaXMuc2hvdWxkU2hvdyA9IHNob3VsZFNob3c7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMubW91c2Vkb3duSGFuZGxlciwgeyBjYXB0dXJlOiB0cnVlIH0pO1xuICAgICAgICB0aGlzLnZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHRoaXMuZHJhZ3N0YXJ0SGFuZGxlcik7XG4gICAgICAgIHRoaXMuZWRpdG9yLm9uKCdmb2N1cycsIHRoaXMuZm9jdXNIYW5kbGVyKTtcbiAgICAgICAgdGhpcy5lZGl0b3Iub24oJ2JsdXInLCB0aGlzLmJsdXJIYW5kbGVyKTtcbiAgICAgICAgdGhpcy50aXBweU9wdGlvbnMgPSB0aXBweU9wdGlvbnM7XG4gICAgICAgIC8vIERldGFjaGVzIG1lbnUgY29udGVudCBmcm9tIGl0cyBjdXJyZW50IHBhcmVudFxuICAgICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlKCk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICAgIH1cbiAgICBjcmVhdGVUb29sdGlwKCkge1xuICAgICAgICBjb25zdCB7IGVsZW1lbnQ6IGVkaXRvckVsZW1lbnQgfSA9IHRoaXMuZWRpdG9yLm9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGVkaXRvcklzQXR0YWNoZWQgPSAhIWVkaXRvckVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICAgICAgdGhpcy5lbGVtZW50LnRhYkluZGV4ID0gMDtcbiAgICAgICAgaWYgKHRoaXMudGlwcHkgfHwgIWVkaXRvcklzQXR0YWNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRpcHB5ID0gdGlwcHkoZWRpdG9yRWxlbWVudCwge1xuICAgICAgICAgICAgZHVyYXRpb246IDAsXG4gICAgICAgICAgICBnZXRSZWZlcmVuY2VDbGllbnRSZWN0OiBudWxsLFxuICAgICAgICAgICAgY29udGVudDogdGhpcy5lbGVtZW50LFxuICAgICAgICAgICAgaW50ZXJhY3RpdmU6IHRydWUsXG4gICAgICAgICAgICB0cmlnZ2VyOiAnbWFudWFsJyxcbiAgICAgICAgICAgIHBsYWNlbWVudDogJ3RvcCcsXG4gICAgICAgICAgICBoaWRlT25DbGljazogJ3RvZ2dsZScsXG4gICAgICAgICAgICAuLi50aGlzLnRpcHB5T3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIG1heWJlIHdlIGhhdmUgdG8gaGlkZSB0aXBweSBvbiBpdHMgb3duIGJsdXIgZXZlbnQgYXMgd2VsbFxuICAgICAgICBpZiAodGhpcy50aXBweS5wb3BwZXIuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgdGhpcy50aXBweS5wb3BwZXIuZmlyc3RDaGlsZC5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcy50aXBweUJsdXJIYW5kbGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGUodmlldywgb2xkU3RhdGUpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0ZSB9ID0gdmlldztcbiAgICAgICAgY29uc3QgaGFzVmFsaWRTZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb24uZnJvbSAhPT0gc3RhdGUuc2VsZWN0aW9uLnRvO1xuICAgICAgICBpZiAodGhpcy51cGRhdGVEZWxheSA+IDAgJiYgaGFzVmFsaWRTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRGVib3VuY2VkVXBkYXRlKHZpZXcsIG9sZFN0YXRlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWxlY3Rpb25DaGFuZ2VkID0gIShvbGRTdGF0ZSA9PT0gbnVsbCB8fCBvbGRTdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2xkU3RhdGUuc2VsZWN0aW9uLmVxKHZpZXcuc3RhdGUuc2VsZWN0aW9uKSk7XG4gICAgICAgIGNvbnN0IGRvY0NoYW5nZWQgPSAhKG9sZFN0YXRlID09PSBudWxsIHx8IG9sZFN0YXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbGRTdGF0ZS5kb2MuZXEodmlldy5zdGF0ZS5kb2MpKTtcbiAgICAgICAgdGhpcy51cGRhdGVIYW5kbGVyKHZpZXcsIHNlbGVjdGlvbkNoYW5nZWQsIGRvY0NoYW5nZWQsIG9sZFN0YXRlKTtcbiAgICB9XG4gICAgc2hvdygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLnRpcHB5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2hvdygpO1xuICAgIH1cbiAgICBoaWRlKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMudGlwcHkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oaWRlKCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICgoX2EgPSB0aGlzLnRpcHB5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucG9wcGVyLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIHRoaXMudGlwcHkucG9wcGVyLmZpcnN0Q2hpbGQucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMudGlwcHlCbHVySGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgKF9iID0gdGhpcy50aXBweSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMubW91c2Vkb3duSGFuZGxlciwgeyBjYXB0dXJlOiB0cnVlIH0pO1xuICAgICAgICB0aGlzLnZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdzdGFydCcsIHRoaXMuZHJhZ3N0YXJ0SGFuZGxlcik7XG4gICAgICAgIHRoaXMuZWRpdG9yLm9mZignZm9jdXMnLCB0aGlzLmZvY3VzSGFuZGxlcik7XG4gICAgICAgIHRoaXMuZWRpdG9yLm9mZignYmx1cicsIHRoaXMuYmx1ckhhbmRsZXIpO1xuICAgIH1cbn1cbmNvbnN0IEJ1YmJsZU1lbnVQbHVnaW4gPSAob3B0aW9ucykgPT4ge1xuICAgIHJldHVybiBuZXcgUGx1Z2luKHtcbiAgICAgICAga2V5OiB0eXBlb2Ygb3B0aW9ucy5wbHVnaW5LZXkgPT09ICdzdHJpbmcnID8gbmV3IFBsdWdpbktleShvcHRpb25zLnBsdWdpbktleSkgOiBvcHRpb25zLnBsdWdpbktleSxcbiAgICAgICAgdmlldzogdmlldyA9PiBuZXcgQnViYmxlTWVudVZpZXcoeyB2aWV3LCAuLi5vcHRpb25zIH0pLFxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBUaGlzIGV4dGVuc2lvbiBhbGxvd3MgeW91IHRvIGNyZWF0ZSBhIGJ1YmJsZSBtZW51LlxuICogQHNlZSBodHRwczovL3RpcHRhcC5kZXYvYXBpL2V4dGVuc2lvbnMvYnViYmxlLW1lbnVcbiAqL1xuY29uc3QgQnViYmxlTWVudSA9IEV4dGVuc2lvbi5jcmVhdGUoe1xuICAgIG5hbWU6ICdidWJibGVNZW51JyxcbiAgICBhZGRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZWxlbWVudDogbnVsbCxcbiAgICAgICAgICAgIHRpcHB5T3B0aW9uczoge30sXG4gICAgICAgICAgICBwbHVnaW5LZXk6ICdidWJibGVNZW51JyxcbiAgICAgICAgICAgIHVwZGF0ZURlbGF5OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBzaG91bGRTaG93OiBudWxsLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5lbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIEJ1YmJsZU1lbnVQbHVnaW4oe1xuICAgICAgICAgICAgICAgIHBsdWdpbktleTogdGhpcy5vcHRpb25zLnBsdWdpbktleSxcbiAgICAgICAgICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IHRoaXMub3B0aW9ucy5lbGVtZW50LFxuICAgICAgICAgICAgICAgIHRpcHB5T3B0aW9uczogdGhpcy5vcHRpb25zLnRpcHB5T3B0aW9ucyxcbiAgICAgICAgICAgICAgICB1cGRhdGVEZWxheTogdGhpcy5vcHRpb25zLnVwZGF0ZURlbGF5LFxuICAgICAgICAgICAgICAgIHNob3VsZFNob3c6IHRoaXMub3B0aW9ucy5zaG91bGRTaG93LFxuICAgICAgICAgICAgfSksXG4gICAgICAgIF07XG4gICAgfSxcbn0pO1xuXG5leHBvcnQgeyBCdWJibGVNZW51LCBCdWJibGVNZW51UGx1Z2luLCBCdWJibGVNZW51VmlldywgQnViYmxlTWVudSBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/extension-bubble-menu/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/extension-bullet-list/dist/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@tiptap/extension-bullet-list/dist/index.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BulletList: function() { return /* binding */ BulletList; },\n/* harmony export */   \"default\": function() { return /* binding */ BulletList; },\n/* harmony export */   inputRegex: function() { return /* binding */ inputRegex; }\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(app-pages-browser)/./node_modules/@tiptap/core/dist/index.js\");\n\n\nconst ListItemName = 'listItem';\nconst TextStyleName = 'textStyle';\n/**\n * Matches a bullet list to a dash or asterisk.\n */\nconst inputRegex = /^\\s*([-+*])\\s$/;\n/**\n * This extension allows you to create bullet lists.\n * This requires the ListItem extension\n * @see https://tiptap.dev/api/nodes/bullet-list\n * @see https://tiptap.dev/api/nodes/list-item.\n */\nconst BulletList = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: 'bulletList',\n    addOptions() {\n        return {\n            itemTypeName: 'listItem',\n            HTMLAttributes: {},\n            keepMarks: false,\n            keepAttributes: false,\n        };\n    },\n    group: 'block list',\n    content() {\n        return `${this.options.itemTypeName}+`;\n    },\n    parseHTML() {\n        return [\n            { tag: 'ul' },\n        ];\n    },\n    renderHTML({ HTMLAttributes }) {\n        return ['ul', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n    },\n    addCommands() {\n        return {\n            toggleBulletList: () => ({ commands, chain }) => {\n                if (this.options.keepAttributes) {\n                    return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItemName, this.editor.getAttributes(TextStyleName)).run();\n                }\n                return commands.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);\n            },\n        };\n    },\n    addKeyboardShortcuts() {\n        return {\n            'Mod-Shift-8': () => this.editor.commands.toggleBulletList(),\n        };\n    },\n    addInputRules() {\n        let inputRule = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\n            find: inputRegex,\n            type: this.type,\n        });\n        if (this.options.keepMarks || this.options.keepAttributes) {\n            inputRule = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\n                find: inputRegex,\n                type: this.type,\n                keepMarks: this.options.keepMarks,\n                keepAttributes: this.options.keepAttributes,\n                getAttributes: () => { return this.editor.getAttributes(TextStyleName); },\n                editor: this.editor,\n            });\n        }\n        return [\n            inputRule,\n        ];\n    },\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1idWxsZXQtbGlzdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBd0U7O0FBRXhFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw4Q0FBSTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGtCQUFrQiwwQkFBMEI7QUFDNUMsS0FBSztBQUNMO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQSxLQUFLO0FBQ0wsaUJBQWlCLGdCQUFnQjtBQUNqQyxzQkFBc0IsNkRBQWU7QUFDckMsS0FBSztBQUNMO0FBQ0E7QUFDQSx1Q0FBdUMsaUJBQWlCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0Esd0JBQXdCLCtEQUFpQjtBQUN6QztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esd0JBQXdCLCtEQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxrREFBa0Q7QUFDekY7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFd0Q7QUFDekQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWJ1bGxldC1saXN0L2Rpc3QvaW5kZXguanM/MGYzZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOb2RlLCBtZXJnZUF0dHJpYnV0ZXMsIHdyYXBwaW5nSW5wdXRSdWxlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJztcblxuY29uc3QgTGlzdEl0ZW1OYW1lID0gJ2xpc3RJdGVtJztcbmNvbnN0IFRleHRTdHlsZU5hbWUgPSAndGV4dFN0eWxlJztcbi8qKlxuICogTWF0Y2hlcyBhIGJ1bGxldCBsaXN0IHRvIGEgZGFzaCBvciBhc3Rlcmlzay5cbiAqL1xuY29uc3QgaW5wdXRSZWdleCA9IC9eXFxzKihbLSsqXSlcXHMkLztcbi8qKlxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBjcmVhdGUgYnVsbGV0IGxpc3RzLlxuICogVGhpcyByZXF1aXJlcyB0aGUgTGlzdEl0ZW0gZXh0ZW5zaW9uXG4gKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9hcGkvbm9kZXMvYnVsbGV0LWxpc3RcbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2FwaS9ub2Rlcy9saXN0LWl0ZW0uXG4gKi9cbmNvbnN0IEJ1bGxldExpc3QgPSBOb2RlLmNyZWF0ZSh7XG4gICAgbmFtZTogJ2J1bGxldExpc3QnLFxuICAgIGFkZE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpdGVtVHlwZU5hbWU6ICdsaXN0SXRlbScsXG4gICAgICAgICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgICAgICAgICBrZWVwTWFya3M6IGZhbHNlLFxuICAgICAgICAgICAga2VlcEF0dHJpYnV0ZXM6IGZhbHNlLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgZ3JvdXA6ICdibG9jayBsaXN0JyxcbiAgICBjb250ZW50KCkge1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5vcHRpb25zLml0ZW1UeXBlTmFtZX0rYDtcbiAgICB9LFxuICAgIHBhcnNlSFRNTCgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgdGFnOiAndWwnIH0sXG4gICAgICAgIF07XG4gICAgfSxcbiAgICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgICAgICByZXR1cm4gWyd1bCcsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF07XG4gICAgfSxcbiAgICBhZGRDb21tYW5kcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvZ2dsZUJ1bGxldExpc3Q6ICgpID0+ICh7IGNvbW1hbmRzLCBjaGFpbiB9KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5rZWVwQXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hhaW4oKS50b2dnbGVMaXN0KHRoaXMubmFtZSwgdGhpcy5vcHRpb25zLml0ZW1UeXBlTmFtZSwgdGhpcy5vcHRpb25zLmtlZXBNYXJrcykudXBkYXRlQXR0cmlidXRlcyhMaXN0SXRlbU5hbWUsIHRoaXMuZWRpdG9yLmdldEF0dHJpYnV0ZXMoVGV4dFN0eWxlTmFtZSkpLnJ1bigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlTGlzdCh0aGlzLm5hbWUsIHRoaXMub3B0aW9ucy5pdGVtVHlwZU5hbWUsIHRoaXMub3B0aW9ucy5rZWVwTWFya3MpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ01vZC1TaGlmdC04JzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlQnVsbGV0TGlzdCgpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYWRkSW5wdXRSdWxlcygpIHtcbiAgICAgICAgbGV0IGlucHV0UnVsZSA9IHdyYXBwaW5nSW5wdXRSdWxlKHtcbiAgICAgICAgICAgIGZpbmQ6IGlucHV0UmVnZXgsXG4gICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmtlZXBNYXJrcyB8fCB0aGlzLm9wdGlvbnMua2VlcEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIGlucHV0UnVsZSA9IHdyYXBwaW5nSW5wdXRSdWxlKHtcbiAgICAgICAgICAgICAgICBmaW5kOiBpbnB1dFJlZ2V4LFxuICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgICAgICBrZWVwTWFya3M6IHRoaXMub3B0aW9ucy5rZWVwTWFya3MsXG4gICAgICAgICAgICAgICAga2VlcEF0dHJpYnV0ZXM6IHRoaXMub3B0aW9ucy5rZWVwQXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICBnZXRBdHRyaWJ1dGVzOiAoKSA9PiB7IHJldHVybiB0aGlzLmVkaXRvci5nZXRBdHRyaWJ1dGVzKFRleHRTdHlsZU5hbWUpOyB9LFxuICAgICAgICAgICAgICAgIGVkaXRvcjogdGhpcy5lZGl0b3IsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgaW5wdXRSdWxlLFxuICAgICAgICBdO1xuICAgIH0sXG59KTtcblxuZXhwb3J0IHsgQnVsbGV0TGlzdCwgQnVsbGV0TGlzdCBhcyBkZWZhdWx0LCBpbnB1dFJlZ2V4IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/extension-bullet-list/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/extension-code-block/dist/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-code-block/dist/index.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CodeBlock: function() { return /* binding */ CodeBlock; },\n/* harmony export */   backtickInputRegex: function() { return /* binding */ backtickInputRegex; },\n/* harmony export */   \"default\": function() { return /* binding */ CodeBlock; },\n/* harmony export */   tildeInputRegex: function() { return /* binding */ tildeInputRegex; }\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ \"(app-pages-browser)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ \"(app-pages-browser)/./node_modules/@tiptap/pm/state/dist/index.js\");\n\n\n\n/**\n * Matches a code block with backticks.\n */\nconst backtickInputRegex = /^```([a-z]+)?[\\s\\n]$/;\n/**\n * Matches a code block with tildes.\n */\nconst tildeInputRegex = /^~~~([a-z]+)?[\\s\\n]$/;\n/**\n * This extension allows you to create code blocks.\n * @see https://tiptap.dev/api/nodes/code-block\n */\nconst CodeBlock = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Node.create({\n    name: 'codeBlock',\n    addOptions() {\n        return {\n            languageClassPrefix: 'language-',\n            exitOnTripleEnter: true,\n            exitOnArrowDown: true,\n            defaultLanguage: null,\n            HTMLAttributes: {},\n        };\n    },\n    content: 'text*',\n    marks: '',\n    group: 'block',\n    code: true,\n    defining: true,\n    addAttributes() {\n        return {\n            language: {\n                default: this.options.defaultLanguage,\n                parseHTML: element => {\n                    var _a;\n                    const { languageClassPrefix } = this.options;\n                    const classNames = [...(((_a = element.firstElementChild) === null || _a === void 0 ? void 0 : _a.classList) || [])];\n                    const languages = classNames\n                        .filter(className => className.startsWith(languageClassPrefix))\n                        .map(className => className.replace(languageClassPrefix, ''));\n                    const language = languages[0];\n                    if (!language) {\n                        return null;\n                    }\n                    return language;\n                },\n                rendered: false,\n            },\n        };\n    },\n    parseHTML() {\n        return [\n            {\n                tag: 'pre',\n                preserveWhitespace: 'full',\n            },\n        ];\n    },\n    renderHTML({ node, HTMLAttributes }) {\n        return [\n            'pre',\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes),\n            [\n                'code',\n                {\n                    class: node.attrs.language\n                        ? this.options.languageClassPrefix + node.attrs.language\n                        : null,\n                },\n                0,\n            ],\n        ];\n    },\n    addCommands() {\n        return {\n            setCodeBlock: attributes => ({ commands }) => {\n                return commands.setNode(this.name, attributes);\n            },\n            toggleCodeBlock: attributes => ({ commands }) => {\n                return commands.toggleNode(this.name, 'paragraph', attributes);\n            },\n        };\n    },\n    addKeyboardShortcuts() {\n        return {\n            'Mod-Alt-c': () => this.editor.commands.toggleCodeBlock(),\n            // remove code block when at start of document or code block is empty\n            Backspace: () => {\n                const { empty, $anchor } = this.editor.state.selection;\n                const isAtStart = $anchor.pos === 1;\n                if (!empty || $anchor.parent.type.name !== this.name) {\n                    return false;\n                }\n                if (isAtStart || !$anchor.parent.textContent.length) {\n                    return this.editor.commands.clearNodes();\n                }\n                return false;\n            },\n            // exit node on triple enter\n            Enter: ({ editor }) => {\n                if (!this.options.exitOnTripleEnter) {\n                    return false;\n                }\n                const { state } = editor;\n                const { selection } = state;\n                const { $from, empty } = selection;\n                if (!empty || $from.parent.type !== this.type) {\n                    return false;\n                }\n                const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;\n                const endsWithDoubleNewline = $from.parent.textContent.endsWith('\\n\\n');\n                if (!isAtEnd || !endsWithDoubleNewline) {\n                    return false;\n                }\n                return editor\n                    .chain()\n                    .command(({ tr }) => {\n                    tr.delete($from.pos - 2, $from.pos);\n                    return true;\n                })\n                    .exitCode()\n                    .run();\n            },\n            // exit node on arrow down\n            ArrowDown: ({ editor }) => {\n                if (!this.options.exitOnArrowDown) {\n                    return false;\n                }\n                const { state } = editor;\n                const { selection, doc } = state;\n                const { $from, empty } = selection;\n                if (!empty || $from.parent.type !== this.type) {\n                    return false;\n                }\n                const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;\n                if (!isAtEnd) {\n                    return false;\n                }\n                const after = $from.after();\n                if (after === undefined) {\n                    return false;\n                }\n                const nodeAfter = doc.nodeAt(after);\n                if (nodeAfter) {\n                    return editor.commands.command(({ tr }) => {\n                        tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near(doc.resolve(after)));\n                        return true;\n                    });\n                }\n                return editor.commands.exitCode();\n            },\n        };\n    },\n    addInputRules() {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.textblockTypeInputRule)({\n                find: backtickInputRegex,\n                type: this.type,\n                getAttributes: match => ({\n                    language: match[1],\n                }),\n            }),\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.textblockTypeInputRule)({\n                find: tildeInputRegex,\n                type: this.type,\n                getAttributes: match => ({\n                    language: match[1],\n                }),\n            }),\n        ];\n    },\n    addProseMirrorPlugins() {\n        return [\n            // this plugin creates a code block for pasted content from VS Code\n            // we can also detect the copied code language\n            new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n                key: new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey('codeBlockVSCodeHandler'),\n                props: {\n                    handlePaste: (view, event) => {\n                        if (!event.clipboardData) {\n                            return false;\n                        }\n                        // don’t create a new code block within code blocks\n                        if (this.editor.isActive(this.type.name)) {\n                            return false;\n                        }\n                        const text = event.clipboardData.getData('text/plain');\n                        const vscode = event.clipboardData.getData('vscode-editor-data');\n                        const vscodeData = vscode ? JSON.parse(vscode) : undefined;\n                        const language = vscodeData === null || vscodeData === void 0 ? void 0 : vscodeData.mode;\n                        if (!text || !language) {\n                            return false;\n                        }\n                        const { tr, schema } = view.state;\n                        // prepare a text node\n                        // strip carriage return chars from text pasted as code\n                        // see: https://github.com/ProseMirror/prosemirror-view/commit/a50a6bcceb4ce52ac8fcc6162488d8875613aacd\n                        const textNode = schema.text(text.replace(/\\r\\n?/g, '\\n'));\n                        // create a code block with the text node\n                        // replace selection with the code block\n                        tr.replaceSelectionWith(this.type.create({ language }, textNode));\n                        if (tr.selection.$from.parent.type !== this.type) {\n                            // put cursor inside the newly created code block\n                            tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.near(tr.doc.resolve(Math.max(0, tr.selection.from - 2))));\n                        }\n                        // store meta information\n                        // this is useful for other plugins that depends on the paste event\n                        // like the paste rule plugin\n                        tr.setMeta('paste', true);\n                        view.dispatch(tr);\n                        return true;\n                    },\n                },\n            }),\n        ];\n    },\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1jb2RlLWJsb2NrL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQTZFO0FBQ0U7O0FBRS9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw4Q0FBSTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTCxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQSxZQUFZLDZEQUFlO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLDJDQUEyQyxVQUFVO0FBQ3JEO0FBQ0EsYUFBYTtBQUNiLDhDQUE4QyxVQUFVO0FBQ3hEO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQyx3QkFBd0IsWUFBWTtBQUNwQyx3QkFBd0IsZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLDBCQUEwQixRQUFRO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDLHdCQUF3QixpQkFBaUI7QUFDekMsd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsSUFBSTtBQUMxRCx3Q0FBd0MsdURBQVM7QUFDakQ7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWSxvRUFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFlBQVksb0VBQXNCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvREFBTTtBQUN0Qix5QkFBeUIsdURBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsYUFBYTtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsVUFBVTtBQUM3RTtBQUNBO0FBQ0EsNENBQTRDLDJEQUFhO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFK0U7QUFDaEYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWNvZGUtYmxvY2svZGlzdC9pbmRleC5qcz81ZWM4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5vZGUsIG1lcmdlQXR0cmlidXRlcywgdGV4dGJsb2NrVHlwZUlucHV0UnVsZSB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5pbXBvcnQgeyBTZWxlY3Rpb24sIFBsdWdpbiwgUGx1Z2luS2V5LCBUZXh0U2VsZWN0aW9uIH0gZnJvbSAnQHRpcHRhcC9wbS9zdGF0ZSc7XG5cbi8qKlxuICogTWF0Y2hlcyBhIGNvZGUgYmxvY2sgd2l0aCBiYWNrdGlja3MuXG4gKi9cbmNvbnN0IGJhY2t0aWNrSW5wdXRSZWdleCA9IC9eYGBgKFthLXpdKyk/W1xcc1xcbl0kLztcbi8qKlxuICogTWF0Y2hlcyBhIGNvZGUgYmxvY2sgd2l0aCB0aWxkZXMuXG4gKi9cbmNvbnN0IHRpbGRlSW5wdXRSZWdleCA9IC9efn5+KFthLXpdKyk/W1xcc1xcbl0kLztcbi8qKlxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBjcmVhdGUgY29kZSBibG9ja3MuXG4gKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9hcGkvbm9kZXMvY29kZS1ibG9ja1xuICovXG5jb25zdCBDb2RlQmxvY2sgPSBOb2RlLmNyZWF0ZSh7XG4gICAgbmFtZTogJ2NvZGVCbG9jaycsXG4gICAgYWRkT3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxhbmd1YWdlQ2xhc3NQcmVmaXg6ICdsYW5ndWFnZS0nLFxuICAgICAgICAgICAgZXhpdE9uVHJpcGxlRW50ZXI6IHRydWUsXG4gICAgICAgICAgICBleGl0T25BcnJvd0Rvd246IHRydWUsXG4gICAgICAgICAgICBkZWZhdWx0TGFuZ3VhZ2U6IG51bGwsXG4gICAgICAgICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBjb250ZW50OiAndGV4dConLFxuICAgIG1hcmtzOiAnJyxcbiAgICBncm91cDogJ2Jsb2NrJyxcbiAgICBjb2RlOiB0cnVlLFxuICAgIGRlZmluaW5nOiB0cnVlLFxuICAgIGFkZEF0dHJpYnV0ZXMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsYW5ndWFnZToge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHRoaXMub3B0aW9ucy5kZWZhdWx0TGFuZ3VhZ2UsXG4gICAgICAgICAgICAgICAgcGFyc2VIVE1MOiBlbGVtZW50ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGxhbmd1YWdlQ2xhc3NQcmVmaXggfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xhc3NOYW1lcyA9IFsuLi4oKChfYSA9IGVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbGFzc0xpc3QpIHx8IFtdKV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhbmd1YWdlcyA9IGNsYXNzTmFtZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoY2xhc3NOYW1lID0+IGNsYXNzTmFtZS5zdGFydHNXaXRoKGxhbmd1YWdlQ2xhc3NQcmVmaXgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChjbGFzc05hbWUgPT4gY2xhc3NOYW1lLnJlcGxhY2UobGFuZ3VhZ2VDbGFzc1ByZWZpeCwgJycpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFuZ3VhZ2UgPSBsYW5ndWFnZXNbMF07XG4gICAgICAgICAgICAgICAgICAgIGlmICghbGFuZ3VhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsYW5ndWFnZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHJlbmRlcmVkOiBmYWxzZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBwYXJzZUhUTUwoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGFnOiAncHJlJyxcbiAgICAgICAgICAgICAgICBwcmVzZXJ2ZVdoaXRlc3BhY2U6ICdmdWxsJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF07XG4gICAgfSxcbiAgICByZW5kZXJIVE1MKHsgbm9kZSwgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgJ3ByZScsXG4gICAgICAgICAgICBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgJ2NvZGUnLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M6IG5vZGUuYXR0cnMubGFuZ3VhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy5vcHRpb25zLmxhbmd1YWdlQ2xhc3NQcmVmaXggKyBub2RlLmF0dHJzLmxhbmd1YWdlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAwLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgXTtcbiAgICB9LFxuICAgIGFkZENvbW1hbmRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2V0Q29kZUJsb2NrOiBhdHRyaWJ1dGVzID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZHMuc2V0Tm9kZSh0aGlzLm5hbWUsIGF0dHJpYnV0ZXMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvZ2dsZUNvZGVCbG9jazogYXR0cmlidXRlcyA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZU5vZGUodGhpcy5uYW1lLCAncGFyYWdyYXBoJywgYXR0cmlidXRlcyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnTW9kLUFsdC1jJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlQ29kZUJsb2NrKCksXG4gICAgICAgICAgICAvLyByZW1vdmUgY29kZSBibG9jayB3aGVuIGF0IHN0YXJ0IG9mIGRvY3VtZW50IG9yIGNvZGUgYmxvY2sgaXMgZW1wdHlcbiAgICAgICAgICAgIEJhY2tzcGFjZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZW1wdHksICRhbmNob3IgfSA9IHRoaXMuZWRpdG9yLnN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0F0U3RhcnQgPSAkYW5jaG9yLnBvcyA9PT0gMTtcbiAgICAgICAgICAgICAgICBpZiAoIWVtcHR5IHx8ICRhbmNob3IucGFyZW50LnR5cGUubmFtZSAhPT0gdGhpcy5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzQXRTdGFydCB8fCAhJGFuY2hvci5wYXJlbnQudGV4dENvbnRlbnQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVkaXRvci5jb21tYW5kcy5jbGVhck5vZGVzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBleGl0IG5vZGUgb24gdHJpcGxlIGVudGVyXG4gICAgICAgICAgICBFbnRlcjogKHsgZWRpdG9yIH0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5leGl0T25UcmlwbGVFbnRlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgc3RhdGUgfSA9IGVkaXRvcjtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gc3RhdGU7XG4gICAgICAgICAgICAgICAgY29uc3QgeyAkZnJvbSwgZW1wdHkgfSA9IHNlbGVjdGlvbjtcbiAgICAgICAgICAgICAgICBpZiAoIWVtcHR5IHx8ICRmcm9tLnBhcmVudC50eXBlICE9PSB0aGlzLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBpc0F0RW5kID0gJGZyb20ucGFyZW50T2Zmc2V0ID09PSAkZnJvbS5wYXJlbnQubm9kZVNpemUgLSAyO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuZHNXaXRoRG91YmxlTmV3bGluZSA9ICRmcm9tLnBhcmVudC50ZXh0Q29udGVudC5lbmRzV2l0aCgnXFxuXFxuJyk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0F0RW5kIHx8ICFlbmRzV2l0aERvdWJsZU5ld2xpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZWRpdG9yXG4gICAgICAgICAgICAgICAgICAgIC5jaGFpbigpXG4gICAgICAgICAgICAgICAgICAgIC5jb21tYW5kKCh7IHRyIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdHIuZGVsZXRlKCRmcm9tLnBvcyAtIDIsICRmcm9tLnBvcyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5leGl0Q29kZSgpXG4gICAgICAgICAgICAgICAgICAgIC5ydW4oKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBleGl0IG5vZGUgb24gYXJyb3cgZG93blxuICAgICAgICAgICAgQXJyb3dEb3duOiAoeyBlZGl0b3IgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLmV4aXRPbkFycm93RG93bikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgc3RhdGUgfSA9IGVkaXRvcjtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHNlbGVjdGlvbiwgZG9jIH0gPSBzdGF0ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB7ICRmcm9tLCBlbXB0eSB9ID0gc2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgIGlmICghZW1wdHkgfHwgJGZyb20ucGFyZW50LnR5cGUgIT09IHRoaXMudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGlzQXRFbmQgPSAkZnJvbS5wYXJlbnRPZmZzZXQgPT09ICRmcm9tLnBhcmVudC5ub2RlU2l6ZSAtIDI7XG4gICAgICAgICAgICAgICAgaWYgKCFpc0F0RW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgYWZ0ZXIgPSAkZnJvbS5hZnRlcigpO1xuICAgICAgICAgICAgICAgIGlmIChhZnRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZUFmdGVyID0gZG9jLm5vZGVBdChhZnRlcik7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVBZnRlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZWRpdG9yLmNvbW1hbmRzLmNvbW1hbmQoKHsgdHIgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFNlbGVjdGlvbi5uZWFyKGRvYy5yZXNvbHZlKGFmdGVyKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZWRpdG9yLmNvbW1hbmRzLmV4aXRDb2RlKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYWRkSW5wdXRSdWxlcygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHRleHRibG9ja1R5cGVJbnB1dFJ1bGUoe1xuICAgICAgICAgICAgICAgIGZpbmQ6IGJhY2t0aWNrSW5wdXRSZWdleCxcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICAgICAgZ2V0QXR0cmlidXRlczogbWF0Y2ggPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgbGFuZ3VhZ2U6IG1hdGNoWzFdLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0ZXh0YmxvY2tUeXBlSW5wdXRSdWxlKHtcbiAgICAgICAgICAgICAgICBmaW5kOiB0aWxkZUlucHV0UmVnZXgsXG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgICAgIGdldEF0dHJpYnV0ZXM6IG1hdGNoID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlOiBtYXRjaFsxXSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdO1xuICAgIH0sXG4gICAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgLy8gdGhpcyBwbHVnaW4gY3JlYXRlcyBhIGNvZGUgYmxvY2sgZm9yIHBhc3RlZCBjb250ZW50IGZyb20gVlMgQ29kZVxuICAgICAgICAgICAgLy8gd2UgY2FuIGFsc28gZGV0ZWN0IHRoZSBjb3BpZWQgY29kZSBsYW5ndWFnZVxuICAgICAgICAgICAgbmV3IFBsdWdpbih7XG4gICAgICAgICAgICAgICAga2V5OiBuZXcgUGx1Z2luS2V5KCdjb2RlQmxvY2tWU0NvZGVIYW5kbGVyJyksXG4gICAgICAgICAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlUGFzdGU6ICh2aWV3LCBldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFldmVudC5jbGlwYm9hcmREYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG9u4oCZdCBjcmVhdGUgYSBuZXcgY29kZSBibG9jayB3aXRoaW4gY29kZSBibG9ja3NcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmVkaXRvci5pc0FjdGl2ZSh0aGlzLnR5cGUubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gZXZlbnQuY2xpcGJvYXJkRGF0YS5nZXREYXRhKCd0ZXh0L3BsYWluJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2c2NvZGUgPSBldmVudC5jbGlwYm9hcmREYXRhLmdldERhdGEoJ3ZzY29kZS1lZGl0b3ItZGF0YScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdnNjb2RlRGF0YSA9IHZzY29kZSA/IEpTT04ucGFyc2UodnNjb2RlKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhbmd1YWdlID0gdnNjb2RlRGF0YSA9PT0gbnVsbCB8fCB2c2NvZGVEYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2c2NvZGVEYXRhLm1vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRleHQgfHwgIWxhbmd1YWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB0ciwgc2NoZW1hIH0gPSB2aWV3LnN0YXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJlcGFyZSBhIHRleHQgbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RyaXAgY2FycmlhZ2UgcmV0dXJuIGNoYXJzIGZyb20gdGV4dCBwYXN0ZWQgYXMgY29kZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vUHJvc2VNaXJyb3IvcHJvc2VtaXJyb3Itdmlldy9jb21taXQvYTUwYTZiY2NlYjRjZTUyYWM4ZmNjNjE2MjQ4OGQ4ODc1NjEzYWFjZFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dE5vZGUgPSBzY2hlbWEudGV4dCh0ZXh0LnJlcGxhY2UoL1xcclxcbj8vZywgJ1xcbicpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNyZWF0ZSBhIGNvZGUgYmxvY2sgd2l0aCB0aGUgdGV4dCBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXBsYWNlIHNlbGVjdGlvbiB3aXRoIHRoZSBjb2RlIGJsb2NrXG4gICAgICAgICAgICAgICAgICAgICAgICB0ci5yZXBsYWNlU2VsZWN0aW9uV2l0aCh0aGlzLnR5cGUuY3JlYXRlKHsgbGFuZ3VhZ2UgfSwgdGV4dE5vZGUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ci5zZWxlY3Rpb24uJGZyb20ucGFyZW50LnR5cGUgIT09IHRoaXMudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHB1dCBjdXJzb3IgaW5zaWRlIHRoZSBuZXdseSBjcmVhdGVkIGNvZGUgYmxvY2tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5uZWFyKHRyLmRvYy5yZXNvbHZlKE1hdGgubWF4KDAsIHRyLnNlbGVjdGlvbi5mcm9tIC0gMikpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdG9yZSBtZXRhIGluZm9ybWF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIHVzZWZ1bCBmb3Igb3RoZXIgcGx1Z2lucyB0aGF0IGRlcGVuZHMgb24gdGhlIHBhc3RlIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsaWtlIHRoZSBwYXN0ZSBydWxlIHBsdWdpblxuICAgICAgICAgICAgICAgICAgICAgICAgdHIuc2V0TWV0YSgncGFzdGUnLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdO1xuICAgIH0sXG59KTtcblxuZXhwb3J0IHsgQ29kZUJsb2NrLCBiYWNrdGlja0lucHV0UmVnZXgsIENvZGVCbG9jayBhcyBkZWZhdWx0LCB0aWxkZUlucHV0UmVnZXggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/extension-code-block/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/extension-code/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/extension-code/dist/index.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Code: function() { return /* binding */ Code; },\n/* harmony export */   \"default\": function() { return /* binding */ Code; },\n/* harmony export */   inputRegex: function() { return /* binding */ inputRegex; },\n/* harmony export */   pasteRegex: function() { return /* binding */ pasteRegex; }\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(app-pages-browser)/./node_modules/@tiptap/core/dist/index.js\");\n\n\n/**\n * Regular expressions to match inline code blocks enclosed in backticks.\n *  It matches:\n *     - An opening backtick, followed by\n *     - Any text that doesn't include a backtick (captured for marking), followed by\n *     - A closing backtick.\n *  This ensures that any text between backticks is formatted as code,\n *  regardless of the surrounding characters (exception being another backtick).\n */\nconst inputRegex = /(^|[^`])`([^`]+)`(?!`)/;\n/**\n * Matches inline code while pasting.\n */\nconst pasteRegex = /(^|[^`])`([^`]+)`(?!`)/g;\n/**\n * This extension allows you to mark text as inline code.\n * @see https://tiptap.dev/api/marks/code\n */\nconst Code = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\n    name: 'code',\n    addOptions() {\n        return {\n            HTMLAttributes: {},\n        };\n    },\n    excludes: '_',\n    code: true,\n    exitable: true,\n    parseHTML() {\n        return [\n            { tag: 'code' },\n        ];\n    },\n    renderHTML({ HTMLAttributes }) {\n        return ['code', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n    },\n    addCommands() {\n        return {\n            setCode: () => ({ commands }) => {\n                return commands.setMark(this.name);\n            },\n            toggleCode: () => ({ commands }) => {\n                return commands.toggleMark(this.name);\n            },\n            unsetCode: () => ({ commands }) => {\n                return commands.unsetMark(this.name);\n            },\n        };\n    },\n    addKeyboardShortcuts() {\n        return {\n            'Mod-e': () => this.editor.commands.toggleCode(),\n        };\n    },\n    addInputRules() {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n                find: inputRegex,\n                type: this.type,\n            }),\n        ];\n    },\n    addPasteRules() {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n                find: pasteRegex,\n                type: this.type,\n            }),\n        ];\n    },\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1jb2RlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBbUY7O0FBRW5GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsOENBQUk7QUFDakI7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWE7QUFDM0I7QUFDQSxLQUFLO0FBQ0wsaUJBQWlCLGdCQUFnQjtBQUNqQyx3QkFBd0IsNkRBQWU7QUFDdkMsS0FBSztBQUNMO0FBQ0E7QUFDQSw4QkFBOEIsVUFBVTtBQUN4QztBQUNBLGFBQWE7QUFDYixpQ0FBaUMsVUFBVTtBQUMzQztBQUNBLGFBQWE7QUFDYixnQ0FBZ0MsVUFBVTtBQUMxQztBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWSwyREFBYTtBQUN6QjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZLDJEQUFhO0FBQ3pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFd0Q7QUFDekQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWNvZGUvZGlzdC9pbmRleC5qcz8xNTI4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1hcmssIG1lcmdlQXR0cmlidXRlcywgbWFya0lucHV0UnVsZSwgbWFya1Bhc3RlUnVsZSB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5cbi8qKlxuICogUmVndWxhciBleHByZXNzaW9ucyB0byBtYXRjaCBpbmxpbmUgY29kZSBibG9ja3MgZW5jbG9zZWQgaW4gYmFja3RpY2tzLlxuICogIEl0IG1hdGNoZXM6XG4gKiAgICAgLSBBbiBvcGVuaW5nIGJhY2t0aWNrLCBmb2xsb3dlZCBieVxuICogICAgIC0gQW55IHRleHQgdGhhdCBkb2Vzbid0IGluY2x1ZGUgYSBiYWNrdGljayAoY2FwdHVyZWQgZm9yIG1hcmtpbmcpLCBmb2xsb3dlZCBieVxuICogICAgIC0gQSBjbG9zaW5nIGJhY2t0aWNrLlxuICogIFRoaXMgZW5zdXJlcyB0aGF0IGFueSB0ZXh0IGJldHdlZW4gYmFja3RpY2tzIGlzIGZvcm1hdHRlZCBhcyBjb2RlLFxuICogIHJlZ2FyZGxlc3Mgb2YgdGhlIHN1cnJvdW5kaW5nIGNoYXJhY3RlcnMgKGV4Y2VwdGlvbiBiZWluZyBhbm90aGVyIGJhY2t0aWNrKS5cbiAqL1xuY29uc3QgaW5wdXRSZWdleCA9IC8oXnxbXmBdKWAoW15gXSspYCg/IWApLztcbi8qKlxuICogTWF0Y2hlcyBpbmxpbmUgY29kZSB3aGlsZSBwYXN0aW5nLlxuICovXG5jb25zdCBwYXN0ZVJlZ2V4ID0gLyhefFteYF0pYChbXmBdKylgKD8hYCkvZztcbi8qKlxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBtYXJrIHRleHQgYXMgaW5saW5lIGNvZGUuXG4gKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9hcGkvbWFya3MvY29kZVxuICovXG5jb25zdCBDb2RlID0gTWFyay5jcmVhdGUoe1xuICAgIG5hbWU6ICdjb2RlJyxcbiAgICBhZGRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgZXhjbHVkZXM6ICdfJyxcbiAgICBjb2RlOiB0cnVlLFxuICAgIGV4aXRhYmxlOiB0cnVlLFxuICAgIHBhcnNlSFRNTCgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgdGFnOiAnY29kZScgfSxcbiAgICAgICAgXTtcbiAgICB9LFxuICAgIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgICAgIHJldHVybiBbJ2NvZGUnLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdO1xuICAgIH0sXG4gICAgYWRkQ29tbWFuZHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZXRDb2RlOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnNldE1hcmsodGhpcy5uYW1lKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b2dnbGVDb2RlOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZU1hcmsodGhpcy5uYW1lKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1bnNldENvZGU6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZHMudW5zZXRNYXJrKHRoaXMubmFtZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnTW9kLWUnOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVDb2RlKCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBhZGRJbnB1dFJ1bGVzKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbWFya0lucHV0UnVsZSh7XG4gICAgICAgICAgICAgICAgZmluZDogaW5wdXRSZWdleCxcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgXTtcbiAgICB9LFxuICAgIGFkZFBhc3RlUnVsZXMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBtYXJrUGFzdGVSdWxlKHtcbiAgICAgICAgICAgICAgICBmaW5kOiBwYXN0ZVJlZ2V4LFxuICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdO1xuICAgIH0sXG59KTtcblxuZXhwb3J0IHsgQ29kZSwgQ29kZSBhcyBkZWZhdWx0LCBpbnB1dFJlZ2V4LCBwYXN0ZVJlZ2V4IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/extension-code/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/extension-document/dist/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@tiptap/extension-document/dist/index.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Document: function() { return /* binding */ Document; },\n/* harmony export */   \"default\": function() { return /* binding */ Document; }\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(app-pages-browser)/./node_modules/@tiptap/core/dist/index.js\");\n\n\n/**\n * The default document node which represents the top level node of the editor.\n * @see https://tiptap.dev/api/nodes/document\n */\nconst Document = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: 'doc',\n    topNode: true,\n    content: 'block+',\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1kb2N1bWVudC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFvQzs7QUFFcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsOENBQUk7QUFDckI7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFd0M7QUFDekMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWRvY3VtZW50L2Rpc3QvaW5kZXguanM/ODM3MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOb2RlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJztcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBkb2N1bWVudCBub2RlIHdoaWNoIHJlcHJlc2VudHMgdGhlIHRvcCBsZXZlbCBub2RlIG9mIHRoZSBlZGl0b3IuXG4gKiBAc2VlIGh0dHBzOi8vdGlwdGFwLmRldi9hcGkvbm9kZXMvZG9jdW1lbnRcbiAqL1xuY29uc3QgRG9jdW1lbnQgPSBOb2RlLmNyZWF0ZSh7XG4gICAgbmFtZTogJ2RvYycsXG4gICAgdG9wTm9kZTogdHJ1ZSxcbiAgICBjb250ZW50OiAnYmxvY2srJyxcbn0pO1xuXG5leHBvcnQgeyBEb2N1bWVudCwgRG9jdW1lbnQgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/extension-document/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/extension-dropcursor/dist/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-dropcursor/dist/index.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Dropcursor: function() { return /* binding */ Dropcursor; },\n/* harmony export */   \"default\": function() { return /* binding */ Dropcursor; }\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ \"(app-pages-browser)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_dropcursor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/dropcursor */ \"(app-pages-browser)/./node_modules/@tiptap/pm/dropcursor/dist/index.js\");\n\n\n\n/**\n * This extension allows you to add a drop cursor to your editor.\n * A drop cursor is a line that appears when you drag and drop content\n * inbetween nodes.\n * @see https://tiptap.dev/api/extensions/dropcursor\n */\nconst Dropcursor = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n    name: 'dropCursor',\n    addOptions() {\n        return {\n            color: 'currentColor',\n            width: 1,\n            class: undefined,\n        };\n    },\n    addProseMirrorPlugins() {\n        return [\n            (0,_tiptap_pm_dropcursor__WEBPACK_IMPORTED_MODULE_0__.dropCursor)(this.options),\n        ];\n    },\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1kcm9wY3Vyc29yL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUF5QztBQUNVOztBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbURBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLFlBQVksaUVBQVU7QUFDdEI7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFNEM7QUFDN0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWRyb3BjdXJzb3IvZGlzdC9pbmRleC5qcz9mMjFjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5pbXBvcnQgeyBkcm9wQ3Vyc29yIH0gZnJvbSAnQHRpcHRhcC9wbS9kcm9wY3Vyc29yJztcblxuLyoqXG4gKiBUaGlzIGV4dGVuc2lvbiBhbGxvd3MgeW91IHRvIGFkZCBhIGRyb3AgY3Vyc29yIHRvIHlvdXIgZWRpdG9yLlxuICogQSBkcm9wIGN1cnNvciBpcyBhIGxpbmUgdGhhdCBhcHBlYXJzIHdoZW4geW91IGRyYWcgYW5kIGRyb3AgY29udGVudFxuICogaW5iZXR3ZWVuIG5vZGVzLlxuICogQHNlZSBodHRwczovL3RpcHRhcC5kZXYvYXBpL2V4dGVuc2lvbnMvZHJvcGN1cnNvclxuICovXG5jb25zdCBEcm9wY3Vyc29yID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gICAgbmFtZTogJ2Ryb3BDdXJzb3InLFxuICAgIGFkZE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb2xvcjogJ2N1cnJlbnRDb2xvcicsXG4gICAgICAgICAgICB3aWR0aDogMSxcbiAgICAgICAgICAgIGNsYXNzOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBkcm9wQ3Vyc29yKHRoaXMub3B0aW9ucyksXG4gICAgICAgIF07XG4gICAgfSxcbn0pO1xuXG5leHBvcnQgeyBEcm9wY3Vyc29yLCBEcm9wY3Vyc29yIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/extension-dropcursor/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/extension-floating-menu/dist/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@tiptap/extension-floating-menu/dist/index.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   FloatingMenu: function() { return /* binding */ FloatingMenu; },\n/* harmony export */   FloatingMenuPlugin: function() { return /* binding */ FloatingMenuPlugin; },\n/* harmony export */   FloatingMenuView: function() { return /* binding */ FloatingMenuView; },\n/* harmony export */   \"default\": function() { return /* binding */ FloatingMenu; }\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ \"(app-pages-browser)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ \"(app-pages-browser)/./node_modules/@tiptap/pm/state/dist/index.js\");\n/* harmony import */ var tippy_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tippy.js */ \"(app-pages-browser)/./node_modules/tippy.js/dist/tippy.esm.js\");\n\n\n\n\nclass FloatingMenuView {\n    getTextContent(node) {\n        return (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.getText)(node, { textSerializers: (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.getTextSerializersFromSchema)(this.editor.schema) });\n    }\n    constructor({ editor, element, view, tippyOptions = {}, shouldShow, }) {\n        this.preventHide = false;\n        this.shouldShow = ({ view, state }) => {\n            const { selection } = state;\n            const { $anchor, empty } = selection;\n            const isRootDepth = $anchor.depth === 1;\n            const isEmptyTextBlock = $anchor.parent.isTextblock && !$anchor.parent.type.spec.code && !$anchor.parent.textContent && $anchor.parent.childCount === 0 && !this.getTextContent($anchor.parent);\n            if (!view.hasFocus()\n                || !empty\n                || !isRootDepth\n                || !isEmptyTextBlock\n                || !this.editor.isEditable) {\n                return false;\n            }\n            return true;\n        };\n        this.mousedownHandler = () => {\n            this.preventHide = true;\n        };\n        this.focusHandler = () => {\n            // we use `setTimeout` to make sure `selection` is already updated\n            setTimeout(() => this.update(this.editor.view));\n        };\n        this.blurHandler = ({ event }) => {\n            var _a;\n            if (this.preventHide) {\n                this.preventHide = false;\n                return;\n            }\n            if ((event === null || event === void 0 ? void 0 : event.relatedTarget) && ((_a = this.element.parentNode) === null || _a === void 0 ? void 0 : _a.contains(event.relatedTarget))) {\n                return;\n            }\n            if ((event === null || event === void 0 ? void 0 : event.relatedTarget) === this.editor.view.dom) {\n                return;\n            }\n            this.hide();\n        };\n        this.tippyBlurHandler = (event) => {\n            this.blurHandler({ event });\n        };\n        this.editor = editor;\n        this.element = element;\n        this.view = view;\n        if (shouldShow) {\n            this.shouldShow = shouldShow;\n        }\n        this.element.addEventListener('mousedown', this.mousedownHandler, { capture: true });\n        this.editor.on('focus', this.focusHandler);\n        this.editor.on('blur', this.blurHandler);\n        this.tippyOptions = tippyOptions;\n        // Detaches menu content from its current parent\n        this.element.remove();\n        this.element.style.visibility = 'visible';\n    }\n    createTooltip() {\n        const { element: editorElement } = this.editor.options;\n        const editorIsAttached = !!editorElement.parentElement;\n        this.element.tabIndex = 0;\n        if (this.tippy || !editorIsAttached) {\n            return;\n        }\n        this.tippy = (0,tippy_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(editorElement, {\n            duration: 0,\n            getReferenceClientRect: null,\n            content: this.element,\n            interactive: true,\n            trigger: 'manual',\n            placement: 'right',\n            hideOnClick: 'toggle',\n            ...this.tippyOptions,\n        });\n        // maybe we have to hide tippy on its own blur event as well\n        if (this.tippy.popper.firstChild) {\n            this.tippy.popper.firstChild.addEventListener('blur', this.tippyBlurHandler);\n        }\n    }\n    update(view, oldState) {\n        var _a, _b, _c;\n        const { state } = view;\n        const { doc, selection } = state;\n        const { from, to } = selection;\n        const isSame = oldState && oldState.doc.eq(doc) && oldState.selection.eq(selection);\n        if (isSame) {\n            return;\n        }\n        this.createTooltip();\n        const shouldShow = (_a = this.shouldShow) === null || _a === void 0 ? void 0 : _a.call(this, {\n            editor: this.editor,\n            view,\n            state,\n            oldState,\n        });\n        if (!shouldShow) {\n            this.hide();\n            return;\n        }\n        (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.setProps({\n            getReferenceClientRect: ((_c = this.tippyOptions) === null || _c === void 0 ? void 0 : _c.getReferenceClientRect) || (() => (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.posToDOMRect)(view, from, to)),\n        });\n        this.show();\n    }\n    show() {\n        var _a;\n        (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.show();\n    }\n    hide() {\n        var _a;\n        (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.hide();\n    }\n    destroy() {\n        var _a, _b;\n        if ((_a = this.tippy) === null || _a === void 0 ? void 0 : _a.popper.firstChild) {\n            this.tippy.popper.firstChild.removeEventListener('blur', this.tippyBlurHandler);\n        }\n        (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.destroy();\n        this.element.removeEventListener('mousedown', this.mousedownHandler, { capture: true });\n        this.editor.off('focus', this.focusHandler);\n        this.editor.off('blur', this.blurHandler);\n    }\n}\nconst FloatingMenuPlugin = (options) => {\n    return new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        key: typeof options.pluginKey === 'string' ? new _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey(options.pluginKey) : options.pluginKey,\n        view: view => new FloatingMenuView({ view, ...options }),\n    });\n};\n\n/**\n * This extension allows you to create a floating menu.\n * @see https://tiptap.dev/api/extensions/floating-menu\n */\nconst FloatingMenu = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n    name: 'floatingMenu',\n    addOptions() {\n        return {\n            element: null,\n            tippyOptions: {},\n            pluginKey: 'floatingMenu',\n            shouldShow: null,\n        };\n    },\n    addProseMirrorPlugins() {\n        if (!this.options.element) {\n            return [];\n        }\n        return [\n            FloatingMenuPlugin({\n                pluginKey: this.options.pluginKey,\n                editor: this.editor,\n                element: this.options.element,\n                tippyOptions: this.options.tippyOptions,\n                shouldShow: this.options.shouldShow,\n            }),\n        ];\n    },\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1mbG9hdGluZy1tZW51L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUE4RjtBQUN6QztBQUN4Qjs7QUFFN0I7QUFDQTtBQUNBLGVBQWUscURBQU8sU0FBUyxpQkFBaUIsMEVBQTRCLHNCQUFzQjtBQUNsRztBQUNBLGtCQUFrQix3Q0FBd0MsZUFBZTtBQUN6RTtBQUNBLDZCQUE2QixhQUFhO0FBQzFDLG9CQUFvQixZQUFZO0FBQ2hDLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLE9BQU87QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixPQUFPO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLGVBQWU7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvREFBSztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLGlCQUFpQjtBQUNqQyxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0lBQXdJLDBEQUFZO0FBQ3BKLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxlQUFlO0FBQzlGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9EQUFNO0FBQ3JCLHlEQUF5RCx1REFBUztBQUNsRSw2Q0FBNkMsa0JBQWtCO0FBQy9ELEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtREFBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUVzRjtBQUN2RiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tZmxvYXRpbmctbWVudS9kaXN0L2luZGV4LmpzP2U3MDAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0VGV4dCwgZ2V0VGV4dFNlcmlhbGl6ZXJzRnJvbVNjaGVtYSwgcG9zVG9ET01SZWN0LCBFeHRlbnNpb24gfSBmcm9tICdAdGlwdGFwL2NvcmUnO1xuaW1wb3J0IHsgUGx1Z2luLCBQbHVnaW5LZXkgfSBmcm9tICdAdGlwdGFwL3BtL3N0YXRlJztcbmltcG9ydCB0aXBweSBmcm9tICd0aXBweS5qcyc7XG5cbmNsYXNzIEZsb2F0aW5nTWVudVZpZXcge1xuICAgIGdldFRleHRDb250ZW50KG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGdldFRleHQobm9kZSwgeyB0ZXh0U2VyaWFsaXplcnM6IGdldFRleHRTZXJpYWxpemVyc0Zyb21TY2hlbWEodGhpcy5lZGl0b3Iuc2NoZW1hKSB9KTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoeyBlZGl0b3IsIGVsZW1lbnQsIHZpZXcsIHRpcHB5T3B0aW9ucyA9IHt9LCBzaG91bGRTaG93LCB9KSB7XG4gICAgICAgIHRoaXMucHJldmVudEhpZGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zaG91bGRTaG93ID0gKHsgdmlldywgc3RhdGUgfSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBzZWxlY3Rpb24gfSA9IHN0YXRlO1xuICAgICAgICAgICAgY29uc3QgeyAkYW5jaG9yLCBlbXB0eSB9ID0gc2VsZWN0aW9uO1xuICAgICAgICAgICAgY29uc3QgaXNSb290RGVwdGggPSAkYW5jaG9yLmRlcHRoID09PSAxO1xuICAgICAgICAgICAgY29uc3QgaXNFbXB0eVRleHRCbG9jayA9ICRhbmNob3IucGFyZW50LmlzVGV4dGJsb2NrICYmICEkYW5jaG9yLnBhcmVudC50eXBlLnNwZWMuY29kZSAmJiAhJGFuY2hvci5wYXJlbnQudGV4dENvbnRlbnQgJiYgJGFuY2hvci5wYXJlbnQuY2hpbGRDb3VudCA9PT0gMCAmJiAhdGhpcy5nZXRUZXh0Q29udGVudCgkYW5jaG9yLnBhcmVudCk7XG4gICAgICAgICAgICBpZiAoIXZpZXcuaGFzRm9jdXMoKVxuICAgICAgICAgICAgICAgIHx8ICFlbXB0eVxuICAgICAgICAgICAgICAgIHx8ICFpc1Jvb3REZXB0aFxuICAgICAgICAgICAgICAgIHx8ICFpc0VtcHR5VGV4dEJsb2NrXG4gICAgICAgICAgICAgICAgfHwgIXRoaXMuZWRpdG9yLmlzRWRpdGFibGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5tb3VzZWRvd25IYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wcmV2ZW50SGlkZSA9IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZm9jdXNIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgLy8gd2UgdXNlIGBzZXRUaW1lb3V0YCB0byBtYWtlIHN1cmUgYHNlbGVjdGlvbmAgaXMgYWxyZWFkeSB1cGRhdGVkXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMudXBkYXRlKHRoaXMuZWRpdG9yLnZpZXcpKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ibHVySGFuZGxlciA9ICh7IGV2ZW50IH0pID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXZlbnRIaWRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcmV2ZW50SGlkZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoZXZlbnQgPT09IG51bGwgfHwgZXZlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV2ZW50LnJlbGF0ZWRUYXJnZXQpICYmICgoX2EgPSB0aGlzLmVsZW1lbnQucGFyZW50Tm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoZXZlbnQgPT09IG51bGwgfHwgZXZlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV2ZW50LnJlbGF0ZWRUYXJnZXQpID09PSB0aGlzLmVkaXRvci52aWV3LmRvbSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLnRpcHB5Qmx1ckhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuYmx1ckhhbmRsZXIoeyBldmVudCB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5lZGl0b3IgPSBlZGl0b3I7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIGlmIChzaG91bGRTaG93KSB7XG4gICAgICAgICAgICB0aGlzLnNob3VsZFNob3cgPSBzaG91bGRTaG93O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLm1vdXNlZG93bkhhbmRsZXIsIHsgY2FwdHVyZTogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5lZGl0b3Iub24oJ2ZvY3VzJywgdGhpcy5mb2N1c0hhbmRsZXIpO1xuICAgICAgICB0aGlzLmVkaXRvci5vbignYmx1cicsIHRoaXMuYmx1ckhhbmRsZXIpO1xuICAgICAgICB0aGlzLnRpcHB5T3B0aW9ucyA9IHRpcHB5T3B0aW9ucztcbiAgICAgICAgLy8gRGV0YWNoZXMgbWVudSBjb250ZW50IGZyb20gaXRzIGN1cnJlbnQgcGFyZW50XG4gICAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XG4gICAgfVxuICAgIGNyZWF0ZVRvb2x0aXAoKSB7XG4gICAgICAgIGNvbnN0IHsgZWxlbWVudDogZWRpdG9yRWxlbWVudCB9ID0gdGhpcy5lZGl0b3Iub3B0aW9ucztcbiAgICAgICAgY29uc3QgZWRpdG9ySXNBdHRhY2hlZCA9ICEhZWRpdG9yRWxlbWVudC5wYXJlbnRFbGVtZW50O1xuICAgICAgICB0aGlzLmVsZW1lbnQudGFiSW5kZXggPSAwO1xuICAgICAgICBpZiAodGhpcy50aXBweSB8fCAhZWRpdG9ySXNBdHRhY2hlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGlwcHkgPSB0aXBweShlZGl0b3JFbGVtZW50LCB7XG4gICAgICAgICAgICBkdXJhdGlvbjogMCxcbiAgICAgICAgICAgIGdldFJlZmVyZW5jZUNsaWVudFJlY3Q6IG51bGwsXG4gICAgICAgICAgICBjb250ZW50OiB0aGlzLmVsZW1lbnQsXG4gICAgICAgICAgICBpbnRlcmFjdGl2ZTogdHJ1ZSxcbiAgICAgICAgICAgIHRyaWdnZXI6ICdtYW51YWwnLFxuICAgICAgICAgICAgcGxhY2VtZW50OiAncmlnaHQnLFxuICAgICAgICAgICAgaGlkZU9uQ2xpY2s6ICd0b2dnbGUnLFxuICAgICAgICAgICAgLi4udGhpcy50aXBweU9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBtYXliZSB3ZSBoYXZlIHRvIGhpZGUgdGlwcHkgb24gaXRzIG93biBibHVyIGV2ZW50IGFzIHdlbGxcbiAgICAgICAgaWYgKHRoaXMudGlwcHkucG9wcGVyLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIHRoaXMudGlwcHkucG9wcGVyLmZpcnN0Q2hpbGQuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMudGlwcHlCbHVySGFuZGxlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlKHZpZXcsIG9sZFN0YXRlKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCB7IHN0YXRlIH0gPSB2aWV3O1xuICAgICAgICBjb25zdCB7IGRvYywgc2VsZWN0aW9uIH0gPSBzdGF0ZTtcbiAgICAgICAgY29uc3QgeyBmcm9tLCB0byB9ID0gc2VsZWN0aW9uO1xuICAgICAgICBjb25zdCBpc1NhbWUgPSBvbGRTdGF0ZSAmJiBvbGRTdGF0ZS5kb2MuZXEoZG9jKSAmJiBvbGRTdGF0ZS5zZWxlY3Rpb24uZXEoc2VsZWN0aW9uKTtcbiAgICAgICAgaWYgKGlzU2FtZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3JlYXRlVG9vbHRpcCgpO1xuICAgICAgICBjb25zdCBzaG91bGRTaG93ID0gKF9hID0gdGhpcy5zaG91bGRTaG93KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCB7XG4gICAgICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgICAgICAgdmlldyxcbiAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgb2xkU3RhdGUsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXNob3VsZFNob3cpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIChfYiA9IHRoaXMudGlwcHkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zZXRQcm9wcyh7XG4gICAgICAgICAgICBnZXRSZWZlcmVuY2VDbGllbnRSZWN0OiAoKF9jID0gdGhpcy50aXBweU9wdGlvbnMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5nZXRSZWZlcmVuY2VDbGllbnRSZWN0KSB8fCAoKCkgPT4gcG9zVG9ET01SZWN0KHZpZXcsIGZyb20sIHRvKSksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNob3coKTtcbiAgICB9XG4gICAgc2hvdygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLnRpcHB5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2hvdygpO1xuICAgIH1cbiAgICBoaWRlKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHRoaXMudGlwcHkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oaWRlKCk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICgoX2EgPSB0aGlzLnRpcHB5KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucG9wcGVyLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIHRoaXMudGlwcHkucG9wcGVyLmZpcnN0Q2hpbGQucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMudGlwcHlCbHVySGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgKF9iID0gdGhpcy50aXBweSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMubW91c2Vkb3duSGFuZGxlciwgeyBjYXB0dXJlOiB0cnVlIH0pO1xuICAgICAgICB0aGlzLmVkaXRvci5vZmYoJ2ZvY3VzJywgdGhpcy5mb2N1c0hhbmRsZXIpO1xuICAgICAgICB0aGlzLmVkaXRvci5vZmYoJ2JsdXInLCB0aGlzLmJsdXJIYW5kbGVyKTtcbiAgICB9XG59XG5jb25zdCBGbG9hdGluZ01lbnVQbHVnaW4gPSAob3B0aW9ucykgPT4ge1xuICAgIHJldHVybiBuZXcgUGx1Z2luKHtcbiAgICAgICAga2V5OiB0eXBlb2Ygb3B0aW9ucy5wbHVnaW5LZXkgPT09ICdzdHJpbmcnID8gbmV3IFBsdWdpbktleShvcHRpb25zLnBsdWdpbktleSkgOiBvcHRpb25zLnBsdWdpbktleSxcbiAgICAgICAgdmlldzogdmlldyA9PiBuZXcgRmxvYXRpbmdNZW51Vmlldyh7IHZpZXcsIC4uLm9wdGlvbnMgfSksXG4gICAgfSk7XG59O1xuXG4vKipcbiAqIFRoaXMgZXh0ZW5zaW9uIGFsbG93cyB5b3UgdG8gY3JlYXRlIGEgZmxvYXRpbmcgbWVudS5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2FwaS9leHRlbnNpb25zL2Zsb2F0aW5nLW1lbnVcbiAqL1xuY29uc3QgRmxvYXRpbmdNZW51ID0gRXh0ZW5zaW9uLmNyZWF0ZSh7XG4gICAgbmFtZTogJ2Zsb2F0aW5nTWVudScsXG4gICAgYWRkT3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IG51bGwsXG4gICAgICAgICAgICB0aXBweU9wdGlvbnM6IHt9LFxuICAgICAgICAgICAgcGx1Z2luS2V5OiAnZmxvYXRpbmdNZW51JyxcbiAgICAgICAgICAgIHNob3VsZFNob3c6IG51bGwsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgRmxvYXRpbmdNZW51UGx1Z2luKHtcbiAgICAgICAgICAgICAgICBwbHVnaW5LZXk6IHRoaXMub3B0aW9ucy5wbHVnaW5LZXksXG4gICAgICAgICAgICAgICAgZWRpdG9yOiB0aGlzLmVkaXRvcixcbiAgICAgICAgICAgICAgICBlbGVtZW50OiB0aGlzLm9wdGlvbnMuZWxlbWVudCxcbiAgICAgICAgICAgICAgICB0aXBweU9wdGlvbnM6IHRoaXMub3B0aW9ucy50aXBweU9wdGlvbnMsXG4gICAgICAgICAgICAgICAgc2hvdWxkU2hvdzogdGhpcy5vcHRpb25zLnNob3VsZFNob3csXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgXTtcbiAgICB9LFxufSk7XG5cbmV4cG9ydCB7IEZsb2F0aW5nTWVudSwgRmxvYXRpbmdNZW51UGx1Z2luLCBGbG9hdGluZ01lbnVWaWV3LCBGbG9hdGluZ01lbnUgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/extension-floating-menu/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/extension-gapcursor/dist/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-gapcursor/dist/index.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Gapcursor: function() { return /* binding */ Gapcursor; },\n/* harmony export */   \"default\": function() { return /* binding */ Gapcursor; }\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ \"(app-pages-browser)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_gapcursor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/gapcursor */ \"(app-pages-browser)/./node_modules/@tiptap/pm/gapcursor/dist/index.js\");\n\n\n\n/**\n * This extension allows you to add a gap cursor to your editor.\n * A gap cursor is a cursor that appears when you click on a place\n * where no content is present, for example inbetween nodes.\n * @see https://tiptap.dev/api/extensions/gapcursor\n */\nconst Gapcursor = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n    name: 'gapCursor',\n    addProseMirrorPlugins() {\n        return [\n            (0,_tiptap_pm_gapcursor__WEBPACK_IMPORTED_MODULE_0__.gapCursor)(),\n        ];\n    },\n    extendNodeSchema(extension) {\n        var _a;\n        const context = {\n            name: extension.name,\n            options: extension.options,\n            storage: extension.storage,\n        };\n        return {\n            allowGapCursor: (_a = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.callOrReturn)((0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.getExtensionField)(extension, 'allowGapCursor', context))) !== null && _a !== void 0 ? _a : null,\n        };\n    },\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1nYXBjdXJzb3IvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTBFO0FBQ3pCOztBQUVqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsbURBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsWUFBWSwrREFBUztBQUNyQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDBEQUFZLENBQUMsK0RBQWlCO0FBQ2hFO0FBQ0EsS0FBSztBQUNMLENBQUM7O0FBRTBDO0FBQzNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1nYXBjdXJzb3IvZGlzdC9pbmRleC5qcz84NDNhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV4dGVuc2lvbiwgY2FsbE9yUmV0dXJuLCBnZXRFeHRlbnNpb25GaWVsZCB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5pbXBvcnQgeyBnYXBDdXJzb3IgfSBmcm9tICdAdGlwdGFwL3BtL2dhcGN1cnNvcic7XG5cbi8qKlxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBhZGQgYSBnYXAgY3Vyc29yIHRvIHlvdXIgZWRpdG9yLlxuICogQSBnYXAgY3Vyc29yIGlzIGEgY3Vyc29yIHRoYXQgYXBwZWFycyB3aGVuIHlvdSBjbGljayBvbiBhIHBsYWNlXG4gKiB3aGVyZSBubyBjb250ZW50IGlzIHByZXNlbnQsIGZvciBleGFtcGxlIGluYmV0d2VlbiBub2Rlcy5cbiAqIEBzZWUgaHR0cHM6Ly90aXB0YXAuZGV2L2FwaS9leHRlbnNpb25zL2dhcGN1cnNvclxuICovXG5jb25zdCBHYXBjdXJzb3IgPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgICBuYW1lOiAnZ2FwQ3Vyc29yJyxcbiAgICBhZGRQcm9zZU1pcnJvclBsdWdpbnMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBnYXBDdXJzb3IoKSxcbiAgICAgICAgXTtcbiAgICB9LFxuICAgIGV4dGVuZE5vZGVTY2hlbWEoZXh0ZW5zaW9uKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHtcbiAgICAgICAgICAgIG5hbWU6IGV4dGVuc2lvbi5uYW1lLFxuICAgICAgICAgICAgb3B0aW9uczogZXh0ZW5zaW9uLm9wdGlvbnMsXG4gICAgICAgICAgICBzdG9yYWdlOiBleHRlbnNpb24uc3RvcmFnZSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFsbG93R2FwQ3Vyc29yOiAoX2EgPSBjYWxsT3JSZXR1cm4oZ2V0RXh0ZW5zaW9uRmllbGQoZXh0ZW5zaW9uLCAnYWxsb3dHYXBDdXJzb3InLCBjb250ZXh0KSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGwsXG4gICAgICAgIH07XG4gICAgfSxcbn0pO1xuXG5leHBvcnQgeyBHYXBjdXJzb3IsIEdhcGN1cnNvciBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/extension-gapcursor/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/extension-hard-break/dist/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-hard-break/dist/index.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HardBreak: function() { return /* binding */ HardBreak; },\n/* harmony export */   \"default\": function() { return /* binding */ HardBreak; }\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(app-pages-browser)/./node_modules/@tiptap/core/dist/index.js\");\n\n\n/**\n * This extension allows you to insert hard breaks.\n * @see https://www.tiptap.dev/api/nodes/hard-break\n */\nconst HardBreak = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: 'hardBreak',\n    addOptions() {\n        return {\n            keepMarks: true,\n            HTMLAttributes: {},\n        };\n    },\n    inline: true,\n    group: 'inline',\n    selectable: false,\n    linebreakReplacement: true,\n    parseHTML() {\n        return [\n            { tag: 'br' },\n        ];\n    },\n    renderHTML({ HTMLAttributes }) {\n        return ['br', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes)];\n    },\n    renderText() {\n        return '\\n';\n    },\n    addCommands() {\n        return {\n            setHardBreak: () => ({ commands, chain, state, editor, }) => {\n                return commands.first([\n                    () => commands.exitCode(),\n                    () => commands.command(() => {\n                        const { selection, storedMarks } = state;\n                        if (selection.$from.parent.type.spec.isolating) {\n                            return false;\n                        }\n                        const { keepMarks } = this.options;\n                        const { splittableMarks } = editor.extensionManager;\n                        const marks = storedMarks\n                            || (selection.$to.parentOffset && selection.$from.marks());\n                        return chain()\n                            .insertContent({ type: this.name })\n                            .command(({ tr, dispatch }) => {\n                            if (dispatch && marks && keepMarks) {\n                                const filteredMarks = marks\n                                    .filter(mark => splittableMarks.includes(mark.type.name));\n                                tr.ensureMarks(filteredMarks);\n                            }\n                            return true;\n                        })\n                            .run();\n                    }),\n                ]);\n            },\n        };\n    },\n    addKeyboardShortcuts() {\n        return {\n            'Mod-Enter': () => this.editor.commands.setHardBreak(),\n            'Shift-Enter': () => this.editor.commands.setHardBreak(),\n        };\n    },\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1oYXJkLWJyZWFrL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXFEOztBQUVyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw4Q0FBSTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQSxLQUFLO0FBQ0wsaUJBQWlCLGdCQUFnQjtBQUNqQyxzQkFBc0IsNkRBQWU7QUFDckMsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG1DQUFtQyxpQ0FBaUM7QUFDcEU7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHlCQUF5QjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsWUFBWTtBQUM1QyxnQ0FBZ0Msa0JBQWtCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxpQkFBaUI7QUFDOUQsd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFMEM7QUFDM0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWhhcmQtYnJlYWsvZGlzdC9pbmRleC5qcz83N2RiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5vZGUsIG1lcmdlQXR0cmlidXRlcyB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5cbi8qKlxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBpbnNlcnQgaGFyZCBicmVha3MuXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnRpcHRhcC5kZXYvYXBpL25vZGVzL2hhcmQtYnJlYWtcbiAqL1xuY29uc3QgSGFyZEJyZWFrID0gTm9kZS5jcmVhdGUoe1xuICAgIG5hbWU6ICdoYXJkQnJlYWsnLFxuICAgIGFkZE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBrZWVwTWFya3M6IHRydWUsXG4gICAgICAgICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBpbmxpbmU6IHRydWUsXG4gICAgZ3JvdXA6ICdpbmxpbmUnLFxuICAgIHNlbGVjdGFibGU6IGZhbHNlLFxuICAgIGxpbmVicmVha1JlcGxhY2VtZW50OiB0cnVlLFxuICAgIHBhcnNlSFRNTCgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHsgdGFnOiAnYnInIH0sXG4gICAgICAgIF07XG4gICAgfSxcbiAgICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgICAgICByZXR1cm4gWydicicsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKV07XG4gICAgfSxcbiAgICByZW5kZXJUZXh0KCkge1xuICAgICAgICByZXR1cm4gJ1xcbic7XG4gICAgfSxcbiAgICBhZGRDb21tYW5kcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNldEhhcmRCcmVhazogKCkgPT4gKHsgY29tbWFuZHMsIGNoYWluLCBzdGF0ZSwgZWRpdG9yLCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLmZpcnN0KFtcbiAgICAgICAgICAgICAgICAgICAgKCkgPT4gY29tbWFuZHMuZXhpdENvZGUoKSxcbiAgICAgICAgICAgICAgICAgICAgKCkgPT4gY29tbWFuZHMuY29tbWFuZCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHNlbGVjdGlvbiwgc3RvcmVkTWFya3MgfSA9IHN0YXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbi4kZnJvbS5wYXJlbnQudHlwZS5zcGVjLmlzb2xhdGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsga2VlcE1hcmtzIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHNwbGl0dGFibGVNYXJrcyB9ID0gZWRpdG9yLmV4dGVuc2lvbk1hbmFnZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXJrcyA9IHN0b3JlZE1hcmtzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfHwgKHNlbGVjdGlvbi4kdG8ucGFyZW50T2Zmc2V0ICYmIHNlbGVjdGlvbi4kZnJvbS5tYXJrcygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGFpbigpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmluc2VydENvbnRlbnQoeyB0eXBlOiB0aGlzLm5hbWUgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuY29tbWFuZCgoeyB0ciwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXNwYXRjaCAmJiBtYXJrcyAmJiBrZWVwTWFya3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlsdGVyZWRNYXJrcyA9IG1hcmtzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKG1hcmsgPT4gc3BsaXR0YWJsZU1hcmtzLmluY2x1ZGVzKG1hcmsudHlwZS5uYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyLmVuc3VyZU1hcmtzKGZpbHRlcmVkTWFya3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJ1bigpO1xuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBhZGRLZXlib2FyZFNob3J0Y3V0cygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICdNb2QtRW50ZXInOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zZXRIYXJkQnJlYWsoKSxcbiAgICAgICAgICAgICdTaGlmdC1FbnRlcic6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnNldEhhcmRCcmVhaygpLFxuICAgICAgICB9O1xuICAgIH0sXG59KTtcblxuZXhwb3J0IHsgSGFyZEJyZWFrLCBIYXJkQnJlYWsgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/extension-hard-break/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/extension-heading/dist/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@tiptap/extension-heading/dist/index.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Heading: function() { return /* binding */ Heading; },\n/* harmony export */   \"default\": function() { return /* binding */ Heading; }\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(app-pages-browser)/./node_modules/@tiptap/core/dist/index.js\");\n\n\n/**\n * This extension allows you to create headings.\n * @see https://www.tiptap.dev/api/nodes/heading\n */\nconst Heading = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: 'heading',\n    addOptions() {\n        return {\n            levels: [1, 2, 3, 4, 5, 6],\n            HTMLAttributes: {},\n        };\n    },\n    content: 'inline*',\n    group: 'block',\n    defining: true,\n    addAttributes() {\n        return {\n            level: {\n                default: 1,\n                rendered: false,\n            },\n        };\n    },\n    parseHTML() {\n        return this.options.levels\n            .map((level) => ({\n            tag: `h${level}`,\n            attrs: { level },\n        }));\n    },\n    renderHTML({ node, HTMLAttributes }) {\n        const hasLevel = this.options.levels.includes(node.attrs.level);\n        const level = hasLevel\n            ? node.attrs.level\n            : this.options.levels[0];\n        return [`h${level}`, (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n    },\n    addCommands() {\n        return {\n            setHeading: attributes => ({ commands }) => {\n                if (!this.options.levels.includes(attributes.level)) {\n                    return false;\n                }\n                return commands.setNode(this.name, attributes);\n            },\n            toggleHeading: attributes => ({ commands }) => {\n                if (!this.options.levels.includes(attributes.level)) {\n                    return false;\n                }\n                return commands.toggleNode(this.name, 'paragraph', attributes);\n            },\n        };\n    },\n    addKeyboardShortcuts() {\n        return this.options.levels.reduce((items, level) => ({\n            ...items,\n            ...{\n                [`Mod-Alt-${level}`]: () => this.editor.commands.toggleHeading({ level }),\n            },\n        }), {});\n    },\n    addInputRules() {\n        return this.options.levels.map(level => {\n            return (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.textblockTypeInputRule)({\n                find: new RegExp(`^(#{${Math.min(...this.options.levels)},${level}})\\\\s$`),\n                type: this.type,\n                getAttributes: {\n                    level,\n                },\n            });\n        });\n    },\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1oZWFkaW5nL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTZFOztBQUU3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw4Q0FBSTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixNQUFNO0FBQzNCLHFCQUFxQixPQUFPO0FBQzVCLFNBQVM7QUFDVCxLQUFLO0FBQ0wsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixNQUFNLEdBQUcsNkRBQWU7QUFDNUMsS0FBSztBQUNMO0FBQ0E7QUFDQSx5Q0FBeUMsVUFBVTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYiw0Q0FBNEMsVUFBVTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixNQUFNLCtDQUErQyxPQUFPO0FBQ3hGLGFBQWE7QUFDYixTQUFTLEtBQUs7QUFDZCxLQUFLO0FBQ0w7QUFDQTtBQUNBLG1CQUFtQixvRUFBc0I7QUFDekMsc0NBQXNDLEVBQUUsaUNBQWlDLEdBQUcsT0FBTztBQUNuRjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVCxLQUFLO0FBQ0wsQ0FBQzs7QUFFc0M7QUFDdkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWhlYWRpbmcvZGlzdC9pbmRleC5qcz9iMDlhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5vZGUsIG1lcmdlQXR0cmlidXRlcywgdGV4dGJsb2NrVHlwZUlucHV0UnVsZSB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5cbi8qKlxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBjcmVhdGUgaGVhZGluZ3MuXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnRpcHRhcC5kZXYvYXBpL25vZGVzL2hlYWRpbmdcbiAqL1xuY29uc3QgSGVhZGluZyA9IE5vZGUuY3JlYXRlKHtcbiAgICBuYW1lOiAnaGVhZGluZycsXG4gICAgYWRkT3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxldmVsczogWzEsIDIsIDMsIDQsIDUsIDZdLFxuICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgY29udGVudDogJ2lubGluZSonLFxuICAgIGdyb3VwOiAnYmxvY2snLFxuICAgIGRlZmluaW5nOiB0cnVlLFxuICAgIGFkZEF0dHJpYnV0ZXMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZXZlbDoge1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IDEsXG4gICAgICAgICAgICAgICAgcmVuZGVyZWQ6IGZhbHNlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHBhcnNlSFRNTCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5sZXZlbHNcbiAgICAgICAgICAgIC5tYXAoKGxldmVsKSA9PiAoe1xuICAgICAgICAgICAgdGFnOiBgaCR7bGV2ZWx9YCxcbiAgICAgICAgICAgIGF0dHJzOiB7IGxldmVsIH0sXG4gICAgICAgIH0pKTtcbiAgICB9LFxuICAgIHJlbmRlckhUTUwoeyBub2RlLCBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgICAgIGNvbnN0IGhhc0xldmVsID0gdGhpcy5vcHRpb25zLmxldmVscy5pbmNsdWRlcyhub2RlLmF0dHJzLmxldmVsKTtcbiAgICAgICAgY29uc3QgbGV2ZWwgPSBoYXNMZXZlbFxuICAgICAgICAgICAgPyBub2RlLmF0dHJzLmxldmVsXG4gICAgICAgICAgICA6IHRoaXMub3B0aW9ucy5sZXZlbHNbMF07XG4gICAgICAgIHJldHVybiBbYGgke2xldmVsfWAsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF07XG4gICAgfSxcbiAgICBhZGRDb21tYW5kcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNldEhlYWRpbmc6IGF0dHJpYnV0ZXMgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLmxldmVscy5pbmNsdWRlcyhhdHRyaWJ1dGVzLmxldmVsKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy5zZXROb2RlKHRoaXMubmFtZSwgYXR0cmlidXRlcyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG9nZ2xlSGVhZGluZzogYXR0cmlidXRlcyA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMubGV2ZWxzLmluY2x1ZGVzKGF0dHJpYnV0ZXMubGV2ZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnRvZ2dsZU5vZGUodGhpcy5uYW1lLCAncGFyYWdyYXBoJywgYXR0cmlidXRlcyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMubGV2ZWxzLnJlZHVjZSgoaXRlbXMsIGxldmVsKSA9PiAoe1xuICAgICAgICAgICAgLi4uaXRlbXMsXG4gICAgICAgICAgICAuLi57XG4gICAgICAgICAgICAgICAgW2BNb2QtQWx0LSR7bGV2ZWx9YF06ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZUhlYWRpbmcoeyBsZXZlbCB9KSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pLCB7fSk7XG4gICAgfSxcbiAgICBhZGRJbnB1dFJ1bGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmxldmVscy5tYXAobGV2ZWwgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRleHRibG9ja1R5cGVJbnB1dFJ1bGUoe1xuICAgICAgICAgICAgICAgIGZpbmQ6IG5ldyBSZWdFeHAoYF4oI3ske01hdGgubWluKC4uLnRoaXMub3B0aW9ucy5sZXZlbHMpfSwke2xldmVsfX0pXFxcXHMkYCksXG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgICAgIGdldEF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgbGV2ZWwsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9LFxufSk7XG5cbmV4cG9ydCB7IEhlYWRpbmcsIEhlYWRpbmcgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/extension-heading/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/extension-history/dist/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@tiptap/extension-history/dist/index.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   History: function() { return /* binding */ History; },\n/* harmony export */   \"default\": function() { return /* binding */ History; }\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ \"(app-pages-browser)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_history__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/history */ \"(app-pages-browser)/./node_modules/@tiptap/pm/history/dist/index.js\");\n\n\n\n/**\n * This extension allows you to undo and redo recent changes.\n * @see https://www.tiptap.dev/api/extensions/history\n *\n * **Important**: If the `@tiptap/extension-collaboration` package is used, make sure to remove\n * the `history` extension, as it is not compatible with the `collaboration` extension.\n *\n * `@tiptap/extension-collaboration` uses its own history implementation.\n */\nconst History = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Extension.create({\n    name: 'history',\n    addOptions() {\n        return {\n            depth: 100,\n            newGroupDelay: 500,\n        };\n    },\n    addCommands() {\n        return {\n            undo: () => ({ state, dispatch }) => {\n                return (0,_tiptap_pm_history__WEBPACK_IMPORTED_MODULE_0__.undo)(state, dispatch);\n            },\n            redo: () => ({ state, dispatch }) => {\n                return (0,_tiptap_pm_history__WEBPACK_IMPORTED_MODULE_0__.redo)(state, dispatch);\n            },\n        };\n    },\n    addProseMirrorPlugins() {\n        return [\n            (0,_tiptap_pm_history__WEBPACK_IMPORTED_MODULE_0__.history)(this.options),\n        ];\n    },\n    addKeyboardShortcuts() {\n        return {\n            'Mod-z': () => this.editor.commands.undo(),\n            'Shift-Mod-z': () => this.editor.commands.redo(),\n            'Mod-y': () => this.editor.commands.redo(),\n            // Russian keyboard layouts\n            'Mod-я': () => this.editor.commands.undo(),\n            'Shift-Mod-я': () => this.editor.commands.redo(),\n        };\n    },\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1oaXN0b3J5L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUF5QztBQUNnQjs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1EQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1Qyx1QkFBdUIsd0RBQUk7QUFDM0IsYUFBYTtBQUNiLDJCQUEyQixpQkFBaUI7QUFDNUMsdUJBQXVCLHdEQUFJO0FBQzNCLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWSwyREFBTztBQUNuQjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFc0M7QUFDdkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWhpc3RvcnkvZGlzdC9pbmRleC5qcz9mNzcyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5pbXBvcnQgeyB1bmRvLCByZWRvLCBoaXN0b3J5IH0gZnJvbSAnQHRpcHRhcC9wbS9oaXN0b3J5JztcblxuLyoqXG4gKiBUaGlzIGV4dGVuc2lvbiBhbGxvd3MgeW91IHRvIHVuZG8gYW5kIHJlZG8gcmVjZW50IGNoYW5nZXMuXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnRpcHRhcC5kZXYvYXBpL2V4dGVuc2lvbnMvaGlzdG9yeVxuICpcbiAqICoqSW1wb3J0YW50Kio6IElmIHRoZSBgQHRpcHRhcC9leHRlbnNpb24tY29sbGFib3JhdGlvbmAgcGFja2FnZSBpcyB1c2VkLCBtYWtlIHN1cmUgdG8gcmVtb3ZlXG4gKiB0aGUgYGhpc3RvcnlgIGV4dGVuc2lvbiwgYXMgaXQgaXMgbm90IGNvbXBhdGlibGUgd2l0aCB0aGUgYGNvbGxhYm9yYXRpb25gIGV4dGVuc2lvbi5cbiAqXG4gKiBgQHRpcHRhcC9leHRlbnNpb24tY29sbGFib3JhdGlvbmAgdXNlcyBpdHMgb3duIGhpc3RvcnkgaW1wbGVtZW50YXRpb24uXG4gKi9cbmNvbnN0IEhpc3RvcnkgPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgICBuYW1lOiAnaGlzdG9yeScsXG4gICAgYWRkT3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlcHRoOiAxMDAsXG4gICAgICAgICAgICBuZXdHcm91cERlbGF5OiA1MDAsXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBhZGRDb21tYW5kcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHVuZG86ICgpID0+ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZG8oc3RhdGUsIGRpc3BhdGNoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWRvOiAoKSA9PiAoeyBzdGF0ZSwgZGlzcGF0Y2ggfSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWRvKHN0YXRlLCBkaXNwYXRjaCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYWRkUHJvc2VNaXJyb3JQbHVnaW5zKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgaGlzdG9yeSh0aGlzLm9wdGlvbnMpLFxuICAgICAgICBdO1xuICAgIH0sXG4gICAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnTW9kLXonOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy51bmRvKCksXG4gICAgICAgICAgICAnU2hpZnQtTW9kLXonOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5yZWRvKCksXG4gICAgICAgICAgICAnTW9kLXknOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5yZWRvKCksXG4gICAgICAgICAgICAvLyBSdXNzaWFuIGtleWJvYXJkIGxheW91dHNcbiAgICAgICAgICAgICdNb2Qt0Y8nOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy51bmRvKCksXG4gICAgICAgICAgICAnU2hpZnQtTW9kLdGPJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMucmVkbygpLFxuICAgICAgICB9O1xuICAgIH0sXG59KTtcblxuZXhwb3J0IHsgSGlzdG9yeSwgSGlzdG9yeSBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/extension-history/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/extension-horizontal-rule/dist/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@tiptap/extension-horizontal-rule/dist/index.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HorizontalRule: function() { return /* binding */ HorizontalRule; },\n/* harmony export */   \"default\": function() { return /* binding */ HorizontalRule; }\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/core */ \"(app-pages-browser)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/pm/state */ \"(app-pages-browser)/./node_modules/@tiptap/pm/state/dist/index.js\");\n\n\n\n/**\n * This extension allows you to insert horizontal rules.\n * @see https://www.tiptap.dev/api/nodes/horizontal-rule\n */\nconst HorizontalRule = _tiptap_core__WEBPACK_IMPORTED_MODULE_1__.Node.create({\n    name: 'horizontalRule',\n    addOptions() {\n        return {\n            HTMLAttributes: {},\n        };\n    },\n    group: 'block',\n    parseHTML() {\n        return [{ tag: 'hr' }];\n    },\n    renderHTML({ HTMLAttributes }) {\n        return ['hr', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes)];\n    },\n    addCommands() {\n        return {\n            setHorizontalRule: () => ({ chain, state }) => {\n                // Check if we can insert the node at the current selection\n                if (!(0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.canInsertNode)(state, state.schema.nodes[this.name])) {\n                    return false;\n                }\n                const { selection } = state;\n                const { $from: $originFrom, $to: $originTo } = selection;\n                const currentChain = chain();\n                if ($originFrom.parentOffset === 0) {\n                    currentChain.insertContentAt({\n                        from: Math.max($originFrom.pos - 1, 0),\n                        to: $originTo.pos,\n                    }, {\n                        type: this.name,\n                    });\n                }\n                else if ((0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.isNodeSelection)(selection)) {\n                    currentChain.insertContentAt($originTo.pos, {\n                        type: this.name,\n                    });\n                }\n                else {\n                    currentChain.insertContent({ type: this.name });\n                }\n                return (currentChain\n                    // set cursor after horizontal rule\n                    .command(({ tr, dispatch }) => {\n                    var _a;\n                    if (dispatch) {\n                        const { $to } = tr.selection;\n                        const posAfter = $to.end();\n                        if ($to.nodeAfter) {\n                            if ($to.nodeAfter.isTextblock) {\n                                tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(tr.doc, $to.pos + 1));\n                            }\n                            else if ($to.nodeAfter.isBlock) {\n                                tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.create(tr.doc, $to.pos));\n                            }\n                            else {\n                                tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(tr.doc, $to.pos));\n                            }\n                        }\n                        else {\n                            // add node after horizontal rule if it’s the end of the document\n                            const node = (_a = $to.parent.type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.create();\n                            if (node) {\n                                tr.insert(posAfter, node);\n                                tr.setSelection(_tiptap_pm_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.create(tr.doc, posAfter + 1));\n                            }\n                        }\n                        tr.scrollIntoView();\n                    }\n                    return true;\n                })\n                    .run());\n            },\n        };\n    },\n    addInputRules() {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_1__.nodeInputRule)({\n                find: /^(?:---|—-|___\\s|\\*\\*\\*\\s)$/,\n                type: this.type,\n            }),\n        ];\n    },\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1ob3Jpem9udGFsLXJ1bGUvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQW9HO0FBQ3BDOztBQUVoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw4Q0FBSTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGtCQUFrQixXQUFXO0FBQzdCLEtBQUs7QUFDTCxpQkFBaUIsZ0JBQWdCO0FBQ2pDLHNCQUFzQiw2REFBZTtBQUNyQyxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdDQUF3QyxjQUFjO0FBQ3REO0FBQ0EscUJBQXFCLDJEQUFhO0FBQ2xDO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQyx3QkFBd0IscUNBQXFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSx5QkFBeUIsNkRBQWU7QUFDeEM7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsaURBQWlELGlCQUFpQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsY0FBYztBQUM5QztBQUNBO0FBQ0EsZ0NBQWdDLE1BQU07QUFDdEM7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELDJEQUFhO0FBQzdEO0FBQ0E7QUFDQSxnREFBZ0QsMkRBQWE7QUFDN0Q7QUFDQTtBQUNBLGdEQUFnRCwyREFBYTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCwyREFBYTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZLDJEQUFhO0FBQ3pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFb0Q7QUFDckQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWhvcml6b250YWwtcnVsZS9kaXN0L2luZGV4LmpzP2FkYTUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTm9kZSwgbWVyZ2VBdHRyaWJ1dGVzLCBjYW5JbnNlcnROb2RlLCBpc05vZGVTZWxlY3Rpb24sIG5vZGVJbnB1dFJ1bGUgfSBmcm9tICdAdGlwdGFwL2NvcmUnO1xuaW1wb3J0IHsgVGV4dFNlbGVjdGlvbiwgTm9kZVNlbGVjdGlvbiB9IGZyb20gJ0B0aXB0YXAvcG0vc3RhdGUnO1xuXG4vKipcbiAqIFRoaXMgZXh0ZW5zaW9uIGFsbG93cyB5b3UgdG8gaW5zZXJ0IGhvcml6b250YWwgcnVsZXMuXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnRpcHRhcC5kZXYvYXBpL25vZGVzL2hvcml6b250YWwtcnVsZVxuICovXG5jb25zdCBIb3Jpem9udGFsUnVsZSA9IE5vZGUuY3JlYXRlKHtcbiAgICBuYW1lOiAnaG9yaXpvbnRhbFJ1bGUnLFxuICAgIGFkZE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBncm91cDogJ2Jsb2NrJyxcbiAgICBwYXJzZUhUTUwoKSB7XG4gICAgICAgIHJldHVybiBbeyB0YWc6ICdocicgfV07XG4gICAgfSxcbiAgICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgICAgICByZXR1cm4gWydocicsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKV07XG4gICAgfSxcbiAgICBhZGRDb21tYW5kcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNldEhvcml6b250YWxSdWxlOiAoKSA9PiAoeyBjaGFpbiwgc3RhdGUgfSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlIGNhbiBpbnNlcnQgdGhlIG5vZGUgYXQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgaWYgKCFjYW5JbnNlcnROb2RlKHN0YXRlLCBzdGF0ZS5zY2hlbWEubm9kZXNbdGhpcy5uYW1lXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IHNlbGVjdGlvbiB9ID0gc3RhdGU7XG4gICAgICAgICAgICAgICAgY29uc3QgeyAkZnJvbTogJG9yaWdpbkZyb20sICR0bzogJG9yaWdpblRvIH0gPSBzZWxlY3Rpb247XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudENoYWluID0gY2hhaW4oKTtcbiAgICAgICAgICAgICAgICBpZiAoJG9yaWdpbkZyb20ucGFyZW50T2Zmc2V0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRDaGFpbi5pbnNlcnRDb250ZW50QXQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZnJvbTogTWF0aC5tYXgoJG9yaWdpbkZyb20ucG9zIC0gMSwgMCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0bzogJG9yaWdpblRvLnBvcyxcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNOb2RlU2VsZWN0aW9uKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudENoYWluLmluc2VydENvbnRlbnRBdCgkb3JpZ2luVG8ucG9zLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudENoYWluLmluc2VydENvbnRlbnQoeyB0eXBlOiB0aGlzLm5hbWUgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAoY3VycmVudENoYWluXG4gICAgICAgICAgICAgICAgICAgIC8vIHNldCBjdXJzb3IgYWZ0ZXIgaG9yaXpvbnRhbCBydWxlXG4gICAgICAgICAgICAgICAgICAgIC5jb21tYW5kKCh7IHRyLCBkaXNwYXRjaCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7ICR0byB9ID0gdHIuc2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zQWZ0ZXIgPSAkdG8uZW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoJHRvLm5vZGVBZnRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgkdG8ubm9kZUFmdGVyLmlzVGV4dGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbihUZXh0U2VsZWN0aW9uLmNyZWF0ZSh0ci5kb2MsICR0by5wb3MgKyAxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKCR0by5ub2RlQWZ0ZXIuaXNCbG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oTm9kZVNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCAkdG8ucG9zKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5jcmVhdGUodHIuZG9jLCAkdG8ucG9zKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIG5vZGUgYWZ0ZXIgaG9yaXpvbnRhbCBydWxlIGlmIGl04oCZcyB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSAoX2EgPSAkdG8ucGFyZW50LnR5cGUuY29udGVudE1hdGNoLmRlZmF1bHRUeXBlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY3JlYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHIuaW5zZXJ0KHBvc0FmdGVyLCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgcG9zQWZ0ZXIgKyAxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdHIuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAucnVuKCkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFkZElucHV0UnVsZXMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBub2RlSW5wdXRSdWxlKHtcbiAgICAgICAgICAgICAgICBmaW5kOiAvXig/Oi0tLXzigJQtfF9fX1xcc3xcXCpcXCpcXCpcXHMpJC8sXG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIF07XG4gICAgfSxcbn0pO1xuXG5leHBvcnQgeyBIb3Jpem9udGFsUnVsZSwgSG9yaXpvbnRhbFJ1bGUgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/extension-horizontal-rule/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/extension-italic/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@tiptap/extension-italic/dist/index.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Italic: function() { return /* binding */ Italic; },\n/* harmony export */   \"default\": function() { return /* binding */ Italic; },\n/* harmony export */   starInputRegex: function() { return /* binding */ starInputRegex; },\n/* harmony export */   starPasteRegex: function() { return /* binding */ starPasteRegex; },\n/* harmony export */   underscoreInputRegex: function() { return /* binding */ underscoreInputRegex; },\n/* harmony export */   underscorePasteRegex: function() { return /* binding */ underscorePasteRegex; }\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(app-pages-browser)/./node_modules/@tiptap/core/dist/index.js\");\n\n\n/**\n * Matches an italic to a *italic* on input.\n */\nconst starInputRegex = /(?:^|\\s)(\\*(?!\\s+\\*)((?:[^*]+))\\*(?!\\s+\\*))$/;\n/**\n * Matches an italic to a *italic* on paste.\n */\nconst starPasteRegex = /(?:^|\\s)(\\*(?!\\s+\\*)((?:[^*]+))\\*(?!\\s+\\*))/g;\n/**\n * Matches an italic to a _italic_ on input.\n */\nconst underscoreInputRegex = /(?:^|\\s)(_(?!\\s+_)((?:[^_]+))_(?!\\s+_))$/;\n/**\n * Matches an italic to a _italic_ on paste.\n */\nconst underscorePasteRegex = /(?:^|\\s)(_(?!\\s+_)((?:[^_]+))_(?!\\s+_))/g;\n/**\n * This extension allows you to create italic text.\n * @see https://www.tiptap.dev/api/marks/italic\n */\nconst Italic = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\n    name: 'italic',\n    addOptions() {\n        return {\n            HTMLAttributes: {},\n        };\n    },\n    parseHTML() {\n        return [\n            {\n                tag: 'em',\n            },\n            {\n                tag: 'i',\n                getAttrs: node => node.style.fontStyle !== 'normal' && null,\n            },\n            {\n                style: 'font-style=normal',\n                clearMark: mark => mark.type.name === this.name,\n            },\n            {\n                style: 'font-style=italic',\n            },\n        ];\n    },\n    renderHTML({ HTMLAttributes }) {\n        return ['em', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n    },\n    addCommands() {\n        return {\n            setItalic: () => ({ commands }) => {\n                return commands.setMark(this.name);\n            },\n            toggleItalic: () => ({ commands }) => {\n                return commands.toggleMark(this.name);\n            },\n            unsetItalic: () => ({ commands }) => {\n                return commands.unsetMark(this.name);\n            },\n        };\n    },\n    addKeyboardShortcuts() {\n        return {\n            'Mod-i': () => this.editor.commands.toggleItalic(),\n            'Mod-I': () => this.editor.commands.toggleItalic(),\n        };\n    },\n    addInputRules() {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n                find: starInputRegex,\n                type: this.type,\n            }),\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n                find: underscoreInputRegex,\n                type: this.type,\n            }),\n        ];\n    },\n    addPasteRules() {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n                find: starPasteRegex,\n                type: this.type,\n            }),\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n                find: underscorePasteRegex,\n                type: this.type,\n            }),\n        ];\n    },\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1pdGFsaWMvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQW1GOztBQUVuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4Q0FBSTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMLGlCQUFpQixnQkFBZ0I7QUFDakMsc0JBQXNCLDZEQUFlO0FBQ3JDLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVU7QUFDMUM7QUFDQSxhQUFhO0FBQ2IsbUNBQW1DLFVBQVU7QUFDN0M7QUFDQSxhQUFhO0FBQ2Isa0NBQWtDLFVBQVU7QUFDNUM7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWSwyREFBYTtBQUN6QjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVksMkRBQWE7QUFDekI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWSwyREFBYTtBQUN6QjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVksMkRBQWE7QUFDekI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUVnSDtBQUNqSCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24taXRhbGljL2Rpc3QvaW5kZXguanM/ZjUxNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBNYXJrLCBtZXJnZUF0dHJpYnV0ZXMsIG1hcmtJbnB1dFJ1bGUsIG1hcmtQYXN0ZVJ1bGUgfSBmcm9tICdAdGlwdGFwL2NvcmUnO1xuXG4vKipcbiAqIE1hdGNoZXMgYW4gaXRhbGljIHRvIGEgKml0YWxpYyogb24gaW5wdXQuXG4gKi9cbmNvbnN0IHN0YXJJbnB1dFJlZ2V4ID0gLyg/Ol58XFxzKShcXCooPyFcXHMrXFwqKSgoPzpbXipdKykpXFwqKD8hXFxzK1xcKikpJC87XG4vKipcbiAqIE1hdGNoZXMgYW4gaXRhbGljIHRvIGEgKml0YWxpYyogb24gcGFzdGUuXG4gKi9cbmNvbnN0IHN0YXJQYXN0ZVJlZ2V4ID0gLyg/Ol58XFxzKShcXCooPyFcXHMrXFwqKSgoPzpbXipdKykpXFwqKD8hXFxzK1xcKikpL2c7XG4vKipcbiAqIE1hdGNoZXMgYW4gaXRhbGljIHRvIGEgX2l0YWxpY18gb24gaW5wdXQuXG4gKi9cbmNvbnN0IHVuZGVyc2NvcmVJbnB1dFJlZ2V4ID0gLyg/Ol58XFxzKShfKD8hXFxzK18pKCg/OlteX10rKSlfKD8hXFxzK18pKSQvO1xuLyoqXG4gKiBNYXRjaGVzIGFuIGl0YWxpYyB0byBhIF9pdGFsaWNfIG9uIHBhc3RlLlxuICovXG5jb25zdCB1bmRlcnNjb3JlUGFzdGVSZWdleCA9IC8oPzpefFxccykoXyg/IVxccytfKSgoPzpbXl9dKykpXyg/IVxccytfKSkvZztcbi8qKlxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBjcmVhdGUgaXRhbGljIHRleHQuXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnRpcHRhcC5kZXYvYXBpL21hcmtzL2l0YWxpY1xuICovXG5jb25zdCBJdGFsaWMgPSBNYXJrLmNyZWF0ZSh7XG4gICAgbmFtZTogJ2l0YWxpYycsXG4gICAgYWRkT3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHBhcnNlSFRNTCgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0YWc6ICdlbScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRhZzogJ2knLFxuICAgICAgICAgICAgICAgIGdldEF0dHJzOiBub2RlID0+IG5vZGUuc3R5bGUuZm9udFN0eWxlICE9PSAnbm9ybWFsJyAmJiBudWxsLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdHlsZTogJ2ZvbnQtc3R5bGU9bm9ybWFsJyxcbiAgICAgICAgICAgICAgICBjbGVhck1hcms6IG1hcmsgPT4gbWFyay50eXBlLm5hbWUgPT09IHRoaXMubmFtZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3R5bGU6ICdmb250LXN0eWxlPWl0YWxpYycsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgIH0sXG4gICAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICAgICAgcmV0dXJuIFsnZW0nLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdO1xuICAgIH0sXG4gICAgYWRkQ29tbWFuZHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZXRJdGFsaWM6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZHMuc2V0TWFyayh0aGlzLm5hbWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvZ2dsZUl0YWxpYzogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy50b2dnbGVNYXJrKHRoaXMubmFtZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdW5zZXRJdGFsaWM6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZHMudW5zZXRNYXJrKHRoaXMubmFtZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnTW9kLWknOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy50b2dnbGVJdGFsaWMoKSxcbiAgICAgICAgICAgICdNb2QtSSc6ICgpID0+IHRoaXMuZWRpdG9yLmNvbW1hbmRzLnRvZ2dsZUl0YWxpYygpLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYWRkSW5wdXRSdWxlcygpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIG1hcmtJbnB1dFJ1bGUoe1xuICAgICAgICAgICAgICAgIGZpbmQ6IHN0YXJJbnB1dFJlZ2V4LFxuICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgbWFya0lucHV0UnVsZSh7XG4gICAgICAgICAgICAgICAgZmluZDogdW5kZXJzY29yZUlucHV0UmVnZXgsXG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIF07XG4gICAgfSxcbiAgICBhZGRQYXN0ZVJ1bGVzKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbWFya1Bhc3RlUnVsZSh7XG4gICAgICAgICAgICAgICAgZmluZDogc3RhclBhc3RlUmVnZXgsXG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBtYXJrUGFzdGVSdWxlKHtcbiAgICAgICAgICAgICAgICBmaW5kOiB1bmRlcnNjb3JlUGFzdGVSZWdleCxcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgXTtcbiAgICB9LFxufSk7XG5cbmV4cG9ydCB7IEl0YWxpYywgSXRhbGljIGFzIGRlZmF1bHQsIHN0YXJJbnB1dFJlZ2V4LCBzdGFyUGFzdGVSZWdleCwgdW5kZXJzY29yZUlucHV0UmVnZXgsIHVuZGVyc2NvcmVQYXN0ZVJlZ2V4IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/extension-italic/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/extension-list-item/dist/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-list-item/dist/index.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ListItem: function() { return /* binding */ ListItem; },\n/* harmony export */   \"default\": function() { return /* binding */ ListItem; }\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(app-pages-browser)/./node_modules/@tiptap/core/dist/index.js\");\n\n\n/**\n * This extension allows you to create list items.\n * @see https://www.tiptap.dev/api/nodes/list-item\n */\nconst ListItem = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: 'listItem',\n    addOptions() {\n        return {\n            HTMLAttributes: {},\n            bulletListTypeName: 'bulletList',\n            orderedListTypeName: 'orderedList',\n        };\n    },\n    content: 'paragraph block*',\n    defining: true,\n    parseHTML() {\n        return [\n            {\n                tag: 'li',\n            },\n        ];\n    },\n    renderHTML({ HTMLAttributes }) {\n        return ['li', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n    },\n    addKeyboardShortcuts() {\n        return {\n            Enter: () => this.editor.commands.splitListItem(this.name),\n            Tab: () => this.editor.commands.sinkListItem(this.name),\n            'Shift-Tab': () => this.editor.commands.liftListItem(this.name),\n        };\n    },\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1saXN0LWl0ZW0vZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBcUQ7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDhDQUFJO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMLGlCQUFpQixnQkFBZ0I7QUFDakMsc0JBQXNCLDZEQUFlO0FBQ3JDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFd0M7QUFDekMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLWxpc3QtaXRlbS9kaXN0L2luZGV4LmpzPzgzZjYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTm9kZSwgbWVyZ2VBdHRyaWJ1dGVzIH0gZnJvbSAnQHRpcHRhcC9jb3JlJztcblxuLyoqXG4gKiBUaGlzIGV4dGVuc2lvbiBhbGxvd3MgeW91IHRvIGNyZWF0ZSBsaXN0IGl0ZW1zLlxuICogQHNlZSBodHRwczovL3d3dy50aXB0YXAuZGV2L2FwaS9ub2Rlcy9saXN0LWl0ZW1cbiAqL1xuY29uc3QgTGlzdEl0ZW0gPSBOb2RlLmNyZWF0ZSh7XG4gICAgbmFtZTogJ2xpc3RJdGVtJyxcbiAgICBhZGRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgICAgICAgICAgYnVsbGV0TGlzdFR5cGVOYW1lOiAnYnVsbGV0TGlzdCcsXG4gICAgICAgICAgICBvcmRlcmVkTGlzdFR5cGVOYW1lOiAnb3JkZXJlZExpc3QnLFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgY29udGVudDogJ3BhcmFncmFwaCBibG9jayonLFxuICAgIGRlZmluaW5nOiB0cnVlLFxuICAgIHBhcnNlSFRNTCgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0YWc6ICdsaScsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdO1xuICAgIH0sXG4gICAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICAgICAgcmV0dXJuIFsnbGknLCBtZXJnZUF0dHJpYnV0ZXModGhpcy5vcHRpb25zLkhUTUxBdHRyaWJ1dGVzLCBIVE1MQXR0cmlidXRlcyksIDBdO1xuICAgIH0sXG4gICAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBFbnRlcjogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc3BsaXRMaXN0SXRlbSh0aGlzLm5hbWUpLFxuICAgICAgICAgICAgVGFiOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5zaW5rTGlzdEl0ZW0odGhpcy5uYW1lKSxcbiAgICAgICAgICAgICdTaGlmdC1UYWInOiAoKSA9PiB0aGlzLmVkaXRvci5jb21tYW5kcy5saWZ0TGlzdEl0ZW0odGhpcy5uYW1lKSxcbiAgICAgICAgfTtcbiAgICB9LFxufSk7XG5cbmV4cG9ydCB7IExpc3RJdGVtLCBMaXN0SXRlbSBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/extension-list-item/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/extension-ordered-list/dist/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@tiptap/extension-ordered-list/dist/index.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OrderedList: function() { return /* binding */ OrderedList; },\n/* harmony export */   \"default\": function() { return /* binding */ OrderedList; },\n/* harmony export */   inputRegex: function() { return /* binding */ inputRegex; }\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(app-pages-browser)/./node_modules/@tiptap/core/dist/index.js\");\n\n\nconst ListItemName = 'listItem';\nconst TextStyleName = 'textStyle';\n/**\n * Matches an ordered list to a 1. on input (or any number followed by a dot).\n */\nconst inputRegex = /^(\\d+)\\.\\s$/;\n/**\n * This extension allows you to create ordered lists.\n * This requires the ListItem extension\n * @see https://www.tiptap.dev/api/nodes/ordered-list\n * @see https://www.tiptap.dev/api/nodes/list-item\n */\nconst OrderedList = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: 'orderedList',\n    addOptions() {\n        return {\n            itemTypeName: 'listItem',\n            HTMLAttributes: {},\n            keepMarks: false,\n            keepAttributes: false,\n        };\n    },\n    group: 'block list',\n    content() {\n        return `${this.options.itemTypeName}+`;\n    },\n    addAttributes() {\n        return {\n            start: {\n                default: 1,\n                parseHTML: element => {\n                    return element.hasAttribute('start')\n                        ? parseInt(element.getAttribute('start') || '', 10)\n                        : 1;\n                },\n            },\n            type: {\n                default: null,\n                parseHTML: element => element.getAttribute('type'),\n            },\n        };\n    },\n    parseHTML() {\n        return [\n            {\n                tag: 'ol',\n            },\n        ];\n    },\n    renderHTML({ HTMLAttributes }) {\n        const { start, ...attributesWithoutStart } = HTMLAttributes;\n        return start === 1\n            ? ['ol', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, attributesWithoutStart), 0]\n            : ['ol', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n    },\n    addCommands() {\n        return {\n            toggleOrderedList: () => ({ commands, chain }) => {\n                if (this.options.keepAttributes) {\n                    return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItemName, this.editor.getAttributes(TextStyleName)).run();\n                }\n                return commands.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);\n            },\n        };\n    },\n    addKeyboardShortcuts() {\n        return {\n            'Mod-Shift-7': () => this.editor.commands.toggleOrderedList(),\n        };\n    },\n    addInputRules() {\n        let inputRule = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\n            find: inputRegex,\n            type: this.type,\n            getAttributes: match => ({ start: +match[1] }),\n            joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1],\n        });\n        if (this.options.keepMarks || this.options.keepAttributes) {\n            inputRule = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.wrappingInputRule)({\n                find: inputRegex,\n                type: this.type,\n                keepMarks: this.options.keepMarks,\n                keepAttributes: this.options.keepAttributes,\n                getAttributes: match => ({ start: +match[1], ...this.editor.getAttributes(TextStyleName) }),\n                joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1],\n                editor: this.editor,\n            });\n        }\n        return [\n            inputRule,\n        ];\n    },\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1vcmRlcmVkLWxpc3QvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXdFOztBQUV4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsOENBQUk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxrQkFBa0IsMEJBQTBCO0FBQzVDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0wsaUJBQWlCLGdCQUFnQjtBQUNqQyxnQkFBZ0IsbUNBQW1DO0FBQ25EO0FBQ0EscUJBQXFCLDZEQUFlO0FBQ3BDLHFCQUFxQiw2REFBZTtBQUNwQyxLQUFLO0FBQ0w7QUFDQTtBQUNBLHdDQUF3QyxpQkFBaUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3QkFBd0IsK0RBQWlCO0FBQ3pDO0FBQ0E7QUFDQSx1Q0FBdUMsa0JBQWtCO0FBQ3pEO0FBQ0EsU0FBUztBQUNUO0FBQ0Esd0JBQXdCLCtEQUFpQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQywrREFBK0Q7QUFDMUc7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDOztBQUUwRDtBQUMzRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9leHRlbnNpb24tb3JkZXJlZC1saXN0L2Rpc3QvaW5kZXguanM/NmQxYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOb2RlLCBtZXJnZUF0dHJpYnV0ZXMsIHdyYXBwaW5nSW5wdXRSdWxlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJztcblxuY29uc3QgTGlzdEl0ZW1OYW1lID0gJ2xpc3RJdGVtJztcbmNvbnN0IFRleHRTdHlsZU5hbWUgPSAndGV4dFN0eWxlJztcbi8qKlxuICogTWF0Y2hlcyBhbiBvcmRlcmVkIGxpc3QgdG8gYSAxLiBvbiBpbnB1dCAob3IgYW55IG51bWJlciBmb2xsb3dlZCBieSBhIGRvdCkuXG4gKi9cbmNvbnN0IGlucHV0UmVnZXggPSAvXihcXGQrKVxcLlxccyQvO1xuLyoqXG4gKiBUaGlzIGV4dGVuc2lvbiBhbGxvd3MgeW91IHRvIGNyZWF0ZSBvcmRlcmVkIGxpc3RzLlxuICogVGhpcyByZXF1aXJlcyB0aGUgTGlzdEl0ZW0gZXh0ZW5zaW9uXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnRpcHRhcC5kZXYvYXBpL25vZGVzL29yZGVyZWQtbGlzdFxuICogQHNlZSBodHRwczovL3d3dy50aXB0YXAuZGV2L2FwaS9ub2Rlcy9saXN0LWl0ZW1cbiAqL1xuY29uc3QgT3JkZXJlZExpc3QgPSBOb2RlLmNyZWF0ZSh7XG4gICAgbmFtZTogJ29yZGVyZWRMaXN0JyxcbiAgICBhZGRPcHRpb25zKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXRlbVR5cGVOYW1lOiAnbGlzdEl0ZW0nLFxuICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IHt9LFxuICAgICAgICAgICAga2VlcE1hcmtzOiBmYWxzZSxcbiAgICAgICAgICAgIGtlZXBBdHRyaWJ1dGVzOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGdyb3VwOiAnYmxvY2sgbGlzdCcsXG4gICAgY29udGVudCgpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMub3B0aW9ucy5pdGVtVHlwZU5hbWV9K2A7XG4gICAgfSxcbiAgICBhZGRBdHRyaWJ1dGVzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiAxLFxuICAgICAgICAgICAgICAgIHBhcnNlSFRNTDogZWxlbWVudCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnc3RhcnQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBwYXJzZUludChlbGVtZW50LmdldEF0dHJpYnV0ZSgnc3RhcnQnKSB8fCAnJywgMTApXG4gICAgICAgICAgICAgICAgICAgICAgICA6IDE7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgICAgICAgICAgICBwYXJzZUhUTUw6IGVsZW1lbnQgPT4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBwYXJzZUhUTUwoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGFnOiAnb2wnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXTtcbiAgICB9LFxuICAgIHJlbmRlckhUTUwoeyBIVE1MQXR0cmlidXRlcyB9KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhcnQsIC4uLmF0dHJpYnV0ZXNXaXRob3V0U3RhcnQgfSA9IEhUTUxBdHRyaWJ1dGVzO1xuICAgICAgICByZXR1cm4gc3RhcnQgPT09IDFcbiAgICAgICAgICAgID8gWydvbCcsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIGF0dHJpYnV0ZXNXaXRob3V0U3RhcnQpLCAwXVxuICAgICAgICAgICAgOiBbJ29sJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXTtcbiAgICB9LFxuICAgIGFkZENvbW1hbmRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9nZ2xlT3JkZXJlZExpc3Q6ICgpID0+ICh7IGNvbW1hbmRzLCBjaGFpbiB9KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5rZWVwQXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hhaW4oKS50b2dnbGVMaXN0KHRoaXMubmFtZSwgdGhpcy5vcHRpb25zLml0ZW1UeXBlTmFtZSwgdGhpcy5vcHRpb25zLmtlZXBNYXJrcykudXBkYXRlQXR0cmlidXRlcyhMaXN0SXRlbU5hbWUsIHRoaXMuZWRpdG9yLmdldEF0dHJpYnV0ZXMoVGV4dFN0eWxlTmFtZSkpLnJ1bigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlTGlzdCh0aGlzLm5hbWUsIHRoaXMub3B0aW9ucy5pdGVtVHlwZU5hbWUsIHRoaXMub3B0aW9ucy5rZWVwTWFya3MpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ01vZC1TaGlmdC03JzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlT3JkZXJlZExpc3QoKSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFkZElucHV0UnVsZXMoKSB7XG4gICAgICAgIGxldCBpbnB1dFJ1bGUgPSB3cmFwcGluZ0lucHV0UnVsZSh7XG4gICAgICAgICAgICBmaW5kOiBpbnB1dFJlZ2V4LFxuICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgZ2V0QXR0cmlidXRlczogbWF0Y2ggPT4gKHsgc3RhcnQ6ICttYXRjaFsxXSB9KSxcbiAgICAgICAgICAgIGpvaW5QcmVkaWNhdGU6IChtYXRjaCwgbm9kZSkgPT4gbm9kZS5jaGlsZENvdW50ICsgbm9kZS5hdHRycy5zdGFydCA9PT0gK21hdGNoWzFdLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5rZWVwTWFya3MgfHwgdGhpcy5vcHRpb25zLmtlZXBBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBpbnB1dFJ1bGUgPSB3cmFwcGluZ0lucHV0UnVsZSh7XG4gICAgICAgICAgICAgICAgZmluZDogaW5wdXRSZWdleCxcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICAgICAga2VlcE1hcmtzOiB0aGlzLm9wdGlvbnMua2VlcE1hcmtzLFxuICAgICAgICAgICAgICAgIGtlZXBBdHRyaWJ1dGVzOiB0aGlzLm9wdGlvbnMua2VlcEF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgZ2V0QXR0cmlidXRlczogbWF0Y2ggPT4gKHsgc3RhcnQ6ICttYXRjaFsxXSwgLi4udGhpcy5lZGl0b3IuZ2V0QXR0cmlidXRlcyhUZXh0U3R5bGVOYW1lKSB9KSxcbiAgICAgICAgICAgICAgICBqb2luUHJlZGljYXRlOiAobWF0Y2gsIG5vZGUpID0+IG5vZGUuY2hpbGRDb3VudCArIG5vZGUuYXR0cnMuc3RhcnQgPT09ICttYXRjaFsxXSxcbiAgICAgICAgICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGlucHV0UnVsZSxcbiAgICAgICAgXTtcbiAgICB9LFxufSk7XG5cbmV4cG9ydCB7IE9yZGVyZWRMaXN0LCBPcmRlcmVkTGlzdCBhcyBkZWZhdWx0LCBpbnB1dFJlZ2V4IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/extension-ordered-list/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/extension-paragraph/dist/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@tiptap/extension-paragraph/dist/index.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Paragraph: function() { return /* binding */ Paragraph; },\n/* harmony export */   \"default\": function() { return /* binding */ Paragraph; }\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(app-pages-browser)/./node_modules/@tiptap/core/dist/index.js\");\n\n\n/**\n * This extension allows you to create paragraphs.\n * @see https://www.tiptap.dev/api/nodes/paragraph\n */\nconst Paragraph = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: 'paragraph',\n    priority: 1000,\n    addOptions() {\n        return {\n            HTMLAttributes: {},\n        };\n    },\n    group: 'block',\n    content: 'inline*',\n    parseHTML() {\n        return [\n            { tag: 'p' },\n        ];\n    },\n    renderHTML({ HTMLAttributes }) {\n        return ['p', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n    },\n    addCommands() {\n        return {\n            setParagraph: () => ({ commands }) => {\n                return commands.setNode(this.name);\n            },\n        };\n    },\n    addKeyboardShortcuts() {\n        return {\n            'Mod-Alt-0': () => this.editor.commands.setParagraph(),\n        };\n    },\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1wYXJhZ3JhcGgvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBcUQ7O0FBRXJEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDhDQUFJO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCO0FBQ0EsS0FBSztBQUNMLGlCQUFpQixnQkFBZ0I7QUFDakMscUJBQXFCLDZEQUFlO0FBQ3BDLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbUNBQW1DLFVBQVU7QUFDN0M7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFMEM7QUFDM0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLXBhcmFncmFwaC9kaXN0L2luZGV4LmpzP2ExYTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTm9kZSwgbWVyZ2VBdHRyaWJ1dGVzIH0gZnJvbSAnQHRpcHRhcC9jb3JlJztcblxuLyoqXG4gKiBUaGlzIGV4dGVuc2lvbiBhbGxvd3MgeW91IHRvIGNyZWF0ZSBwYXJhZ3JhcGhzLlxuICogQHNlZSBodHRwczovL3d3dy50aXB0YXAuZGV2L2FwaS9ub2Rlcy9wYXJhZ3JhcGhcbiAqL1xuY29uc3QgUGFyYWdyYXBoID0gTm9kZS5jcmVhdGUoe1xuICAgIG5hbWU6ICdwYXJhZ3JhcGgnLFxuICAgIHByaW9yaXR5OiAxMDAwLFxuICAgIGFkZE9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBIVE1MQXR0cmlidXRlczoge30sXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBncm91cDogJ2Jsb2NrJyxcbiAgICBjb250ZW50OiAnaW5saW5lKicsXG4gICAgcGFyc2VIVE1MKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgeyB0YWc6ICdwJyB9LFxuICAgICAgICBdO1xuICAgIH0sXG4gICAgcmVuZGVySFRNTCh7IEhUTUxBdHRyaWJ1dGVzIH0pIHtcbiAgICAgICAgcmV0dXJuIFsncCcsIG1lcmdlQXR0cmlidXRlcyh0aGlzLm9wdGlvbnMuSFRNTEF0dHJpYnV0ZXMsIEhUTUxBdHRyaWJ1dGVzKSwgMF07XG4gICAgfSxcbiAgICBhZGRDb21tYW5kcygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNldFBhcmFncmFwaDogKCkgPT4gKHsgY29tbWFuZHMgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kcy5zZXROb2RlKHRoaXMubmFtZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgYWRkS2V5Ym9hcmRTaG9ydGN1dHMoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAnTW9kLUFsdC0wJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMuc2V0UGFyYWdyYXBoKCksXG4gICAgICAgIH07XG4gICAgfSxcbn0pO1xuXG5leHBvcnQgeyBQYXJhZ3JhcGgsIFBhcmFncmFwaCBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/extension-paragraph/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/extension-strike/dist/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@tiptap/extension-strike/dist/index.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Strike: function() { return /* binding */ Strike; },\n/* harmony export */   \"default\": function() { return /* binding */ Strike; },\n/* harmony export */   inputRegex: function() { return /* binding */ inputRegex; },\n/* harmony export */   pasteRegex: function() { return /* binding */ pasteRegex; }\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(app-pages-browser)/./node_modules/@tiptap/core/dist/index.js\");\n\n\n/**\n * Matches a strike to a ~~strike~~ on input.\n */\nconst inputRegex = /(?:^|\\s)(~~(?!\\s+~~)((?:[^~]+))~~(?!\\s+~~))$/;\n/**\n * Matches a strike to a ~~strike~~ on paste.\n */\nconst pasteRegex = /(?:^|\\s)(~~(?!\\s+~~)((?:[^~]+))~~(?!\\s+~~))/g;\n/**\n * This extension allows you to create strike text.\n * @see https://www.tiptap.dev/api/marks/strike\n */\nconst Strike = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Mark.create({\n    name: 'strike',\n    addOptions() {\n        return {\n            HTMLAttributes: {},\n        };\n    },\n    parseHTML() {\n        return [\n            {\n                tag: 's',\n            },\n            {\n                tag: 'del',\n            },\n            {\n                tag: 'strike',\n            },\n            {\n                style: 'text-decoration',\n                consuming: false,\n                getAttrs: style => (style.includes('line-through') ? {} : false),\n            },\n        ];\n    },\n    renderHTML({ HTMLAttributes }) {\n        return ['s', (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.mergeAttributes)(this.options.HTMLAttributes, HTMLAttributes), 0];\n    },\n    addCommands() {\n        return {\n            setStrike: () => ({ commands }) => {\n                return commands.setMark(this.name);\n            },\n            toggleStrike: () => ({ commands }) => {\n                return commands.toggleMark(this.name);\n            },\n            unsetStrike: () => ({ commands }) => {\n                return commands.unsetMark(this.name);\n            },\n        };\n    },\n    addKeyboardShortcuts() {\n        return {\n            'Mod-Shift-s': () => this.editor.commands.toggleStrike(),\n        };\n    },\n    addInputRules() {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markInputRule)({\n                find: inputRegex,\n                type: this.type,\n            }),\n        ];\n    },\n    addPasteRules() {\n        return [\n            (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_0__.markPasteRule)({\n                find: pasteRegex,\n                type: this.type,\n            }),\n        ];\n    },\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi1zdHJpa2UvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFtRjs7QUFFbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4Q0FBSTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RTtBQUN4RSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0wsaUJBQWlCLGdCQUFnQjtBQUNqQyxxQkFBcUIsNkRBQWU7QUFDcEMsS0FBSztBQUNMO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVTtBQUMxQztBQUNBLGFBQWE7QUFDYixtQ0FBbUMsVUFBVTtBQUM3QztBQUNBLGFBQWE7QUFDYixrQ0FBa0MsVUFBVTtBQUM1QztBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWSwyREFBYTtBQUN6QjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZLDJEQUFhO0FBQ3pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFNEQ7QUFDN0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvZXh0ZW5zaW9uLXN0cmlrZS9kaXN0L2luZGV4LmpzPzViMzgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTWFyaywgbWVyZ2VBdHRyaWJ1dGVzLCBtYXJrSW5wdXRSdWxlLCBtYXJrUGFzdGVSdWxlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJztcblxuLyoqXG4gKiBNYXRjaGVzIGEgc3RyaWtlIHRvIGEgfn5zdHJpa2V+fiBvbiBpbnB1dC5cbiAqL1xuY29uc3QgaW5wdXRSZWdleCA9IC8oPzpefFxccykofn4oPyFcXHMrfn4pKCg/Oltefl0rKSl+fig/IVxccyt+fikpJC87XG4vKipcbiAqIE1hdGNoZXMgYSBzdHJpa2UgdG8gYSB+fnN0cmlrZX5+IG9uIHBhc3RlLlxuICovXG5jb25zdCBwYXN0ZVJlZ2V4ID0gLyg/Ol58XFxzKSh+fig/IVxccyt+fikoKD86W15+XSspKX5+KD8hXFxzK35+KSkvZztcbi8qKlxuICogVGhpcyBleHRlbnNpb24gYWxsb3dzIHlvdSB0byBjcmVhdGUgc3RyaWtlIHRleHQuXG4gKiBAc2VlIGh0dHBzOi8vd3d3LnRpcHRhcC5kZXYvYXBpL21hcmtzL3N0cmlrZVxuICovXG5jb25zdCBTdHJpa2UgPSBNYXJrLmNyZWF0ZSh7XG4gICAgbmFtZTogJ3N0cmlrZScsXG4gICAgYWRkT3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIEhUTUxBdHRyaWJ1dGVzOiB7fSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIHBhcnNlSFRNTCgpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0YWc6ICdzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGFnOiAnZGVsJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdGFnOiAnc3RyaWtlJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3R5bGU6ICd0ZXh0LWRlY29yYXRpb24nLFxuICAgICAgICAgICAgICAgIGNvbnN1bWluZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgZ2V0QXR0cnM6IHN0eWxlID0+IChzdHlsZS5pbmNsdWRlcygnbGluZS10aHJvdWdoJykgPyB7fSA6IGZhbHNlKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF07XG4gICAgfSxcbiAgICByZW5kZXJIVE1MKHsgSFRNTEF0dHJpYnV0ZXMgfSkge1xuICAgICAgICByZXR1cm4gWydzJywgbWVyZ2VBdHRyaWJ1dGVzKHRoaXMub3B0aW9ucy5IVE1MQXR0cmlidXRlcywgSFRNTEF0dHJpYnV0ZXMpLCAwXTtcbiAgICB9LFxuICAgIGFkZENvbW1hbmRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2V0U3RyaWtlOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnNldE1hcmsodGhpcy5uYW1lKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b2dnbGVTdHJpa2U6ICgpID0+ICh7IGNvbW1hbmRzIH0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZHMudG9nZ2xlTWFyayh0aGlzLm5hbWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVuc2V0U3RyaWtlOiAoKSA9PiAoeyBjb21tYW5kcyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnVuc2V0TWFyayh0aGlzLm5hbWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIGFkZEtleWJvYXJkU2hvcnRjdXRzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJ01vZC1TaGlmdC1zJzogKCkgPT4gdGhpcy5lZGl0b3IuY29tbWFuZHMudG9nZ2xlU3RyaWtlKCksXG4gICAgICAgIH07XG4gICAgfSxcbiAgICBhZGRJbnB1dFJ1bGVzKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgbWFya0lucHV0UnVsZSh7XG4gICAgICAgICAgICAgICAgZmluZDogaW5wdXRSZWdleCxcbiAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgXTtcbiAgICB9LFxuICAgIGFkZFBhc3RlUnVsZXMoKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBtYXJrUGFzdGVSdWxlKHtcbiAgICAgICAgICAgICAgICBmaW5kOiBwYXN0ZVJlZ2V4LFxuICAgICAgICAgICAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICBdO1xuICAgIH0sXG59KTtcblxuZXhwb3J0IHsgU3RyaWtlLCBTdHJpa2UgYXMgZGVmYXVsdCwgaW5wdXRSZWdleCwgcGFzdGVSZWdleCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/extension-strike/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/extension-text/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/extension-text/dist/index.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Text: function() { return /* binding */ Text; },\n/* harmony export */   \"default\": function() { return /* binding */ Text; }\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/core */ \"(app-pages-browser)/./node_modules/@tiptap/core/dist/index.js\");\n\n\n/**\n * This extension allows you to create text nodes.\n * @see https://www.tiptap.dev/api/nodes/text\n */\nconst Text = _tiptap_core__WEBPACK_IMPORTED_MODULE_0__.Node.create({\n    name: 'text',\n    group: 'inline',\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi10ZXh0L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQW9DOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsOENBQUk7QUFDakI7QUFDQTtBQUNBLENBQUM7O0FBRWdDO0FBQ2pDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL2V4dGVuc2lvbi10ZXh0L2Rpc3QvaW5kZXguanM/YmQwOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOb2RlIH0gZnJvbSAnQHRpcHRhcC9jb3JlJztcblxuLyoqXG4gKiBUaGlzIGV4dGVuc2lvbiBhbGxvd3MgeW91IHRvIGNyZWF0ZSB0ZXh0IG5vZGVzLlxuICogQHNlZSBodHRwczovL3d3dy50aXB0YXAuZGV2L2FwaS9ub2Rlcy90ZXh0XG4gKi9cbmNvbnN0IFRleHQgPSBOb2RlLmNyZWF0ZSh7XG4gICAgbmFtZTogJ3RleHQnLFxuICAgIGdyb3VwOiAnaW5saW5lJyxcbn0pO1xuXG5leHBvcnQgeyBUZXh0LCBUZXh0IGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/extension-text/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/pm/commands/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@tiptap/pm/commands/dist/index.js ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   autoJoin: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.autoJoin; },\n/* harmony export */   baseKeymap: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.baseKeymap; },\n/* harmony export */   chainCommands: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.chainCommands; },\n/* harmony export */   createParagraphNear: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.createParagraphNear; },\n/* harmony export */   deleteSelection: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.deleteSelection; },\n/* harmony export */   exitCode: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.exitCode; },\n/* harmony export */   joinBackward: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinBackward; },\n/* harmony export */   joinDown: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinDown; },\n/* harmony export */   joinForward: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinForward; },\n/* harmony export */   joinTextblockBackward: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinTextblockBackward; },\n/* harmony export */   joinTextblockForward: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinTextblockForward; },\n/* harmony export */   joinUp: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.joinUp; },\n/* harmony export */   lift: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.lift; },\n/* harmony export */   liftEmptyBlock: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.liftEmptyBlock; },\n/* harmony export */   macBaseKeymap: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.macBaseKeymap; },\n/* harmony export */   newlineInCode: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.newlineInCode; },\n/* harmony export */   pcBaseKeymap: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.pcBaseKeymap; },\n/* harmony export */   selectAll: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectAll; },\n/* harmony export */   selectNodeBackward: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectNodeBackward; },\n/* harmony export */   selectNodeForward: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectNodeForward; },\n/* harmony export */   selectParentNode: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectParentNode; },\n/* harmony export */   selectTextblockEnd: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectTextblockEnd; },\n/* harmony export */   selectTextblockStart: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.selectTextblockStart; },\n/* harmony export */   setBlockType: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.setBlockType; },\n/* harmony export */   splitBlock: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.splitBlock; },\n/* harmony export */   splitBlockAs: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.splitBlockAs; },\n/* harmony export */   splitBlockKeepMarks: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.splitBlockKeepMarks; },\n/* harmony export */   toggleMark: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.toggleMark; },\n/* harmony export */   wrapIn: function() { return /* reexport safe */ prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__.wrapIn; }\n/* harmony export */ });\n/* harmony import */ var prosemirror_commands__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-commands */ \"(app-pages-browser)/./node_modules/prosemirror-commands/dist/index.js\");\n// commands/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3BtL2NvbW1hbmRzL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDcUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvcG0vY29tbWFuZHMvZGlzdC9pbmRleC5qcz80MjA0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIGNvbW1hbmRzL2luZGV4LnRzXG5leHBvcnQgKiBmcm9tIFwicHJvc2VtaXJyb3ItY29tbWFuZHNcIjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/pm/commands/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/pm/dropcursor/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@tiptap/pm/dropcursor/dist/index.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dropCursor: function() { return /* reexport safe */ prosemirror_dropcursor__WEBPACK_IMPORTED_MODULE_0__.dropCursor; }\n/* harmony export */ });\n/* harmony import */ var prosemirror_dropcursor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-dropcursor */ \"(app-pages-browser)/./node_modules/prosemirror-dropcursor/dist/index.js\");\n// dropcursor/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3BtL2Ryb3BjdXJzb3IvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ3VDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3BtL2Ryb3BjdXJzb3IvZGlzdC9pbmRleC5qcz83MDAzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGRyb3BjdXJzb3IvaW5kZXgudHNcbmV4cG9ydCAqIGZyb20gXCJwcm9zZW1pcnJvci1kcm9wY3Vyc29yXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/pm/dropcursor/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/pm/gapcursor/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@tiptap/pm/gapcursor/dist/index.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GapCursor: function() { return /* reexport safe */ prosemirror_gapcursor__WEBPACK_IMPORTED_MODULE_0__.GapCursor; },\n/* harmony export */   gapCursor: function() { return /* reexport safe */ prosemirror_gapcursor__WEBPACK_IMPORTED_MODULE_0__.gapCursor; }\n/* harmony export */ });\n/* harmony import */ var prosemirror_gapcursor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-gapcursor */ \"(app-pages-browser)/./node_modules/prosemirror-gapcursor/dist/index.js\");\n// gapcursor/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3BtL2dhcGN1cnNvci9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ3NDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3BtL2dhcGN1cnNvci9kaXN0L2luZGV4LmpzPzc0MzYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZ2FwY3Vyc29yL2luZGV4LnRzXG5leHBvcnQgKiBmcm9tIFwicHJvc2VtaXJyb3ItZ2FwY3Vyc29yXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/pm/gapcursor/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/pm/history/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@tiptap/pm/history/dist/index.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   closeHistory: function() { return /* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.closeHistory; },\n/* harmony export */   history: function() { return /* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.history; },\n/* harmony export */   redo: function() { return /* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.redo; },\n/* harmony export */   redoDepth: function() { return /* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.redoDepth; },\n/* harmony export */   redoNoScroll: function() { return /* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.redoNoScroll; },\n/* harmony export */   undo: function() { return /* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.undo; },\n/* harmony export */   undoDepth: function() { return /* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.undoDepth; },\n/* harmony export */   undoNoScroll: function() { return /* reexport safe */ prosemirror_history__WEBPACK_IMPORTED_MODULE_0__.undoNoScroll; }\n/* harmony export */ });\n/* harmony import */ var prosemirror_history__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-history */ \"(app-pages-browser)/./node_modules/prosemirror-history/dist/index.js\");\n// history/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3BtL2hpc3RvcnkvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQUNvQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9oaXN0b3J5L2Rpc3QvaW5kZXguanM/MDJmYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBoaXN0b3J5L2luZGV4LnRzXG5leHBvcnQgKiBmcm9tIFwicHJvc2VtaXJyb3ItaGlzdG9yeVwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/pm/history/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/pm/keymap/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@tiptap/pm/keymap/dist/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   keydownHandler: function() { return /* reexport safe */ prosemirror_keymap__WEBPACK_IMPORTED_MODULE_0__.keydownHandler; },\n/* harmony export */   keymap: function() { return /* reexport safe */ prosemirror_keymap__WEBPACK_IMPORTED_MODULE_0__.keymap; }\n/* harmony export */ });\n/* harmony import */ var prosemirror_keymap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-keymap */ \"(app-pages-browser)/./node_modules/prosemirror-keymap/dist/index.js\");\n// keymap/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3BtL2tleW1hcC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ21DIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3BtL2tleW1hcC9kaXN0L2luZGV4LmpzPzNiYWUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8ga2V5bWFwL2luZGV4LnRzXG5leHBvcnQgKiBmcm9tIFwicHJvc2VtaXJyb3Ita2V5bWFwXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/pm/keymap/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/pm/model/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@tiptap/pm/model/dist/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContentMatch: function() { return /* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.ContentMatch; },\n/* harmony export */   DOMParser: function() { return /* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMParser; },\n/* harmony export */   DOMSerializer: function() { return /* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer; },\n/* harmony export */   Fragment: function() { return /* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment; },\n/* harmony export */   Mark: function() { return /* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Mark; },\n/* harmony export */   MarkType: function() { return /* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.MarkType; },\n/* harmony export */   Node: function() { return /* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Node; },\n/* harmony export */   NodeRange: function() { return /* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.NodeRange; },\n/* harmony export */   NodeType: function() { return /* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.NodeType; },\n/* harmony export */   ReplaceError: function() { return /* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.ReplaceError; },\n/* harmony export */   ResolvedPos: function() { return /* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.ResolvedPos; },\n/* harmony export */   Schema: function() { return /* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Schema; },\n/* harmony export */   Slice: function() { return /* reexport safe */ prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice; }\n/* harmony export */ });\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-model */ \"(app-pages-browser)/./node_modules/prosemirror-model/dist/index.js\");\n// model/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3BtL21vZGVsL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNrQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9tb2RlbC9kaXN0L2luZGV4LmpzPzdmMzEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gbW9kZWwvaW5kZXgudHNcbmV4cG9ydCAqIGZyb20gXCJwcm9zZW1pcnJvci1tb2RlbFwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/pm/model/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/pm/schema-list/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@tiptap/pm/schema-list/dist/index.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addListNodes: function() { return /* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.addListNodes; },\n/* harmony export */   bulletList: function() { return /* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.bulletList; },\n/* harmony export */   liftListItem: function() { return /* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.liftListItem; },\n/* harmony export */   listItem: function() { return /* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.listItem; },\n/* harmony export */   orderedList: function() { return /* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.orderedList; },\n/* harmony export */   sinkListItem: function() { return /* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.sinkListItem; },\n/* harmony export */   splitListItem: function() { return /* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.splitListItem; },\n/* harmony export */   splitListItemKeepMarks: function() { return /* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.splitListItemKeepMarks; },\n/* harmony export */   wrapInList: function() { return /* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.wrapInList; },\n/* harmony export */   wrapRangeInList: function() { return /* reexport safe */ prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__.wrapRangeInList; }\n/* harmony export */ });\n/* harmony import */ var prosemirror_schema_list__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-schema-list */ \"(app-pages-browser)/./node_modules/prosemirror-schema-list/dist/index.js\");\n// schema-list/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3BtL3NjaGVtYS1saXN0L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUN3QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS9zY2hlbWEtbGlzdC9kaXN0L2luZGV4LmpzP2EyYjMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc2NoZW1hLWxpc3QvaW5kZXgudHNcbmV4cG9ydCAqIGZyb20gXCJwcm9zZW1pcnJvci1zY2hlbWEtbGlzdFwiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/pm/schema-list/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/pm/state/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@tiptap/pm/state/dist/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AllSelection: function() { return /* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.AllSelection; },\n/* harmony export */   EditorState: function() { return /* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.EditorState; },\n/* harmony export */   NodeSelection: function() { return /* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection; },\n/* harmony export */   Plugin: function() { return /* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin; },\n/* harmony export */   PluginKey: function() { return /* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.PluginKey; },\n/* harmony export */   Selection: function() { return /* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection; },\n/* harmony export */   SelectionRange: function() { return /* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.SelectionRange; },\n/* harmony export */   TextSelection: function() { return /* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection; },\n/* harmony export */   Transaction: function() { return /* reexport safe */ prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Transaction; }\n/* harmony export */ });\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-state */ \"(app-pages-browser)/./node_modules/prosemirror-state/dist/index.js\");\n// state/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3BtL3N0YXRlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ2tDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3BtL3N0YXRlL2Rpc3QvaW5kZXguanM/YzFiZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzdGF0ZS9pbmRleC50c1xuZXhwb3J0ICogZnJvbSBcInByb3NlbWlycm9yLXN0YXRlXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/pm/state/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/pm/transform/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@tiptap/pm/transform/dist/index.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddMarkStep: function() { return /* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.AddMarkStep; },\n/* harmony export */   AddNodeMarkStep: function() { return /* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.AddNodeMarkStep; },\n/* harmony export */   AttrStep: function() { return /* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.AttrStep; },\n/* harmony export */   DocAttrStep: function() { return /* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.DocAttrStep; },\n/* harmony export */   MapResult: function() { return /* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.MapResult; },\n/* harmony export */   Mapping: function() { return /* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.Mapping; },\n/* harmony export */   RemoveMarkStep: function() { return /* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.RemoveMarkStep; },\n/* harmony export */   RemoveNodeMarkStep: function() { return /* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.RemoveNodeMarkStep; },\n/* harmony export */   ReplaceAroundStep: function() { return /* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceAroundStep; },\n/* harmony export */   ReplaceStep: function() { return /* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceStep; },\n/* harmony export */   Step: function() { return /* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.Step; },\n/* harmony export */   StepMap: function() { return /* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.StepMap; },\n/* harmony export */   StepResult: function() { return /* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.StepResult; },\n/* harmony export */   Transform: function() { return /* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.Transform; },\n/* harmony export */   TransformError: function() { return /* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.TransformError; },\n/* harmony export */   canJoin: function() { return /* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin; },\n/* harmony export */   canSplit: function() { return /* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit; },\n/* harmony export */   dropPoint: function() { return /* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.dropPoint; },\n/* harmony export */   findWrapping: function() { return /* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.findWrapping; },\n/* harmony export */   insertPoint: function() { return /* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.insertPoint; },\n/* harmony export */   joinPoint: function() { return /* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.joinPoint; },\n/* harmony export */   liftTarget: function() { return /* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget; },\n/* harmony export */   replaceStep: function() { return /* reexport safe */ prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.replaceStep; }\n/* harmony export */ });\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-transform */ \"(app-pages-browser)/./node_modules/prosemirror-transform/dist/index.js\");\n// transform/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3BtL3RyYW5zZm9ybS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ3NDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3BtL3RyYW5zZm9ybS9kaXN0L2luZGV4LmpzP2E1NTAiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gdHJhbnNmb3JtL2luZGV4LnRzXG5leHBvcnQgKiBmcm9tIFwicHJvc2VtaXJyb3ItdHJhbnNmb3JtXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/pm/transform/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/pm/view/dist/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@tiptap/pm/view/dist/index.js ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Decoration: function() { return /* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.Decoration; },\n/* harmony export */   DecorationSet: function() { return /* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.DecorationSet; },\n/* harmony export */   EditorView: function() { return /* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.EditorView; },\n/* harmony export */   __endComposition: function() { return /* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.__endComposition; },\n/* harmony export */   __parseFromClipboard: function() { return /* reexport safe */ prosemirror_view__WEBPACK_IMPORTED_MODULE_0__.__parseFromClipboard; }\n/* harmony export */ });\n/* harmony import */ var prosemirror_view__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-view */ \"(app-pages-browser)/./node_modules/prosemirror-view/dist/index.js\");\n// view/index.ts\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3BtL3ZpZXcvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNpQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHRpcHRhcC9wbS92aWV3L2Rpc3QvaW5kZXguanM/NDNhNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB2aWV3L2luZGV4LnRzXG5leHBvcnQgKiBmcm9tIFwicHJvc2VtaXJyb3Itdmlld1wiO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/pm/view/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/react/dist/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@tiptap/react/dist/index.js ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BubbleMenu: function() { return /* binding */ BubbleMenu; },\n/* harmony export */   CommandManager: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.CommandManager; },\n/* harmony export */   Editor: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.Editor; },\n/* harmony export */   EditorConsumer: function() { return /* binding */ EditorConsumer; },\n/* harmony export */   EditorContent: function() { return /* binding */ EditorContent; },\n/* harmony export */   EditorContext: function() { return /* binding */ EditorContext; },\n/* harmony export */   EditorProvider: function() { return /* binding */ EditorProvider; },\n/* harmony export */   Extension: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.Extension; },\n/* harmony export */   FloatingMenu: function() { return /* binding */ FloatingMenu; },\n/* harmony export */   InputRule: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.InputRule; },\n/* harmony export */   Mark: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.Mark; },\n/* harmony export */   Node: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.Node; },\n/* harmony export */   NodePos: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.NodePos; },\n/* harmony export */   NodeView: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.NodeView; },\n/* harmony export */   NodeViewContent: function() { return /* binding */ NodeViewContent; },\n/* harmony export */   NodeViewWrapper: function() { return /* binding */ NodeViewWrapper; },\n/* harmony export */   PasteRule: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.PasteRule; },\n/* harmony export */   PureEditorContent: function() { return /* binding */ PureEditorContent; },\n/* harmony export */   ReactNodeView: function() { return /* binding */ ReactNodeView; },\n/* harmony export */   ReactNodeViewContext: function() { return /* binding */ ReactNodeViewContext; },\n/* harmony export */   ReactNodeViewRenderer: function() { return /* binding */ ReactNodeViewRenderer; },\n/* harmony export */   ReactRenderer: function() { return /* binding */ ReactRenderer; },\n/* harmony export */   Tracker: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.Tracker; },\n/* harmony export */   callOrReturn: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.callOrReturn; },\n/* harmony export */   canInsertNode: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.canInsertNode; },\n/* harmony export */   combineTransactionSteps: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.combineTransactionSteps; },\n/* harmony export */   createChainableState: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.createChainableState; },\n/* harmony export */   createDocument: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.createDocument; },\n/* harmony export */   createNodeFromContent: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.createNodeFromContent; },\n/* harmony export */   createStyleTag: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.createStyleTag; },\n/* harmony export */   defaultBlockAt: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.defaultBlockAt; },\n/* harmony export */   deleteProps: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.deleteProps; },\n/* harmony export */   elementFromString: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.elementFromString; },\n/* harmony export */   escapeForRegEx: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.escapeForRegEx; },\n/* harmony export */   extensions: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.extensions; },\n/* harmony export */   findChildren: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.findChildren; },\n/* harmony export */   findChildrenInRange: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.findChildrenInRange; },\n/* harmony export */   findDuplicates: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.findDuplicates; },\n/* harmony export */   findParentNode: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.findParentNode; },\n/* harmony export */   findParentNodeClosestToPos: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.findParentNodeClosestToPos; },\n/* harmony export */   fromString: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.fromString; },\n/* harmony export */   generateHTML: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.generateHTML; },\n/* harmony export */   generateJSON: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.generateJSON; },\n/* harmony export */   generateText: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.generateText; },\n/* harmony export */   getAttributes: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getAttributes; },\n/* harmony export */   getAttributesFromExtensions: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getAttributesFromExtensions; },\n/* harmony export */   getChangedRanges: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getChangedRanges; },\n/* harmony export */   getDebugJSON: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getDebugJSON; },\n/* harmony export */   getExtensionField: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getExtensionField; },\n/* harmony export */   getHTMLFromFragment: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getHTMLFromFragment; },\n/* harmony export */   getMarkAttributes: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getMarkAttributes; },\n/* harmony export */   getMarkRange: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getMarkRange; },\n/* harmony export */   getMarkType: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getMarkType; },\n/* harmony export */   getMarksBetween: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getMarksBetween; },\n/* harmony export */   getNodeAtPosition: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getNodeAtPosition; },\n/* harmony export */   getNodeAttributes: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getNodeAttributes; },\n/* harmony export */   getNodeType: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getNodeType; },\n/* harmony export */   getRenderedAttributes: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getRenderedAttributes; },\n/* harmony export */   getSchema: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getSchema; },\n/* harmony export */   getSchemaByResolvedExtensions: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getSchemaByResolvedExtensions; },\n/* harmony export */   getSchemaTypeByName: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getSchemaTypeByName; },\n/* harmony export */   getSchemaTypeNameByName: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getSchemaTypeNameByName; },\n/* harmony export */   getSplittedAttributes: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getSplittedAttributes; },\n/* harmony export */   getText: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getText; },\n/* harmony export */   getTextBetween: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getTextBetween; },\n/* harmony export */   getTextContentFromNodes: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getTextContentFromNodes; },\n/* harmony export */   getTextSerializersFromSchema: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getTextSerializersFromSchema; },\n/* harmony export */   injectExtensionAttributesToParseRule: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.injectExtensionAttributesToParseRule; },\n/* harmony export */   inputRulesPlugin: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.inputRulesPlugin; },\n/* harmony export */   isActive: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isActive; },\n/* harmony export */   isAtEndOfNode: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isAtEndOfNode; },\n/* harmony export */   isAtStartOfNode: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isAtStartOfNode; },\n/* harmony export */   isEmptyObject: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isEmptyObject; },\n/* harmony export */   isExtensionRulesEnabled: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isExtensionRulesEnabled; },\n/* harmony export */   isFunction: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isFunction; },\n/* harmony export */   isList: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isList; },\n/* harmony export */   isMacOS: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isMacOS; },\n/* harmony export */   isMarkActive: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isMarkActive; },\n/* harmony export */   isNodeActive: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isNodeActive; },\n/* harmony export */   isNodeEmpty: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isNodeEmpty; },\n/* harmony export */   isNodeSelection: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isNodeSelection; },\n/* harmony export */   isNumber: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isNumber; },\n/* harmony export */   isPlainObject: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isPlainObject; },\n/* harmony export */   isRegExp: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isRegExp; },\n/* harmony export */   isString: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isString; },\n/* harmony export */   isTextSelection: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isTextSelection; },\n/* harmony export */   isiOS: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.isiOS; },\n/* harmony export */   markInputRule: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.markInputRule; },\n/* harmony export */   markPasteRule: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.markPasteRule; },\n/* harmony export */   mergeAttributes: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.mergeAttributes; },\n/* harmony export */   mergeDeep: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.mergeDeep; },\n/* harmony export */   minMax: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.minMax; },\n/* harmony export */   nodeInputRule: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.nodeInputRule; },\n/* harmony export */   nodePasteRule: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.nodePasteRule; },\n/* harmony export */   objectIncludes: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.objectIncludes; },\n/* harmony export */   pasteRulesPlugin: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.pasteRulesPlugin; },\n/* harmony export */   posToDOMRect: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.posToDOMRect; },\n/* harmony export */   removeDuplicates: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.removeDuplicates; },\n/* harmony export */   resolveFocusPosition: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.resolveFocusPosition; },\n/* harmony export */   rewriteUnknownContent: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.rewriteUnknownContent; },\n/* harmony export */   selectionToInsertionEnd: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.selectionToInsertionEnd; },\n/* harmony export */   splitExtensions: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.splitExtensions; },\n/* harmony export */   textInputRule: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.textInputRule; },\n/* harmony export */   textPasteRule: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.textPasteRule; },\n/* harmony export */   textblockTypeInputRule: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.textblockTypeInputRule; },\n/* harmony export */   useCurrentEditor: function() { return /* binding */ useCurrentEditor; },\n/* harmony export */   useEditor: function() { return /* binding */ useEditor; },\n/* harmony export */   useEditorState: function() { return /* binding */ useEditorState; },\n/* harmony export */   useReactNodeView: function() { return /* binding */ useReactNodeView; },\n/* harmony export */   wrappingInputRule: function() { return /* reexport safe */ _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.wrappingInputRule; }\n/* harmony export */ });\n/* harmony import */ var _tiptap_extension_bubble_menu__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tiptap/extension-bubble-menu */ \"(app-pages-browser)/./node_modules/@tiptap/extension-bubble-menu/dist/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\");\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/core */ \"(app-pages-browser)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_extension_floating_menu__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tiptap/extension-floating-menu */ \"(app-pages-browser)/./node_modules/@tiptap/extension-floating-menu/dist/index.js\");\n\n\n\n\n\n\n\nfunction getDefaultExportFromCjs (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nvar shim = {exports: {}};\n\nvar useSyncExternalStoreShim_production_min = {};\n\n/**\n * @license React\n * use-sync-external-store-shim.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar hasRequiredUseSyncExternalStoreShim_production_min;\n\nfunction requireUseSyncExternalStoreShim_production_min () {\n\tif (hasRequiredUseSyncExternalStoreShim_production_min) return useSyncExternalStoreShim_production_min;\n\thasRequiredUseSyncExternalStoreShim_production_min = 1;\nvar e=react__WEBPACK_IMPORTED_MODULE_0__;function h(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var k=\"function\"===typeof Object.is?Object.is:h,l=e.useState,m=e.useEffect,n=e.useLayoutEffect,p=e.useDebugValue;function q(a,b){var d=b(),f=l({inst:{value:d,getSnapshot:b}}),c=f[0].inst,g=f[1];n(function(){c.value=d;c.getSnapshot=b;r(c)&&g({inst:c});},[a,d,b]);m(function(){r(c)&&g({inst:c});return a(function(){r(c)&&g({inst:c});})},[a]);p(d);return d}\n\tfunction r(a){var b=a.getSnapshot;a=a.value;try{var d=b();return !k(a,d)}catch(f){return !0}}function t(a,b){return b()}var u=\"undefined\"===typeof window||\"undefined\"===typeof window.document||\"undefined\"===typeof window.document.createElement?t:q;useSyncExternalStoreShim_production_min.useSyncExternalStore=void 0!==e.useSyncExternalStore?e.useSyncExternalStore:u;\n\treturn useSyncExternalStoreShim_production_min;\n}\n\nvar useSyncExternalStoreShim_development = {};\n\n/**\n * @license React\n * use-sync-external-store-shim.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar hasRequiredUseSyncExternalStoreShim_development;\n\nfunction requireUseSyncExternalStoreShim_development () {\n\tif (hasRequiredUseSyncExternalStoreShim_development) return useSyncExternalStoreShim_development;\n\thasRequiredUseSyncExternalStoreShim_development = 1;\n\n\tif (true) {\n\t  (function() {\n\n\t/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n\tif (\n\t  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n\t  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===\n\t    'function'\n\t) {\n\t  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n\t}\n\t          var React$1 = react__WEBPACK_IMPORTED_MODULE_0__;\n\n\tvar ReactSharedInternals = React$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\n\tfunction error(format) {\n\t  {\n\t    {\n\t      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n\t        args[_key2 - 1] = arguments[_key2];\n\t      }\n\n\t      printWarning('error', format, args);\n\t    }\n\t  }\n\t}\n\n\tfunction printWarning(level, format, args) {\n\t  // When changing this logic, you might want to also\n\t  // update consoleWithStackDev.www.js as well.\n\t  {\n\t    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n\t    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n\t    if (stack !== '') {\n\t      format += '%s';\n\t      args = args.concat([stack]);\n\t    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n\t    var argsWithFormat = args.map(function (item) {\n\t      return String(item);\n\t    }); // Careful: RN currently depends on this prefix\n\n\t    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n\t    // breaks IE9: https://github.com/facebook/react/issues/13610\n\t    // eslint-disable-next-line react-internal/no-production-logging\n\n\t    Function.prototype.apply.call(console[level], console, argsWithFormat);\n\t  }\n\t}\n\n\t/**\n\t * inlined Object.is polyfill to avoid requiring consumers ship their own\n\t * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n\t */\n\tfunction is(x, y) {\n\t  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n\t  ;\n\t}\n\n\tvar objectIs = typeof Object.is === 'function' ? Object.is : is;\n\n\t// dispatch for CommonJS interop named imports.\n\n\tvar useState = React$1.useState,\n\t    useEffect = React$1.useEffect,\n\t    useLayoutEffect = React$1.useLayoutEffect,\n\t    useDebugValue = React$1.useDebugValue;\n\tvar didWarnOld18Alpha = false;\n\tvar didWarnUncachedGetSnapshot = false; // Disclaimer: This shim breaks many of the rules of React, and only works\n\t// because of a very particular set of implementation details and assumptions\n\t// -- change any one of them and it will break. The most important assumption\n\t// is that updates are always synchronous, because concurrent rendering is\n\t// only available in versions of React that also have a built-in\n\t// useSyncExternalStore API. And we only use this shim when the built-in API\n\t// does not exist.\n\t//\n\t// Do not assume that the clever hacks used by this hook also work in general.\n\t// The point of this shim is to replace the need for hacks by other libraries.\n\n\tfunction useSyncExternalStore(subscribe, getSnapshot, // Note: The shim does not use getServerSnapshot, because pre-18 versions of\n\t// React do not expose a way to check if we're hydrating. So users of the shim\n\t// will need to track that themselves and return the correct value\n\t// from `getSnapshot`.\n\tgetServerSnapshot) {\n\t  {\n\t    if (!didWarnOld18Alpha) {\n\t      if (React$1.startTransition !== undefined) {\n\t        didWarnOld18Alpha = true;\n\n\t        error('You are using an outdated, pre-release alpha of React 18 that ' + 'does not support useSyncExternalStore. The ' + 'use-sync-external-store shim will not work correctly. Upgrade ' + 'to a newer pre-release.');\n\t      }\n\t    }\n\t  } // Read the current snapshot from the store on every render. Again, this\n\t  // breaks the rules of React, and only works here because of specific\n\t  // implementation details, most importantly that updates are\n\t  // always synchronous.\n\n\n\t  var value = getSnapshot();\n\n\t  {\n\t    if (!didWarnUncachedGetSnapshot) {\n\t      var cachedValue = getSnapshot();\n\n\t      if (!objectIs(value, cachedValue)) {\n\t        error('The result of getSnapshot should be cached to avoid an infinite loop');\n\n\t        didWarnUncachedGetSnapshot = true;\n\t      }\n\t    }\n\t  } // Because updates are synchronous, we don't queue them. Instead we force a\n\t  // re-render whenever the subscribed state changes by updating an some\n\t  // arbitrary useState hook. Then, during render, we call getSnapshot to read\n\t  // the current value.\n\t  //\n\t  // Because we don't actually use the state returned by the useState hook, we\n\t  // can save a bit of memory by storing other stuff in that slot.\n\t  //\n\t  // To implement the early bailout, we need to track some things on a mutable\n\t  // object. Usually, we would put that in a useRef hook, but we can stash it in\n\t  // our useState hook instead.\n\t  //\n\t  // To force a re-render, we call forceUpdate({inst}). That works because the\n\t  // new object always fails an equality check.\n\n\n\t  var _useState = useState({\n\t    inst: {\n\t      value: value,\n\t      getSnapshot: getSnapshot\n\t    }\n\t  }),\n\t      inst = _useState[0].inst,\n\t      forceUpdate = _useState[1]; // Track the latest getSnapshot function with a ref. This needs to be updated\n\t  // in the layout phase so we can access it during the tearing check that\n\t  // happens on subscribe.\n\n\n\t  useLayoutEffect(function () {\n\t    inst.value = value;\n\t    inst.getSnapshot = getSnapshot; // Whenever getSnapshot or subscribe changes, we need to check in the\n\t    // commit phase if there was an interleaved mutation. In concurrent mode\n\t    // this can happen all the time, but even in synchronous mode, an earlier\n\t    // effect may have mutated the store.\n\n\t    if (checkIfSnapshotChanged(inst)) {\n\t      // Force a re-render.\n\t      forceUpdate({\n\t        inst: inst\n\t      });\n\t    }\n\t  }, [subscribe, value, getSnapshot]);\n\t  useEffect(function () {\n\t    // Check for changes right before subscribing. Subsequent changes will be\n\t    // detected in the subscription handler.\n\t    if (checkIfSnapshotChanged(inst)) {\n\t      // Force a re-render.\n\t      forceUpdate({\n\t        inst: inst\n\t      });\n\t    }\n\n\t    var handleStoreChange = function () {\n\t      // TODO: Because there is no cross-renderer API for batching updates, it's\n\t      // up to the consumer of this library to wrap their subscription event\n\t      // with unstable_batchedUpdates. Should we try to detect when this isn't\n\t      // the case and print a warning in development?\n\t      // The store changed. Check if the snapshot changed since the last time we\n\t      // read from the store.\n\t      if (checkIfSnapshotChanged(inst)) {\n\t        // Force a re-render.\n\t        forceUpdate({\n\t          inst: inst\n\t        });\n\t      }\n\t    }; // Subscribe to the store and return a clean-up function.\n\n\n\t    return subscribe(handleStoreChange);\n\t  }, [subscribe]);\n\t  useDebugValue(value);\n\t  return value;\n\t}\n\n\tfunction checkIfSnapshotChanged(inst) {\n\t  var latestGetSnapshot = inst.getSnapshot;\n\t  var prevValue = inst.value;\n\n\t  try {\n\t    var nextValue = latestGetSnapshot();\n\t    return !objectIs(prevValue, nextValue);\n\t  } catch (error) {\n\t    return true;\n\t  }\n\t}\n\n\tfunction useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {\n\t  // Note: The shim does not use getServerSnapshot, because pre-18 versions of\n\t  // React do not expose a way to check if we're hydrating. So users of the shim\n\t  // will need to track that themselves and return the correct value\n\t  // from `getSnapshot`.\n\t  return getSnapshot();\n\t}\n\n\tvar canUseDOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined');\n\n\tvar isServerEnvironment = !canUseDOM;\n\n\tvar shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;\n\tvar useSyncExternalStore$2 = React$1.useSyncExternalStore !== undefined ? React$1.useSyncExternalStore : shim;\n\n\tuseSyncExternalStoreShim_development.useSyncExternalStore = useSyncExternalStore$2;\n\t          /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n\tif (\n\t  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n\t  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===\n\t    'function'\n\t) {\n\t  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n\t}\n\t        \n\t  })();\n\t}\n\treturn useSyncExternalStoreShim_development;\n}\n\nif (false) {} else {\n  shim.exports = requireUseSyncExternalStoreShim_development();\n}\n\nvar shimExports = shim.exports;\n\nconst mergeRefs = (...refs) => {\n    return (node) => {\n        refs.forEach(ref => {\n            if (typeof ref === 'function') {\n                ref(node);\n            }\n            else if (ref) {\n                ref.current = node;\n            }\n        });\n    };\n};\n/**\n * This component renders all of the editor's node views.\n */\nconst Portals = ({ contentComponent, }) => {\n    // For performance reasons, we render the node view portals on state changes only\n    const renderers = shimExports.useSyncExternalStore(contentComponent.subscribe, contentComponent.getSnapshot, contentComponent.getServerSnapshot);\n    // This allows us to directly render the portals without any additional wrapper\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, Object.values(renderers)));\n};\nfunction getInstance() {\n    const subscribers = new Set();\n    let renderers = {};\n    return {\n        /**\n         * Subscribe to the editor instance's changes.\n         */\n        subscribe(callback) {\n            subscribers.add(callback);\n            return () => {\n                subscribers.delete(callback);\n            };\n        },\n        getSnapshot() {\n            return renderers;\n        },\n        getServerSnapshot() {\n            return renderers;\n        },\n        /**\n         * Adds a new NodeView Renderer to the editor.\n         */\n        setRenderer(id, renderer) {\n            renderers = {\n                ...renderers,\n                [id]: react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal(renderer.reactElement, renderer.element, id),\n            };\n            subscribers.forEach(subscriber => subscriber());\n        },\n        /**\n         * Removes a NodeView Renderer from the editor.\n         */\n        removeRenderer(id) {\n            const nextRenderers = { ...renderers };\n            delete nextRenderers[id];\n            renderers = nextRenderers;\n            subscribers.forEach(subscriber => subscriber());\n        },\n    };\n}\nclass PureEditorContent extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    constructor(props) {\n        var _a;\n        super(props);\n        this.editorContentRef = react__WEBPACK_IMPORTED_MODULE_0__.createRef();\n        this.initialized = false;\n        this.state = {\n            hasContentComponentInitialized: Boolean((_a = props.editor) === null || _a === void 0 ? void 0 : _a.contentComponent),\n        };\n    }\n    componentDidMount() {\n        this.init();\n    }\n    componentDidUpdate() {\n        this.init();\n    }\n    init() {\n        const editor = this.props.editor;\n        if (editor && !editor.isDestroyed && editor.options.element) {\n            if (editor.contentComponent) {\n                return;\n            }\n            const element = this.editorContentRef.current;\n            element.append(...editor.options.element.childNodes);\n            editor.setOptions({\n                element,\n            });\n            editor.contentComponent = getInstance();\n            // Has the content component been initialized?\n            if (!this.state.hasContentComponentInitialized) {\n                // Subscribe to the content component\n                this.unsubscribeToContentComponent = editor.contentComponent.subscribe(() => {\n                    this.setState(prevState => {\n                        if (!prevState.hasContentComponentInitialized) {\n                            return {\n                                hasContentComponentInitialized: true,\n                            };\n                        }\n                        return prevState;\n                    });\n                    // Unsubscribe to previous content component\n                    if (this.unsubscribeToContentComponent) {\n                        this.unsubscribeToContentComponent();\n                    }\n                });\n            }\n            editor.createNodeViews();\n            this.initialized = true;\n        }\n    }\n    componentWillUnmount() {\n        const editor = this.props.editor;\n        if (!editor) {\n            return;\n        }\n        this.initialized = false;\n        if (!editor.isDestroyed) {\n            editor.view.setProps({\n                nodeViews: {},\n            });\n        }\n        if (this.unsubscribeToContentComponent) {\n            this.unsubscribeToContentComponent();\n        }\n        editor.contentComponent = null;\n        if (!editor.options.element.firstChild) {\n            return;\n        }\n        const newElement = document.createElement('div');\n        newElement.append(...editor.options.element.childNodes);\n        editor.setOptions({\n            element: newElement,\n        });\n    }\n    render() {\n        const { editor, innerRef, ...rest } = this.props;\n        return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: mergeRefs(innerRef, this.editorContentRef), ...rest }),\n            (editor === null || editor === void 0 ? void 0 : editor.contentComponent) && react__WEBPACK_IMPORTED_MODULE_0__.createElement(Portals, { contentComponent: editor.contentComponent })));\n    }\n}\n// EditorContent should be re-created whenever the Editor instance changes\nconst EditorContentWithKey = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)((props, ref) => {\n    const key = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(() => {\n        return Math.floor(Math.random() * 0xffffffff).toString();\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [props.editor]);\n    // Can't use JSX here because it conflicts with the type definition of Vue's JSX, so use createElement\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(PureEditorContent, {\n        key,\n        innerRef: ref,\n        ...props,\n    });\n});\nconst EditorContent = react__WEBPACK_IMPORTED_MODULE_0__.memo(EditorContentWithKey);\n\nvar react = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n    if ((a instanceof Map) && (b instanceof Map)) {\n      if (a.size !== b.size) return false;\n      for (i of a.entries())\n        if (!b.has(i[0])) return false;\n      for (i of a.entries())\n        if (!equal(i[1], b.get(i[0]))) return false;\n      return true;\n    }\n\n    if ((a instanceof Set) && (b instanceof Set)) {\n      if (a.size !== b.size) return false;\n      for (i of a.entries())\n        if (!b.has(i[0])) return false;\n      return true;\n    }\n\n    if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (a[i] !== b[i]) return false;\n      return true;\n    }\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (key === '_owner' && a.$$typeof) {\n        // React-specific: avoid traversing React elements' _owner.\n        //  _owner contains circular references\n        // and is not needed when comparing the actual elements (and not their owners)\n        continue;\n      }\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n\nvar deepEqual = /*@__PURE__*/getDefaultExportFromCjs(react);\n\nvar withSelector = {exports: {}};\n\nvar withSelector_production_min = {};\n\n/**\n * @license React\n * use-sync-external-store-shim/with-selector.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar hasRequiredWithSelector_production_min;\n\nfunction requireWithSelector_production_min () {\n\tif (hasRequiredWithSelector_production_min) return withSelector_production_min;\n\thasRequiredWithSelector_production_min = 1;\nvar h=react__WEBPACK_IMPORTED_MODULE_0__,n=shimExports;function p(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var q=\"function\"===typeof Object.is?Object.is:p,r=n.useSyncExternalStore,t=h.useRef,u=h.useEffect,v=h.useMemo,w=h.useDebugValue;\n\twithSelector_production_min.useSyncExternalStoreWithSelector=function(a,b,e,l,g){var c=t(null);if(null===c.current){var f={hasValue:!1,value:null};c.current=f;}else f=c.current;c=v(function(){function a(a){if(!c){c=!0;d=a;a=l(a);if(void 0!==g&&f.hasValue){var b=f.value;if(g(b,a))return k=b}return k=a}b=k;if(q(d,a))return b;var e=l(a);if(void 0!==g&&g(b,e))return b;d=a;return k=e}var c=!1,d,k,m=void 0===e?null:e;return [function(){return a(b())},null===m?void 0:function(){return a(m())}]},[b,e,l,g]);var d=r(a,c[0],c[1]);\n\tu(function(){f.hasValue=!0;f.value=d;},[d]);w(d);return d};\n\treturn withSelector_production_min;\n}\n\nvar withSelector_development = {};\n\n/**\n * @license React\n * use-sync-external-store-shim/with-selector.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar hasRequiredWithSelector_development;\n\nfunction requireWithSelector_development () {\n\tif (hasRequiredWithSelector_development) return withSelector_development;\n\thasRequiredWithSelector_development = 1;\n\n\tif (true) {\n\t  (function() {\n\n\t/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n\tif (\n\t  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n\t  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===\n\t    'function'\n\t) {\n\t  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n\t}\n\t          var React$1 = react__WEBPACK_IMPORTED_MODULE_0__;\n\tvar shim = shimExports;\n\n\t/**\n\t * inlined Object.is polyfill to avoid requiring consumers ship their own\n\t * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n\t */\n\tfunction is(x, y) {\n\t  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n\t  ;\n\t}\n\n\tvar objectIs = typeof Object.is === 'function' ? Object.is : is;\n\n\tvar useSyncExternalStore = shim.useSyncExternalStore;\n\n\t// for CommonJS interop.\n\n\tvar useRef = React$1.useRef,\n\t    useEffect = React$1.useEffect,\n\t    useMemo = React$1.useMemo,\n\t    useDebugValue = React$1.useDebugValue; // Same as useSyncExternalStore, but supports selector and isEqual arguments.\n\n\tfunction useSyncExternalStoreWithSelector(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {\n\t  // Use this to track the rendered snapshot.\n\t  var instRef = useRef(null);\n\t  var inst;\n\n\t  if (instRef.current === null) {\n\t    inst = {\n\t      hasValue: false,\n\t      value: null\n\t    };\n\t    instRef.current = inst;\n\t  } else {\n\t    inst = instRef.current;\n\t  }\n\n\t  var _useMemo = useMemo(function () {\n\t    // Track the memoized state using closure variables that are local to this\n\t    // memoized instance of a getSnapshot function. Intentionally not using a\n\t    // useRef hook, because that state would be shared across all concurrent\n\t    // copies of the hook/component.\n\t    var hasMemo = false;\n\t    var memoizedSnapshot;\n\t    var memoizedSelection;\n\n\t    var memoizedSelector = function (nextSnapshot) {\n\t      if (!hasMemo) {\n\t        // The first time the hook is called, there is no memoized result.\n\t        hasMemo = true;\n\t        memoizedSnapshot = nextSnapshot;\n\n\t        var _nextSelection = selector(nextSnapshot);\n\n\t        if (isEqual !== undefined) {\n\t          // Even if the selector has changed, the currently rendered selection\n\t          // may be equal to the new selection. We should attempt to reuse the\n\t          // current value if possible, to preserve downstream memoizations.\n\t          if (inst.hasValue) {\n\t            var currentSelection = inst.value;\n\n\t            if (isEqual(currentSelection, _nextSelection)) {\n\t              memoizedSelection = currentSelection;\n\t              return currentSelection;\n\t            }\n\t          }\n\t        }\n\n\t        memoizedSelection = _nextSelection;\n\t        return _nextSelection;\n\t      } // We may be able to reuse the previous invocation's result.\n\n\n\t      // We may be able to reuse the previous invocation's result.\n\t      var prevSnapshot = memoizedSnapshot;\n\t      var prevSelection = memoizedSelection;\n\n\t      if (objectIs(prevSnapshot, nextSnapshot)) {\n\t        // The snapshot is the same as last time. Reuse the previous selection.\n\t        return prevSelection;\n\t      } // The snapshot has changed, so we need to compute a new selection.\n\n\n\t      // The snapshot has changed, so we need to compute a new selection.\n\t      var nextSelection = selector(nextSnapshot); // If a custom isEqual function is provided, use that to check if the data\n\t      // has changed. If it hasn't, return the previous selection. That signals\n\t      // to React that the selections are conceptually equal, and we can bail\n\t      // out of rendering.\n\n\t      // If a custom isEqual function is provided, use that to check if the data\n\t      // has changed. If it hasn't, return the previous selection. That signals\n\t      // to React that the selections are conceptually equal, and we can bail\n\t      // out of rendering.\n\t      if (isEqual !== undefined && isEqual(prevSelection, nextSelection)) {\n\t        return prevSelection;\n\t      }\n\n\t      memoizedSnapshot = nextSnapshot;\n\t      memoizedSelection = nextSelection;\n\t      return nextSelection;\n\t    }; // Assigning this to a constant so that Flow knows it can't change.\n\n\n\t    // Assigning this to a constant so that Flow knows it can't change.\n\t    var maybeGetServerSnapshot = getServerSnapshot === undefined ? null : getServerSnapshot;\n\n\t    var getSnapshotWithSelector = function () {\n\t      return memoizedSelector(getSnapshot());\n\t    };\n\n\t    var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? undefined : function () {\n\t      return memoizedSelector(maybeGetServerSnapshot());\n\t    };\n\t    return [getSnapshotWithSelector, getServerSnapshotWithSelector];\n\t  }, [getSnapshot, getServerSnapshot, selector, isEqual]),\n\t      getSelection = _useMemo[0],\n\t      getServerSelection = _useMemo[1];\n\n\t  var value = useSyncExternalStore(subscribe, getSelection, getServerSelection);\n\t  useEffect(function () {\n\t    inst.hasValue = true;\n\t    inst.value = value;\n\t  }, [value]);\n\t  useDebugValue(value);\n\t  return value;\n\t}\n\n\twithSelector_development.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector;\n\t          /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n\tif (\n\t  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n\t  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===\n\t    'function'\n\t) {\n\t  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n\t}\n\t        \n\t  })();\n\t}\n\treturn withSelector_development;\n}\n\nif (false) {} else {\n  withSelector.exports = requireWithSelector_development();\n}\n\nvar withSelectorExports = withSelector.exports;\n\nconst useIsomorphicLayoutEffect = typeof window !== 'undefined' ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\n/**\n * To synchronize the editor instance with the component state,\n * we need to create a separate instance that is not affected by the component re-renders.\n */\nclass EditorStateManager {\n    constructor(initialEditor) {\n        this.transactionNumber = 0;\n        this.lastTransactionNumber = 0;\n        this.subscribers = new Set();\n        this.editor = initialEditor;\n        this.lastSnapshot = { editor: initialEditor, transactionNumber: 0 };\n        this.getSnapshot = this.getSnapshot.bind(this);\n        this.getServerSnapshot = this.getServerSnapshot.bind(this);\n        this.watch = this.watch.bind(this);\n        this.subscribe = this.subscribe.bind(this);\n    }\n    /**\n     * Get the current editor instance.\n     */\n    getSnapshot() {\n        if (this.transactionNumber === this.lastTransactionNumber) {\n            return this.lastSnapshot;\n        }\n        this.lastTransactionNumber = this.transactionNumber;\n        this.lastSnapshot = { editor: this.editor, transactionNumber: this.transactionNumber };\n        return this.lastSnapshot;\n    }\n    /**\n     * Always disable the editor on the server-side.\n     */\n    getServerSnapshot() {\n        return { editor: null, transactionNumber: 0 };\n    }\n    /**\n     * Subscribe to the editor instance's changes.\n     */\n    subscribe(callback) {\n        this.subscribers.add(callback);\n        return () => {\n            this.subscribers.delete(callback);\n        };\n    }\n    /**\n     * Watch the editor instance for changes.\n     */\n    watch(nextEditor) {\n        this.editor = nextEditor;\n        if (this.editor) {\n            /**\n             * This will force a re-render when the editor state changes.\n             * This is to support things like `editor.can().toggleBold()` in components that `useEditor`.\n             * This could be more efficient, but it's a good trade-off for now.\n             */\n            const fn = () => {\n                this.transactionNumber += 1;\n                this.subscribers.forEach(callback => callback());\n            };\n            const currentEditor = this.editor;\n            currentEditor.on('transaction', fn);\n            return () => {\n                currentEditor.off('transaction', fn);\n            };\n        }\n        return undefined;\n    }\n}\n/**\n * This hook allows you to watch for changes on the editor instance.\n * It will allow you to select a part of the editor state and re-render the component when it changes.\n * @example\n * ```tsx\n * const editor = useEditor({...options})\n * const { currentSelection } = useEditorState({\n *  editor,\n *  selector: snapshot => ({ currentSelection: snapshot.editor.state.selection }),\n * })\n */\nfunction useEditorState(options) {\n    var _a;\n    const [editorStateManager] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => new EditorStateManager(options.editor));\n    // Using the `useSyncExternalStore` hook to sync the editor instance with the component state\n    const selectedState = withSelectorExports.useSyncExternalStoreWithSelector(editorStateManager.subscribe, editorStateManager.getSnapshot, editorStateManager.getServerSnapshot, options.selector, (_a = options.equalityFn) !== null && _a !== void 0 ? _a : deepEqual);\n    useIsomorphicLayoutEffect(() => {\n        return editorStateManager.watch(options.editor);\n    }, [options.editor, editorStateManager]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(selectedState);\n    return selectedState;\n}\n\nconst isDev = \"development\" !== 'production';\nconst isSSR = typeof window === 'undefined';\nconst isNext = isSSR || Boolean(typeof window !== 'undefined' && window.next);\n/**\n * This class handles the creation, destruction, and re-creation of the editor instance.\n */\nclass EditorInstanceManager {\n    constructor(options) {\n        /**\n         * The current editor instance.\n         */\n        this.editor = null;\n        /**\n         * The subscriptions to notify when the editor instance\n         * has been created or destroyed.\n         */\n        this.subscriptions = new Set();\n        /**\n         * Whether the editor has been mounted.\n         */\n        this.isComponentMounted = false;\n        /**\n         * The most recent dependencies array.\n         */\n        this.previousDeps = null;\n        /**\n         * The unique instance ID. This is used to identify the editor instance. And will be re-generated for each new instance.\n         */\n        this.instanceId = '';\n        this.options = options;\n        this.subscriptions = new Set();\n        this.setEditor(this.getInitialEditor());\n        this.scheduleDestroy();\n        this.getEditor = this.getEditor.bind(this);\n        this.getServerSnapshot = this.getServerSnapshot.bind(this);\n        this.subscribe = this.subscribe.bind(this);\n        this.refreshEditorInstance = this.refreshEditorInstance.bind(this);\n        this.scheduleDestroy = this.scheduleDestroy.bind(this);\n        this.onRender = this.onRender.bind(this);\n        this.createEditor = this.createEditor.bind(this);\n    }\n    setEditor(editor) {\n        this.editor = editor;\n        this.instanceId = Math.random().toString(36).slice(2, 9);\n        // Notify all subscribers that the editor instance has been created\n        this.subscriptions.forEach(cb => cb());\n    }\n    getInitialEditor() {\n        if (this.options.current.immediatelyRender === undefined) {\n            if (isSSR || isNext) {\n                // TODO in the next major release, we should throw an error here\n                if (isDev) {\n                    /**\n                     * Throw an error in development, to make sure the developer is aware that tiptap cannot be SSR'd\n                     * and that they need to set `immediatelyRender` to `false` to avoid hydration mismatches.\n                     */\n                    console.warn('Tiptap Error: SSR has been detected, please set `immediatelyRender` explicitly to `false` to avoid hydration mismatches.');\n                }\n                // Best faith effort in production, run the code in the legacy mode to avoid hydration mismatches and errors in production\n                return null;\n            }\n            // Default to immediately rendering when client-side rendering\n            return this.createEditor();\n        }\n        if (this.options.current.immediatelyRender && isSSR && isDev) {\n            // Warn in development, to make sure the developer is aware that tiptap cannot be SSR'd, set `immediatelyRender` to `false` to avoid hydration mismatches.\n            throw new Error('Tiptap Error: SSR has been detected, and `immediatelyRender` has been set to `true` this is an unsupported configuration that may result in errors, explicitly set `immediatelyRender` to `false` to avoid hydration mismatches.');\n        }\n        if (this.options.current.immediatelyRender) {\n            return this.createEditor();\n        }\n        return null;\n    }\n    /**\n     * Create a new editor instance. And attach event listeners.\n     */\n    createEditor() {\n        const optionsToApply = {\n            ...this.options.current,\n            // Always call the most recent version of the callback function by default\n            onBeforeCreate: (...args) => { var _a, _b; return (_b = (_a = this.options.current).onBeforeCreate) === null || _b === void 0 ? void 0 : _b.call(_a, ...args); },\n            onBlur: (...args) => { var _a, _b; return (_b = (_a = this.options.current).onBlur) === null || _b === void 0 ? void 0 : _b.call(_a, ...args); },\n            onCreate: (...args) => { var _a, _b; return (_b = (_a = this.options.current).onCreate) === null || _b === void 0 ? void 0 : _b.call(_a, ...args); },\n            onDestroy: (...args) => { var _a, _b; return (_b = (_a = this.options.current).onDestroy) === null || _b === void 0 ? void 0 : _b.call(_a, ...args); },\n            onFocus: (...args) => { var _a, _b; return (_b = (_a = this.options.current).onFocus) === null || _b === void 0 ? void 0 : _b.call(_a, ...args); },\n            onSelectionUpdate: (...args) => { var _a, _b; return (_b = (_a = this.options.current).onSelectionUpdate) === null || _b === void 0 ? void 0 : _b.call(_a, ...args); },\n            onTransaction: (...args) => { var _a, _b; return (_b = (_a = this.options.current).onTransaction) === null || _b === void 0 ? void 0 : _b.call(_a, ...args); },\n            onUpdate: (...args) => { var _a, _b; return (_b = (_a = this.options.current).onUpdate) === null || _b === void 0 ? void 0 : _b.call(_a, ...args); },\n            onContentError: (...args) => { var _a, _b; return (_b = (_a = this.options.current).onContentError) === null || _b === void 0 ? void 0 : _b.call(_a, ...args); },\n            onDrop: (...args) => { var _a, _b; return (_b = (_a = this.options.current).onDrop) === null || _b === void 0 ? void 0 : _b.call(_a, ...args); },\n            onPaste: (...args) => { var _a, _b; return (_b = (_a = this.options.current).onPaste) === null || _b === void 0 ? void 0 : _b.call(_a, ...args); },\n        };\n        const editor = new _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.Editor(optionsToApply);\n        // no need to keep track of the event listeners, they will be removed when the editor is destroyed\n        return editor;\n    }\n    /**\n     * Get the current editor instance.\n     */\n    getEditor() {\n        return this.editor;\n    }\n    /**\n     * Always disable the editor on the server-side.\n     */\n    getServerSnapshot() {\n        return null;\n    }\n    /**\n     * Subscribe to the editor instance's changes.\n     */\n    subscribe(onStoreChange) {\n        this.subscriptions.add(onStoreChange);\n        return () => {\n            this.subscriptions.delete(onStoreChange);\n        };\n    }\n    static compareOptions(a, b) {\n        return Object.keys(a).every(key => {\n            if (['onCreate', 'onBeforeCreate', 'onDestroy', 'onUpdate', 'onTransaction', 'onFocus', 'onBlur', 'onSelectionUpdate', 'onContentError', 'onDrop', 'onPaste'].includes(key)) {\n                // we don't want to compare callbacks, they are always different and only registered once\n                return true;\n            }\n            // We often encourage putting extensions inlined in the options object, so we will do a slightly deeper comparison here\n            if (key === 'extensions' && a.extensions && b.extensions) {\n                if (a.extensions.length !== b.extensions.length) {\n                    return false;\n                }\n                return a.extensions.every((extension, index) => {\n                    var _a;\n                    if (extension !== ((_a = b.extensions) === null || _a === void 0 ? void 0 : _a[index])) {\n                        return false;\n                    }\n                    return true;\n                });\n            }\n            if (a[key] !== b[key]) {\n                // if any of the options have changed, we should update the editor options\n                return false;\n            }\n            return true;\n        });\n    }\n    /**\n     * On each render, we will create, update, or destroy the editor instance.\n     * @param deps The dependencies to watch for changes\n     * @returns A cleanup function\n     */\n    onRender(deps) {\n        // The returned callback will run on each render\n        return () => {\n            this.isComponentMounted = true;\n            // Cleanup any scheduled destructions, since we are currently rendering\n            clearTimeout(this.scheduledDestructionTimeout);\n            if (this.editor && !this.editor.isDestroyed && deps.length === 0) {\n                // if the editor does exist & deps are empty, we don't need to re-initialize the editor generally\n                if (!EditorInstanceManager.compareOptions(this.options.current, this.editor.options)) {\n                    // But, the options are different, so we need to update the editor options\n                    // Still, this is faster than re-creating the editor\n                    this.editor.setOptions({\n                        ...this.options.current,\n                        editable: this.editor.isEditable,\n                    });\n                }\n            }\n            else {\n                // When the editor:\n                // - does not yet exist\n                // - is destroyed\n                // - the deps array changes\n                // We need to destroy the editor instance and re-initialize it\n                this.refreshEditorInstance(deps);\n            }\n            return () => {\n                this.isComponentMounted = false;\n                this.scheduleDestroy();\n            };\n        };\n    }\n    /**\n     * Recreate the editor instance if the dependencies have changed.\n     */\n    refreshEditorInstance(deps) {\n        if (this.editor && !this.editor.isDestroyed) {\n            // Editor instance already exists\n            if (this.previousDeps === null) {\n                // If lastDeps has not yet been initialized, reuse the current editor instance\n                this.previousDeps = deps;\n                return;\n            }\n            const depsAreEqual = this.previousDeps.length === deps.length\n                && this.previousDeps.every((dep, index) => dep === deps[index]);\n            if (depsAreEqual) {\n                // deps exist and are equal, no need to recreate\n                return;\n            }\n        }\n        if (this.editor && !this.editor.isDestroyed) {\n            // Destroy the editor instance if it exists\n            this.editor.destroy();\n        }\n        this.setEditor(this.createEditor());\n        // Update the lastDeps to the current deps\n        this.previousDeps = deps;\n    }\n    /**\n     * Schedule the destruction of the editor instance.\n     * This will only destroy the editor if it was not mounted on the next tick.\n     * This is to avoid destroying the editor instance when it's actually still mounted.\n     */\n    scheduleDestroy() {\n        const currentInstanceId = this.instanceId;\n        const currentEditor = this.editor;\n        // Wait two ticks to see if the component is still mounted\n        this.scheduledDestructionTimeout = setTimeout(() => {\n            if (this.isComponentMounted && this.instanceId === currentInstanceId) {\n                // If still mounted on the following tick, with the same instanceId, do not destroy the editor\n                if (currentEditor) {\n                    // just re-apply options as they might have changed\n                    currentEditor.setOptions(this.options.current);\n                }\n                return;\n            }\n            if (currentEditor && !currentEditor.isDestroyed) {\n                currentEditor.destroy();\n                if (this.instanceId === currentInstanceId) {\n                    this.setEditor(null);\n                }\n            }\n            // This allows the effect to run again between ticks\n            // which may save us from having to re-create the editor\n        }, 1);\n    }\n}\nfunction useEditor(options = {}, deps = []) {\n    const mostRecentOptions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(options);\n    mostRecentOptions.current = options;\n    const [instanceManager] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => new EditorInstanceManager(mostRecentOptions));\n    const editor = shimExports.useSyncExternalStore(instanceManager.subscribe, instanceManager.getEditor, instanceManager.getServerSnapshot);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(editor);\n    // This effect will handle creating/updating the editor instance\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(instanceManager.onRender(deps));\n    // The default behavior is to re-render on each transaction\n    // This is legacy behavior that will be removed in future versions\n    useEditorState({\n        editor,\n        selector: ({ transactionNumber }) => {\n            if (options.shouldRerenderOnTransaction === false) {\n                // This will prevent the editor from re-rendering on each transaction\n                return null;\n            }\n            // This will avoid re-rendering on the first transaction when `immediatelyRender` is set to `true`\n            if (options.immediatelyRender && transactionNumber === 0) {\n                return 0;\n            }\n            return transactionNumber + 1;\n        },\n    });\n    return editor;\n}\n\nconst EditorContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    editor: null,\n});\nconst EditorConsumer = EditorContext.Consumer;\n/**\n * A hook to get the current editor instance.\n */\nconst useCurrentEditor = () => (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(EditorContext);\n/**\n * This is the provider component for the editor.\n * It allows the editor to be accessible across the entire component tree\n * with `useCurrentEditor`.\n */\nfunction EditorProvider({ children, slotAfter, slotBefore, editorContainerProps = {}, ...editorOptions }) {\n    const editor = useEditor(editorOptions);\n    if (!editor) {\n        return null;\n    }\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(EditorContext.Provider, { value: { editor } },\n        slotBefore,\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(EditorConsumer, null, ({ editor: currentEditor }) => (react__WEBPACK_IMPORTED_MODULE_0__.createElement(EditorContent, { editor: currentEditor, ...editorContainerProps }))),\n        children,\n        slotAfter));\n}\n\nconst BubbleMenu = (props) => {\n    const [element, setElement] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const { editor: currentEditor } = useCurrentEditor();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        var _a;\n        if (!element) {\n            return;\n        }\n        if (((_a = props.editor) === null || _a === void 0 ? void 0 : _a.isDestroyed) || (currentEditor === null || currentEditor === void 0 ? void 0 : currentEditor.isDestroyed)) {\n            return;\n        }\n        const { pluginKey = 'bubbleMenu', editor, tippyOptions = {}, updateDelay, shouldShow = null, } = props;\n        const menuEditor = editor || currentEditor;\n        if (!menuEditor) {\n            console.warn('BubbleMenu component is not rendered inside of an editor component or does not have editor prop.');\n            return;\n        }\n        const plugin = (0,_tiptap_extension_bubble_menu__WEBPACK_IMPORTED_MODULE_3__.BubbleMenuPlugin)({\n            updateDelay,\n            editor: menuEditor,\n            element,\n            pluginKey,\n            shouldShow,\n            tippyOptions,\n        });\n        menuEditor.registerPlugin(plugin);\n        return () => { menuEditor.unregisterPlugin(pluginKey); };\n    }, [props.editor, currentEditor, element]);\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: setElement, className: props.className, style: { visibility: 'hidden' } }, props.children));\n};\n\nconst FloatingMenu = (props) => {\n    const [element, setElement] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const { editor: currentEditor } = useCurrentEditor();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        var _a;\n        if (!element) {\n            return;\n        }\n        if (((_a = props.editor) === null || _a === void 0 ? void 0 : _a.isDestroyed) || (currentEditor === null || currentEditor === void 0 ? void 0 : currentEditor.isDestroyed)) {\n            return;\n        }\n        const { pluginKey = 'floatingMenu', editor, tippyOptions = {}, shouldShow = null, } = props;\n        const menuEditor = editor || currentEditor;\n        if (!menuEditor) {\n            console.warn('FloatingMenu component is not rendered inside of an editor component or does not have editor prop.');\n            return;\n        }\n        const plugin = (0,_tiptap_extension_floating_menu__WEBPACK_IMPORTED_MODULE_4__.FloatingMenuPlugin)({\n            pluginKey,\n            editor: menuEditor,\n            element,\n            tippyOptions,\n            shouldShow,\n        });\n        menuEditor.registerPlugin(plugin);\n        return () => { menuEditor.unregisterPlugin(pluginKey); };\n    }, [\n        props.editor,\n        currentEditor,\n        element,\n    ]);\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { ref: setElement, className: props.className, style: { visibility: 'hidden' } }, props.children));\n};\n\nconst ReactNodeViewContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({\n    onDragStart: undefined,\n});\nconst useReactNodeView = () => (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ReactNodeViewContext);\n\nconst NodeViewContent = props => {\n    const Tag = props.as || 'div';\n    const { nodeViewContentRef } = useReactNodeView();\n    return (\n    // @ts-ignore\n    react__WEBPACK_IMPORTED_MODULE_0__.createElement(Tag, { ...props, ref: nodeViewContentRef, \"data-node-view-content\": \"\", style: {\n            whiteSpace: 'pre-wrap',\n            ...props.style,\n        } }));\n};\n\nconst NodeViewWrapper = react__WEBPACK_IMPORTED_MODULE_0__.forwardRef((props, ref) => {\n    const { onDragStart } = useReactNodeView();\n    const Tag = props.as || 'div';\n    return (\n    // @ts-ignore\n    react__WEBPACK_IMPORTED_MODULE_0__.createElement(Tag, { ...props, ref: ref, \"data-node-view-wrapper\": \"\", onDragStart: onDragStart, style: {\n            whiteSpace: 'normal',\n            ...props.style,\n        } }));\n});\n\n/**\n * Check if a component is a class component.\n * @param Component\n * @returns {boolean}\n */\nfunction isClassComponent(Component) {\n    return !!(typeof Component === 'function'\n        && Component.prototype\n        && Component.prototype.isReactComponent);\n}\n/**\n * Check if a component is a forward ref component.\n * @param Component\n * @returns {boolean}\n */\nfunction isForwardRefComponent(Component) {\n    return !!(typeof Component === 'object'\n        && Component.$$typeof\n        && (Component.$$typeof.toString() === 'Symbol(react.forward_ref)'\n            || Component.$$typeof.description === 'react.forward_ref'));\n}\n/**\n * Check if a component is a memoized component.\n * @param Component\n * @returns {boolean}\n */\nfunction isMemoComponent(Component) {\n    return !!(typeof Component === 'object'\n        && Component.$$typeof\n        && (Component.$$typeof.toString() === 'Symbol(react.memo)' || Component.$$typeof.description === 'react.memo'));\n}\n/**\n * Check if a component can safely receive a ref prop.\n * This includes class components, forwardRef components, and memoized components\n * that wrap forwardRef or class components.\n * @param Component\n * @returns {boolean}\n */\nfunction canReceiveRef(Component) {\n    // Check if it's a class component\n    if (isClassComponent(Component)) {\n        return true;\n    }\n    // Check if it's a forwardRef component\n    if (isForwardRefComponent(Component)) {\n        return true;\n    }\n    // Check if it's a memoized component\n    if (isMemoComponent(Component)) {\n        // For memoized components, check the wrapped component\n        const wrappedComponent = Component.type;\n        if (wrappedComponent) {\n            return isClassComponent(wrappedComponent) || isForwardRefComponent(wrappedComponent);\n        }\n    }\n    return false;\n}\n/**\n * Check if we're running React 19+ by detecting if function components support ref props\n * @returns {boolean}\n */\nfunction isReact19Plus() {\n    // React 19 is detected by checking React version if available\n    // In practice, we'll use a more conservative approach and assume React 18 behavior\n    // unless we can definitively detect React 19\n    try {\n        // @ts-ignore\n        if (react__WEBPACK_IMPORTED_MODULE_0__.version) {\n            const majorVersion = parseInt(react__WEBPACK_IMPORTED_MODULE_0__.version.split('.')[0], 10);\n            return majorVersion >= 19;\n        }\n    }\n    catch {\n        // Fallback to React 18 behavior if we can't determine version\n    }\n    return false;\n}\n/**\n * The ReactRenderer class. It's responsible for rendering React components inside the editor.\n * @example\n * new ReactRenderer(MyComponent, {\n *   editor,\n *   props: {\n *     foo: 'bar',\n *   },\n *   as: 'span',\n * })\n*/\nclass ReactRenderer {\n    /**\n     * Immediately creates element and renders the provided React component.\n     */\n    constructor(component, { editor, props = {}, as = 'div', className = '', }) {\n        this.ref = null;\n        this.id = Math.floor(Math.random() * 0xFFFFFFFF).toString();\n        this.component = component;\n        this.editor = editor;\n        this.props = props;\n        this.element = document.createElement(as);\n        this.element.classList.add('react-renderer');\n        if (className) {\n            this.element.classList.add(...className.split(' '));\n        }\n        // If the editor is already initialized, we will need to\n        // synchronously render the component to ensure it renders\n        // together with Prosemirror's rendering.\n        if (this.editor.isInitialized) {\n            (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.flushSync)(() => {\n                this.render();\n            });\n        }\n        else {\n            queueMicrotask(() => {\n                this.render();\n            });\n        }\n    }\n    /**\n     * Render the React component.\n     */\n    render() {\n        var _a;\n        const Component = this.component;\n        const props = this.props;\n        const editor = this.editor;\n        // Handle ref forwarding with React 18/19 compatibility\n        const isReact19 = isReact19Plus();\n        const componentCanReceiveRef = canReceiveRef(Component);\n        const elementProps = { ...props };\n        // Always remove ref if the component cannot receive it (unless React 19+)\n        if (elementProps.ref && !(isReact19 || componentCanReceiveRef)) {\n            delete elementProps.ref;\n        }\n        // Only assign our own ref if allowed\n        if (!elementProps.ref && (isReact19 || componentCanReceiveRef)) {\n            // @ts-ignore - Setting ref prop for compatible components\n            elementProps.ref = (ref) => {\n                this.ref = ref;\n            };\n        }\n        this.reactElement = react__WEBPACK_IMPORTED_MODULE_0__.createElement(Component, { ...elementProps });\n        (_a = editor === null || editor === void 0 ? void 0 : editor.contentComponent) === null || _a === void 0 ? void 0 : _a.setRenderer(this.id, this);\n    }\n    /**\n     * Re-renders the React component with new props.\n     */\n    updateProps(props = {}) {\n        this.props = {\n            ...this.props,\n            ...props,\n        };\n        this.render();\n    }\n    /**\n     * Destroy the React component.\n     */\n    destroy() {\n        var _a;\n        const editor = this.editor;\n        (_a = editor === null || editor === void 0 ? void 0 : editor.contentComponent) === null || _a === void 0 ? void 0 : _a.removeRenderer(this.id);\n    }\n    /**\n     * Update the attributes of the element that holds the React component.\n     */\n    updateAttributes(attributes) {\n        Object.keys(attributes).forEach(key => {\n            this.element.setAttribute(key, attributes[key]);\n        });\n    }\n}\n\nclass ReactNodeView extends _tiptap_core__WEBPACK_IMPORTED_MODULE_2__.NodeView {\n    constructor(component, props, options) {\n        super(component, props, options);\n        if (!this.node.isLeaf) {\n            if (this.options.contentDOMElementTag) {\n                this.contentDOMElement = document.createElement(this.options.contentDOMElementTag);\n            }\n            else {\n                this.contentDOMElement = document.createElement(this.node.isInline ? 'span' : 'div');\n            }\n            this.contentDOMElement.dataset.nodeViewContentReact = '';\n            this.contentDOMElement.dataset.nodeViewWrapper = '';\n            // For some reason the whiteSpace prop is not inherited properly in Chrome and Safari\n            // With this fix it seems to work fine\n            // See: https://github.com/ueberdosis/tiptap/issues/1197\n            this.contentDOMElement.style.whiteSpace = 'inherit';\n            const contentTarget = this.dom.querySelector('[data-node-view-content]');\n            if (!contentTarget) {\n                return;\n            }\n            contentTarget.appendChild(this.contentDOMElement);\n        }\n    }\n    /**\n     * Setup the React component.\n     * Called on initialization.\n     */\n    mount() {\n        const props = {\n            editor: this.editor,\n            node: this.node,\n            decorations: this.decorations,\n            innerDecorations: this.innerDecorations,\n            view: this.view,\n            selected: false,\n            extension: this.extension,\n            HTMLAttributes: this.HTMLAttributes,\n            getPos: () => this.getPos(),\n            updateAttributes: (attributes = {}) => this.updateAttributes(attributes),\n            deleteNode: () => this.deleteNode(),\n            ref: (0,react__WEBPACK_IMPORTED_MODULE_0__.createRef)(),\n        };\n        if (!this.component.displayName) {\n            const capitalizeFirstChar = (string) => {\n                return string.charAt(0).toUpperCase() + string.substring(1);\n            };\n            this.component.displayName = capitalizeFirstChar(this.extension.name);\n        }\n        const onDragStart = this.onDragStart.bind(this);\n        const nodeViewContentRef = element => {\n            if (element && this.contentDOMElement && element.firstChild !== this.contentDOMElement) {\n                // remove the nodeViewWrapper attribute from the element\n                if (element.hasAttribute('data-node-view-wrapper')) {\n                    element.removeAttribute('data-node-view-wrapper');\n                }\n                element.appendChild(this.contentDOMElement);\n            }\n        };\n        const context = { onDragStart, nodeViewContentRef };\n        const Component = this.component;\n        // For performance reasons, we memoize the provider component\n        // And all of the things it requires are declared outside of the component, so it doesn't need to re-render\n        const ReactNodeViewProvider = (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(componentProps => {\n            return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(ReactNodeViewContext.Provider, { value: context }, (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Component, componentProps)));\n        });\n        ReactNodeViewProvider.displayName = 'ReactNodeView';\n        let as = this.node.isInline ? 'span' : 'div';\n        if (this.options.as) {\n            as = this.options.as;\n        }\n        const { className = '' } = this.options;\n        this.handleSelectionUpdate = this.handleSelectionUpdate.bind(this);\n        this.renderer = new ReactRenderer(ReactNodeViewProvider, {\n            editor: this.editor,\n            props,\n            as,\n            className: `node-${this.node.type.name} ${className}`.trim(),\n        });\n        this.editor.on('selectionUpdate', this.handleSelectionUpdate);\n        this.updateElementAttributes();\n    }\n    /**\n     * Return the DOM element.\n     * This is the element that will be used to display the node view.\n     */\n    get dom() {\n        var _a;\n        if (this.renderer.element.firstElementChild\n            && !((_a = this.renderer.element.firstElementChild) === null || _a === void 0 ? void 0 : _a.hasAttribute('data-node-view-wrapper'))) {\n            throw Error('Please use the NodeViewWrapper component for your node view.');\n        }\n        return this.renderer.element;\n    }\n    /**\n     * Return the content DOM element.\n     * This is the element that will be used to display the rich-text content of the node.\n     */\n    get contentDOM() {\n        if (this.node.isLeaf) {\n            return null;\n        }\n        return this.contentDOMElement;\n    }\n    /**\n     * On editor selection update, check if the node is selected.\n     * If it is, call `selectNode`, otherwise call `deselectNode`.\n     */\n    handleSelectionUpdate() {\n        const { from, to } = this.editor.state.selection;\n        const pos = this.getPos();\n        if (typeof pos !== 'number') {\n            return;\n        }\n        if (from <= pos && to >= pos + this.node.nodeSize) {\n            if (this.renderer.props.selected) {\n                return;\n            }\n            this.selectNode();\n        }\n        else {\n            if (!this.renderer.props.selected) {\n                return;\n            }\n            this.deselectNode();\n        }\n    }\n    /**\n     * On update, update the React component.\n     * To prevent unnecessary updates, the `update` option can be used.\n     */\n    update(node, decorations, innerDecorations) {\n        const rerenderComponent = (props) => {\n            this.renderer.updateProps(props);\n            if (typeof this.options.attrs === 'function') {\n                this.updateElementAttributes();\n            }\n        };\n        if (node.type !== this.node.type) {\n            return false;\n        }\n        if (typeof this.options.update === 'function') {\n            const oldNode = this.node;\n            const oldDecorations = this.decorations;\n            const oldInnerDecorations = this.innerDecorations;\n            this.node = node;\n            this.decorations = decorations;\n            this.innerDecorations = innerDecorations;\n            return this.options.update({\n                oldNode,\n                oldDecorations,\n                newNode: node,\n                newDecorations: decorations,\n                oldInnerDecorations,\n                innerDecorations,\n                updateProps: () => rerenderComponent({ node, decorations, innerDecorations }),\n            });\n        }\n        if (node === this.node\n            && this.decorations === decorations\n            && this.innerDecorations === innerDecorations) {\n            return true;\n        }\n        this.node = node;\n        this.decorations = decorations;\n        this.innerDecorations = innerDecorations;\n        rerenderComponent({ node, decorations, innerDecorations });\n        return true;\n    }\n    /**\n     * Select the node.\n     * Add the `selected` prop and the `ProseMirror-selectednode` class.\n     */\n    selectNode() {\n        this.renderer.updateProps({\n            selected: true,\n        });\n        this.renderer.element.classList.add('ProseMirror-selectednode');\n    }\n    /**\n     * Deselect the node.\n     * Remove the `selected` prop and the `ProseMirror-selectednode` class.\n     */\n    deselectNode() {\n        this.renderer.updateProps({\n            selected: false,\n        });\n        this.renderer.element.classList.remove('ProseMirror-selectednode');\n    }\n    /**\n     * Destroy the React component instance.\n     */\n    destroy() {\n        this.renderer.destroy();\n        this.editor.off('selectionUpdate', this.handleSelectionUpdate);\n        this.contentDOMElement = null;\n    }\n    /**\n     * Update the attributes of the top-level element that holds the React component.\n     * Applying the attributes defined in the `attrs` option.\n     */\n    updateElementAttributes() {\n        if (this.options.attrs) {\n            let attrsObj = {};\n            if (typeof this.options.attrs === 'function') {\n                const extensionAttributes = this.editor.extensionManager.attributes;\n                const HTMLAttributes = (0,_tiptap_core__WEBPACK_IMPORTED_MODULE_2__.getRenderedAttributes)(this.node, extensionAttributes);\n                attrsObj = this.options.attrs({ node: this.node, HTMLAttributes });\n            }\n            else {\n                attrsObj = this.options.attrs;\n            }\n            this.renderer.updateAttributes(attrsObj);\n        }\n    }\n}\n/**\n * Create a React node view renderer.\n */\nfunction ReactNodeViewRenderer(component, options) {\n    return props => {\n        // try to get the parent component\n        // this is important for vue devtools to show the component hierarchy correctly\n        // maybe it’s `undefined` because <editor-content> isn’t rendered yet\n        if (!props.editor.contentComponent) {\n            return {};\n        }\n        return new ReactNodeView(component, props, options);\n    };\n}\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3JlYWN0L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFpRTtBQUMwRztBQUMzSDtBQUN1QjtBQUMxQztBQUN3Qzs7QUFFckU7QUFDQTtBQUNBOztBQUVBLFlBQVk7O0FBRVo7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sa0NBQUssQ0FBQyxnQkFBZ0IsK0NBQStDLGlIQUFpSCxnQkFBZ0IsZUFBZSxNQUFNLHVCQUF1QixxQkFBcUIsYUFBYSxVQUFVLGdCQUFnQixTQUFTLE9BQU8sR0FBRyxVQUFVLGFBQWEsU0FBUyxPQUFPLEVBQUUsb0JBQW9CLFNBQVMsT0FBTyxHQUFHLEVBQUUsTUFBTSxLQUFLO0FBQ3BhLGVBQWUsb0JBQW9CLFVBQVUsSUFBSSxVQUFVLGVBQWUsU0FBUyxXQUFXLGdCQUFnQixXQUFXLGdJQUFnSTtBQUN6UDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSyxJQUFxQztBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGtDQUFLOztBQUU5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrR0FBa0csZUFBZTtBQUNqSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOzs7QUFHUDtBQUNBO0FBQ0EsTUFBTSxHQUFHOztBQUVULG1EQUFtRDtBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxLQUFLO0FBQ3REOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxRQUFROzs7QUFHUjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQSxZQUFZLGdEQUFtQixDQUFDLDJDQUFjO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbURBQXFCO0FBQzNDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQ0FBZ0MsNENBQWU7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDRDQUFlO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsZ0JBQWdCLDRCQUE0QjtBQUM1QyxnQkFBZ0IsZ0RBQW1CLENBQUMsMkNBQWM7QUFDbEQsWUFBWSxnREFBbUIsVUFBVSwwREFBMEQ7QUFDbkcseUZBQXlGLGdEQUFtQixZQUFZLDJDQUEyQztBQUNuSztBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsaURBQVU7QUFDdkMsZ0JBQWdCLDBDQUFhO0FBQzdCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxXQUFXLGdEQUFtQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQztBQUNELHNCQUFzQix1Q0FBVTs7QUFFaEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFVBQVU7QUFDakM7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsVUFBVTtBQUNqQztBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFVBQVU7QUFDL0I7O0FBRUEscUJBQXFCLFVBQVU7QUFDL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0JBQW9COztBQUVwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTSxrQ0FBSyxlQUFlLGdCQUFnQiwrQ0FBK0M7QUFDekYsa0ZBQWtGLGNBQWMscUJBQXFCLE9BQU8sd0JBQXdCLGFBQWEsaUJBQWlCLGVBQWUsY0FBYyxPQUFPLEtBQUssSUFBSSxPQUFPLDJCQUEyQixjQUFjLHFCQUFxQixXQUFXLElBQUksbUJBQW1CLFdBQVcsK0JBQStCLElBQUksV0FBVyxpQ0FBaUMsbUJBQW1CLGNBQWMsNEJBQTRCLGNBQWMsRUFBRSxZQUFZO0FBQ3pmLGNBQWMsY0FBYyxXQUFXLE1BQU0sS0FBSztBQUNsRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsS0FBSyxJQUFxQztBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGtDQUFLO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNENBQTRDOztBQUU1QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUzs7O0FBR1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7OztBQUdUO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRjtBQUNBOztBQUVBOztBQUVBLGtFQUFrRSxrREFBZSxHQUFHLDRDQUFTO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsV0FBVztBQUN4QyxXQUFXLG1CQUFtQjtBQUM5QjtBQUNBLDZCQUE2QixtREFBbUQ7QUFDaEYsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywrQ0FBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLG9EQUFhO0FBQ2pCO0FBQ0E7O0FBRUEsY0FBYyxhQUFvQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxZQUFZLHFIQUFxSDtBQUM1SyxtQ0FBbUMsWUFBWSw2R0FBNkc7QUFDNUoscUNBQXFDLFlBQVksK0dBQStHO0FBQ2hLLHNDQUFzQyxZQUFZLGdIQUFnSDtBQUNsSyxvQ0FBb0MsWUFBWSw4R0FBOEc7QUFDOUosOENBQThDLFlBQVksd0hBQXdIO0FBQ2xMLDBDQUEwQyxZQUFZLG9IQUFvSDtBQUMxSyxxQ0FBcUMsWUFBWSwrR0FBK0c7QUFDaEssMkNBQTJDLFlBQVkscUhBQXFIO0FBQzVLLG1DQUFtQyxZQUFZLDZHQUE2RztBQUM1SixvQ0FBb0MsWUFBWSw4R0FBOEc7QUFDOUo7QUFDQSwyQkFBMkIsZ0RBQU07QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0IsOEJBQThCLDZDQUFNO0FBQ3BDO0FBQ0EsOEJBQThCLCtDQUFRO0FBQ3RDO0FBQ0EsSUFBSSxvREFBYTtBQUNqQjtBQUNBO0FBQ0EsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1CQUFtQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7O0FBRUEsc0JBQXNCLG9EQUFhO0FBQ25DO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlEQUFVO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMERBQTBELG9CQUFvQjtBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZ0RBQW1CLDJCQUEyQixTQUFTLFVBQVU7QUFDN0U7QUFDQSxRQUFRLGdEQUFtQiwwQkFBMEIsdUJBQXVCLE1BQU0sZ0RBQW1CLGtCQUFrQixnREFBZ0Q7QUFDdks7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDLCtDQUFRO0FBQzFDLFlBQVksd0JBQXdCO0FBQ3BDLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtREFBbUQsb0NBQW9DO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsK0VBQWdCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHVCQUF1QjtBQUN2QixLQUFLO0FBQ0wsWUFBWSxnREFBbUIsVUFBVSxzREFBc0Qsd0JBQXdCO0FBQ3ZIOztBQUVBO0FBQ0Esa0NBQWtDLCtDQUFRO0FBQzFDLFlBQVksd0JBQXdCO0FBQ3BDLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxREFBcUQsdUJBQXVCO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUZBQWtCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx1QkFBdUI7QUFDdkIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxnREFBbUIsVUFBVSxzREFBc0Qsd0JBQXdCO0FBQ3ZIOztBQUVBLDZCQUE2QixvREFBYTtBQUMxQztBQUNBLENBQUM7QUFDRCwrQkFBK0IsaURBQVU7O0FBRXpDO0FBQ0E7QUFDQSxZQUFZLHFCQUFxQjtBQUNqQztBQUNBO0FBQ0EsSUFBSSxnREFBbUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBLHdCQUF3Qiw2Q0FBZ0I7QUFDeEMsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0RBQW1CLFFBQVE7QUFDL0I7QUFDQTtBQUNBLFdBQVc7QUFDWCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMENBQU87QUFDbkIsMENBQTBDLDBDQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGtCQUFrQiwrQkFBK0I7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksb0RBQVM7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnREFBbUIsY0FBYyxpQkFBaUI7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsNEJBQTRCLGtEQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0EsaUJBQWlCLGdEQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDJDQUFJO0FBQzFDLG9CQUFvQixnREFBbUIsa0NBQWtDLGdCQUFnQixFQUFFLG9EQUFhO0FBQ3hHLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHFCQUFxQixFQUFFLFVBQVU7QUFDaEUsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxxQ0FBcUM7QUFDNUYsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixxQ0FBcUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxtRUFBcUI7QUFDNUQsZ0RBQWdELGlDQUFpQztBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFaVM7QUFDalMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvcmVhY3QvZGlzdC9pbmRleC5qcz84MDNhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJ1YmJsZU1lbnVQbHVnaW4gfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1idWJibGUtbWVudSc7XG5pbXBvcnQgUmVhY3QsIHsgZm9yd2FyZFJlZiwgdXNlU3RhdGUsIHVzZURlYnVnVmFsdWUsIHVzZUxheW91dEVmZmVjdCwgdXNlRWZmZWN0LCB1c2VSZWYsIGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHZlcnNpb24sIGNyZWF0ZVJlZiwgbWVtbywgY3JlYXRlRWxlbWVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBSZWFjdERPTSwgeyBmbHVzaFN5bmMgfSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IHsgRWRpdG9yLCBOb2RlVmlldywgZ2V0UmVuZGVyZWRBdHRyaWJ1dGVzIH0gZnJvbSAnQHRpcHRhcC9jb3JlJztcbmV4cG9ydCAqIGZyb20gJ0B0aXB0YXAvY29yZSc7XG5pbXBvcnQgeyBGbG9hdGluZ01lbnVQbHVnaW4gfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1mbG9hdGluZy1tZW51JztcblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMgKHgpIHtcblx0cmV0dXJuIHggJiYgeC5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnZGVmYXVsdCcpID8geFsnZGVmYXVsdCddIDogeDtcbn1cblxudmFyIHNoaW0gPSB7ZXhwb3J0czoge319O1xuXG52YXIgdXNlU3luY0V4dGVybmFsU3RvcmVTaGltX3Byb2R1Y3Rpb25fbWluID0ge307XG5cbi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHVzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXNoaW0ucHJvZHVjdGlvbi5taW4uanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIgaGFzUmVxdWlyZWRVc2VTeW5jRXh0ZXJuYWxTdG9yZVNoaW1fcHJvZHVjdGlvbl9taW47XG5cbmZ1bmN0aW9uIHJlcXVpcmVVc2VTeW5jRXh0ZXJuYWxTdG9yZVNoaW1fcHJvZHVjdGlvbl9taW4gKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRVc2VTeW5jRXh0ZXJuYWxTdG9yZVNoaW1fcHJvZHVjdGlvbl9taW4pIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZVNoaW1fcHJvZHVjdGlvbl9taW47XG5cdGhhc1JlcXVpcmVkVXNlU3luY0V4dGVybmFsU3RvcmVTaGltX3Byb2R1Y3Rpb25fbWluID0gMTtcbnZhciBlPVJlYWN0O2Z1bmN0aW9uIGgoYSxiKXtyZXR1cm4gYT09PWImJigwIT09YXx8MS9hPT09MS9iKXx8YSE9PWEmJmIhPT1ifXZhciBrPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBPYmplY3QuaXM/T2JqZWN0LmlzOmgsbD1lLnVzZVN0YXRlLG09ZS51c2VFZmZlY3Qsbj1lLnVzZUxheW91dEVmZmVjdCxwPWUudXNlRGVidWdWYWx1ZTtmdW5jdGlvbiBxKGEsYil7dmFyIGQ9YigpLGY9bCh7aW5zdDp7dmFsdWU6ZCxnZXRTbmFwc2hvdDpifX0pLGM9ZlswXS5pbnN0LGc9ZlsxXTtuKGZ1bmN0aW9uKCl7Yy52YWx1ZT1kO2MuZ2V0U25hcHNob3Q9YjtyKGMpJiZnKHtpbnN0OmN9KTt9LFthLGQsYl0pO20oZnVuY3Rpb24oKXtyKGMpJiZnKHtpbnN0OmN9KTtyZXR1cm4gYShmdW5jdGlvbigpe3IoYykmJmcoe2luc3Q6Y30pO30pfSxbYV0pO3AoZCk7cmV0dXJuIGR9XG5cdGZ1bmN0aW9uIHIoYSl7dmFyIGI9YS5nZXRTbmFwc2hvdDthPWEudmFsdWU7dHJ5e3ZhciBkPWIoKTtyZXR1cm4gIWsoYSxkKX1jYXRjaChmKXtyZXR1cm4gITB9fWZ1bmN0aW9uIHQoYSxiKXtyZXR1cm4gYigpfXZhciB1PVwidW5kZWZpbmVkXCI9PT10eXBlb2Ygd2luZG93fHxcInVuZGVmaW5lZFwiPT09dHlwZW9mIHdpbmRvdy5kb2N1bWVudHx8XCJ1bmRlZmluZWRcIj09PXR5cGVvZiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudD90OnE7dXNlU3luY0V4dGVybmFsU3RvcmVTaGltX3Byb2R1Y3Rpb25fbWluLnVzZVN5bmNFeHRlcm5hbFN0b3JlPXZvaWQgMCE9PWUudXNlU3luY0V4dGVybmFsU3RvcmU/ZS51c2VTeW5jRXh0ZXJuYWxTdG9yZTp1O1xuXHRyZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmVTaGltX3Byb2R1Y3Rpb25fbWluO1xufVxuXG52YXIgdXNlU3luY0V4dGVybmFsU3RvcmVTaGltX2RldmVsb3BtZW50ID0ge307XG5cbi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHVzZS1zeW5jLWV4dGVybmFsLXN0b3JlLXNoaW0uZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG52YXIgaGFzUmVxdWlyZWRVc2VTeW5jRXh0ZXJuYWxTdG9yZVNoaW1fZGV2ZWxvcG1lbnQ7XG5cbmZ1bmN0aW9uIHJlcXVpcmVVc2VTeW5jRXh0ZXJuYWxTdG9yZVNoaW1fZGV2ZWxvcG1lbnQgKCkge1xuXHRpZiAoaGFzUmVxdWlyZWRVc2VTeW5jRXh0ZXJuYWxTdG9yZVNoaW1fZGV2ZWxvcG1lbnQpIHJldHVybiB1c2VTeW5jRXh0ZXJuYWxTdG9yZVNoaW1fZGV2ZWxvcG1lbnQ7XG5cdGhhc1JlcXVpcmVkVXNlU3luY0V4dGVybmFsU3RvcmVTaGltX2RldmVsb3BtZW50ID0gMTtcblxuXHRpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG5cdCAgKGZ1bmN0aW9uKCkge1xuXG5cdC8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cblx0aWYgKFxuXHQgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gIT09ICd1bmRlZmluZWQnICYmXG5cdCAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQgPT09XG5cdCAgICAnZnVuY3Rpb24nXG5cdCkge1xuXHQgIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQobmV3IEVycm9yKCkpO1xuXHR9XG5cdCAgICAgICAgICB2YXIgUmVhY3QkMSA9IFJlYWN0O1xuXG5cdHZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0JDEuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cblx0ZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG5cdCAge1xuXHQgICAge1xuXHQgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuXHQgICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG5cdCAgICAgIH1cblxuXHQgICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcblx0ICAgIH1cblx0ICB9XG5cdH1cblxuXHRmdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuXHQgIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuXHQgIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuXHQgIHtcblx0ICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblx0ICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG5cdCAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG5cdCAgICAgIGZvcm1hdCArPSAnJXMnO1xuXHQgICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG5cdCAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cblx0ICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG5cdCAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG5cdCAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuXHQgICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG5cdCAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG5cdCAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cblx0ICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG5cdCAgfVxuXHR9XG5cblx0LyoqXG5cdCAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cblx0ICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG5cdCAqL1xuXHRmdW5jdGlvbiBpcyh4LCB5KSB7XG5cdCAgcmV0dXJuIHggPT09IHkgJiYgKHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5KSB8fCB4ICE9PSB4ICYmIHkgIT09IHkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcblx0ICA7XG5cdH1cblxuXHR2YXIgb2JqZWN0SXMgPSB0eXBlb2YgT2JqZWN0LmlzID09PSAnZnVuY3Rpb24nID8gT2JqZWN0LmlzIDogaXM7XG5cblx0Ly8gZGlzcGF0Y2ggZm9yIENvbW1vbkpTIGludGVyb3AgbmFtZWQgaW1wb3J0cy5cblxuXHR2YXIgdXNlU3RhdGUgPSBSZWFjdCQxLnVzZVN0YXRlLFxuXHQgICAgdXNlRWZmZWN0ID0gUmVhY3QkMS51c2VFZmZlY3QsXG5cdCAgICB1c2VMYXlvdXRFZmZlY3QgPSBSZWFjdCQxLnVzZUxheW91dEVmZmVjdCxcblx0ICAgIHVzZURlYnVnVmFsdWUgPSBSZWFjdCQxLnVzZURlYnVnVmFsdWU7XG5cdHZhciBkaWRXYXJuT2xkMThBbHBoYSA9IGZhbHNlO1xuXHR2YXIgZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QgPSBmYWxzZTsgLy8gRGlzY2xhaW1lcjogVGhpcyBzaGltIGJyZWFrcyBtYW55IG9mIHRoZSBydWxlcyBvZiBSZWFjdCwgYW5kIG9ubHkgd29ya3Ncblx0Ly8gYmVjYXVzZSBvZiBhIHZlcnkgcGFydGljdWxhciBzZXQgb2YgaW1wbGVtZW50YXRpb24gZGV0YWlscyBhbmQgYXNzdW1wdGlvbnNcblx0Ly8gLS0gY2hhbmdlIGFueSBvbmUgb2YgdGhlbSBhbmQgaXQgd2lsbCBicmVhay4gVGhlIG1vc3QgaW1wb3J0YW50IGFzc3VtcHRpb25cblx0Ly8gaXMgdGhhdCB1cGRhdGVzIGFyZSBhbHdheXMgc3luY2hyb25vdXMsIGJlY2F1c2UgY29uY3VycmVudCByZW5kZXJpbmcgaXNcblx0Ly8gb25seSBhdmFpbGFibGUgaW4gdmVyc2lvbnMgb2YgUmVhY3QgdGhhdCBhbHNvIGhhdmUgYSBidWlsdC1pblxuXHQvLyB1c2VTeW5jRXh0ZXJuYWxTdG9yZSBBUEkuIEFuZCB3ZSBvbmx5IHVzZSB0aGlzIHNoaW0gd2hlbiB0aGUgYnVpbHQtaW4gQVBJXG5cdC8vIGRvZXMgbm90IGV4aXN0LlxuXHQvL1xuXHQvLyBEbyBub3QgYXNzdW1lIHRoYXQgdGhlIGNsZXZlciBoYWNrcyB1c2VkIGJ5IHRoaXMgaG9vayBhbHNvIHdvcmsgaW4gZ2VuZXJhbC5cblx0Ly8gVGhlIHBvaW50IG9mIHRoaXMgc2hpbSBpcyB0byByZXBsYWNlIHRoZSBuZWVkIGZvciBoYWNrcyBieSBvdGhlciBsaWJyYXJpZXMuXG5cblx0ZnVuY3Rpb24gdXNlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgLy8gTm90ZTogVGhlIHNoaW0gZG9lcyBub3QgdXNlIGdldFNlcnZlclNuYXBzaG90LCBiZWNhdXNlIHByZS0xOCB2ZXJzaW9ucyBvZlxuXHQvLyBSZWFjdCBkbyBub3QgZXhwb3NlIGEgd2F5IHRvIGNoZWNrIGlmIHdlJ3JlIGh5ZHJhdGluZy4gU28gdXNlcnMgb2YgdGhlIHNoaW1cblx0Ly8gd2lsbCBuZWVkIHRvIHRyYWNrIHRoYXQgdGhlbXNlbHZlcyBhbmQgcmV0dXJuIHRoZSBjb3JyZWN0IHZhbHVlXG5cdC8vIGZyb20gYGdldFNuYXBzaG90YC5cblx0Z2V0U2VydmVyU25hcHNob3QpIHtcblx0ICB7XG5cdCAgICBpZiAoIWRpZFdhcm5PbGQxOEFscGhhKSB7XG5cdCAgICAgIGlmIChSZWFjdCQxLnN0YXJ0VHJhbnNpdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgZGlkV2Fybk9sZDE4QWxwaGEgPSB0cnVlO1xuXG5cdCAgICAgICAgZXJyb3IoJ1lvdSBhcmUgdXNpbmcgYW4gb3V0ZGF0ZWQsIHByZS1yZWxlYXNlIGFscGhhIG9mIFJlYWN0IDE4IHRoYXQgJyArICdkb2VzIG5vdCBzdXBwb3J0IHVzZVN5bmNFeHRlcm5hbFN0b3JlLiBUaGUgJyArICd1c2Utc3luYy1leHRlcm5hbC1zdG9yZSBzaGltIHdpbGwgbm90IHdvcmsgY29ycmVjdGx5LiBVcGdyYWRlICcgKyAndG8gYSBuZXdlciBwcmUtcmVsZWFzZS4nKTtcblx0ICAgICAgfVxuXHQgICAgfVxuXHQgIH0gLy8gUmVhZCB0aGUgY3VycmVudCBzbmFwc2hvdCBmcm9tIHRoZSBzdG9yZSBvbiBldmVyeSByZW5kZXIuIEFnYWluLCB0aGlzXG5cdCAgLy8gYnJlYWtzIHRoZSBydWxlcyBvZiBSZWFjdCwgYW5kIG9ubHkgd29ya3MgaGVyZSBiZWNhdXNlIG9mIHNwZWNpZmljXG5cdCAgLy8gaW1wbGVtZW50YXRpb24gZGV0YWlscywgbW9zdCBpbXBvcnRhbnRseSB0aGF0IHVwZGF0ZXMgYXJlXG5cdCAgLy8gYWx3YXlzIHN5bmNocm9ub3VzLlxuXG5cblx0ICB2YXIgdmFsdWUgPSBnZXRTbmFwc2hvdCgpO1xuXG5cdCAge1xuXHQgICAgaWYgKCFkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCkge1xuXHQgICAgICB2YXIgY2FjaGVkVmFsdWUgPSBnZXRTbmFwc2hvdCgpO1xuXG5cdCAgICAgIGlmICghb2JqZWN0SXModmFsdWUsIGNhY2hlZFZhbHVlKSkge1xuXHQgICAgICAgIGVycm9yKCdUaGUgcmVzdWx0IG9mIGdldFNuYXBzaG90IHNob3VsZCBiZSBjYWNoZWQgdG8gYXZvaWQgYW4gaW5maW5pdGUgbG9vcCcpO1xuXG5cdCAgICAgICAgZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QgPSB0cnVlO1xuXHQgICAgICB9XG5cdCAgICB9XG5cdCAgfSAvLyBCZWNhdXNlIHVwZGF0ZXMgYXJlIHN5bmNocm9ub3VzLCB3ZSBkb24ndCBxdWV1ZSB0aGVtLiBJbnN0ZWFkIHdlIGZvcmNlIGFcblx0ICAvLyByZS1yZW5kZXIgd2hlbmV2ZXIgdGhlIHN1YnNjcmliZWQgc3RhdGUgY2hhbmdlcyBieSB1cGRhdGluZyBhbiBzb21lXG5cdCAgLy8gYXJiaXRyYXJ5IHVzZVN0YXRlIGhvb2suIFRoZW4sIGR1cmluZyByZW5kZXIsIHdlIGNhbGwgZ2V0U25hcHNob3QgdG8gcmVhZFxuXHQgIC8vIHRoZSBjdXJyZW50IHZhbHVlLlxuXHQgIC8vXG5cdCAgLy8gQmVjYXVzZSB3ZSBkb24ndCBhY3R1YWxseSB1c2UgdGhlIHN0YXRlIHJldHVybmVkIGJ5IHRoZSB1c2VTdGF0ZSBob29rLCB3ZVxuXHQgIC8vIGNhbiBzYXZlIGEgYml0IG9mIG1lbW9yeSBieSBzdG9yaW5nIG90aGVyIHN0dWZmIGluIHRoYXQgc2xvdC5cblx0ICAvL1xuXHQgIC8vIFRvIGltcGxlbWVudCB0aGUgZWFybHkgYmFpbG91dCwgd2UgbmVlZCB0byB0cmFjayBzb21lIHRoaW5ncyBvbiBhIG11dGFibGVcblx0ICAvLyBvYmplY3QuIFVzdWFsbHksIHdlIHdvdWxkIHB1dCB0aGF0IGluIGEgdXNlUmVmIGhvb2ssIGJ1dCB3ZSBjYW4gc3Rhc2ggaXQgaW5cblx0ICAvLyBvdXIgdXNlU3RhdGUgaG9vayBpbnN0ZWFkLlxuXHQgIC8vXG5cdCAgLy8gVG8gZm9yY2UgYSByZS1yZW5kZXIsIHdlIGNhbGwgZm9yY2VVcGRhdGUoe2luc3R9KS4gVGhhdCB3b3JrcyBiZWNhdXNlIHRoZVxuXHQgIC8vIG5ldyBvYmplY3QgYWx3YXlzIGZhaWxzIGFuIGVxdWFsaXR5IGNoZWNrLlxuXG5cblx0ICB2YXIgX3VzZVN0YXRlID0gdXNlU3RhdGUoe1xuXHQgICAgaW5zdDoge1xuXHQgICAgICB2YWx1ZTogdmFsdWUsXG5cdCAgICAgIGdldFNuYXBzaG90OiBnZXRTbmFwc2hvdFxuXHQgICAgfVxuXHQgIH0pLFxuXHQgICAgICBpbnN0ID0gX3VzZVN0YXRlWzBdLmluc3QsXG5cdCAgICAgIGZvcmNlVXBkYXRlID0gX3VzZVN0YXRlWzFdOyAvLyBUcmFjayB0aGUgbGF0ZXN0IGdldFNuYXBzaG90IGZ1bmN0aW9uIHdpdGggYSByZWYuIFRoaXMgbmVlZHMgdG8gYmUgdXBkYXRlZFxuXHQgIC8vIGluIHRoZSBsYXlvdXQgcGhhc2Ugc28gd2UgY2FuIGFjY2VzcyBpdCBkdXJpbmcgdGhlIHRlYXJpbmcgY2hlY2sgdGhhdFxuXHQgIC8vIGhhcHBlbnMgb24gc3Vic2NyaWJlLlxuXG5cblx0ICB1c2VMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuXHQgICAgaW5zdC52YWx1ZSA9IHZhbHVlO1xuXHQgICAgaW5zdC5nZXRTbmFwc2hvdCA9IGdldFNuYXBzaG90OyAvLyBXaGVuZXZlciBnZXRTbmFwc2hvdCBvciBzdWJzY3JpYmUgY2hhbmdlcywgd2UgbmVlZCB0byBjaGVjayBpbiB0aGVcblx0ICAgIC8vIGNvbW1pdCBwaGFzZSBpZiB0aGVyZSB3YXMgYW4gaW50ZXJsZWF2ZWQgbXV0YXRpb24uIEluIGNvbmN1cnJlbnQgbW9kZVxuXHQgICAgLy8gdGhpcyBjYW4gaGFwcGVuIGFsbCB0aGUgdGltZSwgYnV0IGV2ZW4gaW4gc3luY2hyb25vdXMgbW9kZSwgYW4gZWFybGllclxuXHQgICAgLy8gZWZmZWN0IG1heSBoYXZlIG11dGF0ZWQgdGhlIHN0b3JlLlxuXG5cdCAgICBpZiAoY2hlY2tJZlNuYXBzaG90Q2hhbmdlZChpbnN0KSkge1xuXHQgICAgICAvLyBGb3JjZSBhIHJlLXJlbmRlci5cblx0ICAgICAgZm9yY2VVcGRhdGUoe1xuXHQgICAgICAgIGluc3Q6IGluc3Rcblx0ICAgICAgfSk7XG5cdCAgICB9XG5cdCAgfSwgW3N1YnNjcmliZSwgdmFsdWUsIGdldFNuYXBzaG90XSk7XG5cdCAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIENoZWNrIGZvciBjaGFuZ2VzIHJpZ2h0IGJlZm9yZSBzdWJzY3JpYmluZy4gU3Vic2VxdWVudCBjaGFuZ2VzIHdpbGwgYmVcblx0ICAgIC8vIGRldGVjdGVkIGluIHRoZSBzdWJzY3JpcHRpb24gaGFuZGxlci5cblx0ICAgIGlmIChjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpKSB7XG5cdCAgICAgIC8vIEZvcmNlIGEgcmUtcmVuZGVyLlxuXHQgICAgICBmb3JjZVVwZGF0ZSh7XG5cdCAgICAgICAgaW5zdDogaW5zdFxuXHQgICAgICB9KTtcblx0ICAgIH1cblxuXHQgICAgdmFyIGhhbmRsZVN0b3JlQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAvLyBUT0RPOiBCZWNhdXNlIHRoZXJlIGlzIG5vIGNyb3NzLXJlbmRlcmVyIEFQSSBmb3IgYmF0Y2hpbmcgdXBkYXRlcywgaXQnc1xuXHQgICAgICAvLyB1cCB0byB0aGUgY29uc3VtZXIgb2YgdGhpcyBsaWJyYXJ5IHRvIHdyYXAgdGhlaXIgc3Vic2NyaXB0aW9uIGV2ZW50XG5cdCAgICAgIC8vIHdpdGggdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMuIFNob3VsZCB3ZSB0cnkgdG8gZGV0ZWN0IHdoZW4gdGhpcyBpc24ndFxuXHQgICAgICAvLyB0aGUgY2FzZSBhbmQgcHJpbnQgYSB3YXJuaW5nIGluIGRldmVsb3BtZW50P1xuXHQgICAgICAvLyBUaGUgc3RvcmUgY2hhbmdlZC4gQ2hlY2sgaWYgdGhlIHNuYXBzaG90IGNoYW5nZWQgc2luY2UgdGhlIGxhc3QgdGltZSB3ZVxuXHQgICAgICAvLyByZWFkIGZyb20gdGhlIHN0b3JlLlxuXHQgICAgICBpZiAoY2hlY2tJZlNuYXBzaG90Q2hhbmdlZChpbnN0KSkge1xuXHQgICAgICAgIC8vIEZvcmNlIGEgcmUtcmVuZGVyLlxuXHQgICAgICAgIGZvcmNlVXBkYXRlKHtcblx0ICAgICAgICAgIGluc3Q6IGluc3Rcblx0ICAgICAgICB9KTtcblx0ICAgICAgfVxuXHQgICAgfTsgLy8gU3Vic2NyaWJlIHRvIHRoZSBzdG9yZSBhbmQgcmV0dXJuIGEgY2xlYW4tdXAgZnVuY3Rpb24uXG5cblxuXHQgICAgcmV0dXJuIHN1YnNjcmliZShoYW5kbGVTdG9yZUNoYW5nZSk7XG5cdCAgfSwgW3N1YnNjcmliZV0pO1xuXHQgIHVzZURlYnVnVmFsdWUodmFsdWUpO1xuXHQgIHJldHVybiB2YWx1ZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCkge1xuXHQgIHZhciBsYXRlc3RHZXRTbmFwc2hvdCA9IGluc3QuZ2V0U25hcHNob3Q7XG5cdCAgdmFyIHByZXZWYWx1ZSA9IGluc3QudmFsdWU7XG5cblx0ICB0cnkge1xuXHQgICAgdmFyIG5leHRWYWx1ZSA9IGxhdGVzdEdldFNuYXBzaG90KCk7XG5cdCAgICByZXR1cm4gIW9iamVjdElzKHByZXZWYWx1ZSwgbmV4dFZhbHVlKTtcblx0ICB9IGNhdGNoIChlcnJvcikge1xuXHQgICAgcmV0dXJuIHRydWU7XG5cdCAgfVxuXHR9XG5cblx0ZnVuY3Rpb24gdXNlU3luY0V4dGVybmFsU3RvcmUkMShzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCkge1xuXHQgIC8vIE5vdGU6IFRoZSBzaGltIGRvZXMgbm90IHVzZSBnZXRTZXJ2ZXJTbmFwc2hvdCwgYmVjYXVzZSBwcmUtMTggdmVyc2lvbnMgb2Zcblx0ICAvLyBSZWFjdCBkbyBub3QgZXhwb3NlIGEgd2F5IHRvIGNoZWNrIGlmIHdlJ3JlIGh5ZHJhdGluZy4gU28gdXNlcnMgb2YgdGhlIHNoaW1cblx0ICAvLyB3aWxsIG5lZWQgdG8gdHJhY2sgdGhhdCB0aGVtc2VsdmVzIGFuZCByZXR1cm4gdGhlIGNvcnJlY3QgdmFsdWVcblx0ICAvLyBmcm9tIGBnZXRTbmFwc2hvdGAuXG5cdCAgcmV0dXJuIGdldFNuYXBzaG90KCk7XG5cdH1cblxuXHR2YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50ICE9PSAndW5kZWZpbmVkJyk7XG5cblx0dmFyIGlzU2VydmVyRW52aXJvbm1lbnQgPSAhY2FuVXNlRE9NO1xuXG5cdHZhciBzaGltID0gaXNTZXJ2ZXJFbnZpcm9ubWVudCA/IHVzZVN5bmNFeHRlcm5hbFN0b3JlJDEgOiB1c2VTeW5jRXh0ZXJuYWxTdG9yZTtcblx0dmFyIHVzZVN5bmNFeHRlcm5hbFN0b3JlJDIgPSBSZWFjdCQxLnVzZVN5bmNFeHRlcm5hbFN0b3JlICE9PSB1bmRlZmluZWQgPyBSZWFjdCQxLnVzZVN5bmNFeHRlcm5hbFN0b3JlIDogc2hpbTtcblxuXHR1c2VTeW5jRXh0ZXJuYWxTdG9yZVNoaW1fZGV2ZWxvcG1lbnQudXNlU3luY0V4dGVybmFsU3RvcmUgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZSQyO1xuXHQgICAgICAgICAgLyogZ2xvYmFsIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAqL1xuXHRpZiAoXG5cdCAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCcgJiZcblx0ICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wID09PVxuXHQgICAgJ2Z1bmN0aW9uJ1xuXHQpIHtcblx0ICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AobmV3IEVycm9yKCkpO1xuXHR9XG5cdCAgICAgICAgXG5cdCAgfSkoKTtcblx0fVxuXHRyZXR1cm4gdXNlU3luY0V4dGVybmFsU3RvcmVTaGltX2RldmVsb3BtZW50O1xufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBzaGltLmV4cG9ydHMgPSByZXF1aXJlVXNlU3luY0V4dGVybmFsU3RvcmVTaGltX3Byb2R1Y3Rpb25fbWluKCk7XG59IGVsc2Uge1xuICBzaGltLmV4cG9ydHMgPSByZXF1aXJlVXNlU3luY0V4dGVybmFsU3RvcmVTaGltX2RldmVsb3BtZW50KCk7XG59XG5cbnZhciBzaGltRXhwb3J0cyA9IHNoaW0uZXhwb3J0cztcblxuY29uc3QgbWVyZ2VSZWZzID0gKC4uLnJlZnMpID0+IHtcbiAgICByZXR1cm4gKG5vZGUpID0+IHtcbiAgICAgICAgcmVmcy5mb3JFYWNoKHJlZiA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJlZihub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlZikge1xuICAgICAgICAgICAgICAgIHJlZi5jdXJyZW50ID0gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbn07XG4vKipcbiAqIFRoaXMgY29tcG9uZW50IHJlbmRlcnMgYWxsIG9mIHRoZSBlZGl0b3IncyBub2RlIHZpZXdzLlxuICovXG5jb25zdCBQb3J0YWxzID0gKHsgY29udGVudENvbXBvbmVudCwgfSkgPT4ge1xuICAgIC8vIEZvciBwZXJmb3JtYW5jZSByZWFzb25zLCB3ZSByZW5kZXIgdGhlIG5vZGUgdmlldyBwb3J0YWxzIG9uIHN0YXRlIGNoYW5nZXMgb25seVxuICAgIGNvbnN0IHJlbmRlcmVycyA9IHNoaW1FeHBvcnRzLnVzZVN5bmNFeHRlcm5hbFN0b3JlKGNvbnRlbnRDb21wb25lbnQuc3Vic2NyaWJlLCBjb250ZW50Q29tcG9uZW50LmdldFNuYXBzaG90LCBjb250ZW50Q29tcG9uZW50LmdldFNlcnZlclNuYXBzaG90KTtcbiAgICAvLyBUaGlzIGFsbG93cyB1cyB0byBkaXJlY3RseSByZW5kZXIgdGhlIHBvcnRhbHMgd2l0aG91dCBhbnkgYWRkaXRpb25hbCB3cmFwcGVyXG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCBPYmplY3QudmFsdWVzKHJlbmRlcmVycykpKTtcbn07XG5mdW5jdGlvbiBnZXRJbnN0YW5jZSgpIHtcbiAgICBjb25zdCBzdWJzY3JpYmVycyA9IG5ldyBTZXQoKTtcbiAgICBsZXQgcmVuZGVyZXJzID0ge307XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN1YnNjcmliZSB0byB0aGUgZWRpdG9yIGluc3RhbmNlJ3MgY2hhbmdlcy5cbiAgICAgICAgICovXG4gICAgICAgIHN1YnNjcmliZShjYWxsYmFjaykge1xuICAgICAgICAgICAgc3Vic2NyaWJlcnMuYWRkKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlcnMuZGVsZXRlKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGdldFNuYXBzaG90KCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlbmRlcmVycztcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0U2VydmVyU25hcHNob3QoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVuZGVyZXJzO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyBhIG5ldyBOb2RlVmlldyBSZW5kZXJlciB0byB0aGUgZWRpdG9yLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0UmVuZGVyZXIoaWQsIHJlbmRlcmVyKSB7XG4gICAgICAgICAgICByZW5kZXJlcnMgPSB7XG4gICAgICAgICAgICAgICAgLi4ucmVuZGVyZXJzLFxuICAgICAgICAgICAgICAgIFtpZF06IFJlYWN0RE9NLmNyZWF0ZVBvcnRhbChyZW5kZXJlci5yZWFjdEVsZW1lbnQsIHJlbmRlcmVyLmVsZW1lbnQsIGlkKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzdWJzY3JpYmVycy5mb3JFYWNoKHN1YnNjcmliZXIgPT4gc3Vic2NyaWJlcigpKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZXMgYSBOb2RlVmlldyBSZW5kZXJlciBmcm9tIHRoZSBlZGl0b3IuXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmVSZW5kZXJlcihpZCkge1xuICAgICAgICAgICAgY29uc3QgbmV4dFJlbmRlcmVycyA9IHsgLi4ucmVuZGVyZXJzIH07XG4gICAgICAgICAgICBkZWxldGUgbmV4dFJlbmRlcmVyc1tpZF07XG4gICAgICAgICAgICByZW5kZXJlcnMgPSBuZXh0UmVuZGVyZXJzO1xuICAgICAgICAgICAgc3Vic2NyaWJlcnMuZm9yRWFjaChzdWJzY3JpYmVyID0+IHN1YnNjcmliZXIoKSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmNsYXNzIFB1cmVFZGl0b3JDb250ZW50IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgICAgdGhpcy5lZGl0b3JDb250ZW50UmVmID0gUmVhY3QuY3JlYXRlUmVmKCk7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGhhc0NvbnRlbnRDb21wb25lbnRJbml0aWFsaXplZDogQm9vbGVhbigoX2EgPSBwcm9wcy5lZGl0b3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250ZW50Q29tcG9uZW50KSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29tcG9uZW50RGlkTW91bnQoKSB7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgIH1cbiAgICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgIH1cbiAgICBpbml0KCkge1xuICAgICAgICBjb25zdCBlZGl0b3IgPSB0aGlzLnByb3BzLmVkaXRvcjtcbiAgICAgICAgaWYgKGVkaXRvciAmJiAhZWRpdG9yLmlzRGVzdHJveWVkICYmIGVkaXRvci5vcHRpb25zLmVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChlZGl0b3IuY29udGVudENvbXBvbmVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVkaXRvckNvbnRlbnRSZWYuY3VycmVudDtcbiAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kKC4uLmVkaXRvci5vcHRpb25zLmVsZW1lbnQuY2hpbGROb2Rlcyk7XG4gICAgICAgICAgICBlZGl0b3Iuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZWRpdG9yLmNvbnRlbnRDb21wb25lbnQgPSBnZXRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgLy8gSGFzIHRoZSBjb250ZW50IGNvbXBvbmVudCBiZWVuIGluaXRpYWxpemVkP1xuICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXRlLmhhc0NvbnRlbnRDb21wb25lbnRJbml0aWFsaXplZCkge1xuICAgICAgICAgICAgICAgIC8vIFN1YnNjcmliZSB0byB0aGUgY29udGVudCBjb21wb25lbnRcbiAgICAgICAgICAgICAgICB0aGlzLnVuc3Vic2NyaWJlVG9Db250ZW50Q29tcG9uZW50ID0gZWRpdG9yLmNvbnRlbnRDb21wb25lbnQuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZShwcmV2U3RhdGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwcmV2U3RhdGUuaGFzQ29udGVudENvbXBvbmVudEluaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzQ29udGVudENvbXBvbmVudEluaXRpYWxpemVkOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJldlN0YXRlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVW5zdWJzY3JpYmUgdG8gcHJldmlvdXMgY29udGVudCBjb21wb25lbnRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudW5zdWJzY3JpYmVUb0NvbnRlbnRDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmVUb0NvbnRlbnRDb21wb25lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWRpdG9yLmNyZWF0ZU5vZGVWaWV3cygpO1xuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgICAgIGNvbnN0IGVkaXRvciA9IHRoaXMucHJvcHMuZWRpdG9yO1xuICAgICAgICBpZiAoIWVkaXRvcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKCFlZGl0b3IuaXNEZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIGVkaXRvci52aWV3LnNldFByb3BzKHtcbiAgICAgICAgICAgICAgICBub2RlVmlld3M6IHt9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudW5zdWJzY3JpYmVUb0NvbnRlbnRDb21wb25lbnQpIHtcbiAgICAgICAgICAgIHRoaXMudW5zdWJzY3JpYmVUb0NvbnRlbnRDb21wb25lbnQoKTtcbiAgICAgICAgfVxuICAgICAgICBlZGl0b3IuY29udGVudENvbXBvbmVudCA9IG51bGw7XG4gICAgICAgIGlmICghZWRpdG9yLm9wdGlvbnMuZWxlbWVudC5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBuZXdFbGVtZW50LmFwcGVuZCguLi5lZGl0b3Iub3B0aW9ucy5lbGVtZW50LmNoaWxkTm9kZXMpO1xuICAgICAgICBlZGl0b3Iuc2V0T3B0aW9ucyh7XG4gICAgICAgICAgICBlbGVtZW50OiBuZXdFbGVtZW50LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IGVkaXRvciwgaW5uZXJSZWYsIC4uLnJlc3QgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IG1lcmdlUmVmcyhpbm5lclJlZiwgdGhpcy5lZGl0b3JDb250ZW50UmVmKSwgLi4ucmVzdCB9KSxcbiAgICAgICAgICAgIChlZGl0b3IgPT09IG51bGwgfHwgZWRpdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlZGl0b3IuY29udGVudENvbXBvbmVudCkgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChQb3J0YWxzLCB7IGNvbnRlbnRDb21wb25lbnQ6IGVkaXRvci5jb250ZW50Q29tcG9uZW50IH0pKSk7XG4gICAgfVxufVxuLy8gRWRpdG9yQ29udGVudCBzaG91bGQgYmUgcmUtY3JlYXRlZCB3aGVuZXZlciB0aGUgRWRpdG9yIGluc3RhbmNlIGNoYW5nZXNcbmNvbnN0IEVkaXRvckNvbnRlbnRXaXRoS2V5ID0gZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4ge1xuICAgIGNvbnN0IGtleSA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMHhmZmZmZmZmZikudG9TdHJpbmcoKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIH0sIFtwcm9wcy5lZGl0b3JdKTtcbiAgICAvLyBDYW4ndCB1c2UgSlNYIGhlcmUgYmVjYXVzZSBpdCBjb25mbGljdHMgd2l0aCB0aGUgdHlwZSBkZWZpbml0aW9uIG9mIFZ1ZSdzIEpTWCwgc28gdXNlIGNyZWF0ZUVsZW1lbnRcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChQdXJlRWRpdG9yQ29udGVudCwge1xuICAgICAgICBrZXksXG4gICAgICAgIGlubmVyUmVmOiByZWYsXG4gICAgICAgIC4uLnByb3BzLFxuICAgIH0pO1xufSk7XG5jb25zdCBFZGl0b3JDb250ZW50ID0gUmVhY3QubWVtbyhFZGl0b3JDb250ZW50V2l0aEtleSk7XG5cbnZhciByZWFjdCA9IGZ1bmN0aW9uIGVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xuXG4gIGlmIChhICYmIGIgJiYgdHlwZW9mIGEgPT0gJ29iamVjdCcgJiYgdHlwZW9mIGIgPT0gJ29iamVjdCcpIHtcbiAgICBpZiAoYS5jb25zdHJ1Y3RvciAhPT0gYi5jb25zdHJ1Y3RvcikgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIGxlbmd0aCwgaSwga2V5cztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXG4gICAgICAgIGlmICghZXF1YWwoYVtpXSwgYltpXSkpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuXG4gICAgaWYgKChhIGluc3RhbmNlb2YgTWFwKSAmJiAoYiBpbnN0YW5jZW9mIE1hcCkpIHtcbiAgICAgIGlmIChhLnNpemUgIT09IGIuc2l6ZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgZm9yIChpIG9mIGEuZW50cmllcygpKVxuICAgICAgICBpZiAoIWIuaGFzKGlbMF0pKSByZXR1cm4gZmFsc2U7XG4gICAgICBmb3IgKGkgb2YgYS5lbnRyaWVzKCkpXG4gICAgICAgIGlmICghZXF1YWwoaVsxXSwgYi5nZXQoaVswXSkpKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoKGEgaW5zdGFuY2VvZiBTZXQpICYmIChiIGluc3RhbmNlb2YgU2V0KSkge1xuICAgICAgaWYgKGEuc2l6ZSAhPT0gYi5zaXplKSByZXR1cm4gZmFsc2U7XG4gICAgICBmb3IgKGkgb2YgYS5lbnRyaWVzKCkpXG4gICAgICAgIGlmICghYi5oYXMoaVswXSkpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoYSkgJiYgQXJyYXlCdWZmZXIuaXNWaWV3KGIpKSB7XG4gICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOylcbiAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuXG4gICAgaWYgKGEuY29uc3RydWN0b3IgPT09IFJlZ0V4cCkgcmV0dXJuIGEuc291cmNlID09PSBiLnNvdXJjZSAmJiBhLmZsYWdzID09PSBiLmZsYWdzO1xuICAgIGlmIChhLnZhbHVlT2YgIT09IE9iamVjdC5wcm90b3R5cGUudmFsdWVPZikgcmV0dXJuIGEudmFsdWVPZigpID09PSBiLnZhbHVlT2YoKTtcbiAgICBpZiAoYS50b1N0cmluZyAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZykgcmV0dXJuIGEudG9TdHJpbmcoKSA9PT0gYi50b1N0cmluZygpO1xuXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwga2V5c1tpXSkpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmIChrZXkgPT09ICdfb3duZXInICYmIGEuJCR0eXBlb2YpIHtcbiAgICAgICAgLy8gUmVhY3Qtc3BlY2lmaWM6IGF2b2lkIHRyYXZlcnNpbmcgUmVhY3QgZWxlbWVudHMnIF9vd25lci5cbiAgICAgICAgLy8gIF9vd25lciBjb250YWlucyBjaXJjdWxhciByZWZlcmVuY2VzXG4gICAgICAgIC8vIGFuZCBpcyBub3QgbmVlZGVkIHdoZW4gY29tcGFyaW5nIHRoZSBhY3R1YWwgZWxlbWVudHMgKGFuZCBub3QgdGhlaXIgb3duZXJzKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFlcXVhbChhW2tleV0sIGJba2V5XSkpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIHRydWUgaWYgYm90aCBOYU4sIGZhbHNlIG90aGVyd2lzZVxuICByZXR1cm4gYSE9PWEgJiYgYiE9PWI7XG59O1xuXG52YXIgZGVlcEVxdWFsID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKHJlYWN0KTtcblxudmFyIHdpdGhTZWxlY3RvciA9IHtleHBvcnRzOiB7fX07XG5cbnZhciB3aXRoU2VsZWN0b3JfcHJvZHVjdGlvbl9taW4gPSB7fTtcblxuLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS93aXRoLXNlbGVjdG9yLnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxudmFyIGhhc1JlcXVpcmVkV2l0aFNlbGVjdG9yX3Byb2R1Y3Rpb25fbWluO1xuXG5mdW5jdGlvbiByZXF1aXJlV2l0aFNlbGVjdG9yX3Byb2R1Y3Rpb25fbWluICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkV2l0aFNlbGVjdG9yX3Byb2R1Y3Rpb25fbWluKSByZXR1cm4gd2l0aFNlbGVjdG9yX3Byb2R1Y3Rpb25fbWluO1xuXHRoYXNSZXF1aXJlZFdpdGhTZWxlY3Rvcl9wcm9kdWN0aW9uX21pbiA9IDE7XG52YXIgaD1SZWFjdCxuPXNoaW1FeHBvcnRzO2Z1bmN0aW9uIHAoYSxiKXtyZXR1cm4gYT09PWImJigwIT09YXx8MS9hPT09MS9iKXx8YSE9PWEmJmIhPT1ifXZhciBxPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBPYmplY3QuaXM/T2JqZWN0LmlzOnAscj1uLnVzZVN5bmNFeHRlcm5hbFN0b3JlLHQ9aC51c2VSZWYsdT1oLnVzZUVmZmVjdCx2PWgudXNlTWVtbyx3PWgudXNlRGVidWdWYWx1ZTtcblx0d2l0aFNlbGVjdG9yX3Byb2R1Y3Rpb25fbWluLnVzZVN5bmNFeHRlcm5hbFN0b3JlV2l0aFNlbGVjdG9yPWZ1bmN0aW9uKGEsYixlLGwsZyl7dmFyIGM9dChudWxsKTtpZihudWxsPT09Yy5jdXJyZW50KXt2YXIgZj17aGFzVmFsdWU6ITEsdmFsdWU6bnVsbH07Yy5jdXJyZW50PWY7fWVsc2UgZj1jLmN1cnJlbnQ7Yz12KGZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShhKXtpZighYyl7Yz0hMDtkPWE7YT1sKGEpO2lmKHZvaWQgMCE9PWcmJmYuaGFzVmFsdWUpe3ZhciBiPWYudmFsdWU7aWYoZyhiLGEpKXJldHVybiBrPWJ9cmV0dXJuIGs9YX1iPWs7aWYocShkLGEpKXJldHVybiBiO3ZhciBlPWwoYSk7aWYodm9pZCAwIT09ZyYmZyhiLGUpKXJldHVybiBiO2Q9YTtyZXR1cm4gaz1lfXZhciBjPSExLGQsayxtPXZvaWQgMD09PWU/bnVsbDplO3JldHVybiBbZnVuY3Rpb24oKXtyZXR1cm4gYShiKCkpfSxudWxsPT09bT92b2lkIDA6ZnVuY3Rpb24oKXtyZXR1cm4gYShtKCkpfV19LFtiLGUsbCxnXSk7dmFyIGQ9cihhLGNbMF0sY1sxXSk7XG5cdHUoZnVuY3Rpb24oKXtmLmhhc1ZhbHVlPSEwO2YudmFsdWU9ZDt9LFtkXSk7dyhkKTtyZXR1cm4gZH07XG5cdHJldHVybiB3aXRoU2VsZWN0b3JfcHJvZHVjdGlvbl9taW47XG59XG5cbnZhciB3aXRoU2VsZWN0b3JfZGV2ZWxvcG1lbnQgPSB7fTtcblxuLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogdXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUtc2hpbS93aXRoLXNlbGVjdG9yLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxudmFyIGhhc1JlcXVpcmVkV2l0aFNlbGVjdG9yX2RldmVsb3BtZW50O1xuXG5mdW5jdGlvbiByZXF1aXJlV2l0aFNlbGVjdG9yX2RldmVsb3BtZW50ICgpIHtcblx0aWYgKGhhc1JlcXVpcmVkV2l0aFNlbGVjdG9yX2RldmVsb3BtZW50KSByZXR1cm4gd2l0aFNlbGVjdG9yX2RldmVsb3BtZW50O1xuXHRoYXNSZXF1aXJlZFdpdGhTZWxlY3Rvcl9kZXZlbG9wbWVudCA9IDE7XG5cblx0aWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuXHQgIChmdW5jdGlvbigpIHtcblxuXHQvKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG5cdGlmIChcblx0ICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICE9PSAndW5kZWZpbmVkJyAmJlxuXHQgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0ID09PVxuXHQgICAgJ2Z1bmN0aW9uJ1xuXHQpIHtcblx0ICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0KG5ldyBFcnJvcigpKTtcblx0fVxuXHQgICAgICAgICAgdmFyIFJlYWN0JDEgPSBSZWFjdDtcblx0dmFyIHNoaW0gPSBzaGltRXhwb3J0cztcblxuXHQvKipcblx0ICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuXHQgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcblx0ICovXG5cdGZ1bmN0aW9uIGlzKHgsIHkpIHtcblx0ICByZXR1cm4geCA9PT0geSAmJiAoeCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHkpIHx8IHggIT09IHggJiYgeSAhPT0geSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxuXHQgIDtcblx0fVxuXG5cdHZhciBvYmplY3RJcyA9IHR5cGVvZiBPYmplY3QuaXMgPT09ICdmdW5jdGlvbicgPyBPYmplY3QuaXMgOiBpcztcblxuXHR2YXIgdXNlU3luY0V4dGVybmFsU3RvcmUgPSBzaGltLnVzZVN5bmNFeHRlcm5hbFN0b3JlO1xuXG5cdC8vIGZvciBDb21tb25KUyBpbnRlcm9wLlxuXG5cdHZhciB1c2VSZWYgPSBSZWFjdCQxLnVzZVJlZixcblx0ICAgIHVzZUVmZmVjdCA9IFJlYWN0JDEudXNlRWZmZWN0LFxuXHQgICAgdXNlTWVtbyA9IFJlYWN0JDEudXNlTWVtbyxcblx0ICAgIHVzZURlYnVnVmFsdWUgPSBSZWFjdCQxLnVzZURlYnVnVmFsdWU7IC8vIFNhbWUgYXMgdXNlU3luY0V4dGVybmFsU3RvcmUsIGJ1dCBzdXBwb3J0cyBzZWxlY3RvciBhbmQgaXNFcXVhbCBhcmd1bWVudHMuXG5cblx0ZnVuY3Rpb24gdXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3Ioc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QsIHNlbGVjdG9yLCBpc0VxdWFsKSB7XG5cdCAgLy8gVXNlIHRoaXMgdG8gdHJhY2sgdGhlIHJlbmRlcmVkIHNuYXBzaG90LlxuXHQgIHZhciBpbnN0UmVmID0gdXNlUmVmKG51bGwpO1xuXHQgIHZhciBpbnN0O1xuXG5cdCAgaWYgKGluc3RSZWYuY3VycmVudCA9PT0gbnVsbCkge1xuXHQgICAgaW5zdCA9IHtcblx0ICAgICAgaGFzVmFsdWU6IGZhbHNlLFxuXHQgICAgICB2YWx1ZTogbnVsbFxuXHQgICAgfTtcblx0ICAgIGluc3RSZWYuY3VycmVudCA9IGluc3Q7XG5cdCAgfSBlbHNlIHtcblx0ICAgIGluc3QgPSBpbnN0UmVmLmN1cnJlbnQ7XG5cdCAgfVxuXG5cdCAgdmFyIF91c2VNZW1vID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBUcmFjayB0aGUgbWVtb2l6ZWQgc3RhdGUgdXNpbmcgY2xvc3VyZSB2YXJpYWJsZXMgdGhhdCBhcmUgbG9jYWwgdG8gdGhpc1xuXHQgICAgLy8gbWVtb2l6ZWQgaW5zdGFuY2Ugb2YgYSBnZXRTbmFwc2hvdCBmdW5jdGlvbi4gSW50ZW50aW9uYWxseSBub3QgdXNpbmcgYVxuXHQgICAgLy8gdXNlUmVmIGhvb2ssIGJlY2F1c2UgdGhhdCBzdGF0ZSB3b3VsZCBiZSBzaGFyZWQgYWNyb3NzIGFsbCBjb25jdXJyZW50XG5cdCAgICAvLyBjb3BpZXMgb2YgdGhlIGhvb2svY29tcG9uZW50LlxuXHQgICAgdmFyIGhhc01lbW8gPSBmYWxzZTtcblx0ICAgIHZhciBtZW1vaXplZFNuYXBzaG90O1xuXHQgICAgdmFyIG1lbW9pemVkU2VsZWN0aW9uO1xuXG5cdCAgICB2YXIgbWVtb2l6ZWRTZWxlY3RvciA9IGZ1bmN0aW9uIChuZXh0U25hcHNob3QpIHtcblx0ICAgICAgaWYgKCFoYXNNZW1vKSB7XG5cdCAgICAgICAgLy8gVGhlIGZpcnN0IHRpbWUgdGhlIGhvb2sgaXMgY2FsbGVkLCB0aGVyZSBpcyBubyBtZW1vaXplZCByZXN1bHQuXG5cdCAgICAgICAgaGFzTWVtbyA9IHRydWU7XG5cdCAgICAgICAgbWVtb2l6ZWRTbmFwc2hvdCA9IG5leHRTbmFwc2hvdDtcblxuXHQgICAgICAgIHZhciBfbmV4dFNlbGVjdGlvbiA9IHNlbGVjdG9yKG5leHRTbmFwc2hvdCk7XG5cblx0ICAgICAgICBpZiAoaXNFcXVhbCAhPT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAvLyBFdmVuIGlmIHRoZSBzZWxlY3RvciBoYXMgY2hhbmdlZCwgdGhlIGN1cnJlbnRseSByZW5kZXJlZCBzZWxlY3Rpb25cblx0ICAgICAgICAgIC8vIG1heSBiZSBlcXVhbCB0byB0aGUgbmV3IHNlbGVjdGlvbi4gV2Ugc2hvdWxkIGF0dGVtcHQgdG8gcmV1c2UgdGhlXG5cdCAgICAgICAgICAvLyBjdXJyZW50IHZhbHVlIGlmIHBvc3NpYmxlLCB0byBwcmVzZXJ2ZSBkb3duc3RyZWFtIG1lbW9pemF0aW9ucy5cblx0ICAgICAgICAgIGlmIChpbnN0Lmhhc1ZhbHVlKSB7XG5cdCAgICAgICAgICAgIHZhciBjdXJyZW50U2VsZWN0aW9uID0gaW5zdC52YWx1ZTtcblxuXHQgICAgICAgICAgICBpZiAoaXNFcXVhbChjdXJyZW50U2VsZWN0aW9uLCBfbmV4dFNlbGVjdGlvbikpIHtcblx0ICAgICAgICAgICAgICBtZW1vaXplZFNlbGVjdGlvbiA9IGN1cnJlbnRTZWxlY3Rpb247XG5cdCAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRTZWxlY3Rpb247XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICBtZW1vaXplZFNlbGVjdGlvbiA9IF9uZXh0U2VsZWN0aW9uO1xuXHQgICAgICAgIHJldHVybiBfbmV4dFNlbGVjdGlvbjtcblx0ICAgICAgfSAvLyBXZSBtYXkgYmUgYWJsZSB0byByZXVzZSB0aGUgcHJldmlvdXMgaW52b2NhdGlvbidzIHJlc3VsdC5cblxuXG5cdCAgICAgIC8vIFdlIG1heSBiZSBhYmxlIHRvIHJldXNlIHRoZSBwcmV2aW91cyBpbnZvY2F0aW9uJ3MgcmVzdWx0LlxuXHQgICAgICB2YXIgcHJldlNuYXBzaG90ID0gbWVtb2l6ZWRTbmFwc2hvdDtcblx0ICAgICAgdmFyIHByZXZTZWxlY3Rpb24gPSBtZW1vaXplZFNlbGVjdGlvbjtcblxuXHQgICAgICBpZiAob2JqZWN0SXMocHJldlNuYXBzaG90LCBuZXh0U25hcHNob3QpKSB7XG5cdCAgICAgICAgLy8gVGhlIHNuYXBzaG90IGlzIHRoZSBzYW1lIGFzIGxhc3QgdGltZS4gUmV1c2UgdGhlIHByZXZpb3VzIHNlbGVjdGlvbi5cblx0ICAgICAgICByZXR1cm4gcHJldlNlbGVjdGlvbjtcblx0ICAgICAgfSAvLyBUaGUgc25hcHNob3QgaGFzIGNoYW5nZWQsIHNvIHdlIG5lZWQgdG8gY29tcHV0ZSBhIG5ldyBzZWxlY3Rpb24uXG5cblxuXHQgICAgICAvLyBUaGUgc25hcHNob3QgaGFzIGNoYW5nZWQsIHNvIHdlIG5lZWQgdG8gY29tcHV0ZSBhIG5ldyBzZWxlY3Rpb24uXG5cdCAgICAgIHZhciBuZXh0U2VsZWN0aW9uID0gc2VsZWN0b3IobmV4dFNuYXBzaG90KTsgLy8gSWYgYSBjdXN0b20gaXNFcXVhbCBmdW5jdGlvbiBpcyBwcm92aWRlZCwgdXNlIHRoYXQgdG8gY2hlY2sgaWYgdGhlIGRhdGFcblx0ICAgICAgLy8gaGFzIGNoYW5nZWQuIElmIGl0IGhhc24ndCwgcmV0dXJuIHRoZSBwcmV2aW91cyBzZWxlY3Rpb24uIFRoYXQgc2lnbmFsc1xuXHQgICAgICAvLyB0byBSZWFjdCB0aGF0IHRoZSBzZWxlY3Rpb25zIGFyZSBjb25jZXB0dWFsbHkgZXF1YWwsIGFuZCB3ZSBjYW4gYmFpbFxuXHQgICAgICAvLyBvdXQgb2YgcmVuZGVyaW5nLlxuXG5cdCAgICAgIC8vIElmIGEgY3VzdG9tIGlzRXF1YWwgZnVuY3Rpb24gaXMgcHJvdmlkZWQsIHVzZSB0aGF0IHRvIGNoZWNrIGlmIHRoZSBkYXRhXG5cdCAgICAgIC8vIGhhcyBjaGFuZ2VkLiBJZiBpdCBoYXNuJ3QsIHJldHVybiB0aGUgcHJldmlvdXMgc2VsZWN0aW9uLiBUaGF0IHNpZ25hbHNcblx0ICAgICAgLy8gdG8gUmVhY3QgdGhhdCB0aGUgc2VsZWN0aW9ucyBhcmUgY29uY2VwdHVhbGx5IGVxdWFsLCBhbmQgd2UgY2FuIGJhaWxcblx0ICAgICAgLy8gb3V0IG9mIHJlbmRlcmluZy5cblx0ICAgICAgaWYgKGlzRXF1YWwgIT09IHVuZGVmaW5lZCAmJiBpc0VxdWFsKHByZXZTZWxlY3Rpb24sIG5leHRTZWxlY3Rpb24pKSB7XG5cdCAgICAgICAgcmV0dXJuIHByZXZTZWxlY3Rpb247XG5cdCAgICAgIH1cblxuXHQgICAgICBtZW1vaXplZFNuYXBzaG90ID0gbmV4dFNuYXBzaG90O1xuXHQgICAgICBtZW1vaXplZFNlbGVjdGlvbiA9IG5leHRTZWxlY3Rpb247XG5cdCAgICAgIHJldHVybiBuZXh0U2VsZWN0aW9uO1xuXHQgICAgfTsgLy8gQXNzaWduaW5nIHRoaXMgdG8gYSBjb25zdGFudCBzbyB0aGF0IEZsb3cga25vd3MgaXQgY2FuJ3QgY2hhbmdlLlxuXG5cblx0ICAgIC8vIEFzc2lnbmluZyB0aGlzIHRvIGEgY29uc3RhbnQgc28gdGhhdCBGbG93IGtub3dzIGl0IGNhbid0IGNoYW5nZS5cblx0ICAgIHZhciBtYXliZUdldFNlcnZlclNuYXBzaG90ID0gZ2V0U2VydmVyU25hcHNob3QgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBnZXRTZXJ2ZXJTbmFwc2hvdDtcblxuXHQgICAgdmFyIGdldFNuYXBzaG90V2l0aFNlbGVjdG9yID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICByZXR1cm4gbWVtb2l6ZWRTZWxlY3RvcihnZXRTbmFwc2hvdCgpKTtcblx0ICAgIH07XG5cblx0ICAgIHZhciBnZXRTZXJ2ZXJTbmFwc2hvdFdpdGhTZWxlY3RvciA9IG1heWJlR2V0U2VydmVyU25hcHNob3QgPT09IG51bGwgPyB1bmRlZmluZWQgOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIHJldHVybiBtZW1vaXplZFNlbGVjdG9yKG1heWJlR2V0U2VydmVyU25hcHNob3QoKSk7XG5cdCAgICB9O1xuXHQgICAgcmV0dXJuIFtnZXRTbmFwc2hvdFdpdGhTZWxlY3RvciwgZ2V0U2VydmVyU25hcHNob3RXaXRoU2VsZWN0b3JdO1xuXHQgIH0sIFtnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QsIHNlbGVjdG9yLCBpc0VxdWFsXSksXG5cdCAgICAgIGdldFNlbGVjdGlvbiA9IF91c2VNZW1vWzBdLFxuXHQgICAgICBnZXRTZXJ2ZXJTZWxlY3Rpb24gPSBfdXNlTWVtb1sxXTtcblxuXHQgIHZhciB2YWx1ZSA9IHVzZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U2VsZWN0aW9uLCBnZXRTZXJ2ZXJTZWxlY3Rpb24pO1xuXHQgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG5cdCAgICBpbnN0Lmhhc1ZhbHVlID0gdHJ1ZTtcblx0ICAgIGluc3QudmFsdWUgPSB2YWx1ZTtcblx0ICB9LCBbdmFsdWVdKTtcblx0ICB1c2VEZWJ1Z1ZhbHVlKHZhbHVlKTtcblx0ICByZXR1cm4gdmFsdWU7XG5cdH1cblxuXHR3aXRoU2VsZWN0b3JfZGV2ZWxvcG1lbnQudXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IgPSB1c2VTeW5jRXh0ZXJuYWxTdG9yZVdpdGhTZWxlY3Rvcjtcblx0ICAgICAgICAgIC8qIGdsb2JhbCBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gKi9cblx0aWYgKFxuXHQgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gIT09ICd1bmRlZmluZWQnICYmXG5cdCAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcCA9PT1cblx0ICAgICdmdW5jdGlvbidcblx0KSB7XG5cdCAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLnJlZ2lzdGVySW50ZXJuYWxNb2R1bGVTdG9wKG5ldyBFcnJvcigpKTtcblx0fVxuXHQgICAgICAgIFxuXHQgIH0pKCk7XG5cdH1cblx0cmV0dXJuIHdpdGhTZWxlY3Rvcl9kZXZlbG9wbWVudDtcbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgd2l0aFNlbGVjdG9yLmV4cG9ydHMgPSByZXF1aXJlV2l0aFNlbGVjdG9yX3Byb2R1Y3Rpb25fbWluKCk7XG59IGVsc2Uge1xuICB3aXRoU2VsZWN0b3IuZXhwb3J0cyA9IHJlcXVpcmVXaXRoU2VsZWN0b3JfZGV2ZWxvcG1lbnQoKTtcbn1cblxudmFyIHdpdGhTZWxlY3RvckV4cG9ydHMgPSB3aXRoU2VsZWN0b3IuZXhwb3J0cztcblxuY29uc3QgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gdXNlTGF5b3V0RWZmZWN0IDogdXNlRWZmZWN0O1xuLyoqXG4gKiBUbyBzeW5jaHJvbml6ZSB0aGUgZWRpdG9yIGluc3RhbmNlIHdpdGggdGhlIGNvbXBvbmVudCBzdGF0ZSxcbiAqIHdlIG5lZWQgdG8gY3JlYXRlIGEgc2VwYXJhdGUgaW5zdGFuY2UgdGhhdCBpcyBub3QgYWZmZWN0ZWQgYnkgdGhlIGNvbXBvbmVudCByZS1yZW5kZXJzLlxuICovXG5jbGFzcyBFZGl0b3JTdGF0ZU1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKGluaXRpYWxFZGl0b3IpIHtcbiAgICAgICAgdGhpcy50cmFuc2FjdGlvbk51bWJlciA9IDA7XG4gICAgICAgIHRoaXMubGFzdFRyYW5zYWN0aW9uTnVtYmVyID0gMDtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVycyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5lZGl0b3IgPSBpbml0aWFsRWRpdG9yO1xuICAgICAgICB0aGlzLmxhc3RTbmFwc2hvdCA9IHsgZWRpdG9yOiBpbml0aWFsRWRpdG9yLCB0cmFuc2FjdGlvbk51bWJlcjogMCB9O1xuICAgICAgICB0aGlzLmdldFNuYXBzaG90ID0gdGhpcy5nZXRTbmFwc2hvdC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmdldFNlcnZlclNuYXBzaG90ID0gdGhpcy5nZXRTZXJ2ZXJTbmFwc2hvdC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLndhdGNoID0gdGhpcy53YXRjaC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnN1YnNjcmliZSA9IHRoaXMuc3Vic2NyaWJlLmJpbmQodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCBlZGl0b3IgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZ2V0U25hcHNob3QoKSB7XG4gICAgICAgIGlmICh0aGlzLnRyYW5zYWN0aW9uTnVtYmVyID09PSB0aGlzLmxhc3RUcmFuc2FjdGlvbk51bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFzdFNuYXBzaG90O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGFzdFRyYW5zYWN0aW9uTnVtYmVyID0gdGhpcy50cmFuc2FjdGlvbk51bWJlcjtcbiAgICAgICAgdGhpcy5sYXN0U25hcHNob3QgPSB7IGVkaXRvcjogdGhpcy5lZGl0b3IsIHRyYW5zYWN0aW9uTnVtYmVyOiB0aGlzLnRyYW5zYWN0aW9uTnVtYmVyIH07XG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RTbmFwc2hvdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWx3YXlzIGRpc2FibGUgdGhlIGVkaXRvciBvbiB0aGUgc2VydmVyLXNpZGUuXG4gICAgICovXG4gICAgZ2V0U2VydmVyU25hcHNob3QoKSB7XG4gICAgICAgIHJldHVybiB7IGVkaXRvcjogbnVsbCwgdHJhbnNhY3Rpb25OdW1iZXI6IDAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlIHRvIHRoZSBlZGl0b3IgaW5zdGFuY2UncyBjaGFuZ2VzLlxuICAgICAqL1xuICAgIHN1YnNjcmliZShjYWxsYmFjaykge1xuICAgICAgICB0aGlzLnN1YnNjcmliZXJzLmFkZChjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZXJzLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdhdGNoIHRoZSBlZGl0b3IgaW5zdGFuY2UgZm9yIGNoYW5nZXMuXG4gICAgICovXG4gICAgd2F0Y2gobmV4dEVkaXRvcikge1xuICAgICAgICB0aGlzLmVkaXRvciA9IG5leHRFZGl0b3I7XG4gICAgICAgIGlmICh0aGlzLmVkaXRvcikge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGlzIHdpbGwgZm9yY2UgYSByZS1yZW5kZXIgd2hlbiB0aGUgZWRpdG9yIHN0YXRlIGNoYW5nZXMuXG4gICAgICAgICAgICAgKiBUaGlzIGlzIHRvIHN1cHBvcnQgdGhpbmdzIGxpa2UgYGVkaXRvci5jYW4oKS50b2dnbGVCb2xkKClgIGluIGNvbXBvbmVudHMgdGhhdCBgdXNlRWRpdG9yYC5cbiAgICAgICAgICAgICAqIFRoaXMgY291bGQgYmUgbW9yZSBlZmZpY2llbnQsIGJ1dCBpdCdzIGEgZ29vZCB0cmFkZS1vZmYgZm9yIG5vdy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgZm4gPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2FjdGlvbk51bWJlciArPSAxO1xuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlcnMuZm9yRWFjaChjYWxsYmFjayA9PiBjYWxsYmFjaygpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50RWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgICAgICAgICBjdXJyZW50RWRpdG9yLm9uKCd0cmFuc2FjdGlvbicsIGZuKTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY3VycmVudEVkaXRvci5vZmYoJ3RyYW5zYWN0aW9uJywgZm4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbi8qKlxuICogVGhpcyBob29rIGFsbG93cyB5b3UgdG8gd2F0Y2ggZm9yIGNoYW5nZXMgb24gdGhlIGVkaXRvciBpbnN0YW5jZS5cbiAqIEl0IHdpbGwgYWxsb3cgeW91IHRvIHNlbGVjdCBhIHBhcnQgb2YgdGhlIGVkaXRvciBzdGF0ZSBhbmQgcmUtcmVuZGVyIHRoZSBjb21wb25lbnQgd2hlbiBpdCBjaGFuZ2VzLlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogY29uc3QgZWRpdG9yID0gdXNlRWRpdG9yKHsuLi5vcHRpb25zfSlcbiAqIGNvbnN0IHsgY3VycmVudFNlbGVjdGlvbiB9ID0gdXNlRWRpdG9yU3RhdGUoe1xuICogIGVkaXRvcixcbiAqICBzZWxlY3Rvcjogc25hcHNob3QgPT4gKHsgY3VycmVudFNlbGVjdGlvbjogc25hcHNob3QuZWRpdG9yLnN0YXRlLnNlbGVjdGlvbiB9KSxcbiAqIH0pXG4gKi9cbmZ1bmN0aW9uIHVzZUVkaXRvclN0YXRlKG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgW2VkaXRvclN0YXRlTWFuYWdlcl0gPSB1c2VTdGF0ZSgoKSA9PiBuZXcgRWRpdG9yU3RhdGVNYW5hZ2VyKG9wdGlvbnMuZWRpdG9yKSk7XG4gICAgLy8gVXNpbmcgdGhlIGB1c2VTeW5jRXh0ZXJuYWxTdG9yZWAgaG9vayB0byBzeW5jIHRoZSBlZGl0b3IgaW5zdGFuY2Ugd2l0aCB0aGUgY29tcG9uZW50IHN0YXRlXG4gICAgY29uc3Qgc2VsZWN0ZWRTdGF0ZSA9IHdpdGhTZWxlY3RvckV4cG9ydHMudXNlU3luY0V4dGVybmFsU3RvcmVXaXRoU2VsZWN0b3IoZWRpdG9yU3RhdGVNYW5hZ2VyLnN1YnNjcmliZSwgZWRpdG9yU3RhdGVNYW5hZ2VyLmdldFNuYXBzaG90LCBlZGl0b3JTdGF0ZU1hbmFnZXIuZ2V0U2VydmVyU25hcHNob3QsIG9wdGlvbnMuc2VsZWN0b3IsIChfYSA9IG9wdGlvbnMuZXF1YWxpdHlGbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZGVlcEVxdWFsKTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgcmV0dXJuIGVkaXRvclN0YXRlTWFuYWdlci53YXRjaChvcHRpb25zLmVkaXRvcik7XG4gICAgfSwgW29wdGlvbnMuZWRpdG9yLCBlZGl0b3JTdGF0ZU1hbmFnZXJdKTtcbiAgICB1c2VEZWJ1Z1ZhbHVlKHNlbGVjdGVkU3RhdGUpO1xuICAgIHJldHVybiBzZWxlY3RlZFN0YXRlO1xufVxuXG5jb25zdCBpc0RldiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbic7XG5jb25zdCBpc1NTUiA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnO1xuY29uc3QgaXNOZXh0ID0gaXNTU1IgfHwgQm9vbGVhbih0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubmV4dCk7XG4vKipcbiAqIFRoaXMgY2xhc3MgaGFuZGxlcyB0aGUgY3JlYXRpb24sIGRlc3RydWN0aW9uLCBhbmQgcmUtY3JlYXRpb24gb2YgdGhlIGVkaXRvciBpbnN0YW5jZS5cbiAqL1xuY2xhc3MgRWRpdG9ySW5zdGFuY2VNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgY3VycmVudCBlZGl0b3IgaW5zdGFuY2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmVkaXRvciA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc3Vic2NyaXB0aW9ucyB0byBub3RpZnkgd2hlbiB0aGUgZWRpdG9yIGluc3RhbmNlXG4gICAgICAgICAqIGhhcyBiZWVuIGNyZWF0ZWQgb3IgZGVzdHJveWVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zID0gbmV3IFNldCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hldGhlciB0aGUgZWRpdG9yIGhhcyBiZWVuIG1vdW50ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzQ29tcG9uZW50TW91bnRlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1vc3QgcmVjZW50IGRlcGVuZGVuY2llcyBhcnJheS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucHJldmlvdXNEZXBzID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB1bmlxdWUgaW5zdGFuY2UgSUQuIFRoaXMgaXMgdXNlZCB0byBpZGVudGlmeSB0aGUgZWRpdG9yIGluc3RhbmNlLiBBbmQgd2lsbCBiZSByZS1nZW5lcmF0ZWQgZm9yIGVhY2ggbmV3IGluc3RhbmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbnN0YW5jZUlkID0gJyc7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5zZXRFZGl0b3IodGhpcy5nZXRJbml0aWFsRWRpdG9yKCkpO1xuICAgICAgICB0aGlzLnNjaGVkdWxlRGVzdHJveSgpO1xuICAgICAgICB0aGlzLmdldEVkaXRvciA9IHRoaXMuZ2V0RWRpdG9yLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZ2V0U2VydmVyU25hcHNob3QgPSB0aGlzLmdldFNlcnZlclNuYXBzaG90LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlID0gdGhpcy5zdWJzY3JpYmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZWZyZXNoRWRpdG9ySW5zdGFuY2UgPSB0aGlzLnJlZnJlc2hFZGl0b3JJbnN0YW5jZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNjaGVkdWxlRGVzdHJveSA9IHRoaXMuc2NoZWR1bGVEZXN0cm95LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25SZW5kZXIgPSB0aGlzLm9uUmVuZGVyLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY3JlYXRlRWRpdG9yID0gdGhpcy5jcmVhdGVFZGl0b3IuYmluZCh0aGlzKTtcbiAgICB9XG4gICAgc2V0RWRpdG9yKGVkaXRvcikge1xuICAgICAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcbiAgICAgICAgdGhpcy5pbnN0YW5jZUlkID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMiwgOSk7XG4gICAgICAgIC8vIE5vdGlmeSBhbGwgc3Vic2NyaWJlcnMgdGhhdCB0aGUgZWRpdG9yIGluc3RhbmNlIGhhcyBiZWVuIGNyZWF0ZWRcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmZvckVhY2goY2IgPT4gY2IoKSk7XG4gICAgfVxuICAgIGdldEluaXRpYWxFZGl0b3IoKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY3VycmVudC5pbW1lZGlhdGVseVJlbmRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoaXNTU1IgfHwgaXNOZXh0KSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLCB3ZSBzaG91bGQgdGhyb3cgYW4gZXJyb3IgaGVyZVxuICAgICAgICAgICAgICAgIGlmIChpc0Rldikge1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogVGhyb3cgYW4gZXJyb3IgaW4gZGV2ZWxvcG1lbnQsIHRvIG1ha2Ugc3VyZSB0aGUgZGV2ZWxvcGVyIGlzIGF3YXJlIHRoYXQgdGlwdGFwIGNhbm5vdCBiZSBTU1InZFxuICAgICAgICAgICAgICAgICAgICAgKiBhbmQgdGhhdCB0aGV5IG5lZWQgdG8gc2V0IGBpbW1lZGlhdGVseVJlbmRlcmAgdG8gYGZhbHNlYCB0byBhdm9pZCBoeWRyYXRpb24gbWlzbWF0Y2hlcy5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignVGlwdGFwIEVycm9yOiBTU1IgaGFzIGJlZW4gZGV0ZWN0ZWQsIHBsZWFzZSBzZXQgYGltbWVkaWF0ZWx5UmVuZGVyYCBleHBsaWNpdGx5IHRvIGBmYWxzZWAgdG8gYXZvaWQgaHlkcmF0aW9uIG1pc21hdGNoZXMuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEJlc3QgZmFpdGggZWZmb3J0IGluIHByb2R1Y3Rpb24sIHJ1biB0aGUgY29kZSBpbiB0aGUgbGVnYWN5IG1vZGUgdG8gYXZvaWQgaHlkcmF0aW9uIG1pc21hdGNoZXMgYW5kIGVycm9ycyBpbiBwcm9kdWN0aW9uXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEZWZhdWx0IHRvIGltbWVkaWF0ZWx5IHJlbmRlcmluZyB3aGVuIGNsaWVudC1zaWRlIHJlbmRlcmluZ1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRWRpdG9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jdXJyZW50LmltbWVkaWF0ZWx5UmVuZGVyICYmIGlzU1NSICYmIGlzRGV2KSB7XG4gICAgICAgICAgICAvLyBXYXJuIGluIGRldmVsb3BtZW50LCB0byBtYWtlIHN1cmUgdGhlIGRldmVsb3BlciBpcyBhd2FyZSB0aGF0IHRpcHRhcCBjYW5ub3QgYmUgU1NSJ2QsIHNldCBgaW1tZWRpYXRlbHlSZW5kZXJgIHRvIGBmYWxzZWAgdG8gYXZvaWQgaHlkcmF0aW9uIG1pc21hdGNoZXMuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RpcHRhcCBFcnJvcjogU1NSIGhhcyBiZWVuIGRldGVjdGVkLCBhbmQgYGltbWVkaWF0ZWx5UmVuZGVyYCBoYXMgYmVlbiBzZXQgdG8gYHRydWVgIHRoaXMgaXMgYW4gdW5zdXBwb3J0ZWQgY29uZmlndXJhdGlvbiB0aGF0IG1heSByZXN1bHQgaW4gZXJyb3JzLCBleHBsaWNpdGx5IHNldCBgaW1tZWRpYXRlbHlSZW5kZXJgIHRvIGBmYWxzZWAgdG8gYXZvaWQgaHlkcmF0aW9uIG1pc21hdGNoZXMuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jdXJyZW50LmltbWVkaWF0ZWx5UmVuZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFZGl0b3IoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGVkaXRvciBpbnN0YW5jZS4gQW5kIGF0dGFjaCBldmVudCBsaXN0ZW5lcnMuXG4gICAgICovXG4gICAgY3JlYXRlRWRpdG9yKCkge1xuICAgICAgICBjb25zdCBvcHRpb25zVG9BcHBseSA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMub3B0aW9ucy5jdXJyZW50LFxuICAgICAgICAgICAgLy8gQWx3YXlzIGNhbGwgdGhlIG1vc3QgcmVjZW50IHZlcnNpb24gb2YgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGJ5IGRlZmF1bHRcbiAgICAgICAgICAgIG9uQmVmb3JlQ3JlYXRlOiAoLi4uYXJncykgPT4geyB2YXIgX2EsIF9iOyByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5vcHRpb25zLmN1cnJlbnQpLm9uQmVmb3JlQ3JlYXRlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgLi4uYXJncyk7IH0sXG4gICAgICAgICAgICBvbkJsdXI6ICguLi5hcmdzKSA9PiB7IHZhciBfYSwgX2I7IHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLm9wdGlvbnMuY3VycmVudCkub25CbHVyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgLi4uYXJncyk7IH0sXG4gICAgICAgICAgICBvbkNyZWF0ZTogKC4uLmFyZ3MpID0+IHsgdmFyIF9hLCBfYjsgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMub3B0aW9ucy5jdXJyZW50KS5vbkNyZWF0ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIC4uLmFyZ3MpOyB9LFxuICAgICAgICAgICAgb25EZXN0cm95OiAoLi4uYXJncykgPT4geyB2YXIgX2EsIF9iOyByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5vcHRpb25zLmN1cnJlbnQpLm9uRGVzdHJveSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIC4uLmFyZ3MpOyB9LFxuICAgICAgICAgICAgb25Gb2N1czogKC4uLmFyZ3MpID0+IHsgdmFyIF9hLCBfYjsgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMub3B0aW9ucy5jdXJyZW50KS5vbkZvY3VzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgLi4uYXJncyk7IH0sXG4gICAgICAgICAgICBvblNlbGVjdGlvblVwZGF0ZTogKC4uLmFyZ3MpID0+IHsgdmFyIF9hLCBfYjsgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMub3B0aW9ucy5jdXJyZW50KS5vblNlbGVjdGlvblVwZGF0ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIC4uLmFyZ3MpOyB9LFxuICAgICAgICAgICAgb25UcmFuc2FjdGlvbjogKC4uLmFyZ3MpID0+IHsgdmFyIF9hLCBfYjsgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMub3B0aW9ucy5jdXJyZW50KS5vblRyYW5zYWN0aW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgLi4uYXJncyk7IH0sXG4gICAgICAgICAgICBvblVwZGF0ZTogKC4uLmFyZ3MpID0+IHsgdmFyIF9hLCBfYjsgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMub3B0aW9ucy5jdXJyZW50KS5vblVwZGF0ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIC4uLmFyZ3MpOyB9LFxuICAgICAgICAgICAgb25Db250ZW50RXJyb3I6ICguLi5hcmdzKSA9PiB7IHZhciBfYSwgX2I7IHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLm9wdGlvbnMuY3VycmVudCkub25Db250ZW50RXJyb3IpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCAuLi5hcmdzKTsgfSxcbiAgICAgICAgICAgIG9uRHJvcDogKC4uLmFyZ3MpID0+IHsgdmFyIF9hLCBfYjsgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMub3B0aW9ucy5jdXJyZW50KS5vbkRyb3ApID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCAuLi5hcmdzKTsgfSxcbiAgICAgICAgICAgIG9uUGFzdGU6ICguLi5hcmdzKSA9PiB7IHZhciBfYSwgX2I7IHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLm9wdGlvbnMuY3VycmVudCkub25QYXN0ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIC4uLmFyZ3MpOyB9LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBlZGl0b3IgPSBuZXcgRWRpdG9yKG9wdGlvbnNUb0FwcGx5KTtcbiAgICAgICAgLy8gbm8gbmVlZCB0byBrZWVwIHRyYWNrIG9mIHRoZSBldmVudCBsaXN0ZW5lcnMsIHRoZXkgd2lsbCBiZSByZW1vdmVkIHdoZW4gdGhlIGVkaXRvciBpcyBkZXN0cm95ZWRcbiAgICAgICAgcmV0dXJuIGVkaXRvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IGVkaXRvciBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBnZXRFZGl0b3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVkaXRvcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWx3YXlzIGRpc2FibGUgdGhlIGVkaXRvciBvbiB0aGUgc2VydmVyLXNpZGUuXG4gICAgICovXG4gICAgZ2V0U2VydmVyU25hcHNob3QoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmUgdG8gdGhlIGVkaXRvciBpbnN0YW5jZSdzIGNoYW5nZXMuXG4gICAgICovXG4gICAgc3Vic2NyaWJlKG9uU3RvcmVDaGFuZ2UpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLmFkZChvblN0b3JlQ2hhbmdlKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5kZWxldGUob25TdG9yZUNoYW5nZSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHN0YXRpYyBjb21wYXJlT3B0aW9ucyhhLCBiKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhhKS5ldmVyeShrZXkgPT4ge1xuICAgICAgICAgICAgaWYgKFsnb25DcmVhdGUnLCAnb25CZWZvcmVDcmVhdGUnLCAnb25EZXN0cm95JywgJ29uVXBkYXRlJywgJ29uVHJhbnNhY3Rpb24nLCAnb25Gb2N1cycsICdvbkJsdXInLCAnb25TZWxlY3Rpb25VcGRhdGUnLCAnb25Db250ZW50RXJyb3InLCAnb25Ecm9wJywgJ29uUGFzdGUnXS5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0byBjb21wYXJlIGNhbGxiYWNrcywgdGhleSBhcmUgYWx3YXlzIGRpZmZlcmVudCBhbmQgb25seSByZWdpc3RlcmVkIG9uY2VcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIG9mdGVuIGVuY291cmFnZSBwdXR0aW5nIGV4dGVuc2lvbnMgaW5saW5lZCBpbiB0aGUgb3B0aW9ucyBvYmplY3QsIHNvIHdlIHdpbGwgZG8gYSBzbGlnaHRseSBkZWVwZXIgY29tcGFyaXNvbiBoZXJlXG4gICAgICAgICAgICBpZiAoa2V5ID09PSAnZXh0ZW5zaW9ucycgJiYgYS5leHRlbnNpb25zICYmIGIuZXh0ZW5zaW9ucykge1xuICAgICAgICAgICAgICAgIGlmIChhLmV4dGVuc2lvbnMubGVuZ3RoICE9PSBiLmV4dGVuc2lvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEuZXh0ZW5zaW9ucy5ldmVyeSgoZXh0ZW5zaW9uLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHRlbnNpb24gIT09ICgoX2EgPSBiLmV4dGVuc2lvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtpbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYVtrZXldICE9PSBiW2tleV0pIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBhbnkgb2YgdGhlIG9wdGlvbnMgaGF2ZSBjaGFuZ2VkLCB3ZSBzaG91bGQgdXBkYXRlIHRoZSBlZGl0b3Igb3B0aW9uc1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT24gZWFjaCByZW5kZXIsIHdlIHdpbGwgY3JlYXRlLCB1cGRhdGUsIG9yIGRlc3Ryb3kgdGhlIGVkaXRvciBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0gZGVwcyBUaGUgZGVwZW5kZW5jaWVzIHRvIHdhdGNoIGZvciBjaGFuZ2VzXG4gICAgICogQHJldHVybnMgQSBjbGVhbnVwIGZ1bmN0aW9uXG4gICAgICovXG4gICAgb25SZW5kZXIoZGVwcykge1xuICAgICAgICAvLyBUaGUgcmV0dXJuZWQgY2FsbGJhY2sgd2lsbCBydW4gb24gZWFjaCByZW5kZXJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXNDb21wb25lbnRNb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIENsZWFudXAgYW55IHNjaGVkdWxlZCBkZXN0cnVjdGlvbnMsIHNpbmNlIHdlIGFyZSBjdXJyZW50bHkgcmVuZGVyaW5nXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5zY2hlZHVsZWREZXN0cnVjdGlvblRpbWVvdXQpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZWRpdG9yICYmICF0aGlzLmVkaXRvci5pc0Rlc3Ryb3llZCAmJiBkZXBzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBlZGl0b3IgZG9lcyBleGlzdCAmIGRlcHMgYXJlIGVtcHR5LCB3ZSBkb24ndCBuZWVkIHRvIHJlLWluaXRpYWxpemUgdGhlIGVkaXRvciBnZW5lcmFsbHlcbiAgICAgICAgICAgICAgICBpZiAoIUVkaXRvckluc3RhbmNlTWFuYWdlci5jb21wYXJlT3B0aW9ucyh0aGlzLm9wdGlvbnMuY3VycmVudCwgdGhpcy5lZGl0b3Iub3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQnV0LCB0aGUgb3B0aW9ucyBhcmUgZGlmZmVyZW50LCBzbyB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgZWRpdG9yIG9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RpbGwsIHRoaXMgaXMgZmFzdGVyIHRoYW4gcmUtY3JlYXRpbmcgdGhlIGVkaXRvclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVkaXRvci5zZXRPcHRpb25zKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnRoaXMub3B0aW9ucy5jdXJyZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgZWRpdGFibGU6IHRoaXMuZWRpdG9yLmlzRWRpdGFibGUsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIGVkaXRvcjpcbiAgICAgICAgICAgICAgICAvLyAtIGRvZXMgbm90IHlldCBleGlzdFxuICAgICAgICAgICAgICAgIC8vIC0gaXMgZGVzdHJveWVkXG4gICAgICAgICAgICAgICAgLy8gLSB0aGUgZGVwcyBhcnJheSBjaGFuZ2VzXG4gICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBkZXN0cm95IHRoZSBlZGl0b3IgaW5zdGFuY2UgYW5kIHJlLWluaXRpYWxpemUgaXRcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hFZGl0b3JJbnN0YW5jZShkZXBzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5pc0NvbXBvbmVudE1vdW50ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnNjaGVkdWxlRGVzdHJveSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVjcmVhdGUgdGhlIGVkaXRvciBpbnN0YW5jZSBpZiB0aGUgZGVwZW5kZW5jaWVzIGhhdmUgY2hhbmdlZC5cbiAgICAgKi9cbiAgICByZWZyZXNoRWRpdG9ySW5zdGFuY2UoZGVwcykge1xuICAgICAgICBpZiAodGhpcy5lZGl0b3IgJiYgIXRoaXMuZWRpdG9yLmlzRGVzdHJveWVkKSB7XG4gICAgICAgICAgICAvLyBFZGl0b3IgaW5zdGFuY2UgYWxyZWFkeSBleGlzdHNcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXZpb3VzRGVwcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIElmIGxhc3REZXBzIGhhcyBub3QgeWV0IGJlZW4gaW5pdGlhbGl6ZWQsIHJldXNlIHRoZSBjdXJyZW50IGVkaXRvciBpbnN0YW5jZVxuICAgICAgICAgICAgICAgIHRoaXMucHJldmlvdXNEZXBzID0gZGVwcztcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkZXBzQXJlRXF1YWwgPSB0aGlzLnByZXZpb3VzRGVwcy5sZW5ndGggPT09IGRlcHMubGVuZ3RoXG4gICAgICAgICAgICAgICAgJiYgdGhpcy5wcmV2aW91c0RlcHMuZXZlcnkoKGRlcCwgaW5kZXgpID0+IGRlcCA9PT0gZGVwc1tpbmRleF0pO1xuICAgICAgICAgICAgaWYgKGRlcHNBcmVFcXVhbCkge1xuICAgICAgICAgICAgICAgIC8vIGRlcHMgZXhpc3QgYW5kIGFyZSBlcXVhbCwgbm8gbmVlZCB0byByZWNyZWF0ZVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5lZGl0b3IgJiYgIXRoaXMuZWRpdG9yLmlzRGVzdHJveWVkKSB7XG4gICAgICAgICAgICAvLyBEZXN0cm95IHRoZSBlZGl0b3IgaW5zdGFuY2UgaWYgaXQgZXhpc3RzXG4gICAgICAgICAgICB0aGlzLmVkaXRvci5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRFZGl0b3IodGhpcy5jcmVhdGVFZGl0b3IoKSk7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgbGFzdERlcHMgdG8gdGhlIGN1cnJlbnQgZGVwc1xuICAgICAgICB0aGlzLnByZXZpb3VzRGVwcyA9IGRlcHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNjaGVkdWxlIHRoZSBkZXN0cnVjdGlvbiBvZiB0aGUgZWRpdG9yIGluc3RhbmNlLlxuICAgICAqIFRoaXMgd2lsbCBvbmx5IGRlc3Ryb3kgdGhlIGVkaXRvciBpZiBpdCB3YXMgbm90IG1vdW50ZWQgb24gdGhlIG5leHQgdGljay5cbiAgICAgKiBUaGlzIGlzIHRvIGF2b2lkIGRlc3Ryb3lpbmcgdGhlIGVkaXRvciBpbnN0YW5jZSB3aGVuIGl0J3MgYWN0dWFsbHkgc3RpbGwgbW91bnRlZC5cbiAgICAgKi9cbiAgICBzY2hlZHVsZURlc3Ryb3koKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRJbnN0YW5jZUlkID0gdGhpcy5pbnN0YW5jZUlkO1xuICAgICAgICBjb25zdCBjdXJyZW50RWRpdG9yID0gdGhpcy5lZGl0b3I7XG4gICAgICAgIC8vIFdhaXQgdHdvIHRpY2tzIHRvIHNlZSBpZiB0aGUgY29tcG9uZW50IGlzIHN0aWxsIG1vdW50ZWRcbiAgICAgICAgdGhpcy5zY2hlZHVsZWREZXN0cnVjdGlvblRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQ29tcG9uZW50TW91bnRlZCAmJiB0aGlzLmluc3RhbmNlSWQgPT09IGN1cnJlbnRJbnN0YW5jZUlkKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgc3RpbGwgbW91bnRlZCBvbiB0aGUgZm9sbG93aW5nIHRpY2ssIHdpdGggdGhlIHNhbWUgaW5zdGFuY2VJZCwgZG8gbm90IGRlc3Ryb3kgdGhlIGVkaXRvclxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RWRpdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGp1c3QgcmUtYXBwbHkgb3B0aW9ucyBhcyB0aGV5IG1pZ2h0IGhhdmUgY2hhbmdlZFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50RWRpdG9yLnNldE9wdGlvbnModGhpcy5vcHRpb25zLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3VycmVudEVkaXRvciAmJiAhY3VycmVudEVkaXRvci5pc0Rlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRFZGl0b3IuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmluc3RhbmNlSWQgPT09IGN1cnJlbnRJbnN0YW5jZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0RWRpdG9yKG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoaXMgYWxsb3dzIHRoZSBlZmZlY3QgdG8gcnVuIGFnYWluIGJldHdlZW4gdGlja3NcbiAgICAgICAgICAgIC8vIHdoaWNoIG1heSBzYXZlIHVzIGZyb20gaGF2aW5nIHRvIHJlLWNyZWF0ZSB0aGUgZWRpdG9yXG4gICAgICAgIH0sIDEpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVzZUVkaXRvcihvcHRpb25zID0ge30sIGRlcHMgPSBbXSkge1xuICAgIGNvbnN0IG1vc3RSZWNlbnRPcHRpb25zID0gdXNlUmVmKG9wdGlvbnMpO1xuICAgIG1vc3RSZWNlbnRPcHRpb25zLmN1cnJlbnQgPSBvcHRpb25zO1xuICAgIGNvbnN0IFtpbnN0YW5jZU1hbmFnZXJdID0gdXNlU3RhdGUoKCkgPT4gbmV3IEVkaXRvckluc3RhbmNlTWFuYWdlcihtb3N0UmVjZW50T3B0aW9ucykpO1xuICAgIGNvbnN0IGVkaXRvciA9IHNoaW1FeHBvcnRzLnVzZVN5bmNFeHRlcm5hbFN0b3JlKGluc3RhbmNlTWFuYWdlci5zdWJzY3JpYmUsIGluc3RhbmNlTWFuYWdlci5nZXRFZGl0b3IsIGluc3RhbmNlTWFuYWdlci5nZXRTZXJ2ZXJTbmFwc2hvdCk7XG4gICAgdXNlRGVidWdWYWx1ZShlZGl0b3IpO1xuICAgIC8vIFRoaXMgZWZmZWN0IHdpbGwgaGFuZGxlIGNyZWF0aW5nL3VwZGF0aW5nIHRoZSBlZGl0b3IgaW5zdGFuY2VcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgdXNlRWZmZWN0KGluc3RhbmNlTWFuYWdlci5vblJlbmRlcihkZXBzKSk7XG4gICAgLy8gVGhlIGRlZmF1bHQgYmVoYXZpb3IgaXMgdG8gcmUtcmVuZGVyIG9uIGVhY2ggdHJhbnNhY3Rpb25cbiAgICAvLyBUaGlzIGlzIGxlZ2FjeSBiZWhhdmlvciB0aGF0IHdpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgdmVyc2lvbnNcbiAgICB1c2VFZGl0b3JTdGF0ZSh7XG4gICAgICAgIGVkaXRvcixcbiAgICAgICAgc2VsZWN0b3I6ICh7IHRyYW5zYWN0aW9uTnVtYmVyIH0pID0+IHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3VsZFJlcmVuZGVyT25UcmFuc2FjdGlvbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHdpbGwgcHJldmVudCB0aGUgZWRpdG9yIGZyb20gcmUtcmVuZGVyaW5nIG9uIGVhY2ggdHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRoaXMgd2lsbCBhdm9pZCByZS1yZW5kZXJpbmcgb24gdGhlIGZpcnN0IHRyYW5zYWN0aW9uIHdoZW4gYGltbWVkaWF0ZWx5UmVuZGVyYCBpcyBzZXQgdG8gYHRydWVgXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5pbW1lZGlhdGVseVJlbmRlciAmJiB0cmFuc2FjdGlvbk51bWJlciA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uTnVtYmVyICsgMTtcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICByZXR1cm4gZWRpdG9yO1xufVxuXG5jb25zdCBFZGl0b3JDb250ZXh0ID0gY3JlYXRlQ29udGV4dCh7XG4gICAgZWRpdG9yOiBudWxsLFxufSk7XG5jb25zdCBFZGl0b3JDb25zdW1lciA9IEVkaXRvckNvbnRleHQuQ29uc3VtZXI7XG4vKipcbiAqIEEgaG9vayB0byBnZXQgdGhlIGN1cnJlbnQgZWRpdG9yIGluc3RhbmNlLlxuICovXG5jb25zdCB1c2VDdXJyZW50RWRpdG9yID0gKCkgPT4gdXNlQ29udGV4dChFZGl0b3JDb250ZXh0KTtcbi8qKlxuICogVGhpcyBpcyB0aGUgcHJvdmlkZXIgY29tcG9uZW50IGZvciB0aGUgZWRpdG9yLlxuICogSXQgYWxsb3dzIHRoZSBlZGl0b3IgdG8gYmUgYWNjZXNzaWJsZSBhY3Jvc3MgdGhlIGVudGlyZSBjb21wb25lbnQgdHJlZVxuICogd2l0aCBgdXNlQ3VycmVudEVkaXRvcmAuXG4gKi9cbmZ1bmN0aW9uIEVkaXRvclByb3ZpZGVyKHsgY2hpbGRyZW4sIHNsb3RBZnRlciwgc2xvdEJlZm9yZSwgZWRpdG9yQ29udGFpbmVyUHJvcHMgPSB7fSwgLi4uZWRpdG9yT3B0aW9ucyB9KSB7XG4gICAgY29uc3QgZWRpdG9yID0gdXNlRWRpdG9yKGVkaXRvck9wdGlvbnMpO1xuICAgIGlmICghZWRpdG9yKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoRWRpdG9yQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogeyBlZGl0b3IgfSB9LFxuICAgICAgICBzbG90QmVmb3JlLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KEVkaXRvckNvbnN1bWVyLCBudWxsLCAoeyBlZGl0b3I6IGN1cnJlbnRFZGl0b3IgfSkgPT4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoRWRpdG9yQ29udGVudCwgeyBlZGl0b3I6IGN1cnJlbnRFZGl0b3IsIC4uLmVkaXRvckNvbnRhaW5lclByb3BzIH0pKSksXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBzbG90QWZ0ZXIpKTtcbn1cblxuY29uc3QgQnViYmxlTWVudSA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IFtlbGVtZW50LCBzZXRFbGVtZW50XSA9IHVzZVN0YXRlKG51bGwpO1xuICAgIGNvbnN0IHsgZWRpdG9yOiBjdXJyZW50RWRpdG9yIH0gPSB1c2VDdXJyZW50RWRpdG9yKCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKChfYSA9IHByb3BzLmVkaXRvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzRGVzdHJveWVkKSB8fCAoY3VycmVudEVkaXRvciA9PT0gbnVsbCB8fCBjdXJyZW50RWRpdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50RWRpdG9yLmlzRGVzdHJveWVkKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgcGx1Z2luS2V5ID0gJ2J1YmJsZU1lbnUnLCBlZGl0b3IsIHRpcHB5T3B0aW9ucyA9IHt9LCB1cGRhdGVEZWxheSwgc2hvdWxkU2hvdyA9IG51bGwsIH0gPSBwcm9wcztcbiAgICAgICAgY29uc3QgbWVudUVkaXRvciA9IGVkaXRvciB8fCBjdXJyZW50RWRpdG9yO1xuICAgICAgICBpZiAoIW1lbnVFZGl0b3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignQnViYmxlTWVudSBjb21wb25lbnQgaXMgbm90IHJlbmRlcmVkIGluc2lkZSBvZiBhbiBlZGl0b3IgY29tcG9uZW50IG9yIGRvZXMgbm90IGhhdmUgZWRpdG9yIHByb3AuJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGx1Z2luID0gQnViYmxlTWVudVBsdWdpbih7XG4gICAgICAgICAgICB1cGRhdGVEZWxheSxcbiAgICAgICAgICAgIGVkaXRvcjogbWVudUVkaXRvcixcbiAgICAgICAgICAgIGVsZW1lbnQsXG4gICAgICAgICAgICBwbHVnaW5LZXksXG4gICAgICAgICAgICBzaG91bGRTaG93LFxuICAgICAgICAgICAgdGlwcHlPcHRpb25zLFxuICAgICAgICB9KTtcbiAgICAgICAgbWVudUVkaXRvci5yZWdpc3RlclBsdWdpbihwbHVnaW4pO1xuICAgICAgICByZXR1cm4gKCkgPT4geyBtZW51RWRpdG9yLnVucmVnaXN0ZXJQbHVnaW4ocGx1Z2luS2V5KTsgfTtcbiAgICB9LCBbcHJvcHMuZWRpdG9yLCBjdXJyZW50RWRpdG9yLCBlbGVtZW50XSk7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcmVmOiBzZXRFbGVtZW50LCBjbGFzc05hbWU6IHByb3BzLmNsYXNzTmFtZSwgc3R5bGU6IHsgdmlzaWJpbGl0eTogJ2hpZGRlbicgfSB9LCBwcm9wcy5jaGlsZHJlbikpO1xufTtcblxuY29uc3QgRmxvYXRpbmdNZW51ID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgW2VsZW1lbnQsIHNldEVsZW1lbnRdID0gdXNlU3RhdGUobnVsbCk7XG4gICAgY29uc3QgeyBlZGl0b3I6IGN1cnJlbnRFZGl0b3IgfSA9IHVzZUN1cnJlbnRFZGl0b3IoKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoKF9hID0gcHJvcHMuZWRpdG9yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNEZXN0cm95ZWQpIHx8IChjdXJyZW50RWRpdG9yID09PSBudWxsIHx8IGN1cnJlbnRFZGl0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnRFZGl0b3IuaXNEZXN0cm95ZWQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBwbHVnaW5LZXkgPSAnZmxvYXRpbmdNZW51JywgZWRpdG9yLCB0aXBweU9wdGlvbnMgPSB7fSwgc2hvdWxkU2hvdyA9IG51bGwsIH0gPSBwcm9wcztcbiAgICAgICAgY29uc3QgbWVudUVkaXRvciA9IGVkaXRvciB8fCBjdXJyZW50RWRpdG9yO1xuICAgICAgICBpZiAoIW1lbnVFZGl0b3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRmxvYXRpbmdNZW51IGNvbXBvbmVudCBpcyBub3QgcmVuZGVyZWQgaW5zaWRlIG9mIGFuIGVkaXRvciBjb21wb25lbnQgb3IgZG9lcyBub3QgaGF2ZSBlZGl0b3IgcHJvcC4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwbHVnaW4gPSBGbG9hdGluZ01lbnVQbHVnaW4oe1xuICAgICAgICAgICAgcGx1Z2luS2V5LFxuICAgICAgICAgICAgZWRpdG9yOiBtZW51RWRpdG9yLFxuICAgICAgICAgICAgZWxlbWVudCxcbiAgICAgICAgICAgIHRpcHB5T3B0aW9ucyxcbiAgICAgICAgICAgIHNob3VsZFNob3csXG4gICAgICAgIH0pO1xuICAgICAgICBtZW51RWRpdG9yLnJlZ2lzdGVyUGx1Z2luKHBsdWdpbik7XG4gICAgICAgIHJldHVybiAoKSA9PiB7IG1lbnVFZGl0b3IudW5yZWdpc3RlclBsdWdpbihwbHVnaW5LZXkpOyB9O1xuICAgIH0sIFtcbiAgICAgICAgcHJvcHMuZWRpdG9yLFxuICAgICAgICBjdXJyZW50RWRpdG9yLFxuICAgICAgICBlbGVtZW50LFxuICAgIF0pO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogc2V0RWxlbWVudCwgY2xhc3NOYW1lOiBwcm9wcy5jbGFzc05hbWUsIHN0eWxlOiB7IHZpc2liaWxpdHk6ICdoaWRkZW4nIH0gfSwgcHJvcHMuY2hpbGRyZW4pKTtcbn07XG5cbmNvbnN0IFJlYWN0Tm9kZVZpZXdDb250ZXh0ID0gY3JlYXRlQ29udGV4dCh7XG4gICAgb25EcmFnU3RhcnQ6IHVuZGVmaW5lZCxcbn0pO1xuY29uc3QgdXNlUmVhY3ROb2RlVmlldyA9ICgpID0+IHVzZUNvbnRleHQoUmVhY3ROb2RlVmlld0NvbnRleHQpO1xuXG5jb25zdCBOb2RlVmlld0NvbnRlbnQgPSBwcm9wcyA9PiB7XG4gICAgY29uc3QgVGFnID0gcHJvcHMuYXMgfHwgJ2Rpdic7XG4gICAgY29uc3QgeyBub2RlVmlld0NvbnRlbnRSZWYgfSA9IHVzZVJlYWN0Tm9kZVZpZXcoKTtcbiAgICByZXR1cm4gKFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFRhZywgeyAuLi5wcm9wcywgcmVmOiBub2RlVmlld0NvbnRlbnRSZWYsIFwiZGF0YS1ub2RlLXZpZXctY29udGVudFwiOiBcIlwiLCBzdHlsZToge1xuICAgICAgICAgICAgd2hpdGVTcGFjZTogJ3ByZS13cmFwJyxcbiAgICAgICAgICAgIC4uLnByb3BzLnN0eWxlLFxuICAgICAgICB9IH0pKTtcbn07XG5cbmNvbnN0IE5vZGVWaWV3V3JhcHBlciA9IFJlYWN0LmZvcndhcmRSZWYoKHByb3BzLCByZWYpID0+IHtcbiAgICBjb25zdCB7IG9uRHJhZ1N0YXJ0IH0gPSB1c2VSZWFjdE5vZGVWaWV3KCk7XG4gICAgY29uc3QgVGFnID0gcHJvcHMuYXMgfHwgJ2Rpdic7XG4gICAgcmV0dXJuIChcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgUmVhY3QuY3JlYXRlRWxlbWVudChUYWcsIHsgLi4ucHJvcHMsIHJlZjogcmVmLCBcImRhdGEtbm9kZS12aWV3LXdyYXBwZXJcIjogXCJcIiwgb25EcmFnU3RhcnQ6IG9uRHJhZ1N0YXJ0LCBzdHlsZToge1xuICAgICAgICAgICAgd2hpdGVTcGFjZTogJ25vcm1hbCcsXG4gICAgICAgICAgICAuLi5wcm9wcy5zdHlsZSxcbiAgICAgICAgfSB9KSk7XG59KTtcblxuLyoqXG4gKiBDaGVjayBpZiBhIGNvbXBvbmVudCBpcyBhIGNsYXNzIGNvbXBvbmVudC5cbiAqIEBwYXJhbSBDb21wb25lbnRcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0NsYXNzQ29tcG9uZW50KENvbXBvbmVudCkge1xuICAgIHJldHVybiAhISh0eXBlb2YgQ29tcG9uZW50ID09PSAnZnVuY3Rpb24nXG4gICAgICAgICYmIENvbXBvbmVudC5wcm90b3R5cGVcbiAgICAgICAgJiYgQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSBjb21wb25lbnQgaXMgYSBmb3J3YXJkIHJlZiBjb21wb25lbnQuXG4gKiBAcGFyYW0gQ29tcG9uZW50XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNGb3J3YXJkUmVmQ29tcG9uZW50KENvbXBvbmVudCkge1xuICAgIHJldHVybiAhISh0eXBlb2YgQ29tcG9uZW50ID09PSAnb2JqZWN0J1xuICAgICAgICAmJiBDb21wb25lbnQuJCR0eXBlb2ZcbiAgICAgICAgJiYgKENvbXBvbmVudC4kJHR5cGVvZi50b1N0cmluZygpID09PSAnU3ltYm9sKHJlYWN0LmZvcndhcmRfcmVmKSdcbiAgICAgICAgICAgIHx8IENvbXBvbmVudC4kJHR5cGVvZi5kZXNjcmlwdGlvbiA9PT0gJ3JlYWN0LmZvcndhcmRfcmVmJykpO1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIGNvbXBvbmVudCBpcyBhIG1lbW9pemVkIGNvbXBvbmVudC5cbiAqIEBwYXJhbSBDb21wb25lbnRcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc01lbW9Db21wb25lbnQoQ29tcG9uZW50KSB7XG4gICAgcmV0dXJuICEhKHR5cGVvZiBDb21wb25lbnQgPT09ICdvYmplY3QnXG4gICAgICAgICYmIENvbXBvbmVudC4kJHR5cGVvZlxuICAgICAgICAmJiAoQ29tcG9uZW50LiQkdHlwZW9mLnRvU3RyaW5nKCkgPT09ICdTeW1ib2wocmVhY3QubWVtbyknIHx8IENvbXBvbmVudC4kJHR5cGVvZi5kZXNjcmlwdGlvbiA9PT0gJ3JlYWN0Lm1lbW8nKSk7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgY29tcG9uZW50IGNhbiBzYWZlbHkgcmVjZWl2ZSBhIHJlZiBwcm9wLlxuICogVGhpcyBpbmNsdWRlcyBjbGFzcyBjb21wb25lbnRzLCBmb3J3YXJkUmVmIGNvbXBvbmVudHMsIGFuZCBtZW1vaXplZCBjb21wb25lbnRzXG4gKiB0aGF0IHdyYXAgZm9yd2FyZFJlZiBvciBjbGFzcyBjb21wb25lbnRzLlxuICogQHBhcmFtIENvbXBvbmVudFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGNhblJlY2VpdmVSZWYoQ29tcG9uZW50KSB7XG4gICAgLy8gQ2hlY2sgaWYgaXQncyBhIGNsYXNzIGNvbXBvbmVudFxuICAgIGlmIChpc0NsYXNzQ29tcG9uZW50KENvbXBvbmVudCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8vIENoZWNrIGlmIGl0J3MgYSBmb3J3YXJkUmVmIGNvbXBvbmVudFxuICAgIGlmIChpc0ZvcndhcmRSZWZDb21wb25lbnQoQ29tcG9uZW50KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gQ2hlY2sgaWYgaXQncyBhIG1lbW9pemVkIGNvbXBvbmVudFxuICAgIGlmIChpc01lbW9Db21wb25lbnQoQ29tcG9uZW50KSkge1xuICAgICAgICAvLyBGb3IgbWVtb2l6ZWQgY29tcG9uZW50cywgY2hlY2sgdGhlIHdyYXBwZWQgY29tcG9uZW50XG4gICAgICAgIGNvbnN0IHdyYXBwZWRDb21wb25lbnQgPSBDb21wb25lbnQudHlwZTtcbiAgICAgICAgaWYgKHdyYXBwZWRDb21wb25lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0NsYXNzQ29tcG9uZW50KHdyYXBwZWRDb21wb25lbnQpIHx8IGlzRm9yd2FyZFJlZkNvbXBvbmVudCh3cmFwcGVkQ29tcG9uZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIENoZWNrIGlmIHdlJ3JlIHJ1bm5pbmcgUmVhY3QgMTkrIGJ5IGRldGVjdGluZyBpZiBmdW5jdGlvbiBjb21wb25lbnRzIHN1cHBvcnQgcmVmIHByb3BzXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNSZWFjdDE5UGx1cygpIHtcbiAgICAvLyBSZWFjdCAxOSBpcyBkZXRlY3RlZCBieSBjaGVja2luZyBSZWFjdCB2ZXJzaW9uIGlmIGF2YWlsYWJsZVxuICAgIC8vIEluIHByYWN0aWNlLCB3ZSdsbCB1c2UgYSBtb3JlIGNvbnNlcnZhdGl2ZSBhcHByb2FjaCBhbmQgYXNzdW1lIFJlYWN0IDE4IGJlaGF2aW9yXG4gICAgLy8gdW5sZXNzIHdlIGNhbiBkZWZpbml0aXZlbHkgZGV0ZWN0IFJlYWN0IDE5XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAodmVyc2lvbikge1xuICAgICAgICAgICAgY29uc3QgbWFqb3JWZXJzaW9uID0gcGFyc2VJbnQodmVyc2lvbi5zcGxpdCgnLicpWzBdLCAxMCk7XG4gICAgICAgICAgICByZXR1cm4gbWFqb3JWZXJzaW9uID49IDE5O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgLy8gRmFsbGJhY2sgdG8gUmVhY3QgMTggYmVoYXZpb3IgaWYgd2UgY2FuJ3QgZGV0ZXJtaW5lIHZlcnNpb25cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBUaGUgUmVhY3RSZW5kZXJlciBjbGFzcy4gSXQncyByZXNwb25zaWJsZSBmb3IgcmVuZGVyaW5nIFJlYWN0IGNvbXBvbmVudHMgaW5zaWRlIHRoZSBlZGl0b3IuXG4gKiBAZXhhbXBsZVxuICogbmV3IFJlYWN0UmVuZGVyZXIoTXlDb21wb25lbnQsIHtcbiAqICAgZWRpdG9yLFxuICogICBwcm9wczoge1xuICogICAgIGZvbzogJ2JhcicsXG4gKiAgIH0sXG4gKiAgIGFzOiAnc3BhbicsXG4gKiB9KVxuKi9cbmNsYXNzIFJlYWN0UmVuZGVyZXIge1xuICAgIC8qKlxuICAgICAqIEltbWVkaWF0ZWx5IGNyZWF0ZXMgZWxlbWVudCBhbmQgcmVuZGVycyB0aGUgcHJvdmlkZWQgUmVhY3QgY29tcG9uZW50LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNvbXBvbmVudCwgeyBlZGl0b3IsIHByb3BzID0ge30sIGFzID0gJ2RpdicsIGNsYXNzTmFtZSA9ICcnLCB9KSB7XG4gICAgICAgIHRoaXMucmVmID0gbnVsbDtcbiAgICAgICAgdGhpcy5pZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDB4RkZGRkZGRkYpLnRvU3RyaW5nKCk7XG4gICAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgICAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcbiAgICAgICAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGFzKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQoJ3JlYWN0LXJlbmRlcmVyJyk7XG4gICAgICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKC4uLmNsYXNzTmFtZS5zcGxpdCgnICcpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgZWRpdG9yIGlzIGFscmVhZHkgaW5pdGlhbGl6ZWQsIHdlIHdpbGwgbmVlZCB0b1xuICAgICAgICAvLyBzeW5jaHJvbm91c2x5IHJlbmRlciB0aGUgY29tcG9uZW50IHRvIGVuc3VyZSBpdCByZW5kZXJzXG4gICAgICAgIC8vIHRvZ2V0aGVyIHdpdGggUHJvc2VtaXJyb3IncyByZW5kZXJpbmcuXG4gICAgICAgIGlmICh0aGlzLmVkaXRvci5pc0luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICBmbHVzaFN5bmMoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVuZGVyIHRoZSBSZWFjdCBjb21wb25lbnQuXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IENvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50O1xuICAgICAgICBjb25zdCBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgICAgICAvLyBIYW5kbGUgcmVmIGZvcndhcmRpbmcgd2l0aCBSZWFjdCAxOC8xOSBjb21wYXRpYmlsaXR5XG4gICAgICAgIGNvbnN0IGlzUmVhY3QxOSA9IGlzUmVhY3QxOVBsdXMoKTtcbiAgICAgICAgY29uc3QgY29tcG9uZW50Q2FuUmVjZWl2ZVJlZiA9IGNhblJlY2VpdmVSZWYoQ29tcG9uZW50KTtcbiAgICAgICAgY29uc3QgZWxlbWVudFByb3BzID0geyAuLi5wcm9wcyB9O1xuICAgICAgICAvLyBBbHdheXMgcmVtb3ZlIHJlZiBpZiB0aGUgY29tcG9uZW50IGNhbm5vdCByZWNlaXZlIGl0ICh1bmxlc3MgUmVhY3QgMTkrKVxuICAgICAgICBpZiAoZWxlbWVudFByb3BzLnJlZiAmJiAhKGlzUmVhY3QxOSB8fCBjb21wb25lbnRDYW5SZWNlaXZlUmVmKSkge1xuICAgICAgICAgICAgZGVsZXRlIGVsZW1lbnRQcm9wcy5yZWY7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT25seSBhc3NpZ24gb3VyIG93biByZWYgaWYgYWxsb3dlZFxuICAgICAgICBpZiAoIWVsZW1lbnRQcm9wcy5yZWYgJiYgKGlzUmVhY3QxOSB8fCBjb21wb25lbnRDYW5SZWNlaXZlUmVmKSkge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSAtIFNldHRpbmcgcmVmIHByb3AgZm9yIGNvbXBhdGlibGUgY29tcG9uZW50c1xuICAgICAgICAgICAgZWxlbWVudFByb3BzLnJlZiA9IChyZWYpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZiA9IHJlZjtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWFjdEVsZW1lbnQgPSBSZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvbmVudCwgeyAuLi5lbGVtZW50UHJvcHMgfSk7XG4gICAgICAgIChfYSA9IGVkaXRvciA9PT0gbnVsbCB8fCBlZGl0b3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVkaXRvci5jb250ZW50Q29tcG9uZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0UmVuZGVyZXIodGhpcy5pZCwgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlLXJlbmRlcnMgdGhlIFJlYWN0IGNvbXBvbmVudCB3aXRoIG5ldyBwcm9wcy5cbiAgICAgKi9cbiAgICB1cGRhdGVQcm9wcyhwcm9wcyA9IHt9KSB7XG4gICAgICAgIHRoaXMucHJvcHMgPSB7XG4gICAgICAgICAgICAuLi50aGlzLnByb3BzLFxuICAgICAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3Ryb3kgdGhlIFJlYWN0IGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuZWRpdG9yO1xuICAgICAgICAoX2EgPSBlZGl0b3IgPT09IG51bGwgfHwgZWRpdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlZGl0b3IuY29udGVudENvbXBvbmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZVJlbmRlcmVyKHRoaXMuaWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIGVsZW1lbnQgdGhhdCBob2xkcyB0aGUgUmVhY3QgY29tcG9uZW50LlxuICAgICAqL1xuICAgIHVwZGF0ZUF0dHJpYnV0ZXMoYXR0cmlidXRlcykge1xuICAgICAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKGtleSwgYXR0cmlidXRlc1trZXldKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jbGFzcyBSZWFjdE5vZGVWaWV3IGV4dGVuZHMgTm9kZVZpZXcge1xuICAgIGNvbnN0cnVjdG9yKGNvbXBvbmVudCwgcHJvcHMsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoY29tcG9uZW50LCBwcm9wcywgb3B0aW9ucyk7XG4gICAgICAgIGlmICghdGhpcy5ub2RlLmlzTGVhZikge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb250ZW50RE9NRWxlbWVudFRhZykge1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGVudERPTUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMub3B0aW9ucy5jb250ZW50RE9NRWxlbWVudFRhZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRET01FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0aGlzLm5vZGUuaXNJbmxpbmUgPyAnc3BhbicgOiAnZGl2Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRET01FbGVtZW50LmRhdGFzZXQubm9kZVZpZXdDb250ZW50UmVhY3QgPSAnJztcbiAgICAgICAgICAgIHRoaXMuY29udGVudERPTUVsZW1lbnQuZGF0YXNldC5ub2RlVmlld1dyYXBwZXIgPSAnJztcbiAgICAgICAgICAgIC8vIEZvciBzb21lIHJlYXNvbiB0aGUgd2hpdGVTcGFjZSBwcm9wIGlzIG5vdCBpbmhlcml0ZWQgcHJvcGVybHkgaW4gQ2hyb21lIGFuZCBTYWZhcmlcbiAgICAgICAgICAgIC8vIFdpdGggdGhpcyBmaXggaXQgc2VlbXMgdG8gd29yayBmaW5lXG4gICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS91ZWJlcmRvc2lzL3RpcHRhcC9pc3N1ZXMvMTE5N1xuICAgICAgICAgICAgdGhpcy5jb250ZW50RE9NRWxlbWVudC5zdHlsZS53aGl0ZVNwYWNlID0gJ2luaGVyaXQnO1xuICAgICAgICAgICAgY29uc3QgY29udGVudFRhcmdldCA9IHRoaXMuZG9tLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhLW5vZGUtdmlldy1jb250ZW50XScpO1xuICAgICAgICAgICAgaWYgKCFjb250ZW50VGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGVudFRhcmdldC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRlbnRET01FbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXR1cCB0aGUgUmVhY3QgY29tcG9uZW50LlxuICAgICAqIENhbGxlZCBvbiBpbml0aWFsaXphdGlvbi5cbiAgICAgKi9cbiAgICBtb3VudCgpIHtcbiAgICAgICAgY29uc3QgcHJvcHMgPSB7XG4gICAgICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgICAgICAgbm9kZTogdGhpcy5ub2RlLFxuICAgICAgICAgICAgZGVjb3JhdGlvbnM6IHRoaXMuZGVjb3JhdGlvbnMsXG4gICAgICAgICAgICBpbm5lckRlY29yYXRpb25zOiB0aGlzLmlubmVyRGVjb3JhdGlvbnMsXG4gICAgICAgICAgICB2aWV3OiB0aGlzLnZpZXcsXG4gICAgICAgICAgICBzZWxlY3RlZDogZmFsc2UsXG4gICAgICAgICAgICBleHRlbnNpb246IHRoaXMuZXh0ZW5zaW9uLFxuICAgICAgICAgICAgSFRNTEF0dHJpYnV0ZXM6IHRoaXMuSFRNTEF0dHJpYnV0ZXMsXG4gICAgICAgICAgICBnZXRQb3M6ICgpID0+IHRoaXMuZ2V0UG9zKCksXG4gICAgICAgICAgICB1cGRhdGVBdHRyaWJ1dGVzOiAoYXR0cmlidXRlcyA9IHt9KSA9PiB0aGlzLnVwZGF0ZUF0dHJpYnV0ZXMoYXR0cmlidXRlcyksXG4gICAgICAgICAgICBkZWxldGVOb2RlOiAoKSA9PiB0aGlzLmRlbGV0ZU5vZGUoKSxcbiAgICAgICAgICAgIHJlZjogY3JlYXRlUmVmKCksXG4gICAgICAgIH07XG4gICAgICAgIGlmICghdGhpcy5jb21wb25lbnQuZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNhcGl0YWxpemVGaXJzdENoYXIgPSAoc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0cmluZy5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnQuZGlzcGxheU5hbWUgPSBjYXBpdGFsaXplRmlyc3RDaGFyKHRoaXMuZXh0ZW5zaW9uLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9uRHJhZ1N0YXJ0ID0gdGhpcy5vbkRyYWdTdGFydC5iaW5kKHRoaXMpO1xuICAgICAgICBjb25zdCBub2RlVmlld0NvbnRlbnRSZWYgPSBlbGVtZW50ID0+IHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50ICYmIHRoaXMuY29udGVudERPTUVsZW1lbnQgJiYgZWxlbWVudC5maXJzdENoaWxkICE9PSB0aGlzLmNvbnRlbnRET01FbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBub2RlVmlld1dyYXBwZXIgYXR0cmlidXRlIGZyb20gdGhlIGVsZW1lbnRcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2RhdGEtbm9kZS12aWV3LXdyYXBwZXInKSkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS1ub2RlLXZpZXctd3JhcHBlcicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuY29udGVudERPTUVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjb250ZXh0ID0geyBvbkRyYWdTdGFydCwgbm9kZVZpZXdDb250ZW50UmVmIH07XG4gICAgICAgIGNvbnN0IENvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50O1xuICAgICAgICAvLyBGb3IgcGVyZm9ybWFuY2UgcmVhc29ucywgd2UgbWVtb2l6ZSB0aGUgcHJvdmlkZXIgY29tcG9uZW50XG4gICAgICAgIC8vIEFuZCBhbGwgb2YgdGhlIHRoaW5ncyBpdCByZXF1aXJlcyBhcmUgZGVjbGFyZWQgb3V0c2lkZSBvZiB0aGUgY29tcG9uZW50LCBzbyBpdCBkb2Vzbid0IG5lZWQgdG8gcmUtcmVuZGVyXG4gICAgICAgIGNvbnN0IFJlYWN0Tm9kZVZpZXdQcm92aWRlciA9IG1lbW8oY29tcG9uZW50UHJvcHMgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0Tm9kZVZpZXdDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBjb250ZXh0IH0sIGNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCBjb21wb25lbnRQcm9wcykpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIFJlYWN0Tm9kZVZpZXdQcm92aWRlci5kaXNwbGF5TmFtZSA9ICdSZWFjdE5vZGVWaWV3JztcbiAgICAgICAgbGV0IGFzID0gdGhpcy5ub2RlLmlzSW5saW5lID8gJ3NwYW4nIDogJ2Rpdic7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXMpIHtcbiAgICAgICAgICAgIGFzID0gdGhpcy5vcHRpb25zLmFzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgY2xhc3NOYW1lID0gJycgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgdGhpcy5oYW5kbGVTZWxlY3Rpb25VcGRhdGUgPSB0aGlzLmhhbmRsZVNlbGVjdGlvblVwZGF0ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gbmV3IFJlYWN0UmVuZGVyZXIoUmVhY3ROb2RlVmlld1Byb3ZpZGVyLCB7XG4gICAgICAgICAgICBlZGl0b3I6IHRoaXMuZWRpdG9yLFxuICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICBhcyxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogYG5vZGUtJHt0aGlzLm5vZGUudHlwZS5uYW1lfSAke2NsYXNzTmFtZX1gLnRyaW0oKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZWRpdG9yLm9uKCdzZWxlY3Rpb25VcGRhdGUnLCB0aGlzLmhhbmRsZVNlbGVjdGlvblVwZGF0ZSk7XG4gICAgICAgIHRoaXMudXBkYXRlRWxlbWVudEF0dHJpYnV0ZXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBET00gZWxlbWVudC5cbiAgICAgKiBUaGlzIGlzIHRoZSBlbGVtZW50IHRoYXQgd2lsbCBiZSB1c2VkIHRvIGRpc3BsYXkgdGhlIG5vZGUgdmlldy5cbiAgICAgKi9cbiAgICBnZXQgZG9tKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aGlzLnJlbmRlcmVyLmVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGRcbiAgICAgICAgICAgICYmICEoKF9hID0gdGhpcy5yZW5kZXJlci5lbGVtZW50LmZpcnN0RWxlbWVudENoaWxkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGFzQXR0cmlidXRlKCdkYXRhLW5vZGUtdmlldy13cmFwcGVyJykpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignUGxlYXNlIHVzZSB0aGUgTm9kZVZpZXdXcmFwcGVyIGNvbXBvbmVudCBmb3IgeW91ciBub2RlIHZpZXcuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuZWxlbWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBjb250ZW50IERPTSBlbGVtZW50LlxuICAgICAqIFRoaXMgaXMgdGhlIGVsZW1lbnQgdGhhdCB3aWxsIGJlIHVzZWQgdG8gZGlzcGxheSB0aGUgcmljaC10ZXh0IGNvbnRlbnQgb2YgdGhlIG5vZGUuXG4gICAgICovXG4gICAgZ2V0IGNvbnRlbnRET00oKSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGUuaXNMZWFmKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50RE9NRWxlbWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT24gZWRpdG9yIHNlbGVjdGlvbiB1cGRhdGUsIGNoZWNrIGlmIHRoZSBub2RlIGlzIHNlbGVjdGVkLlxuICAgICAqIElmIGl0IGlzLCBjYWxsIGBzZWxlY3ROb2RlYCwgb3RoZXJ3aXNlIGNhbGwgYGRlc2VsZWN0Tm9kZWAuXG4gICAgICovXG4gICAgaGFuZGxlU2VsZWN0aW9uVXBkYXRlKCkge1xuICAgICAgICBjb25zdCB7IGZyb20sIHRvIH0gPSB0aGlzLmVkaXRvci5zdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGNvbnN0IHBvcyA9IHRoaXMuZ2V0UG9zKCk7XG4gICAgICAgIGlmICh0eXBlb2YgcG9zICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmcm9tIDw9IHBvcyAmJiB0byA+PSBwb3MgKyB0aGlzLm5vZGUubm9kZVNpemUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlbmRlcmVyLnByb3BzLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZWxlY3ROb2RlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucmVuZGVyZXIucHJvcHMuc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmRlc2VsZWN0Tm9kZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9uIHVwZGF0ZSwgdXBkYXRlIHRoZSBSZWFjdCBjb21wb25lbnQuXG4gICAgICogVG8gcHJldmVudCB1bm5lY2Vzc2FyeSB1cGRhdGVzLCB0aGUgYHVwZGF0ZWAgb3B0aW9uIGNhbiBiZSB1c2VkLlxuICAgICAqL1xuICAgIHVwZGF0ZShub2RlLCBkZWNvcmF0aW9ucywgaW5uZXJEZWNvcmF0aW9ucykge1xuICAgICAgICBjb25zdCByZXJlbmRlckNvbXBvbmVudCA9IChwcm9wcykgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci51cGRhdGVQcm9wcyhwcm9wcyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5hdHRycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlRWxlbWVudEF0dHJpYnV0ZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG5vZGUudHlwZSAhPT0gdGhpcy5ub2RlLnR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy51cGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnN0IG9sZE5vZGUgPSB0aGlzLm5vZGU7XG4gICAgICAgICAgICBjb25zdCBvbGREZWNvcmF0aW9ucyA9IHRoaXMuZGVjb3JhdGlvbnM7XG4gICAgICAgICAgICBjb25zdCBvbGRJbm5lckRlY29yYXRpb25zID0gdGhpcy5pbm5lckRlY29yYXRpb25zO1xuICAgICAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSBkZWNvcmF0aW9ucztcbiAgICAgICAgICAgIHRoaXMuaW5uZXJEZWNvcmF0aW9ucyA9IGlubmVyRGVjb3JhdGlvbnM7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgb2xkTm9kZSxcbiAgICAgICAgICAgICAgICBvbGREZWNvcmF0aW9ucyxcbiAgICAgICAgICAgICAgICBuZXdOb2RlOiBub2RlLFxuICAgICAgICAgICAgICAgIG5ld0RlY29yYXRpb25zOiBkZWNvcmF0aW9ucyxcbiAgICAgICAgICAgICAgICBvbGRJbm5lckRlY29yYXRpb25zLFxuICAgICAgICAgICAgICAgIGlubmVyRGVjb3JhdGlvbnMsXG4gICAgICAgICAgICAgICAgdXBkYXRlUHJvcHM6ICgpID0+IHJlcmVuZGVyQ29tcG9uZW50KHsgbm9kZSwgZGVjb3JhdGlvbnMsIGlubmVyRGVjb3JhdGlvbnMgfSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSA9PT0gdGhpcy5ub2RlXG4gICAgICAgICAgICAmJiB0aGlzLmRlY29yYXRpb25zID09PSBkZWNvcmF0aW9uc1xuICAgICAgICAgICAgJiYgdGhpcy5pbm5lckRlY29yYXRpb25zID09PSBpbm5lckRlY29yYXRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gZGVjb3JhdGlvbnM7XG4gICAgICAgIHRoaXMuaW5uZXJEZWNvcmF0aW9ucyA9IGlubmVyRGVjb3JhdGlvbnM7XG4gICAgICAgIHJlcmVuZGVyQ29tcG9uZW50KHsgbm9kZSwgZGVjb3JhdGlvbnMsIGlubmVyRGVjb3JhdGlvbnMgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZWxlY3QgdGhlIG5vZGUuXG4gICAgICogQWRkIHRoZSBgc2VsZWN0ZWRgIHByb3AgYW5kIHRoZSBgUHJvc2VNaXJyb3Itc2VsZWN0ZWRub2RlYCBjbGFzcy5cbiAgICAgKi9cbiAgICBzZWxlY3ROb2RlKCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnVwZGF0ZVByb3BzKHtcbiAgICAgICAgICAgIHNlbGVjdGVkOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5lbGVtZW50LmNsYXNzTGlzdC5hZGQoJ1Byb3NlTWlycm9yLXNlbGVjdGVkbm9kZScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXNlbGVjdCB0aGUgbm9kZS5cbiAgICAgKiBSZW1vdmUgdGhlIGBzZWxlY3RlZGAgcHJvcCBhbmQgdGhlIGBQcm9zZU1pcnJvci1zZWxlY3RlZG5vZGVgIGNsYXNzLlxuICAgICAqL1xuICAgIGRlc2VsZWN0Tm9kZSgpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlci51cGRhdGVQcm9wcyh7XG4gICAgICAgICAgICBzZWxlY3RlZDogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSgnUHJvc2VNaXJyb3Itc2VsZWN0ZWRub2RlJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3Ryb3kgdGhlIFJlYWN0IGNvbXBvbmVudCBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5lZGl0b3Iub2ZmKCdzZWxlY3Rpb25VcGRhdGUnLCB0aGlzLmhhbmRsZVNlbGVjdGlvblVwZGF0ZSk7XG4gICAgICAgIHRoaXMuY29udGVudERPTUVsZW1lbnQgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIHRvcC1sZXZlbCBlbGVtZW50IHRoYXQgaG9sZHMgdGhlIFJlYWN0IGNvbXBvbmVudC5cbiAgICAgKiBBcHBseWluZyB0aGUgYXR0cmlidXRlcyBkZWZpbmVkIGluIHRoZSBgYXR0cnNgIG9wdGlvbi5cbiAgICAgKi9cbiAgICB1cGRhdGVFbGVtZW50QXR0cmlidXRlcygpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdHRycykge1xuICAgICAgICAgICAgbGV0IGF0dHJzT2JqID0ge307XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5hdHRycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4dGVuc2lvbkF0dHJpYnV0ZXMgPSB0aGlzLmVkaXRvci5leHRlbnNpb25NYW5hZ2VyLmF0dHJpYnV0ZXM7XG4gICAgICAgICAgICAgICAgY29uc3QgSFRNTEF0dHJpYnV0ZXMgPSBnZXRSZW5kZXJlZEF0dHJpYnV0ZXModGhpcy5ub2RlLCBleHRlbnNpb25BdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgICAgICBhdHRyc09iaiA9IHRoaXMub3B0aW9ucy5hdHRycyh7IG5vZGU6IHRoaXMubm9kZSwgSFRNTEF0dHJpYnV0ZXMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhdHRyc09iaiA9IHRoaXMub3B0aW9ucy5hdHRycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIudXBkYXRlQXR0cmlidXRlcyhhdHRyc09iaik7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIENyZWF0ZSBhIFJlYWN0IG5vZGUgdmlldyByZW5kZXJlci5cbiAqL1xuZnVuY3Rpb24gUmVhY3ROb2RlVmlld1JlbmRlcmVyKGNvbXBvbmVudCwgb3B0aW9ucykge1xuICAgIHJldHVybiBwcm9wcyA9PiB7XG4gICAgICAgIC8vIHRyeSB0byBnZXQgdGhlIHBhcmVudCBjb21wb25lbnRcbiAgICAgICAgLy8gdGhpcyBpcyBpbXBvcnRhbnQgZm9yIHZ1ZSBkZXZ0b29scyB0byBzaG93IHRoZSBjb21wb25lbnQgaGllcmFyY2h5IGNvcnJlY3RseVxuICAgICAgICAvLyBtYXliZSBpdOKAmXMgYHVuZGVmaW5lZGAgYmVjYXVzZSA8ZWRpdG9yLWNvbnRlbnQ+IGlzbuKAmXQgcmVuZGVyZWQgeWV0XG4gICAgICAgIGlmICghcHJvcHMuZWRpdG9yLmNvbnRlbnRDb21wb25lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFJlYWN0Tm9kZVZpZXcoY29tcG9uZW50LCBwcm9wcywgb3B0aW9ucyk7XG4gICAgfTtcbn1cblxuZXhwb3J0IHsgQnViYmxlTWVudSwgRWRpdG9yQ29uc3VtZXIsIEVkaXRvckNvbnRlbnQsIEVkaXRvckNvbnRleHQsIEVkaXRvclByb3ZpZGVyLCBGbG9hdGluZ01lbnUsIE5vZGVWaWV3Q29udGVudCwgTm9kZVZpZXdXcmFwcGVyLCBQdXJlRWRpdG9yQ29udGVudCwgUmVhY3ROb2RlVmlldywgUmVhY3ROb2RlVmlld0NvbnRleHQsIFJlYWN0Tm9kZVZpZXdSZW5kZXJlciwgUmVhY3RSZW5kZXJlciwgdXNlQ3VycmVudEVkaXRvciwgdXNlRWRpdG9yLCB1c2VFZGl0b3JTdGF0ZSwgdXNlUmVhY3ROb2RlVmlldyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/react/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@tiptap/starter-kit/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@tiptap/starter-kit/dist/index.js ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StarterKit: function() { return /* binding */ StarterKit; },\n/* harmony export */   \"default\": function() { return /* binding */ StarterKit; }\n/* harmony export */ });\n/* harmony import */ var _tiptap_core__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @tiptap/core */ \"(app-pages-browser)/./node_modules/@tiptap/core/dist/index.js\");\n/* harmony import */ var _tiptap_extension_blockquote__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tiptap/extension-blockquote */ \"(app-pages-browser)/./node_modules/@tiptap/extension-blockquote/dist/index.js\");\n/* harmony import */ var _tiptap_extension_bold__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tiptap/extension-bold */ \"(app-pages-browser)/./node_modules/@tiptap/extension-bold/dist/index.js\");\n/* harmony import */ var _tiptap_extension_bullet_list__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tiptap/extension-bullet-list */ \"(app-pages-browser)/./node_modules/@tiptap/extension-bullet-list/dist/index.js\");\n/* harmony import */ var _tiptap_extension_code__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @tiptap/extension-code */ \"(app-pages-browser)/./node_modules/@tiptap/extension-code/dist/index.js\");\n/* harmony import */ var _tiptap_extension_code_block__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @tiptap/extension-code-block */ \"(app-pages-browser)/./node_modules/@tiptap/extension-code-block/dist/index.js\");\n/* harmony import */ var _tiptap_extension_document__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tiptap/extension-document */ \"(app-pages-browser)/./node_modules/@tiptap/extension-document/dist/index.js\");\n/* harmony import */ var _tiptap_extension_dropcursor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @tiptap/extension-dropcursor */ \"(app-pages-browser)/./node_modules/@tiptap/extension-dropcursor/dist/index.js\");\n/* harmony import */ var _tiptap_extension_gapcursor__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @tiptap/extension-gapcursor */ \"(app-pages-browser)/./node_modules/@tiptap/extension-gapcursor/dist/index.js\");\n/* harmony import */ var _tiptap_extension_hard_break__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @tiptap/extension-hard-break */ \"(app-pages-browser)/./node_modules/@tiptap/extension-hard-break/dist/index.js\");\n/* harmony import */ var _tiptap_extension_heading__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @tiptap/extension-heading */ \"(app-pages-browser)/./node_modules/@tiptap/extension-heading/dist/index.js\");\n/* harmony import */ var _tiptap_extension_history__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @tiptap/extension-history */ \"(app-pages-browser)/./node_modules/@tiptap/extension-history/dist/index.js\");\n/* harmony import */ var _tiptap_extension_horizontal_rule__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @tiptap/extension-horizontal-rule */ \"(app-pages-browser)/./node_modules/@tiptap/extension-horizontal-rule/dist/index.js\");\n/* harmony import */ var _tiptap_extension_italic__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @tiptap/extension-italic */ \"(app-pages-browser)/./node_modules/@tiptap/extension-italic/dist/index.js\");\n/* harmony import */ var _tiptap_extension_list_item__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @tiptap/extension-list-item */ \"(app-pages-browser)/./node_modules/@tiptap/extension-list-item/dist/index.js\");\n/* harmony import */ var _tiptap_extension_ordered_list__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @tiptap/extension-ordered-list */ \"(app-pages-browser)/./node_modules/@tiptap/extension-ordered-list/dist/index.js\");\n/* harmony import */ var _tiptap_extension_paragraph__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @tiptap/extension-paragraph */ \"(app-pages-browser)/./node_modules/@tiptap/extension-paragraph/dist/index.js\");\n/* harmony import */ var _tiptap_extension_strike__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @tiptap/extension-strike */ \"(app-pages-browser)/./node_modules/@tiptap/extension-strike/dist/index.js\");\n/* harmony import */ var _tiptap_extension_text__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @tiptap/extension-text */ \"(app-pages-browser)/./node_modules/@tiptap/extension-text/dist/index.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * The starter kit is a collection of essential editor extensions.\n *\n * It’s a good starting point for building your own editor.\n */\nconst StarterKit = _tiptap_core__WEBPACK_IMPORTED_MODULE_18__.Extension.create({\n    name: 'starterKit',\n    addExtensions() {\n        const extensions = [];\n        if (this.options.bold !== false) {\n            extensions.push(_tiptap_extension_bold__WEBPACK_IMPORTED_MODULE_1__.Bold.configure(this.options.bold));\n        }\n        if (this.options.blockquote !== false) {\n            extensions.push(_tiptap_extension_blockquote__WEBPACK_IMPORTED_MODULE_0__.Blockquote.configure(this.options.blockquote));\n        }\n        if (this.options.bulletList !== false) {\n            extensions.push(_tiptap_extension_bullet_list__WEBPACK_IMPORTED_MODULE_2__.BulletList.configure(this.options.bulletList));\n        }\n        if (this.options.code !== false) {\n            extensions.push(_tiptap_extension_code__WEBPACK_IMPORTED_MODULE_3__.Code.configure(this.options.code));\n        }\n        if (this.options.codeBlock !== false) {\n            extensions.push(_tiptap_extension_code_block__WEBPACK_IMPORTED_MODULE_4__.CodeBlock.configure(this.options.codeBlock));\n        }\n        if (this.options.document !== false) {\n            extensions.push(_tiptap_extension_document__WEBPACK_IMPORTED_MODULE_5__.Document.configure(this.options.document));\n        }\n        if (this.options.dropcursor !== false) {\n            extensions.push(_tiptap_extension_dropcursor__WEBPACK_IMPORTED_MODULE_6__.Dropcursor.configure(this.options.dropcursor));\n        }\n        if (this.options.gapcursor !== false) {\n            extensions.push(_tiptap_extension_gapcursor__WEBPACK_IMPORTED_MODULE_7__.Gapcursor.configure(this.options.gapcursor));\n        }\n        if (this.options.hardBreak !== false) {\n            extensions.push(_tiptap_extension_hard_break__WEBPACK_IMPORTED_MODULE_8__.HardBreak.configure(this.options.hardBreak));\n        }\n        if (this.options.heading !== false) {\n            extensions.push(_tiptap_extension_heading__WEBPACK_IMPORTED_MODULE_9__.Heading.configure(this.options.heading));\n        }\n        if (this.options.history !== false) {\n            extensions.push(_tiptap_extension_history__WEBPACK_IMPORTED_MODULE_10__.History.configure(this.options.history));\n        }\n        if (this.options.horizontalRule !== false) {\n            extensions.push(_tiptap_extension_horizontal_rule__WEBPACK_IMPORTED_MODULE_11__.HorizontalRule.configure(this.options.horizontalRule));\n        }\n        if (this.options.italic !== false) {\n            extensions.push(_tiptap_extension_italic__WEBPACK_IMPORTED_MODULE_12__.Italic.configure(this.options.italic));\n        }\n        if (this.options.listItem !== false) {\n            extensions.push(_tiptap_extension_list_item__WEBPACK_IMPORTED_MODULE_13__.ListItem.configure(this.options.listItem));\n        }\n        if (this.options.orderedList !== false) {\n            extensions.push(_tiptap_extension_ordered_list__WEBPACK_IMPORTED_MODULE_14__.OrderedList.configure(this.options.orderedList));\n        }\n        if (this.options.paragraph !== false) {\n            extensions.push(_tiptap_extension_paragraph__WEBPACK_IMPORTED_MODULE_15__.Paragraph.configure(this.options.paragraph));\n        }\n        if (this.options.strike !== false) {\n            extensions.push(_tiptap_extension_strike__WEBPACK_IMPORTED_MODULE_16__.Strike.configure(this.options.strike));\n        }\n        if (this.options.text !== false) {\n            extensions.push(_tiptap_extension_text__WEBPACK_IMPORTED_MODULE_17__.Text.configure(this.options.text));\n        }\n        return extensions;\n    },\n});\n\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AdGlwdGFwL3N0YXJ0ZXIta2l0L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXlDO0FBQ2lCO0FBQ1o7QUFDYTtBQUNiO0FBQ1c7QUFDSDtBQUNJO0FBQ0Y7QUFDQztBQUNMO0FBQ0E7QUFDZTtBQUNqQjtBQUNLO0FBQ007QUFDTDtBQUNOO0FBQ0o7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0RBQVM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsd0RBQUk7QUFDaEM7QUFDQTtBQUNBLDRCQUE0QixvRUFBVTtBQUN0QztBQUNBO0FBQ0EsNEJBQTRCLHFFQUFVO0FBQ3RDO0FBQ0E7QUFDQSw0QkFBNEIsd0RBQUk7QUFDaEM7QUFDQTtBQUNBLDRCQUE0QixtRUFBUztBQUNyQztBQUNBO0FBQ0EsNEJBQTRCLGdFQUFRO0FBQ3BDO0FBQ0E7QUFDQSw0QkFBNEIsb0VBQVU7QUFDdEM7QUFDQTtBQUNBLDRCQUE0QixrRUFBUztBQUNyQztBQUNBO0FBQ0EsNEJBQTRCLG1FQUFTO0FBQ3JDO0FBQ0E7QUFDQSw0QkFBNEIsOERBQU87QUFDbkM7QUFDQTtBQUNBLDRCQUE0QiwrREFBTztBQUNuQztBQUNBO0FBQ0EsNEJBQTRCLDhFQUFjO0FBQzFDO0FBQ0E7QUFDQSw0QkFBNEIsNkRBQU07QUFDbEM7QUFDQTtBQUNBLDRCQUE0QixrRUFBUTtBQUNwQztBQUNBO0FBQ0EsNEJBQTRCLHdFQUFXO0FBQ3ZDO0FBQ0E7QUFDQSw0QkFBNEIsbUVBQVM7QUFDckM7QUFDQTtBQUNBLDRCQUE0Qiw2REFBTTtBQUNsQztBQUNBO0FBQ0EsNEJBQTRCLHlEQUFJO0FBQ2hDO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQzs7QUFFNEM7QUFDN0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0B0aXB0YXAvc3RhcnRlci1raXQvZGlzdC9pbmRleC5qcz82YjY2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV4dGVuc2lvbiB9IGZyb20gJ0B0aXB0YXAvY29yZSc7XG5pbXBvcnQgeyBCbG9ja3F1b3RlIH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tYmxvY2txdW90ZSc7XG5pbXBvcnQgeyBCb2xkIH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tYm9sZCc7XG5pbXBvcnQgeyBCdWxsZXRMaXN0IH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tYnVsbGV0LWxpc3QnO1xuaW1wb3J0IHsgQ29kZSB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWNvZGUnO1xuaW1wb3J0IHsgQ29kZUJsb2NrIH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tY29kZS1ibG9jayc7XG5pbXBvcnQgeyBEb2N1bWVudCB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWRvY3VtZW50JztcbmltcG9ydCB7IERyb3BjdXJzb3IgfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1kcm9wY3Vyc29yJztcbmltcG9ydCB7IEdhcGN1cnNvciB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWdhcGN1cnNvcic7XG5pbXBvcnQgeyBIYXJkQnJlYWsgfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1oYXJkLWJyZWFrJztcbmltcG9ydCB7IEhlYWRpbmcgfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1oZWFkaW5nJztcbmltcG9ydCB7IEhpc3RvcnkgfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1oaXN0b3J5JztcbmltcG9ydCB7IEhvcml6b250YWxSdWxlIH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24taG9yaXpvbnRhbC1ydWxlJztcbmltcG9ydCB7IEl0YWxpYyB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWl0YWxpYyc7XG5pbXBvcnQgeyBMaXN0SXRlbSB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLWxpc3QtaXRlbSc7XG5pbXBvcnQgeyBPcmRlcmVkTGlzdCB9IGZyb20gJ0B0aXB0YXAvZXh0ZW5zaW9uLW9yZGVyZWQtbGlzdCc7XG5pbXBvcnQgeyBQYXJhZ3JhcGggfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi1wYXJhZ3JhcGgnO1xuaW1wb3J0IHsgU3RyaWtlIH0gZnJvbSAnQHRpcHRhcC9leHRlbnNpb24tc3RyaWtlJztcbmltcG9ydCB7IFRleHQgfSBmcm9tICdAdGlwdGFwL2V4dGVuc2lvbi10ZXh0JztcblxuLyoqXG4gKiBUaGUgc3RhcnRlciBraXQgaXMgYSBjb2xsZWN0aW9uIG9mIGVzc2VudGlhbCBlZGl0b3IgZXh0ZW5zaW9ucy5cbiAqXG4gKiBJdOKAmXMgYSBnb29kIHN0YXJ0aW5nIHBvaW50IGZvciBidWlsZGluZyB5b3VyIG93biBlZGl0b3IuXG4gKi9cbmNvbnN0IFN0YXJ0ZXJLaXQgPSBFeHRlbnNpb24uY3JlYXRlKHtcbiAgICBuYW1lOiAnc3RhcnRlcktpdCcsXG4gICAgYWRkRXh0ZW5zaW9ucygpIHtcbiAgICAgICAgY29uc3QgZXh0ZW5zaW9ucyA9IFtdO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJvbGQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBleHRlbnNpb25zLnB1c2goQm9sZC5jb25maWd1cmUodGhpcy5vcHRpb25zLmJvbGQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJsb2NrcXVvdGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBleHRlbnNpb25zLnB1c2goQmxvY2txdW90ZS5jb25maWd1cmUodGhpcy5vcHRpb25zLmJsb2NrcXVvdGUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJ1bGxldExpc3QgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBleHRlbnNpb25zLnB1c2goQnVsbGV0TGlzdC5jb25maWd1cmUodGhpcy5vcHRpb25zLmJ1bGxldExpc3QpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNvZGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBleHRlbnNpb25zLnB1c2goQ29kZS5jb25maWd1cmUodGhpcy5vcHRpb25zLmNvZGUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNvZGVCbG9jayAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGV4dGVuc2lvbnMucHVzaChDb2RlQmxvY2suY29uZmlndXJlKHRoaXMub3B0aW9ucy5jb2RlQmxvY2spKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRvY3VtZW50ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgZXh0ZW5zaW9ucy5wdXNoKERvY3VtZW50LmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMuZG9jdW1lbnQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRyb3BjdXJzb3IgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBleHRlbnNpb25zLnB1c2goRHJvcGN1cnNvci5jb25maWd1cmUodGhpcy5vcHRpb25zLmRyb3BjdXJzb3IpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmdhcGN1cnNvciAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGV4dGVuc2lvbnMucHVzaChHYXBjdXJzb3IuY29uZmlndXJlKHRoaXMub3B0aW9ucy5nYXBjdXJzb3IpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhhcmRCcmVhayAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGV4dGVuc2lvbnMucHVzaChIYXJkQnJlYWsuY29uZmlndXJlKHRoaXMub3B0aW9ucy5oYXJkQnJlYWspKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhlYWRpbmcgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBleHRlbnNpb25zLnB1c2goSGVhZGluZy5jb25maWd1cmUodGhpcy5vcHRpb25zLmhlYWRpbmcpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhpc3RvcnkgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBleHRlbnNpb25zLnB1c2goSGlzdG9yeS5jb25maWd1cmUodGhpcy5vcHRpb25zLmhpc3RvcnkpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhvcml6b250YWxSdWxlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgZXh0ZW5zaW9ucy5wdXNoKEhvcml6b250YWxSdWxlLmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMuaG9yaXpvbnRhbFJ1bGUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLml0YWxpYyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGV4dGVuc2lvbnMucHVzaChJdGFsaWMuY29uZmlndXJlKHRoaXMub3B0aW9ucy5pdGFsaWMpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxpc3RJdGVtICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgZXh0ZW5zaW9ucy5wdXNoKExpc3RJdGVtLmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMubGlzdEl0ZW0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm9yZGVyZWRMaXN0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgZXh0ZW5zaW9ucy5wdXNoKE9yZGVyZWRMaXN0LmNvbmZpZ3VyZSh0aGlzLm9wdGlvbnMub3JkZXJlZExpc3QpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBhcmFncmFwaCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGV4dGVuc2lvbnMucHVzaChQYXJhZ3JhcGguY29uZmlndXJlKHRoaXMub3B0aW9ucy5wYXJhZ3JhcGgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN0cmlrZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGV4dGVuc2lvbnMucHVzaChTdHJpa2UuY29uZmlndXJlKHRoaXMub3B0aW9ucy5zdHJpa2UpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRleHQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBleHRlbnNpb25zLnB1c2goVGV4dC5jb25maWd1cmUodGhpcy5vcHRpb25zLnRleHQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXh0ZW5zaW9ucztcbiAgICB9LFxufSk7XG5cbmV4cG9ydCB7IFN0YXJ0ZXJLaXQsIFN0YXJ0ZXJLaXQgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@tiptap/starter-kit/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/orderedmap/dist/index.js":
/*!***********************************************!*\
  !*** ./node_modules/orderedmap/dist/index.js ***!
  \***********************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n// ::- Persistent data structure representing an ordered mapping from\n// strings to values, with some convenient update methods.\nfunction OrderedMap(content) {\n  this.content = content;\n}\n\nOrderedMap.prototype = {\n  constructor: OrderedMap,\n\n  find: function(key) {\n    for (var i = 0; i < this.content.length; i += 2)\n      if (this.content[i] === key) return i\n    return -1\n  },\n\n  // :: (string) → ?any\n  // Retrieve the value stored under `key`, or return undefined when\n  // no such key exists.\n  get: function(key) {\n    var found = this.find(key);\n    return found == -1 ? undefined : this.content[found + 1]\n  },\n\n  // :: (string, any, ?string) → OrderedMap\n  // Create a new map by replacing the value of `key` with a new\n  // value, or adding a binding to the end of the map. If `newKey` is\n  // given, the key of the binding will be replaced with that key.\n  update: function(key, value, newKey) {\n    var self = newKey && newKey != key ? this.remove(newKey) : this;\n    var found = self.find(key), content = self.content.slice();\n    if (found == -1) {\n      content.push(newKey || key, value);\n    } else {\n      content[found + 1] = value;\n      if (newKey) content[found] = newKey;\n    }\n    return new OrderedMap(content)\n  },\n\n  // :: (string) → OrderedMap\n  // Return a map with the given key removed, if it existed.\n  remove: function(key) {\n    var found = this.find(key);\n    if (found == -1) return this\n    var content = this.content.slice();\n    content.splice(found, 2);\n    return new OrderedMap(content)\n  },\n\n  // :: (string, any) → OrderedMap\n  // Add a new key to the start of the map.\n  addToStart: function(key, value) {\n    return new OrderedMap([key, value].concat(this.remove(key).content))\n  },\n\n  // :: (string, any) → OrderedMap\n  // Add a new key to the end of the map.\n  addToEnd: function(key, value) {\n    var content = this.remove(key).content.slice();\n    content.push(key, value);\n    return new OrderedMap(content)\n  },\n\n  // :: (string, string, any) → OrderedMap\n  // Add a key after the given key. If `place` is not found, the new\n  // key is added to the end.\n  addBefore: function(place, key, value) {\n    var without = this.remove(key), content = without.content.slice();\n    var found = without.find(place);\n    content.splice(found == -1 ? content.length : found, 0, key, value);\n    return new OrderedMap(content)\n  },\n\n  // :: ((key: string, value: any))\n  // Call the given function for each key/value pair in the map, in\n  // order.\n  forEach: function(f) {\n    for (var i = 0; i < this.content.length; i += 2)\n      f(this.content[i], this.content[i + 1]);\n  },\n\n  // :: (union<Object, OrderedMap>) → OrderedMap\n  // Create a new map by prepending the keys in this map that don't\n  // appear in `map` before the keys in `map`.\n  prepend: function(map) {\n    map = OrderedMap.from(map);\n    if (!map.size) return this\n    return new OrderedMap(map.content.concat(this.subtract(map).content))\n  },\n\n  // :: (union<Object, OrderedMap>) → OrderedMap\n  // Create a new map by appending the keys in this map that don't\n  // appear in `map` after the keys in `map`.\n  append: function(map) {\n    map = OrderedMap.from(map);\n    if (!map.size) return this\n    return new OrderedMap(this.subtract(map).content.concat(map.content))\n  },\n\n  // :: (union<Object, OrderedMap>) → OrderedMap\n  // Create a map containing all the keys in this map that don't\n  // appear in `map`.\n  subtract: function(map) {\n    var result = this;\n    map = OrderedMap.from(map);\n    for (var i = 0; i < map.content.length; i += 2)\n      result = result.remove(map.content[i]);\n    return result\n  },\n\n  // :: () → Object\n  // Turn ordered map into a plain object.\n  toObject: function() {\n    var result = {};\n    this.forEach(function(key, value) { result[key] = value; });\n    return result\n  },\n\n  // :: number\n  // The amount of keys in this map.\n  get size() {\n    return this.content.length >> 1\n  }\n};\n\n// :: (?union<Object, OrderedMap>) → OrderedMap\n// Return a map with the given content. If null, create an empty\n// map. If given an ordered map, return that map itself. If given an\n// object, create a map from the object's properties.\nOrderedMap.from = function(value) {\n  if (value instanceof OrderedMap) return value\n  var content = [];\n  if (value) for (var prop in value) content.push(prop, value[prop]);\n  return new OrderedMap(content)\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (OrderedMap);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9vcmRlcmVkbWFwL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQix5QkFBeUI7QUFDN0M7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHlCQUF5QjtBQUM3QztBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isd0JBQXdCO0FBQzVDO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLHNCQUFzQjtBQUM5RDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtEQUFlLFVBQVUsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvb3JkZXJlZG1hcC9kaXN0L2luZGV4LmpzP2M0MmYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gOjotIFBlcnNpc3RlbnQgZGF0YSBzdHJ1Y3R1cmUgcmVwcmVzZW50aW5nIGFuIG9yZGVyZWQgbWFwcGluZyBmcm9tXG4vLyBzdHJpbmdzIHRvIHZhbHVlcywgd2l0aCBzb21lIGNvbnZlbmllbnQgdXBkYXRlIG1ldGhvZHMuXG5mdW5jdGlvbiBPcmRlcmVkTWFwKGNvbnRlbnQpIHtcbiAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbn1cblxuT3JkZXJlZE1hcC5wcm90b3R5cGUgPSB7XG4gIGNvbnN0cnVjdG9yOiBPcmRlcmVkTWFwLFxuXG4gIGZpbmQ6IGZ1bmN0aW9uKGtleSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jb250ZW50Lmxlbmd0aDsgaSArPSAyKVxuICAgICAgaWYgKHRoaXMuY29udGVudFtpXSA9PT0ga2V5KSByZXR1cm4gaVxuICAgIHJldHVybiAtMVxuICB9LFxuXG4gIC8vIDo6IChzdHJpbmcpIOKGkiA/YW55XG4gIC8vIFJldHJpZXZlIHRoZSB2YWx1ZSBzdG9yZWQgdW5kZXIgYGtleWAsIG9yIHJldHVybiB1bmRlZmluZWQgd2hlblxuICAvLyBubyBzdWNoIGtleSBleGlzdHMuXG4gIGdldDogZnVuY3Rpb24oa2V5KSB7XG4gICAgdmFyIGZvdW5kID0gdGhpcy5maW5kKGtleSk7XG4gICAgcmV0dXJuIGZvdW5kID09IC0xID8gdW5kZWZpbmVkIDogdGhpcy5jb250ZW50W2ZvdW5kICsgMV1cbiAgfSxcblxuICAvLyA6OiAoc3RyaW5nLCBhbnksID9zdHJpbmcpIOKGkiBPcmRlcmVkTWFwXG4gIC8vIENyZWF0ZSBhIG5ldyBtYXAgYnkgcmVwbGFjaW5nIHRoZSB2YWx1ZSBvZiBga2V5YCB3aXRoIGEgbmV3XG4gIC8vIHZhbHVlLCBvciBhZGRpbmcgYSBiaW5kaW5nIHRvIHRoZSBlbmQgb2YgdGhlIG1hcC4gSWYgYG5ld0tleWAgaXNcbiAgLy8gZ2l2ZW4sIHRoZSBrZXkgb2YgdGhlIGJpbmRpbmcgd2lsbCBiZSByZXBsYWNlZCB3aXRoIHRoYXQga2V5LlxuICB1cGRhdGU6IGZ1bmN0aW9uKGtleSwgdmFsdWUsIG5ld0tleSkge1xuICAgIHZhciBzZWxmID0gbmV3S2V5ICYmIG5ld0tleSAhPSBrZXkgPyB0aGlzLnJlbW92ZShuZXdLZXkpIDogdGhpcztcbiAgICB2YXIgZm91bmQgPSBzZWxmLmZpbmQoa2V5KSwgY29udGVudCA9IHNlbGYuY29udGVudC5zbGljZSgpO1xuICAgIGlmIChmb3VuZCA9PSAtMSkge1xuICAgICAgY29udGVudC5wdXNoKG5ld0tleSB8fCBrZXksIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudFtmb3VuZCArIDFdID0gdmFsdWU7XG4gICAgICBpZiAobmV3S2V5KSBjb250ZW50W2ZvdW5kXSA9IG5ld0tleTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBPcmRlcmVkTWFwKGNvbnRlbnQpXG4gIH0sXG5cbiAgLy8gOjogKHN0cmluZykg4oaSIE9yZGVyZWRNYXBcbiAgLy8gUmV0dXJuIGEgbWFwIHdpdGggdGhlIGdpdmVuIGtleSByZW1vdmVkLCBpZiBpdCBleGlzdGVkLlxuICByZW1vdmU6IGZ1bmN0aW9uKGtleSkge1xuICAgIHZhciBmb3VuZCA9IHRoaXMuZmluZChrZXkpO1xuICAgIGlmIChmb3VuZCA9PSAtMSkgcmV0dXJuIHRoaXNcbiAgICB2YXIgY29udGVudCA9IHRoaXMuY29udGVudC5zbGljZSgpO1xuICAgIGNvbnRlbnQuc3BsaWNlKGZvdW5kLCAyKTtcbiAgICByZXR1cm4gbmV3IE9yZGVyZWRNYXAoY29udGVudClcbiAgfSxcblxuICAvLyA6OiAoc3RyaW5nLCBhbnkpIOKGkiBPcmRlcmVkTWFwXG4gIC8vIEFkZCBhIG5ldyBrZXkgdG8gdGhlIHN0YXJ0IG9mIHRoZSBtYXAuXG4gIGFkZFRvU3RhcnQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IE9yZGVyZWRNYXAoW2tleSwgdmFsdWVdLmNvbmNhdCh0aGlzLnJlbW92ZShrZXkpLmNvbnRlbnQpKVxuICB9LFxuXG4gIC8vIDo6IChzdHJpbmcsIGFueSkg4oaSIE9yZGVyZWRNYXBcbiAgLy8gQWRkIGEgbmV3IGtleSB0byB0aGUgZW5kIG9mIHRoZSBtYXAuXG4gIGFkZFRvRW5kOiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgdmFyIGNvbnRlbnQgPSB0aGlzLnJlbW92ZShrZXkpLmNvbnRlbnQuc2xpY2UoKTtcbiAgICBjb250ZW50LnB1c2goa2V5LCB2YWx1ZSk7XG4gICAgcmV0dXJuIG5ldyBPcmRlcmVkTWFwKGNvbnRlbnQpXG4gIH0sXG5cbiAgLy8gOjogKHN0cmluZywgc3RyaW5nLCBhbnkpIOKGkiBPcmRlcmVkTWFwXG4gIC8vIEFkZCBhIGtleSBhZnRlciB0aGUgZ2l2ZW4ga2V5LiBJZiBgcGxhY2VgIGlzIG5vdCBmb3VuZCwgdGhlIG5ld1xuICAvLyBrZXkgaXMgYWRkZWQgdG8gdGhlIGVuZC5cbiAgYWRkQmVmb3JlOiBmdW5jdGlvbihwbGFjZSwga2V5LCB2YWx1ZSkge1xuICAgIHZhciB3aXRob3V0ID0gdGhpcy5yZW1vdmUoa2V5KSwgY29udGVudCA9IHdpdGhvdXQuY29udGVudC5zbGljZSgpO1xuICAgIHZhciBmb3VuZCA9IHdpdGhvdXQuZmluZChwbGFjZSk7XG4gICAgY29udGVudC5zcGxpY2UoZm91bmQgPT0gLTEgPyBjb250ZW50Lmxlbmd0aCA6IGZvdW5kLCAwLCBrZXksIHZhbHVlKTtcbiAgICByZXR1cm4gbmV3IE9yZGVyZWRNYXAoY29udGVudClcbiAgfSxcblxuICAvLyA6OiAoKGtleTogc3RyaW5nLCB2YWx1ZTogYW55KSlcbiAgLy8gQ2FsbCB0aGUgZ2l2ZW4gZnVuY3Rpb24gZm9yIGVhY2gga2V5L3ZhbHVlIHBhaXIgaW4gdGhlIG1hcCwgaW5cbiAgLy8gb3JkZXIuXG4gIGZvckVhY2g6IGZ1bmN0aW9uKGYpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY29udGVudC5sZW5ndGg7IGkgKz0gMilcbiAgICAgIGYodGhpcy5jb250ZW50W2ldLCB0aGlzLmNvbnRlbnRbaSArIDFdKTtcbiAgfSxcblxuICAvLyA6OiAodW5pb248T2JqZWN0LCBPcmRlcmVkTWFwPikg4oaSIE9yZGVyZWRNYXBcbiAgLy8gQ3JlYXRlIGEgbmV3IG1hcCBieSBwcmVwZW5kaW5nIHRoZSBrZXlzIGluIHRoaXMgbWFwIHRoYXQgZG9uJ3RcbiAgLy8gYXBwZWFyIGluIGBtYXBgIGJlZm9yZSB0aGUga2V5cyBpbiBgbWFwYC5cbiAgcHJlcGVuZDogZnVuY3Rpb24obWFwKSB7XG4gICAgbWFwID0gT3JkZXJlZE1hcC5mcm9tKG1hcCk7XG4gICAgaWYgKCFtYXAuc2l6ZSkgcmV0dXJuIHRoaXNcbiAgICByZXR1cm4gbmV3IE9yZGVyZWRNYXAobWFwLmNvbnRlbnQuY29uY2F0KHRoaXMuc3VidHJhY3QobWFwKS5jb250ZW50KSlcbiAgfSxcblxuICAvLyA6OiAodW5pb248T2JqZWN0LCBPcmRlcmVkTWFwPikg4oaSIE9yZGVyZWRNYXBcbiAgLy8gQ3JlYXRlIGEgbmV3IG1hcCBieSBhcHBlbmRpbmcgdGhlIGtleXMgaW4gdGhpcyBtYXAgdGhhdCBkb24ndFxuICAvLyBhcHBlYXIgaW4gYG1hcGAgYWZ0ZXIgdGhlIGtleXMgaW4gYG1hcGAuXG4gIGFwcGVuZDogZnVuY3Rpb24obWFwKSB7XG4gICAgbWFwID0gT3JkZXJlZE1hcC5mcm9tKG1hcCk7XG4gICAgaWYgKCFtYXAuc2l6ZSkgcmV0dXJuIHRoaXNcbiAgICByZXR1cm4gbmV3IE9yZGVyZWRNYXAodGhpcy5zdWJ0cmFjdChtYXApLmNvbnRlbnQuY29uY2F0KG1hcC5jb250ZW50KSlcbiAgfSxcblxuICAvLyA6OiAodW5pb248T2JqZWN0LCBPcmRlcmVkTWFwPikg4oaSIE9yZGVyZWRNYXBcbiAgLy8gQ3JlYXRlIGEgbWFwIGNvbnRhaW5pbmcgYWxsIHRoZSBrZXlzIGluIHRoaXMgbWFwIHRoYXQgZG9uJ3RcbiAgLy8gYXBwZWFyIGluIGBtYXBgLlxuICBzdWJ0cmFjdDogZnVuY3Rpb24obWFwKSB7XG4gICAgdmFyIHJlc3VsdCA9IHRoaXM7XG4gICAgbWFwID0gT3JkZXJlZE1hcC5mcm9tKG1hcCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXAuY29udGVudC5sZW5ndGg7IGkgKz0gMilcbiAgICAgIHJlc3VsdCA9IHJlc3VsdC5yZW1vdmUobWFwLmNvbnRlbnRbaV0pO1xuICAgIHJldHVybiByZXN1bHRcbiAgfSxcblxuICAvLyA6OiAoKSDihpIgT2JqZWN0XG4gIC8vIFR1cm4gb3JkZXJlZCBtYXAgaW50byBhIHBsYWluIG9iamVjdC5cbiAgdG9PYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24oa2V5LCB2YWx1ZSkgeyByZXN1bHRba2V5XSA9IHZhbHVlOyB9KTtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH0sXG5cbiAgLy8gOjogbnVtYmVyXG4gIC8vIFRoZSBhbW91bnQgb2Yga2V5cyBpbiB0aGlzIG1hcC5cbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudC5sZW5ndGggPj4gMVxuICB9XG59O1xuXG4vLyA6OiAoP3VuaW9uPE9iamVjdCwgT3JkZXJlZE1hcD4pIOKGkiBPcmRlcmVkTWFwXG4vLyBSZXR1cm4gYSBtYXAgd2l0aCB0aGUgZ2l2ZW4gY29udGVudC4gSWYgbnVsbCwgY3JlYXRlIGFuIGVtcHR5XG4vLyBtYXAuIElmIGdpdmVuIGFuIG9yZGVyZWQgbWFwLCByZXR1cm4gdGhhdCBtYXAgaXRzZWxmLiBJZiBnaXZlbiBhblxuLy8gb2JqZWN0LCBjcmVhdGUgYSBtYXAgZnJvbSB0aGUgb2JqZWN0J3MgcHJvcGVydGllcy5cbk9yZGVyZWRNYXAuZnJvbSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE9yZGVyZWRNYXApIHJldHVybiB2YWx1ZVxuICB2YXIgY29udGVudCA9IFtdO1xuICBpZiAodmFsdWUpIGZvciAodmFyIHByb3AgaW4gdmFsdWUpIGNvbnRlbnQucHVzaChwcm9wLCB2YWx1ZVtwcm9wXSk7XG4gIHJldHVybiBuZXcgT3JkZXJlZE1hcChjb250ZW50KVxufTtcblxuZXhwb3J0IGRlZmF1bHQgT3JkZXJlZE1hcDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/orderedmap/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prosemirror-commands/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/prosemirror-commands/dist/index.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   autoJoin: function() { return /* binding */ autoJoin; },\n/* harmony export */   baseKeymap: function() { return /* binding */ baseKeymap; },\n/* harmony export */   chainCommands: function() { return /* binding */ chainCommands; },\n/* harmony export */   createParagraphNear: function() { return /* binding */ createParagraphNear; },\n/* harmony export */   deleteSelection: function() { return /* binding */ deleteSelection; },\n/* harmony export */   exitCode: function() { return /* binding */ exitCode; },\n/* harmony export */   joinBackward: function() { return /* binding */ joinBackward; },\n/* harmony export */   joinDown: function() { return /* binding */ joinDown; },\n/* harmony export */   joinForward: function() { return /* binding */ joinForward; },\n/* harmony export */   joinTextblockBackward: function() { return /* binding */ joinTextblockBackward; },\n/* harmony export */   joinTextblockForward: function() { return /* binding */ joinTextblockForward; },\n/* harmony export */   joinUp: function() { return /* binding */ joinUp; },\n/* harmony export */   lift: function() { return /* binding */ lift; },\n/* harmony export */   liftEmptyBlock: function() { return /* binding */ liftEmptyBlock; },\n/* harmony export */   macBaseKeymap: function() { return /* binding */ macBaseKeymap; },\n/* harmony export */   newlineInCode: function() { return /* binding */ newlineInCode; },\n/* harmony export */   pcBaseKeymap: function() { return /* binding */ pcBaseKeymap; },\n/* harmony export */   selectAll: function() { return /* binding */ selectAll; },\n/* harmony export */   selectNodeBackward: function() { return /* binding */ selectNodeBackward; },\n/* harmony export */   selectNodeForward: function() { return /* binding */ selectNodeForward; },\n/* harmony export */   selectParentNode: function() { return /* binding */ selectParentNode; },\n/* harmony export */   selectTextblockEnd: function() { return /* binding */ selectTextblockEnd; },\n/* harmony export */   selectTextblockStart: function() { return /* binding */ selectTextblockStart; },\n/* harmony export */   setBlockType: function() { return /* binding */ setBlockType; },\n/* harmony export */   splitBlock: function() { return /* binding */ splitBlock; },\n/* harmony export */   splitBlockAs: function() { return /* binding */ splitBlockAs; },\n/* harmony export */   splitBlockKeepMarks: function() { return /* binding */ splitBlockKeepMarks; },\n/* harmony export */   toggleMark: function() { return /* binding */ toggleMark; },\n/* harmony export */   wrapIn: function() { return /* binding */ wrapIn; }\n/* harmony export */ });\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-transform */ \"(app-pages-browser)/./node_modules/prosemirror-transform/dist/index.js\");\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-model */ \"(app-pages-browser)/./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-state */ \"(app-pages-browser)/./node_modules/prosemirror-state/dist/index.js\");\n\n\n\n\n/**\nDelete the selection, if there is one.\n*/\nconst deleteSelection = (state, dispatch) => {\n    if (state.selection.empty)\n        return false;\n    if (dispatch)\n        dispatch(state.tr.deleteSelection().scrollIntoView());\n    return true;\n};\nfunction atBlockStart(state, view) {\n    let { $cursor } = state.selection;\n    if (!$cursor || (view ? !view.endOfTextblock(\"backward\", state)\n        : $cursor.parentOffset > 0))\n        return null;\n    return $cursor;\n}\n/**\nIf the selection is empty and at the start of a textblock, try to\nreduce the distance between that block and the one before it—if\nthere's a block directly before it that can be joined, join them.\nIf not, try to move the selected block closer to the next one in\nthe document structure by lifting it out of its parent or moving it\ninto a parent of the previous block. Will use the view for accurate\n(bidi-aware) start-of-textblock detection if given.\n*/\nconst joinBackward = (state, dispatch, view) => {\n    let $cursor = atBlockStart(state, view);\n    if (!$cursor)\n        return false;\n    let $cut = findCutBefore($cursor);\n    // If there is no node before this, try to lift\n    if (!$cut) {\n        let range = $cursor.blockRange(), target = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(range);\n        if (target == null)\n            return false;\n        if (dispatch)\n            dispatch(state.tr.lift(range, target).scrollIntoView());\n        return true;\n    }\n    let before = $cut.nodeBefore;\n    // Apply the joining algorithm\n    if (deleteBarrier(state, $cut, dispatch, -1))\n        return true;\n    // If the node below has no content and the node above is\n    // selectable, delete the node below and select the one above.\n    if ($cursor.parent.content.size == 0 &&\n        (textblockAt(before, \"end\") || prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(before))) {\n        for (let depth = $cursor.depth;; depth--) {\n            let delStep = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.replaceStep)(state.doc, $cursor.before(depth), $cursor.after(depth), prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Slice.empty);\n            if (delStep && delStep.slice.size < delStep.to - delStep.from) {\n                if (dispatch) {\n                    let tr = state.tr.step(delStep);\n                    tr.setSelection(textblockAt(before, \"end\")\n                        ? prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1)\n                        : prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(tr.doc, $cut.pos - before.nodeSize));\n                    dispatch(tr.scrollIntoView());\n                }\n                return true;\n            }\n            if (depth == 1 || $cursor.node(depth - 1).childCount > 1)\n                break;\n        }\n    }\n    // If the node before is an atom, delete it\n    if (before.isAtom && $cut.depth == $cursor.depth - 1) {\n        if (dispatch)\n            dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());\n        return true;\n    }\n    return false;\n};\n/**\nA more limited form of [`joinBackward`](https://prosemirror.net/docs/ref/#commands.joinBackward)\nthat only tries to join the current textblock to the one before\nit, if the cursor is at the start of a textblock.\n*/\nconst joinTextblockBackward = (state, dispatch, view) => {\n    let $cursor = atBlockStart(state, view);\n    if (!$cursor)\n        return false;\n    let $cut = findCutBefore($cursor);\n    return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;\n};\n/**\nA more limited form of [`joinForward`](https://prosemirror.net/docs/ref/#commands.joinForward)\nthat only tries to join the current textblock to the one after\nit, if the cursor is at the end of a textblock.\n*/\nconst joinTextblockForward = (state, dispatch, view) => {\n    let $cursor = atBlockEnd(state, view);\n    if (!$cursor)\n        return false;\n    let $cut = findCutAfter($cursor);\n    return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;\n};\nfunction joinTextblocksAround(state, $cut, dispatch) {\n    let before = $cut.nodeBefore, beforeText = before, beforePos = $cut.pos - 1;\n    for (; !beforeText.isTextblock; beforePos--) {\n        if (beforeText.type.spec.isolating)\n            return false;\n        let child = beforeText.lastChild;\n        if (!child)\n            return false;\n        beforeText = child;\n    }\n    let after = $cut.nodeAfter, afterText = after, afterPos = $cut.pos + 1;\n    for (; !afterText.isTextblock; afterPos++) {\n        if (afterText.type.spec.isolating)\n            return false;\n        let child = afterText.firstChild;\n        if (!child)\n            return false;\n        afterText = child;\n    }\n    let step = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.replaceStep)(state.doc, beforePos, afterPos, prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Slice.empty);\n    if (!step || step.from != beforePos ||\n        step instanceof prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceStep && step.slice.size >= afterPos - beforePos)\n        return false;\n    if (dispatch) {\n        let tr = state.tr.step(step);\n        tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(tr.doc, beforePos));\n        dispatch(tr.scrollIntoView());\n    }\n    return true;\n}\nfunction textblockAt(node, side, only = false) {\n    for (let scan = node; scan; scan = (side == \"start\" ? scan.firstChild : scan.lastChild)) {\n        if (scan.isTextblock)\n            return true;\n        if (only && scan.childCount != 1)\n            return false;\n    }\n    return false;\n}\n/**\nWhen the selection is empty and at the start of a textblock, select\nthe node before that textblock, if possible. This is intended to be\nbound to keys like backspace, after\n[`joinBackward`](https://prosemirror.net/docs/ref/#commands.joinBackward) or other deleting\ncommands, as a fall-back behavior when the schema doesn't allow\ndeletion at the selected point.\n*/\nconst selectNodeBackward = (state, dispatch, view) => {\n    let { $head, empty } = state.selection, $cut = $head;\n    if (!empty)\n        return false;\n    if ($head.parent.isTextblock) {\n        if (view ? !view.endOfTextblock(\"backward\", state) : $head.parentOffset > 0)\n            return false;\n        $cut = findCutBefore($head);\n    }\n    let node = $cut && $cut.nodeBefore;\n    if (!node || !prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node))\n        return false;\n    if (dispatch)\n        dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());\n    return true;\n};\nfunction findCutBefore($pos) {\n    if (!$pos.parent.type.spec.isolating)\n        for (let i = $pos.depth - 1; i >= 0; i--) {\n            if ($pos.index(i) > 0)\n                return $pos.doc.resolve($pos.before(i + 1));\n            if ($pos.node(i).type.spec.isolating)\n                break;\n        }\n    return null;\n}\nfunction atBlockEnd(state, view) {\n    let { $cursor } = state.selection;\n    if (!$cursor || (view ? !view.endOfTextblock(\"forward\", state)\n        : $cursor.parentOffset < $cursor.parent.content.size))\n        return null;\n    return $cursor;\n}\n/**\nIf the selection is empty and the cursor is at the end of a\ntextblock, try to reduce or remove the boundary between that block\nand the one after it, either by joining them or by moving the other\nblock closer to this one in the tree structure. Will use the view\nfor accurate start-of-textblock detection if given.\n*/\nconst joinForward = (state, dispatch, view) => {\n    let $cursor = atBlockEnd(state, view);\n    if (!$cursor)\n        return false;\n    let $cut = findCutAfter($cursor);\n    // If there is no node after this, there's nothing to do\n    if (!$cut)\n        return false;\n    let after = $cut.nodeAfter;\n    // Try the joining algorithm\n    if (deleteBarrier(state, $cut, dispatch, 1))\n        return true;\n    // If the node above has no content and the node below is\n    // selectable, delete the node above and select the one below.\n    if ($cursor.parent.content.size == 0 &&\n        (textblockAt(after, \"start\") || prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(after))) {\n        let delStep = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.replaceStep)(state.doc, $cursor.before(), $cursor.after(), prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Slice.empty);\n        if (delStep && delStep.slice.size < delStep.to - delStep.from) {\n            if (dispatch) {\n                let tr = state.tr.step(delStep);\n                tr.setSelection(textblockAt(after, \"start\") ? prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1)\n                    : prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));\n                dispatch(tr.scrollIntoView());\n            }\n            return true;\n        }\n    }\n    // If the next node is an atom, delete it\n    if (after.isAtom && $cut.depth == $cursor.depth - 1) {\n        if (dispatch)\n            dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());\n        return true;\n    }\n    return false;\n};\n/**\nWhen the selection is empty and at the end of a textblock, select\nthe node coming after that textblock, if possible. This is intended\nto be bound to keys like delete, after\n[`joinForward`](https://prosemirror.net/docs/ref/#commands.joinForward) and similar deleting\ncommands, to provide a fall-back behavior when the schema doesn't\nallow deletion at the selected point.\n*/\nconst selectNodeForward = (state, dispatch, view) => {\n    let { $head, empty } = state.selection, $cut = $head;\n    if (!empty)\n        return false;\n    if ($head.parent.isTextblock) {\n        if (view ? !view.endOfTextblock(\"forward\", state) : $head.parentOffset < $head.parent.content.size)\n            return false;\n        $cut = findCutAfter($head);\n    }\n    let node = $cut && $cut.nodeAfter;\n    if (!node || !prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node))\n        return false;\n    if (dispatch)\n        dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());\n    return true;\n};\nfunction findCutAfter($pos) {\n    if (!$pos.parent.type.spec.isolating)\n        for (let i = $pos.depth - 1; i >= 0; i--) {\n            let parent = $pos.node(i);\n            if ($pos.index(i) + 1 < parent.childCount)\n                return $pos.doc.resolve($pos.after(i + 1));\n            if (parent.type.spec.isolating)\n                break;\n        }\n    return null;\n}\n/**\nJoin the selected block or, if there is a text selection, the\nclosest ancestor block of the selection that can be joined, with\nthe sibling above it.\n*/\nconst joinUp = (state, dispatch) => {\n    let sel = state.selection, nodeSel = sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection, point;\n    if (nodeSel) {\n        if (sel.node.isTextblock || !(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(state.doc, sel.from))\n            return false;\n        point = sel.from;\n    }\n    else {\n        point = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.joinPoint)(state.doc, sel.from, -1);\n        if (point == null)\n            return false;\n    }\n    if (dispatch) {\n        let tr = state.tr.join(point);\n        if (nodeSel)\n            tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(tr.doc, point - state.doc.resolve(point).nodeBefore.nodeSize));\n        dispatch(tr.scrollIntoView());\n    }\n    return true;\n};\n/**\nJoin the selected block, or the closest ancestor of the selection\nthat can be joined, with the sibling after it.\n*/\nconst joinDown = (state, dispatch) => {\n    let sel = state.selection, point;\n    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection) {\n        if (sel.node.isTextblock || !(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(state.doc, sel.to))\n            return false;\n        point = sel.to;\n    }\n    else {\n        point = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.joinPoint)(state.doc, sel.to, 1);\n        if (point == null)\n            return false;\n    }\n    if (dispatch)\n        dispatch(state.tr.join(point).scrollIntoView());\n    return true;\n};\n/**\nLift the selected block, or the closest ancestor block of the\nselection that can be lifted, out of its parent node.\n*/\nconst lift = (state, dispatch) => {\n    let { $from, $to } = state.selection;\n    let range = $from.blockRange($to), target = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(range);\n    if (target == null)\n        return false;\n    if (dispatch)\n        dispatch(state.tr.lift(range, target).scrollIntoView());\n    return true;\n};\n/**\nIf the selection is in a node whose type has a truthy\n[`code`](https://prosemirror.net/docs/ref/#model.NodeSpec.code) property in its spec, replace the\nselection with a newline character.\n*/\nconst newlineInCode = (state, dispatch) => {\n    let { $head, $anchor } = state.selection;\n    if (!$head.parent.type.spec.code || !$head.sameParent($anchor))\n        return false;\n    if (dispatch)\n        dispatch(state.tr.insertText(\"\\n\").scrollIntoView());\n    return true;\n};\nfunction defaultBlockAt(match) {\n    for (let i = 0; i < match.edgeCount; i++) {\n        let { type } = match.edge(i);\n        if (type.isTextblock && !type.hasRequiredAttrs())\n            return type;\n    }\n    return null;\n}\n/**\nWhen the selection is in a node with a truthy\n[`code`](https://prosemirror.net/docs/ref/#model.NodeSpec.code) property in its spec, create a\ndefault block after the code block, and move the cursor there.\n*/\nconst exitCode = (state, dispatch) => {\n    let { $head, $anchor } = state.selection;\n    if (!$head.parent.type.spec.code || !$head.sameParent($anchor))\n        return false;\n    let above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after));\n    if (!type || !above.canReplaceWith(after, after, type))\n        return false;\n    if (dispatch) {\n        let pos = $head.after(), tr = state.tr.replaceWith(pos, pos, type.createAndFill());\n        tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.near(tr.doc.resolve(pos), 1));\n        dispatch(tr.scrollIntoView());\n    }\n    return true;\n};\n/**\nIf a block node is selected, create an empty paragraph before (if\nit is its parent's first child) or after it.\n*/\nconst createParagraphNear = (state, dispatch) => {\n    let sel = state.selection, { $from, $to } = sel;\n    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.AllSelection || $from.parent.inlineContent || $to.parent.inlineContent)\n        return false;\n    let type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));\n    if (!type || !type.isTextblock)\n        return false;\n    if (dispatch) {\n        let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;\n        let tr = state.tr.insert(side, type.createAndFill());\n        tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(tr.doc, side + 1));\n        dispatch(tr.scrollIntoView());\n    }\n    return true;\n};\n/**\nIf the cursor is in an empty textblock that can be lifted, lift the\nblock.\n*/\nconst liftEmptyBlock = (state, dispatch) => {\n    let { $cursor } = state.selection;\n    if (!$cursor || $cursor.parent.content.size)\n        return false;\n    if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {\n        let before = $cursor.before();\n        if ((0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(state.doc, before)) {\n            if (dispatch)\n                dispatch(state.tr.split(before).scrollIntoView());\n            return true;\n        }\n    }\n    let range = $cursor.blockRange(), target = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(range);\n    if (target == null)\n        return false;\n    if (dispatch)\n        dispatch(state.tr.lift(range, target).scrollIntoView());\n    return true;\n};\n/**\nCreate a variant of [`splitBlock`](https://prosemirror.net/docs/ref/#commands.splitBlock) that uses\na custom function to determine the type of the newly split off block.\n*/\nfunction splitBlockAs(splitNode) {\n    return (state, dispatch) => {\n        let { $from, $to } = state.selection;\n        if (state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection && state.selection.node.isBlock) {\n            if (!$from.parentOffset || !(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(state.doc, $from.pos))\n                return false;\n            if (dispatch)\n                dispatch(state.tr.split($from.pos).scrollIntoView());\n            return true;\n        }\n        if (!$from.depth)\n            return false;\n        let types = [];\n        let splitDepth, deflt, atEnd = false, atStart = false;\n        for (let d = $from.depth;; d--) {\n            let node = $from.node(d);\n            if (node.isBlock) {\n                atEnd = $from.end(d) == $from.pos + ($from.depth - d);\n                atStart = $from.start(d) == $from.pos - ($from.depth - d);\n                deflt = defaultBlockAt($from.node(d - 1).contentMatchAt($from.indexAfter(d - 1)));\n                let splitType = splitNode && splitNode($to.parent, atEnd, $from);\n                types.unshift(splitType || (atEnd && deflt ? { type: deflt } : null));\n                splitDepth = d;\n                break;\n            }\n            else {\n                if (d == 1)\n                    return false;\n                types.unshift(null);\n            }\n        }\n        let tr = state.tr;\n        if (state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection || state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.AllSelection)\n            tr.deleteSelection();\n        let splitPos = tr.mapping.map($from.pos);\n        let can = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(tr.doc, splitPos, types.length, types);\n        if (!can) {\n            types[0] = deflt ? { type: deflt } : null;\n            can = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canSplit)(tr.doc, splitPos, types.length, types);\n        }\n        if (!can)\n            return false;\n        tr.split(splitPos, types.length, types);\n        if (!atEnd && atStart && $from.node(splitDepth).type != deflt) {\n            let first = tr.mapping.map($from.before(splitDepth)), $first = tr.doc.resolve(first);\n            if (deflt && $from.node(splitDepth - 1).canReplaceWith($first.index(), $first.index() + 1, deflt))\n                tr.setNodeMarkup(tr.mapping.map($from.before(splitDepth)), deflt);\n        }\n        if (dispatch)\n            dispatch(tr.scrollIntoView());\n        return true;\n    };\n}\n/**\nSplit the parent block of the selection. If the selection is a text\nselection, also delete its content.\n*/\nconst splitBlock = splitBlockAs();\n/**\nActs like [`splitBlock`](https://prosemirror.net/docs/ref/#commands.splitBlock), but without\nresetting the set of active marks at the cursor.\n*/\nconst splitBlockKeepMarks = (state, dispatch) => {\n    return splitBlock(state, dispatch && (tr => {\n        let marks = state.storedMarks || (state.selection.$to.parentOffset && state.selection.$from.marks());\n        if (marks)\n            tr.ensureMarks(marks);\n        dispatch(tr);\n    }));\n};\n/**\nMove the selection to the node wrapping the current selection, if\nany. (Will not select the document node.)\n*/\nconst selectParentNode = (state, dispatch) => {\n    let { $from, to } = state.selection, pos;\n    let same = $from.sharedDepth(to);\n    if (same == 0)\n        return false;\n    pos = $from.before(same);\n    if (dispatch)\n        dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(state.doc, pos)));\n    return true;\n};\n/**\nSelect the whole document.\n*/\nconst selectAll = (state, dispatch) => {\n    if (dispatch)\n        dispatch(state.tr.setSelection(new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.AllSelection(state.doc)));\n    return true;\n};\nfunction joinMaybeClear(state, $pos, dispatch) {\n    let before = $pos.nodeBefore, after = $pos.nodeAfter, index = $pos.index();\n    if (!before || !after || !before.type.compatibleContent(after.type))\n        return false;\n    if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {\n        if (dispatch)\n            dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());\n        return true;\n    }\n    if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(state.doc, $pos.pos)))\n        return false;\n    if (dispatch)\n        dispatch(state.tr.join($pos.pos).scrollIntoView());\n    return true;\n}\nfunction deleteBarrier(state, $cut, dispatch, dir) {\n    let before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match;\n    let isolated = before.type.spec.isolating || after.type.spec.isolating;\n    if (!isolated && joinMaybeClear(state, $cut, dispatch))\n        return true;\n    let canDelAfter = !isolated && $cut.parent.canReplace($cut.index(), $cut.index() + 1);\n    if (canDelAfter &&\n        (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) &&\n        match.matchType(conn[0] || after.type).validEnd) {\n        if (dispatch) {\n            let end = $cut.pos + after.nodeSize, wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Fragment.empty;\n            for (let i = conn.length - 1; i >= 0; i--)\n                wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Fragment.from(conn[i].create(null, wrap));\n            wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Fragment.from(before.copy(wrap));\n            let tr = state.tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Slice(wrap, 1, 0), conn.length, true));\n            let $joinAt = tr.doc.resolve(end + 2 * conn.length);\n            if ($joinAt.nodeAfter && $joinAt.nodeAfter.type == before.type &&\n                (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(tr.doc, $joinAt.pos))\n                tr.join($joinAt.pos);\n            dispatch(tr.scrollIntoView());\n        }\n        return true;\n    }\n    let selAfter = after.type.spec.isolating || (dir > 0 && isolated) ? null : prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom($cut, 1);\n    let range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.liftTarget)(range);\n    if (target != null && target >= $cut.depth) {\n        if (dispatch)\n            dispatch(state.tr.lift(range, target).scrollIntoView());\n        return true;\n    }\n    if (canDelAfter && textblockAt(after, \"start\", true) && textblockAt(before, \"end\")) {\n        let at = before, wrap = [];\n        for (;;) {\n            wrap.push(at);\n            if (at.isTextblock)\n                break;\n            at = at.lastChild;\n        }\n        let afterText = after, afterDepth = 1;\n        for (; !afterText.isTextblock; afterText = afterText.firstChild)\n            afterDepth++;\n        if (at.canReplace(at.childCount, at.childCount, afterText.content)) {\n            if (dispatch) {\n                let end = prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Fragment.empty;\n                for (let i = wrap.length - 1; i >= 0; i--)\n                    end = prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Fragment.from(wrap[i].copy(end));\n                let tr = state.tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.ReplaceAroundStep($cut.pos - wrap.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new prosemirror_model__WEBPACK_IMPORTED_MODULE_2__.Slice(end, wrap.length, 0), 0, true));\n                dispatch(tr.scrollIntoView());\n            }\n            return true;\n        }\n    }\n    return false;\n}\nfunction selectTextblockSide(side) {\n    return function (state, dispatch) {\n        let sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to;\n        let depth = $pos.depth;\n        while ($pos.node(depth).isInline) {\n            if (!depth)\n                return false;\n            depth--;\n        }\n        if (!$pos.node(depth).isTextblock)\n            return false;\n        if (dispatch)\n            dispatch(state.tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));\n        return true;\n    };\n}\n/**\nMoves the cursor to the start of current text block.\n*/\nconst selectTextblockStart = selectTextblockSide(-1);\n/**\nMoves the cursor to the end of current text block.\n*/\nconst selectTextblockEnd = selectTextblockSide(1);\n// Parameterized commands\n/**\nWrap the selection in a node of the given type with the given\nattributes.\n*/\nfunction wrapIn(nodeType, attrs = null) {\n    return function (state, dispatch) {\n        let { $from, $to } = state.selection;\n        let range = $from.blockRange($to), wrapping = range && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.findWrapping)(range, nodeType, attrs);\n        if (!wrapping)\n            return false;\n        if (dispatch)\n            dispatch(state.tr.wrap(range, wrapping).scrollIntoView());\n        return true;\n    };\n}\n/**\nReturns a command that tries to set the selected textblocks to the\ngiven node type with the given attributes.\n*/\nfunction setBlockType(nodeType, attrs = null) {\n    return function (state, dispatch) {\n        let applicable = false;\n        for (let i = 0; i < state.selection.ranges.length && !applicable; i++) {\n            let { $from: { pos: from }, $to: { pos: to } } = state.selection.ranges[i];\n            state.doc.nodesBetween(from, to, (node, pos) => {\n                if (applicable)\n                    return false;\n                if (!node.isTextblock || node.hasMarkup(nodeType, attrs))\n                    return;\n                if (node.type == nodeType) {\n                    applicable = true;\n                }\n                else {\n                    let $pos = state.doc.resolve(pos), index = $pos.index();\n                    applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType);\n                }\n            });\n        }\n        if (!applicable)\n            return false;\n        if (dispatch) {\n            let tr = state.tr;\n            for (let i = 0; i < state.selection.ranges.length; i++) {\n                let { $from: { pos: from }, $to: { pos: to } } = state.selection.ranges[i];\n                tr.setBlockType(from, to, nodeType, attrs);\n            }\n            dispatch(tr.scrollIntoView());\n        }\n        return true;\n    };\n}\nfunction markApplies(doc, ranges, type, enterAtoms) {\n    for (let i = 0; i < ranges.length; i++) {\n        let { $from, $to } = ranges[i];\n        let can = $from.depth == 0 ? doc.inlineContent && doc.type.allowsMarkType(type) : false;\n        doc.nodesBetween($from.pos, $to.pos, (node, pos) => {\n            if (can || !enterAtoms && node.isAtom && node.isInline && pos >= $from.pos && pos + node.nodeSize <= $to.pos)\n                return false;\n            can = node.inlineContent && node.type.allowsMarkType(type);\n        });\n        if (can)\n            return true;\n    }\n    return false;\n}\nfunction removeInlineAtoms(ranges) {\n    let result = [];\n    for (let i = 0; i < ranges.length; i++) {\n        let { $from, $to } = ranges[i];\n        $from.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {\n            if (node.isAtom && node.content.size && node.isInline && pos >= $from.pos && pos + node.nodeSize <= $to.pos) {\n                if (pos + 1 > $from.pos)\n                    result.push(new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.SelectionRange($from, $from.doc.resolve(pos + 1)));\n                $from = $from.doc.resolve(pos + 1 + node.content.size);\n                return false;\n            }\n        });\n        if ($from.pos < $to.pos)\n            result.push(new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.SelectionRange($from, $to));\n    }\n    return result;\n}\n/**\nCreate a command function that toggles the given mark with the\ngiven attributes. Will return `false` when the current selection\ndoesn't support that mark. This will remove the mark if any marks\nof that type exist in the selection, or add it otherwise. If the\nselection is empty, this applies to the [stored\nmarks](https://prosemirror.net/docs/ref/#state.EditorState.storedMarks) instead of a range of the\ndocument.\n*/\nfunction toggleMark(markType, attrs = null, options) {\n    let removeWhenPresent = (options && options.removeWhenPresent) !== false;\n    let enterAtoms = (options && options.enterInlineAtoms) !== false;\n    let dropSpace = !(options && options.includeWhitespace);\n    return function (state, dispatch) {\n        let { empty, $cursor, ranges } = state.selection;\n        if ((empty && !$cursor) || !markApplies(state.doc, ranges, markType, enterAtoms))\n            return false;\n        if (dispatch) {\n            if ($cursor) {\n                if (markType.isInSet(state.storedMarks || $cursor.marks()))\n                    dispatch(state.tr.removeStoredMark(markType));\n                else\n                    dispatch(state.tr.addStoredMark(markType.create(attrs)));\n            }\n            else {\n                let add, tr = state.tr;\n                if (!enterAtoms)\n                    ranges = removeInlineAtoms(ranges);\n                if (removeWhenPresent) {\n                    add = !ranges.some(r => state.doc.rangeHasMark(r.$from.pos, r.$to.pos, markType));\n                }\n                else {\n                    add = !ranges.every(r => {\n                        let missing = false;\n                        tr.doc.nodesBetween(r.$from.pos, r.$to.pos, (node, pos, parent) => {\n                            if (missing)\n                                return false;\n                            missing = !markType.isInSet(node.marks) && !!parent && parent.type.allowsMarkType(markType) &&\n                                !(node.isText && /^\\s*$/.test(node.textBetween(Math.max(0, r.$from.pos - pos), Math.min(node.nodeSize, r.$to.pos - pos))));\n                        });\n                        return !missing;\n                    });\n                }\n                for (let i = 0; i < ranges.length; i++) {\n                    let { $from, $to } = ranges[i];\n                    if (!add) {\n                        tr.removeMark($from.pos, $to.pos, markType);\n                    }\n                    else {\n                        let from = $from.pos, to = $to.pos, start = $from.nodeAfter, end = $to.nodeBefore;\n                        let spaceStart = dropSpace && start && start.isText ? /^\\s*/.exec(start.text)[0].length : 0;\n                        let spaceEnd = dropSpace && end && end.isText ? /\\s*$/.exec(end.text)[0].length : 0;\n                        if (from + spaceStart < to) {\n                            from += spaceStart;\n                            to -= spaceEnd;\n                        }\n                        tr.addMark(from, to, markType.create(attrs));\n                    }\n                }\n                dispatch(tr.scrollIntoView());\n            }\n        }\n        return true;\n    };\n}\nfunction wrapDispatchForJoin(dispatch, isJoinable) {\n    return (tr) => {\n        if (!tr.isGeneric)\n            return dispatch(tr);\n        let ranges = [];\n        for (let i = 0; i < tr.mapping.maps.length; i++) {\n            let map = tr.mapping.maps[i];\n            for (let j = 0; j < ranges.length; j++)\n                ranges[j] = map.map(ranges[j]);\n            map.forEach((_s, _e, from, to) => ranges.push(from, to));\n        }\n        // Figure out which joinable points exist inside those ranges,\n        // by checking all node boundaries in their parent nodes.\n        let joinable = [];\n        for (let i = 0; i < ranges.length; i += 2) {\n            let from = ranges[i], to = ranges[i + 1];\n            let $from = tr.doc.resolve(from), depth = $from.sharedDepth(to), parent = $from.node(depth);\n            for (let index = $from.indexAfter(depth), pos = $from.after(depth + 1); pos <= to; ++index) {\n                let after = parent.maybeChild(index);\n                if (!after)\n                    break;\n                if (index && joinable.indexOf(pos) == -1) {\n                    let before = parent.child(index - 1);\n                    if (before.type == after.type && isJoinable(before, after))\n                        joinable.push(pos);\n                }\n                pos += after.nodeSize;\n            }\n        }\n        // Join the joinable points\n        joinable.sort((a, b) => a - b);\n        for (let i = joinable.length - 1; i >= 0; i--) {\n            if ((0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_0__.canJoin)(tr.doc, joinable[i]))\n                tr.join(joinable[i]);\n        }\n        dispatch(tr);\n    };\n}\n/**\nWrap a command so that, when it produces a transform that causes\ntwo joinable nodes to end up next to each other, those are joined.\nNodes are considered joinable when they are of the same type and\nwhen the `isJoinable` predicate returns true for them or, if an\narray of strings was passed, if their node type name is in that\narray.\n*/\nfunction autoJoin(command, isJoinable) {\n    let canJoin = Array.isArray(isJoinable) ? (node) => isJoinable.indexOf(node.type.name) > -1\n        : isJoinable;\n    return (state, dispatch, view) => command(state, dispatch && wrapDispatchForJoin(dispatch, canJoin), view);\n}\n/**\nCombine a number of command functions into a single function (which\ncalls them one by one until one returns true).\n*/\nfunction chainCommands(...commands) {\n    return function (state, dispatch, view) {\n        for (let i = 0; i < commands.length; i++)\n            if (commands[i](state, dispatch, view))\n                return true;\n        return false;\n    };\n}\nlet backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);\nlet del = chainCommands(deleteSelection, joinForward, selectNodeForward);\n/**\nA basic keymap containing bindings not specific to any schema.\nBinds the following keys (when multiple commands are listed, they\nare chained with [`chainCommands`](https://prosemirror.net/docs/ref/#commands.chainCommands)):\n\n* **Enter** to `newlineInCode`, `createParagraphNear`, `liftEmptyBlock`, `splitBlock`\n* **Mod-Enter** to `exitCode`\n* **Backspace** and **Mod-Backspace** to `deleteSelection`, `joinBackward`, `selectNodeBackward`\n* **Delete** and **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n* **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n* **Mod-a** to `selectAll`\n*/\nconst pcBaseKeymap = {\n    \"Enter\": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),\n    \"Mod-Enter\": exitCode,\n    \"Backspace\": backspace,\n    \"Mod-Backspace\": backspace,\n    \"Shift-Backspace\": backspace,\n    \"Delete\": del,\n    \"Mod-Delete\": del,\n    \"Mod-a\": selectAll\n};\n/**\nA copy of `pcBaseKeymap` that also binds **Ctrl-h** like Backspace,\n**Ctrl-d** like Delete, **Alt-Backspace** like Ctrl-Backspace, and\n**Ctrl-Alt-Backspace**, **Alt-Delete**, and **Alt-d** like\nCtrl-Delete.\n*/\nconst macBaseKeymap = {\n    \"Ctrl-h\": pcBaseKeymap[\"Backspace\"],\n    \"Alt-Backspace\": pcBaseKeymap[\"Mod-Backspace\"],\n    \"Ctrl-d\": pcBaseKeymap[\"Delete\"],\n    \"Ctrl-Alt-Backspace\": pcBaseKeymap[\"Mod-Delete\"],\n    \"Alt-Delete\": pcBaseKeymap[\"Mod-Delete\"],\n    \"Alt-d\": pcBaseKeymap[\"Mod-Delete\"],\n    \"Ctrl-a\": selectTextblockStart,\n    \"Ctrl-e\": selectTextblockEnd\n};\nfor (let key in pcBaseKeymap)\n    macBaseKeymap[key] = pcBaseKeymap[key];\nconst mac = typeof navigator != \"undefined\" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform)\n    // @ts-ignore\n    : typeof os != \"undefined\" && os.platform ? os.platform() == \"darwin\" : false;\n/**\nDepending on the detected platform, this will hold\n[`pcBasekeymap`](https://prosemirror.net/docs/ref/#commands.pcBaseKeymap) or\n[`macBaseKeymap`](https://prosemirror.net/docs/ref/#commands.macBaseKeymap).\n*/\nconst baseKeymap = mac ? macBaseKeymap : pcBaseKeymap;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1jb21tYW5kcy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTRJO0FBQ3hGO0FBQ3NEOztBQUUxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxVQUFVO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxpRUFBVTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyw0REFBYTtBQUNwRCx5Q0FBeUM7QUFDekMsMEJBQTBCLGtFQUFXLHlEQUF5RCxvREFBSztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix3REFBUztBQUNuQywwQkFBMEIsNERBQWE7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx5QkFBeUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsd0JBQXdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrRUFBVyxpQ0FBaUMsb0RBQUs7QUFDaEU7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMGIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLWNvbW1hbmRzL2Rpc3QvaW5kZXguanM/YjE2MiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBsaWZ0VGFyZ2V0LCByZXBsYWNlU3RlcCwgUmVwbGFjZVN0ZXAsIGNhbkpvaW4sIGpvaW5Qb2ludCwgY2FuU3BsaXQsIFJlcGxhY2VBcm91bmRTdGVwLCBmaW5kV3JhcHBpbmcgfSBmcm9tICdwcm9zZW1pcnJvci10cmFuc2Zvcm0nO1xuaW1wb3J0IHsgU2xpY2UsIEZyYWdtZW50IH0gZnJvbSAncHJvc2VtaXJyb3ItbW9kZWwnO1xuaW1wb3J0IHsgTm9kZVNlbGVjdGlvbiwgU2VsZWN0aW9uLCBUZXh0U2VsZWN0aW9uLCBBbGxTZWxlY3Rpb24sIFNlbGVjdGlvblJhbmdlIH0gZnJvbSAncHJvc2VtaXJyb3Itc3RhdGUnO1xuXG4vKipcbkRlbGV0ZSB0aGUgc2VsZWN0aW9uLCBpZiB0aGVyZSBpcyBvbmUuXG4qL1xuY29uc3QgZGVsZXRlU2VsZWN0aW9uID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGlmIChzdGF0ZS5zZWxlY3Rpb24uZW1wdHkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmRlbGV0ZVNlbGVjdGlvbigpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIGF0QmxvY2tTdGFydChzdGF0ZSwgdmlldykge1xuICAgIGxldCB7ICRjdXJzb3IgfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoISRjdXJzb3IgfHwgKHZpZXcgPyAhdmlldy5lbmRPZlRleHRibG9jayhcImJhY2t3YXJkXCIsIHN0YXRlKVxuICAgICAgICA6ICRjdXJzb3IucGFyZW50T2Zmc2V0ID4gMCkpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiAkY3Vyc29yO1xufVxuLyoqXG5JZiB0aGUgc2VsZWN0aW9uIGlzIGVtcHR5IGFuZCBhdCB0aGUgc3RhcnQgb2YgYSB0ZXh0YmxvY2ssIHRyeSB0b1xucmVkdWNlIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoYXQgYmxvY2sgYW5kIHRoZSBvbmUgYmVmb3JlIGl04oCUaWZcbnRoZXJlJ3MgYSBibG9jayBkaXJlY3RseSBiZWZvcmUgaXQgdGhhdCBjYW4gYmUgam9pbmVkLCBqb2luIHRoZW0uXG5JZiBub3QsIHRyeSB0byBtb3ZlIHRoZSBzZWxlY3RlZCBibG9jayBjbG9zZXIgdG8gdGhlIG5leHQgb25lIGluXG50aGUgZG9jdW1lbnQgc3RydWN0dXJlIGJ5IGxpZnRpbmcgaXQgb3V0IG9mIGl0cyBwYXJlbnQgb3IgbW92aW5nIGl0XG5pbnRvIGEgcGFyZW50IG9mIHRoZSBwcmV2aW91cyBibG9jay4gV2lsbCB1c2UgdGhlIHZpZXcgZm9yIGFjY3VyYXRlXG4oYmlkaS1hd2FyZSkgc3RhcnQtb2YtdGV4dGJsb2NrIGRldGVjdGlvbiBpZiBnaXZlbi5cbiovXG5jb25zdCBqb2luQmFja3dhcmQgPSAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSA9PiB7XG4gICAgbGV0ICRjdXJzb3IgPSBhdEJsb2NrU3RhcnQoc3RhdGUsIHZpZXcpO1xuICAgIGlmICghJGN1cnNvcilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCAkY3V0ID0gZmluZEN1dEJlZm9yZSgkY3Vyc29yKTtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBub2RlIGJlZm9yZSB0aGlzLCB0cnkgdG8gbGlmdFxuICAgIGlmICghJGN1dCkge1xuICAgICAgICBsZXQgcmFuZ2UgPSAkY3Vyc29yLmJsb2NrUmFuZ2UoKSwgdGFyZ2V0ID0gcmFuZ2UgJiYgbGlmdFRhcmdldChyYW5nZSk7XG4gICAgICAgIGlmICh0YXJnZXQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIubGlmdChyYW5nZSwgdGFyZ2V0KS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxldCBiZWZvcmUgPSAkY3V0Lm5vZGVCZWZvcmU7XG4gICAgLy8gQXBwbHkgdGhlIGpvaW5pbmcgYWxnb3JpdGhtXG4gICAgaWYgKGRlbGV0ZUJhcnJpZXIoc3RhdGUsICRjdXQsIGRpc3BhdGNoLCAtMSkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIC8vIElmIHRoZSBub2RlIGJlbG93IGhhcyBubyBjb250ZW50IGFuZCB0aGUgbm9kZSBhYm92ZSBpc1xuICAgIC8vIHNlbGVjdGFibGUsIGRlbGV0ZSB0aGUgbm9kZSBiZWxvdyBhbmQgc2VsZWN0IHRoZSBvbmUgYWJvdmUuXG4gICAgaWYgKCRjdXJzb3IucGFyZW50LmNvbnRlbnQuc2l6ZSA9PSAwICYmXG4gICAgICAgICh0ZXh0YmxvY2tBdChiZWZvcmUsIFwiZW5kXCIpIHx8IE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKGJlZm9yZSkpKSB7XG4gICAgICAgIGZvciAobGV0IGRlcHRoID0gJGN1cnNvci5kZXB0aDs7IGRlcHRoLS0pIHtcbiAgICAgICAgICAgIGxldCBkZWxTdGVwID0gcmVwbGFjZVN0ZXAoc3RhdGUuZG9jLCAkY3Vyc29yLmJlZm9yZShkZXB0aCksICRjdXJzb3IuYWZ0ZXIoZGVwdGgpLCBTbGljZS5lbXB0eSk7XG4gICAgICAgICAgICBpZiAoZGVsU3RlcCAmJiBkZWxTdGVwLnNsaWNlLnNpemUgPCBkZWxTdGVwLnRvIC0gZGVsU3RlcC5mcm9tKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0ciA9IHN0YXRlLnRyLnN0ZXAoZGVsU3RlcCk7XG4gICAgICAgICAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbih0ZXh0YmxvY2tBdChiZWZvcmUsIFwiZW5kXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFNlbGVjdGlvbi5maW5kRnJvbSh0ci5kb2MucmVzb2x2ZSh0ci5tYXBwaW5nLm1hcCgkY3V0LnBvcywgLTEpKSwgLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IE5vZGVTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgJGN1dC5wb3MgLSBiZWZvcmUubm9kZVNpemUpKTtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlcHRoID09IDEgfHwgJGN1cnNvci5ub2RlKGRlcHRoIC0gMSkuY2hpbGRDb3VudCA+IDEpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSWYgdGhlIG5vZGUgYmVmb3JlIGlzIGFuIGF0b20sIGRlbGV0ZSBpdFxuICAgIGlmIChiZWZvcmUuaXNBdG9tICYmICRjdXQuZGVwdGggPT0gJGN1cnNvci5kZXB0aCAtIDEpIHtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuZGVsZXRlKCRjdXQucG9zIC0gYmVmb3JlLm5vZGVTaXplLCAkY3V0LnBvcykuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuLyoqXG5BIG1vcmUgbGltaXRlZCBmb3JtIG9mIFtgam9pbkJhY2t3YXJkYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI2NvbW1hbmRzLmpvaW5CYWNrd2FyZClcbnRoYXQgb25seSB0cmllcyB0byBqb2luIHRoZSBjdXJyZW50IHRleHRibG9jayB0byB0aGUgb25lIGJlZm9yZVxuaXQsIGlmIHRoZSBjdXJzb3IgaXMgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dGJsb2NrLlxuKi9cbmNvbnN0IGpvaW5UZXh0YmxvY2tCYWNrd2FyZCA9IChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpID0+IHtcbiAgICBsZXQgJGN1cnNvciA9IGF0QmxvY2tTdGFydChzdGF0ZSwgdmlldyk7XG4gICAgaWYgKCEkY3Vyc29yKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0ICRjdXQgPSBmaW5kQ3V0QmVmb3JlKCRjdXJzb3IpO1xuICAgIHJldHVybiAkY3V0ID8gam9pblRleHRibG9ja3NBcm91bmQoc3RhdGUsICRjdXQsIGRpc3BhdGNoKSA6IGZhbHNlO1xufTtcbi8qKlxuQSBtb3JlIGxpbWl0ZWQgZm9ybSBvZiBbYGpvaW5Gb3J3YXJkYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI2NvbW1hbmRzLmpvaW5Gb3J3YXJkKVxudGhhdCBvbmx5IHRyaWVzIHRvIGpvaW4gdGhlIGN1cnJlbnQgdGV4dGJsb2NrIHRvIHRoZSBvbmUgYWZ0ZXJcbml0LCBpZiB0aGUgY3Vyc29yIGlzIGF0IHRoZSBlbmQgb2YgYSB0ZXh0YmxvY2suXG4qL1xuY29uc3Qgam9pblRleHRibG9ja0ZvcndhcmQgPSAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSA9PiB7XG4gICAgbGV0ICRjdXJzb3IgPSBhdEJsb2NrRW5kKHN0YXRlLCB2aWV3KTtcbiAgICBpZiAoISRjdXJzb3IpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgJGN1dCA9IGZpbmRDdXRBZnRlcigkY3Vyc29yKTtcbiAgICByZXR1cm4gJGN1dCA/IGpvaW5UZXh0YmxvY2tzQXJvdW5kKHN0YXRlLCAkY3V0LCBkaXNwYXRjaCkgOiBmYWxzZTtcbn07XG5mdW5jdGlvbiBqb2luVGV4dGJsb2Nrc0Fyb3VuZChzdGF0ZSwgJGN1dCwgZGlzcGF0Y2gpIHtcbiAgICBsZXQgYmVmb3JlID0gJGN1dC5ub2RlQmVmb3JlLCBiZWZvcmVUZXh0ID0gYmVmb3JlLCBiZWZvcmVQb3MgPSAkY3V0LnBvcyAtIDE7XG4gICAgZm9yICg7ICFiZWZvcmVUZXh0LmlzVGV4dGJsb2NrOyBiZWZvcmVQb3MtLSkge1xuICAgICAgICBpZiAoYmVmb3JlVGV4dC50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgY2hpbGQgPSBiZWZvcmVUZXh0Lmxhc3RDaGlsZDtcbiAgICAgICAgaWYgKCFjaGlsZClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgYmVmb3JlVGV4dCA9IGNoaWxkO1xuICAgIH1cbiAgICBsZXQgYWZ0ZXIgPSAkY3V0Lm5vZGVBZnRlciwgYWZ0ZXJUZXh0ID0gYWZ0ZXIsIGFmdGVyUG9zID0gJGN1dC5wb3MgKyAxO1xuICAgIGZvciAoOyAhYWZ0ZXJUZXh0LmlzVGV4dGJsb2NrOyBhZnRlclBvcysrKSB7XG4gICAgICAgIGlmIChhZnRlclRleHQudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IGNoaWxkID0gYWZ0ZXJUZXh0LmZpcnN0Q2hpbGQ7XG4gICAgICAgIGlmICghY2hpbGQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGFmdGVyVGV4dCA9IGNoaWxkO1xuICAgIH1cbiAgICBsZXQgc3RlcCA9IHJlcGxhY2VTdGVwKHN0YXRlLmRvYywgYmVmb3JlUG9zLCBhZnRlclBvcywgU2xpY2UuZW1wdHkpO1xuICAgIGlmICghc3RlcCB8fCBzdGVwLmZyb20gIT0gYmVmb3JlUG9zIHx8XG4gICAgICAgIHN0ZXAgaW5zdGFuY2VvZiBSZXBsYWNlU3RlcCAmJiBzdGVwLnNsaWNlLnNpemUgPj0gYWZ0ZXJQb3MgLSBiZWZvcmVQb3MpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IHRyID0gc3RhdGUudHIuc3RlcChzdGVwKTtcbiAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgYmVmb3JlUG9zKSk7XG4gICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHRleHRibG9ja0F0KG5vZGUsIHNpZGUsIG9ubHkgPSBmYWxzZSkge1xuICAgIGZvciAobGV0IHNjYW4gPSBub2RlOyBzY2FuOyBzY2FuID0gKHNpZGUgPT0gXCJzdGFydFwiID8gc2Nhbi5maXJzdENoaWxkIDogc2Nhbi5sYXN0Q2hpbGQpKSB7XG4gICAgICAgIGlmIChzY2FuLmlzVGV4dGJsb2NrKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChvbmx5ICYmIHNjYW4uY2hpbGRDb3VudCAhPSAxKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbldoZW4gdGhlIHNlbGVjdGlvbiBpcyBlbXB0eSBhbmQgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dGJsb2NrLCBzZWxlY3RcbnRoZSBub2RlIGJlZm9yZSB0aGF0IHRleHRibG9jaywgaWYgcG9zc2libGUuIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmVcbmJvdW5kIHRvIGtleXMgbGlrZSBiYWNrc3BhY2UsIGFmdGVyXG5bYGpvaW5CYWNrd2FyZGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNjb21tYW5kcy5qb2luQmFja3dhcmQpIG9yIG90aGVyIGRlbGV0aW5nXG5jb21tYW5kcywgYXMgYSBmYWxsLWJhY2sgYmVoYXZpb3Igd2hlbiB0aGUgc2NoZW1hIGRvZXNuJ3QgYWxsb3dcbmRlbGV0aW9uIGF0IHRoZSBzZWxlY3RlZCBwb2ludC5cbiovXG5jb25zdCBzZWxlY3ROb2RlQmFja3dhcmQgPSAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSA9PiB7XG4gICAgbGV0IHsgJGhlYWQsIGVtcHR5IH0gPSBzdGF0ZS5zZWxlY3Rpb24sICRjdXQgPSAkaGVhZDtcbiAgICBpZiAoIWVtcHR5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCRoZWFkLnBhcmVudC5pc1RleHRibG9jaykge1xuICAgICAgICBpZiAodmlldyA/ICF2aWV3LmVuZE9mVGV4dGJsb2NrKFwiYmFja3dhcmRcIiwgc3RhdGUpIDogJGhlYWQucGFyZW50T2Zmc2V0ID4gMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgJGN1dCA9IGZpbmRDdXRCZWZvcmUoJGhlYWQpO1xuICAgIH1cbiAgICBsZXQgbm9kZSA9ICRjdXQgJiYgJGN1dC5ub2RlQmVmb3JlO1xuICAgIGlmICghbm9kZSB8fCAhTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobm9kZSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnNldFNlbGVjdGlvbihOb2RlU2VsZWN0aW9uLmNyZWF0ZShzdGF0ZS5kb2MsICRjdXQucG9zIC0gbm9kZS5ub2RlU2l6ZSkpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbmZ1bmN0aW9uIGZpbmRDdXRCZWZvcmUoJHBvcykge1xuICAgIGlmICghJHBvcy5wYXJlbnQudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgZm9yIChsZXQgaSA9ICRwb3MuZGVwdGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKCRwb3MuaW5kZXgoaSkgPiAwKVxuICAgICAgICAgICAgICAgIHJldHVybiAkcG9zLmRvYy5yZXNvbHZlKCRwb3MuYmVmb3JlKGkgKyAxKSk7XG4gICAgICAgICAgICBpZiAoJHBvcy5ub2RlKGkpLnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGF0QmxvY2tFbmQoc3RhdGUsIHZpZXcpIHtcbiAgICBsZXQgeyAkY3Vyc29yIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCEkY3Vyc29yIHx8ICh2aWV3ID8gIXZpZXcuZW5kT2ZUZXh0YmxvY2soXCJmb3J3YXJkXCIsIHN0YXRlKVxuICAgICAgICA6ICRjdXJzb3IucGFyZW50T2Zmc2V0IDwgJGN1cnNvci5wYXJlbnQuY29udGVudC5zaXplKSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuICRjdXJzb3I7XG59XG4vKipcbklmIHRoZSBzZWxlY3Rpb24gaXMgZW1wdHkgYW5kIHRoZSBjdXJzb3IgaXMgYXQgdGhlIGVuZCBvZiBhXG50ZXh0YmxvY2ssIHRyeSB0byByZWR1Y2Ugb3IgcmVtb3ZlIHRoZSBib3VuZGFyeSBiZXR3ZWVuIHRoYXQgYmxvY2tcbmFuZCB0aGUgb25lIGFmdGVyIGl0LCBlaXRoZXIgYnkgam9pbmluZyB0aGVtIG9yIGJ5IG1vdmluZyB0aGUgb3RoZXJcbmJsb2NrIGNsb3NlciB0byB0aGlzIG9uZSBpbiB0aGUgdHJlZSBzdHJ1Y3R1cmUuIFdpbGwgdXNlIHRoZSB2aWV3XG5mb3IgYWNjdXJhdGUgc3RhcnQtb2YtdGV4dGJsb2NrIGRldGVjdGlvbiBpZiBnaXZlbi5cbiovXG5jb25zdCBqb2luRm9yd2FyZCA9IChzdGF0ZSwgZGlzcGF0Y2gsIHZpZXcpID0+IHtcbiAgICBsZXQgJGN1cnNvciA9IGF0QmxvY2tFbmQoc3RhdGUsIHZpZXcpO1xuICAgIGlmICghJGN1cnNvcilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCAkY3V0ID0gZmluZEN1dEFmdGVyKCRjdXJzb3IpO1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIG5vZGUgYWZ0ZXIgdGhpcywgdGhlcmUncyBub3RoaW5nIHRvIGRvXG4gICAgaWYgKCEkY3V0KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGFmdGVyID0gJGN1dC5ub2RlQWZ0ZXI7XG4gICAgLy8gVHJ5IHRoZSBqb2luaW5nIGFsZ29yaXRobVxuICAgIGlmIChkZWxldGVCYXJyaWVyKHN0YXRlLCAkY3V0LCBkaXNwYXRjaCwgMSkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIC8vIElmIHRoZSBub2RlIGFib3ZlIGhhcyBubyBjb250ZW50IGFuZCB0aGUgbm9kZSBiZWxvdyBpc1xuICAgIC8vIHNlbGVjdGFibGUsIGRlbGV0ZSB0aGUgbm9kZSBhYm92ZSBhbmQgc2VsZWN0IHRoZSBvbmUgYmVsb3cuXG4gICAgaWYgKCRjdXJzb3IucGFyZW50LmNvbnRlbnQuc2l6ZSA9PSAwICYmXG4gICAgICAgICh0ZXh0YmxvY2tBdChhZnRlciwgXCJzdGFydFwiKSB8fCBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShhZnRlcikpKSB7XG4gICAgICAgIGxldCBkZWxTdGVwID0gcmVwbGFjZVN0ZXAoc3RhdGUuZG9jLCAkY3Vyc29yLmJlZm9yZSgpLCAkY3Vyc29yLmFmdGVyKCksIFNsaWNlLmVtcHR5KTtcbiAgICAgICAgaWYgKGRlbFN0ZXAgJiYgZGVsU3RlcC5zbGljZS5zaXplIDwgZGVsU3RlcC50byAtIGRlbFN0ZXAuZnJvbSkge1xuICAgICAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRyID0gc3RhdGUudHIuc3RlcChkZWxTdGVwKTtcbiAgICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24odGV4dGJsb2NrQXQoYWZ0ZXIsIFwic3RhcnRcIikgPyBTZWxlY3Rpb24uZmluZEZyb20odHIuZG9jLnJlc29sdmUodHIubWFwcGluZy5tYXAoJGN1dC5wb3MpKSwgMSlcbiAgICAgICAgICAgICAgICAgICAgOiBOb2RlU2VsZWN0aW9uLmNyZWF0ZSh0ci5kb2MsIHRyLm1hcHBpbmcubWFwKCRjdXQucG9zKSkpO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSWYgdGhlIG5leHQgbm9kZSBpcyBhbiBhdG9tLCBkZWxldGUgaXRcbiAgICBpZiAoYWZ0ZXIuaXNBdG9tICYmICRjdXQuZGVwdGggPT0gJGN1cnNvci5kZXB0aCAtIDEpIHtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuZGVsZXRlKCRjdXQucG9zLCAkY3V0LnBvcyArIGFmdGVyLm5vZGVTaXplKS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG4vKipcbldoZW4gdGhlIHNlbGVjdGlvbiBpcyBlbXB0eSBhbmQgYXQgdGhlIGVuZCBvZiBhIHRleHRibG9jaywgc2VsZWN0XG50aGUgbm9kZSBjb21pbmcgYWZ0ZXIgdGhhdCB0ZXh0YmxvY2ssIGlmIHBvc3NpYmxlLiBUaGlzIGlzIGludGVuZGVkXG50byBiZSBib3VuZCB0byBrZXlzIGxpa2UgZGVsZXRlLCBhZnRlclxuW2Bqb2luRm9yd2FyZGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNjb21tYW5kcy5qb2luRm9yd2FyZCkgYW5kIHNpbWlsYXIgZGVsZXRpbmdcbmNvbW1hbmRzLCB0byBwcm92aWRlIGEgZmFsbC1iYWNrIGJlaGF2aW9yIHdoZW4gdGhlIHNjaGVtYSBkb2Vzbid0XG5hbGxvdyBkZWxldGlvbiBhdCB0aGUgc2VsZWN0ZWQgcG9pbnQuXG4qL1xuY29uc3Qgc2VsZWN0Tm9kZUZvcndhcmQgPSAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSA9PiB7XG4gICAgbGV0IHsgJGhlYWQsIGVtcHR5IH0gPSBzdGF0ZS5zZWxlY3Rpb24sICRjdXQgPSAkaGVhZDtcbiAgICBpZiAoIWVtcHR5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCRoZWFkLnBhcmVudC5pc1RleHRibG9jaykge1xuICAgICAgICBpZiAodmlldyA/ICF2aWV3LmVuZE9mVGV4dGJsb2NrKFwiZm9yd2FyZFwiLCBzdGF0ZSkgOiAkaGVhZC5wYXJlbnRPZmZzZXQgPCAkaGVhZC5wYXJlbnQuY29udGVudC5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAkY3V0ID0gZmluZEN1dEFmdGVyKCRoZWFkKTtcbiAgICB9XG4gICAgbGV0IG5vZGUgPSAkY3V0ICYmICRjdXQubm9kZUFmdGVyO1xuICAgIGlmICghbm9kZSB8fCAhTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobm9kZSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnNldFNlbGVjdGlvbihOb2RlU2VsZWN0aW9uLmNyZWF0ZShzdGF0ZS5kb2MsICRjdXQucG9zKSkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gZmluZEN1dEFmdGVyKCRwb3MpIHtcbiAgICBpZiAoISRwb3MucGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgIGZvciAobGV0IGkgPSAkcG9zLmRlcHRoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSAkcG9zLm5vZGUoaSk7XG4gICAgICAgICAgICBpZiAoJHBvcy5pbmRleChpKSArIDEgPCBwYXJlbnQuY2hpbGRDb3VudClcbiAgICAgICAgICAgICAgICByZXR1cm4gJHBvcy5kb2MucmVzb2x2ZSgkcG9zLmFmdGVyKGkgKyAxKSk7XG4gICAgICAgICAgICBpZiAocGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuSm9pbiB0aGUgc2VsZWN0ZWQgYmxvY2sgb3IsIGlmIHRoZXJlIGlzIGEgdGV4dCBzZWxlY3Rpb24sIHRoZVxuY2xvc2VzdCBhbmNlc3RvciBibG9jayBvZiB0aGUgc2VsZWN0aW9uIHRoYXQgY2FuIGJlIGpvaW5lZCwgd2l0aFxudGhlIHNpYmxpbmcgYWJvdmUgaXQuXG4qL1xuY29uc3Qgam9pblVwID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGxldCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb24sIG5vZGVTZWwgPSBzZWwgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uLCBwb2ludDtcbiAgICBpZiAobm9kZVNlbCkge1xuICAgICAgICBpZiAoc2VsLm5vZGUuaXNUZXh0YmxvY2sgfHwgIWNhbkpvaW4oc3RhdGUuZG9jLCBzZWwuZnJvbSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHBvaW50ID0gc2VsLmZyb207XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwb2ludCA9IGpvaW5Qb2ludChzdGF0ZS5kb2MsIHNlbC5mcm9tLCAtMSk7XG4gICAgICAgIGlmIChwb2ludCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IHRyID0gc3RhdGUudHIuam9pbihwb2ludCk7XG4gICAgICAgIGlmIChub2RlU2VsKVxuICAgICAgICAgICAgdHIuc2V0U2VsZWN0aW9uKE5vZGVTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgcG9pbnQgLSBzdGF0ZS5kb2MucmVzb2x2ZShwb2ludCkubm9kZUJlZm9yZS5ub2RlU2l6ZSkpO1xuICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5Kb2luIHRoZSBzZWxlY3RlZCBibG9jaywgb3IgdGhlIGNsb3Nlc3QgYW5jZXN0b3Igb2YgdGhlIHNlbGVjdGlvblxudGhhdCBjYW4gYmUgam9pbmVkLCB3aXRoIHRoZSBzaWJsaW5nIGFmdGVyIGl0LlxuKi9cbmNvbnN0IGpvaW5Eb3duID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGxldCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb24sIHBvaW50O1xuICAgIGlmIChzZWwgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uKSB7XG4gICAgICAgIGlmIChzZWwubm9kZS5pc1RleHRibG9jayB8fCAhY2FuSm9pbihzdGF0ZS5kb2MsIHNlbC50bykpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHBvaW50ID0gc2VsLnRvO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcG9pbnQgPSBqb2luUG9pbnQoc3RhdGUuZG9jLCBzZWwudG8sIDEpO1xuICAgICAgICBpZiAocG9pbnQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5qb2luKHBvaW50KS5zY3JvbGxJbnRvVmlldygpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbkxpZnQgdGhlIHNlbGVjdGVkIGJsb2NrLCBvciB0aGUgY2xvc2VzdCBhbmNlc3RvciBibG9jayBvZiB0aGVcbnNlbGVjdGlvbiB0aGF0IGNhbiBiZSBsaWZ0ZWQsIG91dCBvZiBpdHMgcGFyZW50IG5vZGUuXG4qL1xuY29uc3QgbGlmdCA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgbGV0IHJhbmdlID0gJGZyb20uYmxvY2tSYW5nZSgkdG8pLCB0YXJnZXQgPSByYW5nZSAmJiBsaWZ0VGFyZ2V0KHJhbmdlKTtcbiAgICBpZiAodGFyZ2V0ID09IG51bGwpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmxpZnQocmFuZ2UsIHRhcmdldCkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5JZiB0aGUgc2VsZWN0aW9uIGlzIGluIGEgbm9kZSB3aG9zZSB0eXBlIGhhcyBhIHRydXRoeVxuW2Bjb2RlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLmNvZGUpIHByb3BlcnR5IGluIGl0cyBzcGVjLCByZXBsYWNlIHRoZVxuc2VsZWN0aW9uIHdpdGggYSBuZXdsaW5lIGNoYXJhY3Rlci5cbiovXG5jb25zdCBuZXdsaW5lSW5Db2RlID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGxldCB7ICRoZWFkLCAkYW5jaG9yIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCEkaGVhZC5wYXJlbnQudHlwZS5zcGVjLmNvZGUgfHwgISRoZWFkLnNhbWVQYXJlbnQoJGFuY2hvcikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmluc2VydFRleHQoXCJcXG5cIikuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuZnVuY3Rpb24gZGVmYXVsdEJsb2NrQXQobWF0Y2gpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoLmVkZ2VDb3VudDsgaSsrKSB7XG4gICAgICAgIGxldCB7IHR5cGUgfSA9IG1hdGNoLmVkZ2UoaSk7XG4gICAgICAgIGlmICh0eXBlLmlzVGV4dGJsb2NrICYmICF0eXBlLmhhc1JlcXVpcmVkQXR0cnMoKSlcbiAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8qKlxuV2hlbiB0aGUgc2VsZWN0aW9uIGlzIGluIGEgbm9kZSB3aXRoIGEgdHJ1dGh5XG5bYGNvZGVgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMuY29kZSkgcHJvcGVydHkgaW4gaXRzIHNwZWMsIGNyZWF0ZSBhXG5kZWZhdWx0IGJsb2NrIGFmdGVyIHRoZSBjb2RlIGJsb2NrLCBhbmQgbW92ZSB0aGUgY3Vyc29yIHRoZXJlLlxuKi9cbmNvbnN0IGV4aXRDb2RlID0gKHN0YXRlLCBkaXNwYXRjaCkgPT4ge1xuICAgIGxldCB7ICRoZWFkLCAkYW5jaG9yIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCEkaGVhZC5wYXJlbnQudHlwZS5zcGVjLmNvZGUgfHwgISRoZWFkLnNhbWVQYXJlbnQoJGFuY2hvcikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgYWJvdmUgPSAkaGVhZC5ub2RlKC0xKSwgYWZ0ZXIgPSAkaGVhZC5pbmRleEFmdGVyKC0xKSwgdHlwZSA9IGRlZmF1bHRCbG9ja0F0KGFib3ZlLmNvbnRlbnRNYXRjaEF0KGFmdGVyKSk7XG4gICAgaWYgKCF0eXBlIHx8ICFhYm92ZS5jYW5SZXBsYWNlV2l0aChhZnRlciwgYWZ0ZXIsIHR5cGUpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCBwb3MgPSAkaGVhZC5hZnRlcigpLCB0ciA9IHN0YXRlLnRyLnJlcGxhY2VXaXRoKHBvcywgcG9zLCB0eXBlLmNyZWF0ZUFuZEZpbGwoKSk7XG4gICAgICAgIHRyLnNldFNlbGVjdGlvbihTZWxlY3Rpb24ubmVhcih0ci5kb2MucmVzb2x2ZShwb3MpLCAxKSk7XG4gICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG4vKipcbklmIGEgYmxvY2sgbm9kZSBpcyBzZWxlY3RlZCwgY3JlYXRlIGFuIGVtcHR5IHBhcmFncmFwaCBiZWZvcmUgKGlmXG5pdCBpcyBpdHMgcGFyZW50J3MgZmlyc3QgY2hpbGQpIG9yIGFmdGVyIGl0LlxuKi9cbmNvbnN0IGNyZWF0ZVBhcmFncmFwaE5lYXIgPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgbGV0IHNlbCA9IHN0YXRlLnNlbGVjdGlvbiwgeyAkZnJvbSwgJHRvIH0gPSBzZWw7XG4gICAgaWYgKHNlbCBpbnN0YW5jZW9mIEFsbFNlbGVjdGlvbiB8fCAkZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudCB8fCAkdG8ucGFyZW50LmlubGluZUNvbnRlbnQpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgdHlwZSA9IGRlZmF1bHRCbG9ja0F0KCR0by5wYXJlbnQuY29udGVudE1hdGNoQXQoJHRvLmluZGV4QWZ0ZXIoKSkpO1xuICAgIGlmICghdHlwZSB8fCAhdHlwZS5pc1RleHRibG9jaylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICBsZXQgc2lkZSA9ICghJGZyb20ucGFyZW50T2Zmc2V0ICYmICR0by5pbmRleCgpIDwgJHRvLnBhcmVudC5jaGlsZENvdW50ID8gJGZyb20gOiAkdG8pLnBvcztcbiAgICAgICAgbGV0IHRyID0gc3RhdGUudHIuaW5zZXJ0KHNpZGUsIHR5cGUuY3JlYXRlQW5kRmlsbCgpKTtcbiAgICAgICAgdHIuc2V0U2VsZWN0aW9uKFRleHRTZWxlY3Rpb24uY3JlYXRlKHRyLmRvYywgc2lkZSArIDEpKTtcbiAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuSWYgdGhlIGN1cnNvciBpcyBpbiBhbiBlbXB0eSB0ZXh0YmxvY2sgdGhhdCBjYW4gYmUgbGlmdGVkLCBsaWZ0IHRoZVxuYmxvY2suXG4qL1xuY29uc3QgbGlmdEVtcHR5QmxvY2sgPSAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgbGV0IHsgJGN1cnNvciB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmICghJGN1cnNvciB8fCAkY3Vyc29yLnBhcmVudC5jb250ZW50LnNpemUpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoJGN1cnNvci5kZXB0aCA+IDEgJiYgJGN1cnNvci5hZnRlcigpICE9ICRjdXJzb3IuZW5kKC0xKSkge1xuICAgICAgICBsZXQgYmVmb3JlID0gJGN1cnNvci5iZWZvcmUoKTtcbiAgICAgICAgaWYgKGNhblNwbGl0KHN0YXRlLmRvYywgYmVmb3JlKSkge1xuICAgICAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnNwbGl0KGJlZm9yZSkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgcmFuZ2UgPSAkY3Vyc29yLmJsb2NrUmFuZ2UoKSwgdGFyZ2V0ID0gcmFuZ2UgJiYgbGlmdFRhcmdldChyYW5nZSk7XG4gICAgaWYgKHRhcmdldCA9PSBudWxsKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5saWZ0KHJhbmdlLCB0YXJnZXQpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuQ3JlYXRlIGEgdmFyaWFudCBvZiBbYHNwbGl0QmxvY2tgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jY29tbWFuZHMuc3BsaXRCbG9jaykgdGhhdCB1c2VzXG5hIGN1c3RvbSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgdGhlIHR5cGUgb2YgdGhlIG5ld2x5IHNwbGl0IG9mZiBibG9jay5cbiovXG5mdW5jdGlvbiBzcGxpdEJsb2NrQXMoc3BsaXROb2RlKSB7XG4gICAgcmV0dXJuIChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICAgICAgbGV0IHsgJGZyb20sICR0byB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBpZiAoc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbiAmJiBzdGF0ZS5zZWxlY3Rpb24ubm9kZS5pc0Jsb2NrKSB7XG4gICAgICAgICAgICBpZiAoISRmcm9tLnBhcmVudE9mZnNldCB8fCAhY2FuU3BsaXQoc3RhdGUuZG9jLCAkZnJvbS5wb3MpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5zcGxpdCgkZnJvbS5wb3MpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEkZnJvbS5kZXB0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHR5cGVzID0gW107XG4gICAgICAgIGxldCBzcGxpdERlcHRoLCBkZWZsdCwgYXRFbmQgPSBmYWxzZSwgYXRTdGFydCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBkID0gJGZyb20uZGVwdGg7OyBkLS0pIHtcbiAgICAgICAgICAgIGxldCBub2RlID0gJGZyb20ubm9kZShkKTtcbiAgICAgICAgICAgIGlmIChub2RlLmlzQmxvY2spIHtcbiAgICAgICAgICAgICAgICBhdEVuZCA9ICRmcm9tLmVuZChkKSA9PSAkZnJvbS5wb3MgKyAoJGZyb20uZGVwdGggLSBkKTtcbiAgICAgICAgICAgICAgICBhdFN0YXJ0ID0gJGZyb20uc3RhcnQoZCkgPT0gJGZyb20ucG9zIC0gKCRmcm9tLmRlcHRoIC0gZCk7XG4gICAgICAgICAgICAgICAgZGVmbHQgPSBkZWZhdWx0QmxvY2tBdCgkZnJvbS5ub2RlKGQgLSAxKS5jb250ZW50TWF0Y2hBdCgkZnJvbS5pbmRleEFmdGVyKGQgLSAxKSkpO1xuICAgICAgICAgICAgICAgIGxldCBzcGxpdFR5cGUgPSBzcGxpdE5vZGUgJiYgc3BsaXROb2RlKCR0by5wYXJlbnQsIGF0RW5kLCAkZnJvbSk7XG4gICAgICAgICAgICAgICAgdHlwZXMudW5zaGlmdChzcGxpdFR5cGUgfHwgKGF0RW5kICYmIGRlZmx0ID8geyB0eXBlOiBkZWZsdCB9IDogbnVsbCkpO1xuICAgICAgICAgICAgICAgIHNwbGl0RGVwdGggPSBkO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGQgPT0gMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIHR5cGVzLnVuc2hpZnQobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRyID0gc3RhdGUudHI7XG4gICAgICAgIGlmIChzdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uIHx8IHN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIEFsbFNlbGVjdGlvbilcbiAgICAgICAgICAgIHRyLmRlbGV0ZVNlbGVjdGlvbigpO1xuICAgICAgICBsZXQgc3BsaXRQb3MgPSB0ci5tYXBwaW5nLm1hcCgkZnJvbS5wb3MpO1xuICAgICAgICBsZXQgY2FuID0gY2FuU3BsaXQodHIuZG9jLCBzcGxpdFBvcywgdHlwZXMubGVuZ3RoLCB0eXBlcyk7XG4gICAgICAgIGlmICghY2FuKSB7XG4gICAgICAgICAgICB0eXBlc1swXSA9IGRlZmx0ID8geyB0eXBlOiBkZWZsdCB9IDogbnVsbDtcbiAgICAgICAgICAgIGNhbiA9IGNhblNwbGl0KHRyLmRvYywgc3BsaXRQb3MsIHR5cGVzLmxlbmd0aCwgdHlwZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY2FuKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0ci5zcGxpdChzcGxpdFBvcywgdHlwZXMubGVuZ3RoLCB0eXBlcyk7XG4gICAgICAgIGlmICghYXRFbmQgJiYgYXRTdGFydCAmJiAkZnJvbS5ub2RlKHNwbGl0RGVwdGgpLnR5cGUgIT0gZGVmbHQpIHtcbiAgICAgICAgICAgIGxldCBmaXJzdCA9IHRyLm1hcHBpbmcubWFwKCRmcm9tLmJlZm9yZShzcGxpdERlcHRoKSksICRmaXJzdCA9IHRyLmRvYy5yZXNvbHZlKGZpcnN0KTtcbiAgICAgICAgICAgIGlmIChkZWZsdCAmJiAkZnJvbS5ub2RlKHNwbGl0RGVwdGggLSAxKS5jYW5SZXBsYWNlV2l0aCgkZmlyc3QuaW5kZXgoKSwgJGZpcnN0LmluZGV4KCkgKyAxLCBkZWZsdCkpXG4gICAgICAgICAgICAgICAgdHIuc2V0Tm9kZU1hcmt1cCh0ci5tYXBwaW5nLm1hcCgkZnJvbS5iZWZvcmUoc3BsaXREZXB0aCkpLCBkZWZsdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG4vKipcblNwbGl0IHRoZSBwYXJlbnQgYmxvY2sgb2YgdGhlIHNlbGVjdGlvbi4gSWYgdGhlIHNlbGVjdGlvbiBpcyBhIHRleHRcbnNlbGVjdGlvbiwgYWxzbyBkZWxldGUgaXRzIGNvbnRlbnQuXG4qL1xuY29uc3Qgc3BsaXRCbG9jayA9IHNwbGl0QmxvY2tBcygpO1xuLyoqXG5BY3RzIGxpa2UgW2BzcGxpdEJsb2NrYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI2NvbW1hbmRzLnNwbGl0QmxvY2spLCBidXQgd2l0aG91dFxucmVzZXR0aW5nIHRoZSBzZXQgb2YgYWN0aXZlIG1hcmtzIGF0IHRoZSBjdXJzb3IuXG4qL1xuY29uc3Qgc3BsaXRCbG9ja0tlZXBNYXJrcyA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICByZXR1cm4gc3BsaXRCbG9jayhzdGF0ZSwgZGlzcGF0Y2ggJiYgKHRyID0+IHtcbiAgICAgICAgbGV0IG1hcmtzID0gc3RhdGUuc3RvcmVkTWFya3MgfHwgKHN0YXRlLnNlbGVjdGlvbi4kdG8ucGFyZW50T2Zmc2V0ICYmIHN0YXRlLnNlbGVjdGlvbi4kZnJvbS5tYXJrcygpKTtcbiAgICAgICAgaWYgKG1hcmtzKVxuICAgICAgICAgICAgdHIuZW5zdXJlTWFya3MobWFya3MpO1xuICAgICAgICBkaXNwYXRjaCh0cik7XG4gICAgfSkpO1xufTtcbi8qKlxuTW92ZSB0aGUgc2VsZWN0aW9uIHRvIHRoZSBub2RlIHdyYXBwaW5nIHRoZSBjdXJyZW50IHNlbGVjdGlvbiwgaWZcbmFueS4gKFdpbGwgbm90IHNlbGVjdCB0aGUgZG9jdW1lbnQgbm9kZS4pXG4qL1xuY29uc3Qgc2VsZWN0UGFyZW50Tm9kZSA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBsZXQgeyAkZnJvbSwgdG8gfSA9IHN0YXRlLnNlbGVjdGlvbiwgcG9zO1xuICAgIGxldCBzYW1lID0gJGZyb20uc2hhcmVkRGVwdGgodG8pO1xuICAgIGlmIChzYW1lID09IDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBwb3MgPSAkZnJvbS5iZWZvcmUoc2FtZSk7XG4gICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5zZXRTZWxlY3Rpb24oTm9kZVNlbGVjdGlvbi5jcmVhdGUoc3RhdGUuZG9jLCBwb3MpKSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG5TZWxlY3QgdGhlIHdob2xlIGRvY3VtZW50LlxuKi9cbmNvbnN0IHNlbGVjdEFsbCA9IChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnNldFNlbGVjdGlvbihuZXcgQWxsU2VsZWN0aW9uKHN0YXRlLmRvYykpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5mdW5jdGlvbiBqb2luTWF5YmVDbGVhcihzdGF0ZSwgJHBvcywgZGlzcGF0Y2gpIHtcbiAgICBsZXQgYmVmb3JlID0gJHBvcy5ub2RlQmVmb3JlLCBhZnRlciA9ICRwb3Mubm9kZUFmdGVyLCBpbmRleCA9ICRwb3MuaW5kZXgoKTtcbiAgICBpZiAoIWJlZm9yZSB8fCAhYWZ0ZXIgfHwgIWJlZm9yZS50eXBlLmNvbXBhdGlibGVDb250ZW50KGFmdGVyLnR5cGUpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFiZWZvcmUuY29udGVudC5zaXplICYmICRwb3MucGFyZW50LmNhblJlcGxhY2UoaW5kZXggLSAxLCBpbmRleCkpIHtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuZGVsZXRlKCRwb3MucG9zIC0gYmVmb3JlLm5vZGVTaXplLCAkcG9zLnBvcykuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoISRwb3MucGFyZW50LmNhblJlcGxhY2UoaW5kZXgsIGluZGV4ICsgMSkgfHwgIShhZnRlci5pc1RleHRibG9jayB8fCBjYW5Kb2luKHN0YXRlLmRvYywgJHBvcy5wb3MpKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgZGlzcGF0Y2goc3RhdGUudHIuam9pbigkcG9zLnBvcykuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBkZWxldGVCYXJyaWVyKHN0YXRlLCAkY3V0LCBkaXNwYXRjaCwgZGlyKSB7XG4gICAgbGV0IGJlZm9yZSA9ICRjdXQubm9kZUJlZm9yZSwgYWZ0ZXIgPSAkY3V0Lm5vZGVBZnRlciwgY29ubiwgbWF0Y2g7XG4gICAgbGV0IGlzb2xhdGVkID0gYmVmb3JlLnR5cGUuc3BlYy5pc29sYXRpbmcgfHwgYWZ0ZXIudHlwZS5zcGVjLmlzb2xhdGluZztcbiAgICBpZiAoIWlzb2xhdGVkICYmIGpvaW5NYXliZUNsZWFyKHN0YXRlLCAkY3V0LCBkaXNwYXRjaCkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGxldCBjYW5EZWxBZnRlciA9ICFpc29sYXRlZCAmJiAkY3V0LnBhcmVudC5jYW5SZXBsYWNlKCRjdXQuaW5kZXgoKSwgJGN1dC5pbmRleCgpICsgMSk7XG4gICAgaWYgKGNhbkRlbEFmdGVyICYmXG4gICAgICAgIChjb25uID0gKG1hdGNoID0gYmVmb3JlLmNvbnRlbnRNYXRjaEF0KGJlZm9yZS5jaGlsZENvdW50KSkuZmluZFdyYXBwaW5nKGFmdGVyLnR5cGUpKSAmJlxuICAgICAgICBtYXRjaC5tYXRjaFR5cGUoY29ublswXSB8fCBhZnRlci50eXBlKS52YWxpZEVuZCkge1xuICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIGxldCBlbmQgPSAkY3V0LnBvcyArIGFmdGVyLm5vZGVTaXplLCB3cmFwID0gRnJhZ21lbnQuZW1wdHk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gY29ubi5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgICAgICB3cmFwID0gRnJhZ21lbnQuZnJvbShjb25uW2ldLmNyZWF0ZShudWxsLCB3cmFwKSk7XG4gICAgICAgICAgICB3cmFwID0gRnJhZ21lbnQuZnJvbShiZWZvcmUuY29weSh3cmFwKSk7XG4gICAgICAgICAgICBsZXQgdHIgPSBzdGF0ZS50ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcCgkY3V0LnBvcyAtIDEsIGVuZCwgJGN1dC5wb3MsIGVuZCwgbmV3IFNsaWNlKHdyYXAsIDEsIDApLCBjb25uLmxlbmd0aCwgdHJ1ZSkpO1xuICAgICAgICAgICAgbGV0ICRqb2luQXQgPSB0ci5kb2MucmVzb2x2ZShlbmQgKyAyICogY29ubi5sZW5ndGgpO1xuICAgICAgICAgICAgaWYgKCRqb2luQXQubm9kZUFmdGVyICYmICRqb2luQXQubm9kZUFmdGVyLnR5cGUgPT0gYmVmb3JlLnR5cGUgJiZcbiAgICAgICAgICAgICAgICBjYW5Kb2luKHRyLmRvYywgJGpvaW5BdC5wb3MpKVxuICAgICAgICAgICAgICAgIHRyLmpvaW4oJGpvaW5BdC5wb3MpO1xuICAgICAgICAgICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxldCBzZWxBZnRlciA9IGFmdGVyLnR5cGUuc3BlYy5pc29sYXRpbmcgfHwgKGRpciA+IDAgJiYgaXNvbGF0ZWQpID8gbnVsbCA6IFNlbGVjdGlvbi5maW5kRnJvbSgkY3V0LCAxKTtcbiAgICBsZXQgcmFuZ2UgPSBzZWxBZnRlciAmJiBzZWxBZnRlci4kZnJvbS5ibG9ja1JhbmdlKHNlbEFmdGVyLiR0byksIHRhcmdldCA9IHJhbmdlICYmIGxpZnRUYXJnZXQocmFuZ2UpO1xuICAgIGlmICh0YXJnZXQgIT0gbnVsbCAmJiB0YXJnZXQgPj0gJGN1dC5kZXB0aCkge1xuICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5saWZ0KHJhbmdlLCB0YXJnZXQpLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGNhbkRlbEFmdGVyICYmIHRleHRibG9ja0F0KGFmdGVyLCBcInN0YXJ0XCIsIHRydWUpICYmIHRleHRibG9ja0F0KGJlZm9yZSwgXCJlbmRcIikpIHtcbiAgICAgICAgbGV0IGF0ID0gYmVmb3JlLCB3cmFwID0gW107XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIHdyYXAucHVzaChhdCk7XG4gICAgICAgICAgICBpZiAoYXQuaXNUZXh0YmxvY2spXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBhdCA9IGF0Lmxhc3RDaGlsZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYWZ0ZXJUZXh0ID0gYWZ0ZXIsIGFmdGVyRGVwdGggPSAxO1xuICAgICAgICBmb3IgKDsgIWFmdGVyVGV4dC5pc1RleHRibG9jazsgYWZ0ZXJUZXh0ID0gYWZ0ZXJUZXh0LmZpcnN0Q2hpbGQpXG4gICAgICAgICAgICBhZnRlckRlcHRoKys7XG4gICAgICAgIGlmIChhdC5jYW5SZXBsYWNlKGF0LmNoaWxkQ291bnQsIGF0LmNoaWxkQ291bnQsIGFmdGVyVGV4dC5jb250ZW50KSkge1xuICAgICAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZCA9IEZyYWdtZW50LmVtcHR5O1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSB3cmFwLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICAgICAgICAgICAgICBlbmQgPSBGcmFnbWVudC5mcm9tKHdyYXBbaV0uY29weShlbmQpKTtcbiAgICAgICAgICAgICAgICBsZXQgdHIgPSBzdGF0ZS50ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcCgkY3V0LnBvcyAtIHdyYXAubGVuZ3RoLCAkY3V0LnBvcyArIGFmdGVyLm5vZGVTaXplLCAkY3V0LnBvcyArIGFmdGVyRGVwdGgsICRjdXQucG9zICsgYWZ0ZXIubm9kZVNpemUgLSBhZnRlckRlcHRoLCBuZXcgU2xpY2UoZW5kLCB3cmFwLmxlbmd0aCwgMCksIDAsIHRydWUpKTtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHNlbGVjdFRleHRibG9ja1NpZGUoc2lkZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb24sICRwb3MgPSBzaWRlIDwgMCA/IHNlbC4kZnJvbSA6IHNlbC4kdG87XG4gICAgICAgIGxldCBkZXB0aCA9ICRwb3MuZGVwdGg7XG4gICAgICAgIHdoaWxlICgkcG9zLm5vZGUoZGVwdGgpLmlzSW5saW5lKSB7XG4gICAgICAgICAgICBpZiAoIWRlcHRoKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEkcG9zLm5vZGUoZGVwdGgpLmlzVGV4dGJsb2NrKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5zZXRTZWxlY3Rpb24oVGV4dFNlbGVjdGlvbi5jcmVhdGUoc3RhdGUuZG9jLCBzaWRlIDwgMCA/ICRwb3Muc3RhcnQoZGVwdGgpIDogJHBvcy5lbmQoZGVwdGgpKSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuLyoqXG5Nb3ZlcyB0aGUgY3Vyc29yIHRvIHRoZSBzdGFydCBvZiBjdXJyZW50IHRleHQgYmxvY2suXG4qL1xuY29uc3Qgc2VsZWN0VGV4dGJsb2NrU3RhcnQgPSBzZWxlY3RUZXh0YmxvY2tTaWRlKC0xKTtcbi8qKlxuTW92ZXMgdGhlIGN1cnNvciB0byB0aGUgZW5kIG9mIGN1cnJlbnQgdGV4dCBibG9jay5cbiovXG5jb25zdCBzZWxlY3RUZXh0YmxvY2tFbmQgPSBzZWxlY3RUZXh0YmxvY2tTaWRlKDEpO1xuLy8gUGFyYW1ldGVyaXplZCBjb21tYW5kc1xuLyoqXG5XcmFwIHRoZSBzZWxlY3Rpb24gaW4gYSBub2RlIG9mIHRoZSBnaXZlbiB0eXBlIHdpdGggdGhlIGdpdmVuXG5hdHRyaWJ1dGVzLlxuKi9cbmZ1bmN0aW9uIHdyYXBJbihub2RlVHlwZSwgYXR0cnMgPSBudWxsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IHsgJGZyb20sICR0byB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBsZXQgcmFuZ2UgPSAkZnJvbS5ibG9ja1JhbmdlKCR0byksIHdyYXBwaW5nID0gcmFuZ2UgJiYgZmluZFdyYXBwaW5nKHJhbmdlLCBub2RlVHlwZSwgYXR0cnMpO1xuICAgICAgICBpZiAoIXdyYXBwaW5nKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci53cmFwKHJhbmdlLCB3cmFwcGluZykuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG4vKipcblJldHVybnMgYSBjb21tYW5kIHRoYXQgdHJpZXMgdG8gc2V0IHRoZSBzZWxlY3RlZCB0ZXh0YmxvY2tzIHRvIHRoZVxuZ2l2ZW4gbm9kZSB0eXBlIHdpdGggdGhlIGdpdmVuIGF0dHJpYnV0ZXMuXG4qL1xuZnVuY3Rpb24gc2V0QmxvY2tUeXBlKG5vZGVUeXBlLCBhdHRycyA9IG51bGwpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICBsZXQgYXBwbGljYWJsZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMubGVuZ3RoICYmICFhcHBsaWNhYmxlOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB7ICRmcm9tOiB7IHBvczogZnJvbSB9LCAkdG86IHsgcG9zOiB0byB9IH0gPSBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzW2ldO1xuICAgICAgICAgICAgc3RhdGUuZG9jLm5vZGVzQmV0d2Vlbihmcm9tLCB0bywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChhcHBsaWNhYmxlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlLmlzVGV4dGJsb2NrIHx8IG5vZGUuaGFzTWFya3VwKG5vZGVUeXBlLCBhdHRycykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS50eXBlID09IG5vZGVUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcGxpY2FibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0ICRwb3MgPSBzdGF0ZS5kb2MucmVzb2x2ZShwb3MpLCBpbmRleCA9ICRwb3MuaW5kZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgYXBwbGljYWJsZSA9ICRwb3MucGFyZW50LmNhblJlcGxhY2VXaXRoKGluZGV4LCBpbmRleCArIDEsIG5vZGVUeXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFwcGxpY2FibGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChkaXNwYXRjaCkge1xuICAgICAgICAgICAgbGV0IHRyID0gc3RhdGUudHI7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRlLnNlbGVjdGlvbi5yYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgeyAkZnJvbTogeyBwb3M6IGZyb20gfSwgJHRvOiB7IHBvczogdG8gfSB9ID0gc3RhdGUuc2VsZWN0aW9uLnJhbmdlc1tpXTtcbiAgICAgICAgICAgICAgICB0ci5zZXRCbG9ja1R5cGUoZnJvbSwgdG8sIG5vZGVUeXBlLCBhdHRycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXNwYXRjaCh0ci5zY3JvbGxJbnRvVmlldygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuZnVuY3Rpb24gbWFya0FwcGxpZXMoZG9jLCByYW5nZXMsIHR5cGUsIGVudGVyQXRvbXMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSByYW5nZXNbaV07XG4gICAgICAgIGxldCBjYW4gPSAkZnJvbS5kZXB0aCA9PSAwID8gZG9jLmlubGluZUNvbnRlbnQgJiYgZG9jLnR5cGUuYWxsb3dzTWFya1R5cGUodHlwZSkgOiBmYWxzZTtcbiAgICAgICAgZG9jLm5vZGVzQmV0d2VlbigkZnJvbS5wb3MsICR0by5wb3MsIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgICAgIGlmIChjYW4gfHwgIWVudGVyQXRvbXMgJiYgbm9kZS5pc0F0b20gJiYgbm9kZS5pc0lubGluZSAmJiBwb3MgPj0gJGZyb20ucG9zICYmIHBvcyArIG5vZGUubm9kZVNpemUgPD0gJHRvLnBvcylcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjYW4gPSBub2RlLmlubGluZUNvbnRlbnQgJiYgbm9kZS50eXBlLmFsbG93c01hcmtUeXBlKHR5cGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNhbilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiByZW1vdmVJbmxpbmVBdG9tcyhyYW5nZXMpIHtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHsgJGZyb20sICR0byB9ID0gcmFuZ2VzW2ldO1xuICAgICAgICAkZnJvbS5kb2Mubm9kZXNCZXR3ZWVuKCRmcm9tLnBvcywgJHRvLnBvcywgKG5vZGUsIHBvcykgPT4ge1xuICAgICAgICAgICAgaWYgKG5vZGUuaXNBdG9tICYmIG5vZGUuY29udGVudC5zaXplICYmIG5vZGUuaXNJbmxpbmUgJiYgcG9zID49ICRmcm9tLnBvcyAmJiBwb3MgKyBub2RlLm5vZGVTaXplIDw9ICR0by5wb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAocG9zICsgMSA+ICRmcm9tLnBvcylcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IFNlbGVjdGlvblJhbmdlKCRmcm9tLCAkZnJvbS5kb2MucmVzb2x2ZShwb3MgKyAxKSkpO1xuICAgICAgICAgICAgICAgICRmcm9tID0gJGZyb20uZG9jLnJlc29sdmUocG9zICsgMSArIG5vZGUuY29udGVudC5zaXplKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoJGZyb20ucG9zIDwgJHRvLnBvcylcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBTZWxlY3Rpb25SYW5nZSgkZnJvbSwgJHRvKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbkNyZWF0ZSBhIGNvbW1hbmQgZnVuY3Rpb24gdGhhdCB0b2dnbGVzIHRoZSBnaXZlbiBtYXJrIHdpdGggdGhlXG5naXZlbiBhdHRyaWJ1dGVzLiBXaWxsIHJldHVybiBgZmFsc2VgIHdoZW4gdGhlIGN1cnJlbnQgc2VsZWN0aW9uXG5kb2Vzbid0IHN1cHBvcnQgdGhhdCBtYXJrLiBUaGlzIHdpbGwgcmVtb3ZlIHRoZSBtYXJrIGlmIGFueSBtYXJrc1xub2YgdGhhdCB0eXBlIGV4aXN0IGluIHRoZSBzZWxlY3Rpb24sIG9yIGFkZCBpdCBvdGhlcndpc2UuIElmIHRoZVxuc2VsZWN0aW9uIGlzIGVtcHR5LCB0aGlzIGFwcGxpZXMgdG8gdGhlIFtzdG9yZWRcbm1hcmtzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuc3RvcmVkTWFya3MpIGluc3RlYWQgb2YgYSByYW5nZSBvZiB0aGVcbmRvY3VtZW50LlxuKi9cbmZ1bmN0aW9uIHRvZ2dsZU1hcmsobWFya1R5cGUsIGF0dHJzID0gbnVsbCwgb3B0aW9ucykge1xuICAgIGxldCByZW1vdmVXaGVuUHJlc2VudCA9IChvcHRpb25zICYmIG9wdGlvbnMucmVtb3ZlV2hlblByZXNlbnQpICE9PSBmYWxzZTtcbiAgICBsZXQgZW50ZXJBdG9tcyA9IChvcHRpb25zICYmIG9wdGlvbnMuZW50ZXJJbmxpbmVBdG9tcykgIT09IGZhbHNlO1xuICAgIGxldCBkcm9wU3BhY2UgPSAhKG9wdGlvbnMgJiYgb3B0aW9ucy5pbmNsdWRlV2hpdGVzcGFjZSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IHsgZW1wdHksICRjdXJzb3IsIHJhbmdlcyB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBpZiAoKGVtcHR5ICYmICEkY3Vyc29yKSB8fCAhbWFya0FwcGxpZXMoc3RhdGUuZG9jLCByYW5nZXMsIG1hcmtUeXBlLCBlbnRlckF0b21zKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICBpZiAoJGN1cnNvcikge1xuICAgICAgICAgICAgICAgIGlmIChtYXJrVHlwZS5pc0luU2V0KHN0YXRlLnN0b3JlZE1hcmtzIHx8ICRjdXJzb3IubWFya3MoKSkpXG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnJlbW92ZVN0b3JlZE1hcmsobWFya1R5cGUpKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLmFkZFN0b3JlZE1hcmsobWFya1R5cGUuY3JlYXRlKGF0dHJzKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGFkZCwgdHIgPSBzdGF0ZS50cjtcbiAgICAgICAgICAgICAgICBpZiAoIWVudGVyQXRvbXMpXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlcyA9IHJlbW92ZUlubGluZUF0b21zKHJhbmdlcyk7XG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZVdoZW5QcmVzZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZCA9ICFyYW5nZXMuc29tZShyID0+IHN0YXRlLmRvYy5yYW5nZUhhc01hcmsoci4kZnJvbS5wb3MsIHIuJHRvLnBvcywgbWFya1R5cGUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZCA9ICFyYW5nZXMuZXZlcnkociA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbWlzc2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHIuZG9jLm5vZGVzQmV0d2VlbihyLiRmcm9tLnBvcywgci4kdG8ucG9zLCAobm9kZSwgcG9zLCBwYXJlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWlzc2luZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pc3NpbmcgPSAhbWFya1R5cGUuaXNJblNldChub2RlLm1hcmtzKSAmJiAhIXBhcmVudCAmJiBwYXJlbnQudHlwZS5hbGxvd3NNYXJrVHlwZShtYXJrVHlwZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIShub2RlLmlzVGV4dCAmJiAvXlxccyokLy50ZXN0KG5vZGUudGV4dEJldHdlZW4oTWF0aC5tYXgoMCwgci4kZnJvbS5wb3MgLSBwb3MpLCBNYXRoLm1pbihub2RlLm5vZGVTaXplLCByLiR0by5wb3MgLSBwb3MpKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIW1pc3Npbmc7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSByYW5nZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghYWRkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ci5yZW1vdmVNYXJrKCRmcm9tLnBvcywgJHRvLnBvcywgbWFya1R5cGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZyb20gPSAkZnJvbS5wb3MsIHRvID0gJHRvLnBvcywgc3RhcnQgPSAkZnJvbS5ub2RlQWZ0ZXIsIGVuZCA9ICR0by5ub2RlQmVmb3JlO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHNwYWNlU3RhcnQgPSBkcm9wU3BhY2UgJiYgc3RhcnQgJiYgc3RhcnQuaXNUZXh0ID8gL15cXHMqLy5leGVjKHN0YXJ0LnRleHQpWzBdLmxlbmd0aCA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc3BhY2VFbmQgPSBkcm9wU3BhY2UgJiYgZW5kICYmIGVuZC5pc1RleHQgPyAvXFxzKiQvLmV4ZWMoZW5kLnRleHQpWzBdLmxlbmd0aCA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJvbSArIHNwYWNlU3RhcnQgPCB0bykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gKz0gc3BhY2VTdGFydDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byAtPSBzcGFjZUVuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRyLmFkZE1hcmsoZnJvbSwgdG8sIG1hcmtUeXBlLmNyZWF0ZShhdHRycykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG5mdW5jdGlvbiB3cmFwRGlzcGF0Y2hGb3JKb2luKGRpc3BhdGNoLCBpc0pvaW5hYmxlKSB7XG4gICAgcmV0dXJuICh0cikgPT4ge1xuICAgICAgICBpZiAoIXRyLmlzR2VuZXJpYylcbiAgICAgICAgICAgIHJldHVybiBkaXNwYXRjaCh0cik7XG4gICAgICAgIGxldCByYW5nZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ci5tYXBwaW5nLm1hcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBtYXAgPSB0ci5tYXBwaW5nLm1hcHNbaV07XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHJhbmdlcy5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICByYW5nZXNbal0gPSBtYXAubWFwKHJhbmdlc1tqXSk7XG4gICAgICAgICAgICBtYXAuZm9yRWFjaCgoX3MsIF9lLCBmcm9tLCB0bykgPT4gcmFuZ2VzLnB1c2goZnJvbSwgdG8pKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaWd1cmUgb3V0IHdoaWNoIGpvaW5hYmxlIHBvaW50cyBleGlzdCBpbnNpZGUgdGhvc2UgcmFuZ2VzLFxuICAgICAgICAvLyBieSBjaGVja2luZyBhbGwgbm9kZSBib3VuZGFyaWVzIGluIHRoZWlyIHBhcmVudCBub2Rlcy5cbiAgICAgICAgbGV0IGpvaW5hYmxlID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IHJhbmdlc1tpXSwgdG8gPSByYW5nZXNbaSArIDFdO1xuICAgICAgICAgICAgbGV0ICRmcm9tID0gdHIuZG9jLnJlc29sdmUoZnJvbSksIGRlcHRoID0gJGZyb20uc2hhcmVkRGVwdGgodG8pLCBwYXJlbnQgPSAkZnJvbS5ub2RlKGRlcHRoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gJGZyb20uaW5kZXhBZnRlcihkZXB0aCksIHBvcyA9ICRmcm9tLmFmdGVyKGRlcHRoICsgMSk7IHBvcyA8PSB0bzsgKytpbmRleCkge1xuICAgICAgICAgICAgICAgIGxldCBhZnRlciA9IHBhcmVudC5tYXliZUNoaWxkKGluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoIWFmdGVyKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggJiYgam9pbmFibGUuaW5kZXhPZihwb3MpID09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBiZWZvcmUgPSBwYXJlbnQuY2hpbGQoaW5kZXggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJlZm9yZS50eXBlID09IGFmdGVyLnR5cGUgJiYgaXNKb2luYWJsZShiZWZvcmUsIGFmdGVyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGpvaW5hYmxlLnB1c2gocG9zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9zICs9IGFmdGVyLm5vZGVTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEpvaW4gdGhlIGpvaW5hYmxlIHBvaW50c1xuICAgICAgICBqb2luYWJsZS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gICAgICAgIGZvciAobGV0IGkgPSBqb2luYWJsZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKGNhbkpvaW4odHIuZG9jLCBqb2luYWJsZVtpXSkpXG4gICAgICAgICAgICAgICAgdHIuam9pbihqb2luYWJsZVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZGlzcGF0Y2godHIpO1xuICAgIH07XG59XG4vKipcbldyYXAgYSBjb21tYW5kIHNvIHRoYXQsIHdoZW4gaXQgcHJvZHVjZXMgYSB0cmFuc2Zvcm0gdGhhdCBjYXVzZXNcbnR3byBqb2luYWJsZSBub2RlcyB0byBlbmQgdXAgbmV4dCB0byBlYWNoIG90aGVyLCB0aG9zZSBhcmUgam9pbmVkLlxuTm9kZXMgYXJlIGNvbnNpZGVyZWQgam9pbmFibGUgd2hlbiB0aGV5IGFyZSBvZiB0aGUgc2FtZSB0eXBlIGFuZFxud2hlbiB0aGUgYGlzSm9pbmFibGVgIHByZWRpY2F0ZSByZXR1cm5zIHRydWUgZm9yIHRoZW0gb3IsIGlmIGFuXG5hcnJheSBvZiBzdHJpbmdzIHdhcyBwYXNzZWQsIGlmIHRoZWlyIG5vZGUgdHlwZSBuYW1lIGlzIGluIHRoYXRcbmFycmF5LlxuKi9cbmZ1bmN0aW9uIGF1dG9Kb2luKGNvbW1hbmQsIGlzSm9pbmFibGUpIHtcbiAgICBsZXQgY2FuSm9pbiA9IEFycmF5LmlzQXJyYXkoaXNKb2luYWJsZSkgPyAobm9kZSkgPT4gaXNKb2luYWJsZS5pbmRleE9mKG5vZGUudHlwZS5uYW1lKSA+IC0xXG4gICAgICAgIDogaXNKb2luYWJsZTtcbiAgICByZXR1cm4gKHN0YXRlLCBkaXNwYXRjaCwgdmlldykgPT4gY29tbWFuZChzdGF0ZSwgZGlzcGF0Y2ggJiYgd3JhcERpc3BhdGNoRm9ySm9pbihkaXNwYXRjaCwgY2FuSm9pbiksIHZpZXcpO1xufVxuLyoqXG5Db21iaW5lIGEgbnVtYmVyIG9mIGNvbW1hbmQgZnVuY3Rpb25zIGludG8gYSBzaW5nbGUgZnVuY3Rpb24gKHdoaWNoXG5jYWxscyB0aGVtIG9uZSBieSBvbmUgdW50aWwgb25lIHJldHVybnMgdHJ1ZSkuXG4qL1xuZnVuY3Rpb24gY2hhaW5Db21tYW5kcyguLi5jb21tYW5kcykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29tbWFuZHMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoY29tbWFuZHNbaV0oc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG59XG5sZXQgYmFja3NwYWNlID0gY2hhaW5Db21tYW5kcyhkZWxldGVTZWxlY3Rpb24sIGpvaW5CYWNrd2FyZCwgc2VsZWN0Tm9kZUJhY2t3YXJkKTtcbmxldCBkZWwgPSBjaGFpbkNvbW1hbmRzKGRlbGV0ZVNlbGVjdGlvbiwgam9pbkZvcndhcmQsIHNlbGVjdE5vZGVGb3J3YXJkKTtcbi8qKlxuQSBiYXNpYyBrZXltYXAgY29udGFpbmluZyBiaW5kaW5ncyBub3Qgc3BlY2lmaWMgdG8gYW55IHNjaGVtYS5cbkJpbmRzIHRoZSBmb2xsb3dpbmcga2V5cyAod2hlbiBtdWx0aXBsZSBjb21tYW5kcyBhcmUgbGlzdGVkLCB0aGV5XG5hcmUgY2hhaW5lZCB3aXRoIFtgY2hhaW5Db21tYW5kc2BdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNjb21tYW5kcy5jaGFpbkNvbW1hbmRzKSk6XG5cbiogKipFbnRlcioqIHRvIGBuZXdsaW5lSW5Db2RlYCwgYGNyZWF0ZVBhcmFncmFwaE5lYXJgLCBgbGlmdEVtcHR5QmxvY2tgLCBgc3BsaXRCbG9ja2BcbiogKipNb2QtRW50ZXIqKiB0byBgZXhpdENvZGVgXG4qICoqQmFja3NwYWNlKiogYW5kICoqTW9kLUJhY2tzcGFjZSoqIHRvIGBkZWxldGVTZWxlY3Rpb25gLCBgam9pbkJhY2t3YXJkYCwgYHNlbGVjdE5vZGVCYWNrd2FyZGBcbiogKipEZWxldGUqKiBhbmQgKipNb2QtRGVsZXRlKiogdG8gYGRlbGV0ZVNlbGVjdGlvbmAsIGBqb2luRm9yd2FyZGAsIGBzZWxlY3ROb2RlRm9yd2FyZGBcbiogKipNb2QtRGVsZXRlKiogdG8gYGRlbGV0ZVNlbGVjdGlvbmAsIGBqb2luRm9yd2FyZGAsIGBzZWxlY3ROb2RlRm9yd2FyZGBcbiogKipNb2QtYSoqIHRvIGBzZWxlY3RBbGxgXG4qL1xuY29uc3QgcGNCYXNlS2V5bWFwID0ge1xuICAgIFwiRW50ZXJcIjogY2hhaW5Db21tYW5kcyhuZXdsaW5lSW5Db2RlLCBjcmVhdGVQYXJhZ3JhcGhOZWFyLCBsaWZ0RW1wdHlCbG9jaywgc3BsaXRCbG9jayksXG4gICAgXCJNb2QtRW50ZXJcIjogZXhpdENvZGUsXG4gICAgXCJCYWNrc3BhY2VcIjogYmFja3NwYWNlLFxuICAgIFwiTW9kLUJhY2tzcGFjZVwiOiBiYWNrc3BhY2UsXG4gICAgXCJTaGlmdC1CYWNrc3BhY2VcIjogYmFja3NwYWNlLFxuICAgIFwiRGVsZXRlXCI6IGRlbCxcbiAgICBcIk1vZC1EZWxldGVcIjogZGVsLFxuICAgIFwiTW9kLWFcIjogc2VsZWN0QWxsXG59O1xuLyoqXG5BIGNvcHkgb2YgYHBjQmFzZUtleW1hcGAgdGhhdCBhbHNvIGJpbmRzICoqQ3RybC1oKiogbGlrZSBCYWNrc3BhY2UsXG4qKkN0cmwtZCoqIGxpa2UgRGVsZXRlLCAqKkFsdC1CYWNrc3BhY2UqKiBsaWtlIEN0cmwtQmFja3NwYWNlLCBhbmRcbioqQ3RybC1BbHQtQmFja3NwYWNlKiosICoqQWx0LURlbGV0ZSoqLCBhbmQgKipBbHQtZCoqIGxpa2VcbkN0cmwtRGVsZXRlLlxuKi9cbmNvbnN0IG1hY0Jhc2VLZXltYXAgPSB7XG4gICAgXCJDdHJsLWhcIjogcGNCYXNlS2V5bWFwW1wiQmFja3NwYWNlXCJdLFxuICAgIFwiQWx0LUJhY2tzcGFjZVwiOiBwY0Jhc2VLZXltYXBbXCJNb2QtQmFja3NwYWNlXCJdLFxuICAgIFwiQ3RybC1kXCI6IHBjQmFzZUtleW1hcFtcIkRlbGV0ZVwiXSxcbiAgICBcIkN0cmwtQWx0LUJhY2tzcGFjZVwiOiBwY0Jhc2VLZXltYXBbXCJNb2QtRGVsZXRlXCJdLFxuICAgIFwiQWx0LURlbGV0ZVwiOiBwY0Jhc2VLZXltYXBbXCJNb2QtRGVsZXRlXCJdLFxuICAgIFwiQWx0LWRcIjogcGNCYXNlS2V5bWFwW1wiTW9kLURlbGV0ZVwiXSxcbiAgICBcIkN0cmwtYVwiOiBzZWxlY3RUZXh0YmxvY2tTdGFydCxcbiAgICBcIkN0cmwtZVwiOiBzZWxlY3RUZXh0YmxvY2tFbmRcbn07XG5mb3IgKGxldCBrZXkgaW4gcGNCYXNlS2V5bWFwKVxuICAgIG1hY0Jhc2VLZXltYXBba2V5XSA9IHBjQmFzZUtleW1hcFtrZXldO1xuY29uc3QgbWFjID0gdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiID8gL01hY3xpUChob25lfFtvYV1kKS8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIDogdHlwZW9mIG9zICE9IFwidW5kZWZpbmVkXCIgJiYgb3MucGxhdGZvcm0gPyBvcy5wbGF0Zm9ybSgpID09IFwiZGFyd2luXCIgOiBmYWxzZTtcbi8qKlxuRGVwZW5kaW5nIG9uIHRoZSBkZXRlY3RlZCBwbGF0Zm9ybSwgdGhpcyB3aWxsIGhvbGRcbltgcGNCYXNla2V5bWFwYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI2NvbW1hbmRzLnBjQmFzZUtleW1hcCkgb3JcbltgbWFjQmFzZUtleW1hcGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNjb21tYW5kcy5tYWNCYXNlS2V5bWFwKS5cbiovXG5jb25zdCBiYXNlS2V5bWFwID0gbWFjID8gbWFjQmFzZUtleW1hcCA6IHBjQmFzZUtleW1hcDtcblxuZXhwb3J0IHsgYXV0b0pvaW4sIGJhc2VLZXltYXAsIGNoYWluQ29tbWFuZHMsIGNyZWF0ZVBhcmFncmFwaE5lYXIsIGRlbGV0ZVNlbGVjdGlvbiwgZXhpdENvZGUsIGpvaW5CYWNrd2FyZCwgam9pbkRvd24sIGpvaW5Gb3J3YXJkLCBqb2luVGV4dGJsb2NrQmFja3dhcmQsIGpvaW5UZXh0YmxvY2tGb3J3YXJkLCBqb2luVXAsIGxpZnQsIGxpZnRFbXB0eUJsb2NrLCBtYWNCYXNlS2V5bWFwLCBuZXdsaW5lSW5Db2RlLCBwY0Jhc2VLZXltYXAsIHNlbGVjdEFsbCwgc2VsZWN0Tm9kZUJhY2t3YXJkLCBzZWxlY3ROb2RlRm9yd2FyZCwgc2VsZWN0UGFyZW50Tm9kZSwgc2VsZWN0VGV4dGJsb2NrRW5kLCBzZWxlY3RUZXh0YmxvY2tTdGFydCwgc2V0QmxvY2tUeXBlLCBzcGxpdEJsb2NrLCBzcGxpdEJsb2NrQXMsIHNwbGl0QmxvY2tLZWVwTWFya3MsIHRvZ2dsZU1hcmssIHdyYXBJbiB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prosemirror-commands/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prosemirror-dropcursor/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/prosemirror-dropcursor/dist/index.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   dropCursor: function() { return /* binding */ dropCursor; }\n/* harmony export */ });\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-state */ \"(app-pages-browser)/./node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-transform */ \"(app-pages-browser)/./node_modules/prosemirror-transform/dist/index.js\");\n\n\n\n/**\nCreate a plugin that, when added to a ProseMirror instance,\ncauses a decoration to show up at the drop position when something\nis dragged over the editor.\n\nNodes may add a `disableDropCursor` property to their spec to\ncontrol the showing of a drop cursor inside them. This may be a\nboolean or a function, which will be called with a view and a\nposition, and should return a boolean.\n*/\nfunction dropCursor(options = {}) {\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        view(editorView) { return new DropCursorView(editorView, options); }\n    });\n}\nclass DropCursorView {\n    constructor(editorView, options) {\n        var _a;\n        this.editorView = editorView;\n        this.cursorPos = null;\n        this.element = null;\n        this.timeout = -1;\n        this.width = (_a = options.width) !== null && _a !== void 0 ? _a : 1;\n        this.color = options.color === false ? undefined : (options.color || \"black\");\n        this.class = options.class;\n        this.handlers = [\"dragover\", \"dragend\", \"drop\", \"dragleave\"].map(name => {\n            let handler = (e) => { this[name](e); };\n            editorView.dom.addEventListener(name, handler);\n            return { name, handler };\n        });\n    }\n    destroy() {\n        this.handlers.forEach(({ name, handler }) => this.editorView.dom.removeEventListener(name, handler));\n    }\n    update(editorView, prevState) {\n        if (this.cursorPos != null && prevState.doc != editorView.state.doc) {\n            if (this.cursorPos > editorView.state.doc.content.size)\n                this.setCursor(null);\n            else\n                this.updateOverlay();\n        }\n    }\n    setCursor(pos) {\n        if (pos == this.cursorPos)\n            return;\n        this.cursorPos = pos;\n        if (pos == null) {\n            this.element.parentNode.removeChild(this.element);\n            this.element = null;\n        }\n        else {\n            this.updateOverlay();\n        }\n    }\n    updateOverlay() {\n        let $pos = this.editorView.state.doc.resolve(this.cursorPos);\n        let isBlock = !$pos.parent.inlineContent, rect;\n        let editorDOM = this.editorView.dom, editorRect = editorDOM.getBoundingClientRect();\n        let scaleX = editorRect.width / editorDOM.offsetWidth, scaleY = editorRect.height / editorDOM.offsetHeight;\n        if (isBlock) {\n            let before = $pos.nodeBefore, after = $pos.nodeAfter;\n            if (before || after) {\n                let node = this.editorView.nodeDOM(this.cursorPos - (before ? before.nodeSize : 0));\n                if (node) {\n                    let nodeRect = node.getBoundingClientRect();\n                    let top = before ? nodeRect.bottom : nodeRect.top;\n                    if (before && after)\n                        top = (top + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2;\n                    let halfWidth = (this.width / 2) * scaleY;\n                    rect = { left: nodeRect.left, right: nodeRect.right, top: top - halfWidth, bottom: top + halfWidth };\n                }\n            }\n        }\n        if (!rect) {\n            let coords = this.editorView.coordsAtPos(this.cursorPos);\n            let halfWidth = (this.width / 2) * scaleX;\n            rect = { left: coords.left - halfWidth, right: coords.left + halfWidth, top: coords.top, bottom: coords.bottom };\n        }\n        let parent = this.editorView.dom.offsetParent;\n        if (!this.element) {\n            this.element = parent.appendChild(document.createElement(\"div\"));\n            if (this.class)\n                this.element.className = this.class;\n            this.element.style.cssText = \"position: absolute; z-index: 50; pointer-events: none;\";\n            if (this.color) {\n                this.element.style.backgroundColor = this.color;\n            }\n        }\n        this.element.classList.toggle(\"prosemirror-dropcursor-block\", isBlock);\n        this.element.classList.toggle(\"prosemirror-dropcursor-inline\", !isBlock);\n        let parentLeft, parentTop;\n        if (!parent || parent == document.body && getComputedStyle(parent).position == \"static\") {\n            parentLeft = -pageXOffset;\n            parentTop = -pageYOffset;\n        }\n        else {\n            let rect = parent.getBoundingClientRect();\n            let parentScaleX = rect.width / parent.offsetWidth, parentScaleY = rect.height / parent.offsetHeight;\n            parentLeft = rect.left - parent.scrollLeft * parentScaleX;\n            parentTop = rect.top - parent.scrollTop * parentScaleY;\n        }\n        this.element.style.left = (rect.left - parentLeft) / scaleX + \"px\";\n        this.element.style.top = (rect.top - parentTop) / scaleY + \"px\";\n        this.element.style.width = (rect.right - rect.left) / scaleX + \"px\";\n        this.element.style.height = (rect.bottom - rect.top) / scaleY + \"px\";\n    }\n    scheduleRemoval(timeout) {\n        clearTimeout(this.timeout);\n        this.timeout = setTimeout(() => this.setCursor(null), timeout);\n    }\n    dragover(event) {\n        if (!this.editorView.editable)\n            return;\n        let pos = this.editorView.posAtCoords({ left: event.clientX, top: event.clientY });\n        let node = pos && pos.inside >= 0 && this.editorView.state.doc.nodeAt(pos.inside);\n        let disableDropCursor = node && node.type.spec.disableDropCursor;\n        let disabled = typeof disableDropCursor == \"function\"\n            ? disableDropCursor(this.editorView, pos, event)\n            : disableDropCursor;\n        if (pos && !disabled) {\n            let target = pos.pos;\n            if (this.editorView.dragging && this.editorView.dragging.slice) {\n                let point = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.dropPoint)(this.editorView.state.doc, target, this.editorView.dragging.slice);\n                if (point != null)\n                    target = point;\n            }\n            this.setCursor(target);\n            this.scheduleRemoval(5000);\n        }\n    }\n    dragend() {\n        this.scheduleRemoval(20);\n    }\n    drop() {\n        this.scheduleRemoval(20);\n    }\n    dragleave(event) {\n        if (!this.editorView.dom.contains(event.relatedTarget))\n            this.setCursor(null);\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1kcm9wY3Vyc29yL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTJDO0FBQ087O0FBRWxEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsZUFBZSxxREFBTTtBQUNyQiwyQkFBMkI7QUFDM0IsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBLHFCQUFxQjtBQUNyQixTQUFTO0FBQ1Q7QUFDQTtBQUNBLGlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELGFBQWEscUJBQXFCO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QseUNBQXlDO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0VBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItZHJvcGN1cnNvci9kaXN0L2luZGV4LmpzPzI2MmUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUGx1Z2luIH0gZnJvbSAncHJvc2VtaXJyb3Itc3RhdGUnO1xuaW1wb3J0IHsgZHJvcFBvaW50IH0gZnJvbSAncHJvc2VtaXJyb3ItdHJhbnNmb3JtJztcblxuLyoqXG5DcmVhdGUgYSBwbHVnaW4gdGhhdCwgd2hlbiBhZGRlZCB0byBhIFByb3NlTWlycm9yIGluc3RhbmNlLFxuY2F1c2VzIGEgZGVjb3JhdGlvbiB0byBzaG93IHVwIGF0IHRoZSBkcm9wIHBvc2l0aW9uIHdoZW4gc29tZXRoaW5nXG5pcyBkcmFnZ2VkIG92ZXIgdGhlIGVkaXRvci5cblxuTm9kZXMgbWF5IGFkZCBhIGBkaXNhYmxlRHJvcEN1cnNvcmAgcHJvcGVydHkgdG8gdGhlaXIgc3BlYyB0b1xuY29udHJvbCB0aGUgc2hvd2luZyBvZiBhIGRyb3AgY3Vyc29yIGluc2lkZSB0aGVtLiBUaGlzIG1heSBiZSBhXG5ib29sZWFuIG9yIGEgZnVuY3Rpb24sIHdoaWNoIHdpbGwgYmUgY2FsbGVkIHdpdGggYSB2aWV3IGFuZCBhXG5wb3NpdGlvbiwgYW5kIHNob3VsZCByZXR1cm4gYSBib29sZWFuLlxuKi9cbmZ1bmN0aW9uIGRyb3BDdXJzb3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIG5ldyBQbHVnaW4oe1xuICAgICAgICB2aWV3KGVkaXRvclZpZXcpIHsgcmV0dXJuIG5ldyBEcm9wQ3Vyc29yVmlldyhlZGl0b3JWaWV3LCBvcHRpb25zKTsgfVxuICAgIH0pO1xufVxuY2xhc3MgRHJvcEN1cnNvclZpZXcge1xuICAgIGNvbnN0cnVjdG9yKGVkaXRvclZpZXcsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmVkaXRvclZpZXcgPSBlZGl0b3JWaWV3O1xuICAgICAgICB0aGlzLmN1cnNvclBvcyA9IG51bGw7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IG51bGw7XG4gICAgICAgIHRoaXMudGltZW91dCA9IC0xO1xuICAgICAgICB0aGlzLndpZHRoID0gKF9hID0gb3B0aW9ucy53aWR0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMTtcbiAgICAgICAgdGhpcy5jb2xvciA9IG9wdGlvbnMuY29sb3IgPT09IGZhbHNlID8gdW5kZWZpbmVkIDogKG9wdGlvbnMuY29sb3IgfHwgXCJibGFja1wiKTtcbiAgICAgICAgdGhpcy5jbGFzcyA9IG9wdGlvbnMuY2xhc3M7XG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSBbXCJkcmFnb3ZlclwiLCBcImRyYWdlbmRcIiwgXCJkcm9wXCIsIFwiZHJhZ2xlYXZlXCJdLm1hcChuYW1lID0+IHtcbiAgICAgICAgICAgIGxldCBoYW5kbGVyID0gKGUpID0+IHsgdGhpc1tuYW1lXShlKTsgfTtcbiAgICAgICAgICAgIGVkaXRvclZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlcik7XG4gICAgICAgICAgICByZXR1cm4geyBuYW1lLCBoYW5kbGVyIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmhhbmRsZXJzLmZvckVhY2goKHsgbmFtZSwgaGFuZGxlciB9KSA9PiB0aGlzLmVkaXRvclZpZXcuZG9tLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlcikpO1xuICAgIH1cbiAgICB1cGRhdGUoZWRpdG9yVmlldywgcHJldlN0YXRlKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnNvclBvcyAhPSBudWxsICYmIHByZXZTdGF0ZS5kb2MgIT0gZWRpdG9yVmlldy5zdGF0ZS5kb2MpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnNvclBvcyA+IGVkaXRvclZpZXcuc3RhdGUuZG9jLmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgICAgICAgICB0aGlzLnNldEN1cnNvcihudWxsKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZU92ZXJsYXkoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRDdXJzb3IocG9zKSB7XG4gICAgICAgIGlmIChwb3MgPT0gdGhpcy5jdXJzb3JQb3MpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuY3Vyc29yUG9zID0gcG9zO1xuICAgICAgICBpZiAocG9zID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVPdmVybGF5KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlT3ZlcmxheSgpIHtcbiAgICAgICAgbGV0ICRwb3MgPSB0aGlzLmVkaXRvclZpZXcuc3RhdGUuZG9jLnJlc29sdmUodGhpcy5jdXJzb3JQb3MpO1xuICAgICAgICBsZXQgaXNCbG9jayA9ICEkcG9zLnBhcmVudC5pbmxpbmVDb250ZW50LCByZWN0O1xuICAgICAgICBsZXQgZWRpdG9yRE9NID0gdGhpcy5lZGl0b3JWaWV3LmRvbSwgZWRpdG9yUmVjdCA9IGVkaXRvckRPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgbGV0IHNjYWxlWCA9IGVkaXRvclJlY3Qud2lkdGggLyBlZGl0b3JET00ub2Zmc2V0V2lkdGgsIHNjYWxlWSA9IGVkaXRvclJlY3QuaGVpZ2h0IC8gZWRpdG9yRE9NLm9mZnNldEhlaWdodDtcbiAgICAgICAgaWYgKGlzQmxvY2spIHtcbiAgICAgICAgICAgIGxldCBiZWZvcmUgPSAkcG9zLm5vZGVCZWZvcmUsIGFmdGVyID0gJHBvcy5ub2RlQWZ0ZXI7XG4gICAgICAgICAgICBpZiAoYmVmb3JlIHx8IGFmdGVyKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5vZGUgPSB0aGlzLmVkaXRvclZpZXcubm9kZURPTSh0aGlzLmN1cnNvclBvcyAtIChiZWZvcmUgPyBiZWZvcmUubm9kZVNpemUgOiAwKSk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5vZGVSZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRvcCA9IGJlZm9yZSA/IG5vZGVSZWN0LmJvdHRvbSA6IG5vZGVSZWN0LnRvcDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJlZm9yZSAmJiBhZnRlcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvcCA9ICh0b3AgKyB0aGlzLmVkaXRvclZpZXcubm9kZURPTSh0aGlzLmN1cnNvclBvcykuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wKSAvIDI7XG4gICAgICAgICAgICAgICAgICAgIGxldCBoYWxmV2lkdGggPSAodGhpcy53aWR0aCAvIDIpICogc2NhbGVZO1xuICAgICAgICAgICAgICAgICAgICByZWN0ID0geyBsZWZ0OiBub2RlUmVjdC5sZWZ0LCByaWdodDogbm9kZVJlY3QucmlnaHQsIHRvcDogdG9wIC0gaGFsZldpZHRoLCBib3R0b206IHRvcCArIGhhbGZXaWR0aCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlY3QpIHtcbiAgICAgICAgICAgIGxldCBjb29yZHMgPSB0aGlzLmVkaXRvclZpZXcuY29vcmRzQXRQb3ModGhpcy5jdXJzb3JQb3MpO1xuICAgICAgICAgICAgbGV0IGhhbGZXaWR0aCA9ICh0aGlzLndpZHRoIC8gMikgKiBzY2FsZVg7XG4gICAgICAgICAgICByZWN0ID0geyBsZWZ0OiBjb29yZHMubGVmdCAtIGhhbGZXaWR0aCwgcmlnaHQ6IGNvb3Jkcy5sZWZ0ICsgaGFsZldpZHRoLCB0b3A6IGNvb3Jkcy50b3AsIGJvdHRvbTogY29vcmRzLmJvdHRvbSB9O1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLmVkaXRvclZpZXcuZG9tLm9mZnNldFBhcmVudDtcbiAgICAgICAgaWYgKCF0aGlzLmVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudCA9IHBhcmVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNsYXNzKVxuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5jbGFzc05hbWUgPSB0aGlzLmNsYXNzO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOiBhYnNvbHV0ZTsgei1pbmRleDogNTA7IHBvaW50ZXItZXZlbnRzOiBub25lO1wiO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29sb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdGhpcy5jb2xvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnRvZ2dsZShcInByb3NlbWlycm9yLWRyb3BjdXJzb3ItYmxvY2tcIiwgaXNCbG9jayk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKFwicHJvc2VtaXJyb3ItZHJvcGN1cnNvci1pbmxpbmVcIiwgIWlzQmxvY2spO1xuICAgICAgICBsZXQgcGFyZW50TGVmdCwgcGFyZW50VG9wO1xuICAgICAgICBpZiAoIXBhcmVudCB8fCBwYXJlbnQgPT0gZG9jdW1lbnQuYm9keSAmJiBnZXRDb21wdXRlZFN0eWxlKHBhcmVudCkucG9zaXRpb24gPT0gXCJzdGF0aWNcIikge1xuICAgICAgICAgICAgcGFyZW50TGVmdCA9IC1wYWdlWE9mZnNldDtcbiAgICAgICAgICAgIHBhcmVudFRvcCA9IC1wYWdlWU9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCByZWN0ID0gcGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgbGV0IHBhcmVudFNjYWxlWCA9IHJlY3Qud2lkdGggLyBwYXJlbnQub2Zmc2V0V2lkdGgsIHBhcmVudFNjYWxlWSA9IHJlY3QuaGVpZ2h0IC8gcGFyZW50Lm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgIHBhcmVudExlZnQgPSByZWN0LmxlZnQgLSBwYXJlbnQuc2Nyb2xsTGVmdCAqIHBhcmVudFNjYWxlWDtcbiAgICAgICAgICAgIHBhcmVudFRvcCA9IHJlY3QudG9wIC0gcGFyZW50LnNjcm9sbFRvcCAqIHBhcmVudFNjYWxlWTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVsZW1lbnQuc3R5bGUubGVmdCA9IChyZWN0LmxlZnQgLSBwYXJlbnRMZWZ0KSAvIHNjYWxlWCArIFwicHhcIjtcbiAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLnRvcCA9IChyZWN0LnRvcCAtIHBhcmVudFRvcCkgLyBzY2FsZVkgKyBcInB4XCI7XG4gICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS53aWR0aCA9IChyZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0KSAvIHNjYWxlWCArIFwicHhcIjtcbiAgICAgICAgdGhpcy5lbGVtZW50LnN0eWxlLmhlaWdodCA9IChyZWN0LmJvdHRvbSAtIHJlY3QudG9wKSAvIHNjYWxlWSArIFwicHhcIjtcbiAgICB9XG4gICAgc2NoZWR1bGVSZW1vdmFsKHRpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dCk7XG4gICAgICAgIHRoaXMudGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zZXRDdXJzb3IobnVsbCksIHRpbWVvdXQpO1xuICAgIH1cbiAgICBkcmFnb3ZlcihldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMuZWRpdG9yVmlldy5lZGl0YWJsZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMuZWRpdG9yVmlldy5wb3NBdENvb3Jkcyh7IGxlZnQ6IGV2ZW50LmNsaWVudFgsIHRvcDogZXZlbnQuY2xpZW50WSB9KTtcbiAgICAgICAgbGV0IG5vZGUgPSBwb3MgJiYgcG9zLmluc2lkZSA+PSAwICYmIHRoaXMuZWRpdG9yVmlldy5zdGF0ZS5kb2Mubm9kZUF0KHBvcy5pbnNpZGUpO1xuICAgICAgICBsZXQgZGlzYWJsZURyb3BDdXJzb3IgPSBub2RlICYmIG5vZGUudHlwZS5zcGVjLmRpc2FibGVEcm9wQ3Vyc29yO1xuICAgICAgICBsZXQgZGlzYWJsZWQgPSB0eXBlb2YgZGlzYWJsZURyb3BDdXJzb3IgPT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICA/IGRpc2FibGVEcm9wQ3Vyc29yKHRoaXMuZWRpdG9yVmlldywgcG9zLCBldmVudClcbiAgICAgICAgICAgIDogZGlzYWJsZURyb3BDdXJzb3I7XG4gICAgICAgIGlmIChwb3MgJiYgIWRpc2FibGVkKSB7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gcG9zLnBvcztcbiAgICAgICAgICAgIGlmICh0aGlzLmVkaXRvclZpZXcuZHJhZ2dpbmcgJiYgdGhpcy5lZGl0b3JWaWV3LmRyYWdnaW5nLnNsaWNlKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBvaW50ID0gZHJvcFBvaW50KHRoaXMuZWRpdG9yVmlldy5zdGF0ZS5kb2MsIHRhcmdldCwgdGhpcy5lZGl0b3JWaWV3LmRyYWdnaW5nLnNsaWNlKTtcbiAgICAgICAgICAgICAgICBpZiAocG9pbnQgIT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gcG9pbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldEN1cnNvcih0YXJnZXQpO1xuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVJlbW92YWwoNTAwMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZHJhZ2VuZCgpIHtcbiAgICAgICAgdGhpcy5zY2hlZHVsZVJlbW92YWwoMjApO1xuICAgIH1cbiAgICBkcm9wKCkge1xuICAgICAgICB0aGlzLnNjaGVkdWxlUmVtb3ZhbCgyMCk7XG4gICAgfVxuICAgIGRyYWdsZWF2ZShldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMuZWRpdG9yVmlldy5kb20uY29udGFpbnMoZXZlbnQucmVsYXRlZFRhcmdldCkpXG4gICAgICAgICAgICB0aGlzLnNldEN1cnNvcihudWxsKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IGRyb3BDdXJzb3IgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prosemirror-dropcursor/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prosemirror-gapcursor/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/prosemirror-gapcursor/dist/index.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GapCursor: function() { return /* binding */ GapCursor; },\n/* harmony export */   gapCursor: function() { return /* binding */ gapCursor; }\n/* harmony export */ });\n/* harmony import */ var prosemirror_keymap__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-keymap */ \"(app-pages-browser)/./node_modules/prosemirror-keymap/dist/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-state */ \"(app-pages-browser)/./node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-model */ \"(app-pages-browser)/./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var prosemirror_view__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prosemirror-view */ \"(app-pages-browser)/./node_modules/prosemirror-view/dist/index.js\");\n\n\n\n\n\n/**\nGap cursor selections are represented using this class. Its\n`$anchor` and `$head` properties both point at the cursor position.\n*/\nclass GapCursor extends prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection {\n    /**\n    Create a gap cursor.\n    */\n    constructor($pos) {\n        super($pos, $pos);\n    }\n    map(doc, mapping) {\n        let $pos = doc.resolve(mapping.map(this.head));\n        return GapCursor.valid($pos) ? new GapCursor($pos) : prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near($pos);\n    }\n    content() { return prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice.empty; }\n    eq(other) {\n        return other instanceof GapCursor && other.head == this.head;\n    }\n    toJSON() {\n        return { type: \"gapcursor\", pos: this.head };\n    }\n    /**\n    @internal\n    */\n    static fromJSON(doc, json) {\n        if (typeof json.pos != \"number\")\n            throw new RangeError(\"Invalid input for GapCursor.fromJSON\");\n        return new GapCursor(doc.resolve(json.pos));\n    }\n    /**\n    @internal\n    */\n    getBookmark() { return new GapBookmark(this.anchor); }\n    /**\n    @internal\n    */\n    static valid($pos) {\n        let parent = $pos.parent;\n        if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos))\n            return false;\n        let override = parent.type.spec.allowGapCursor;\n        if (override != null)\n            return override;\n        let deflt = parent.contentMatchAt($pos.index()).defaultType;\n        return deflt && deflt.isTextblock;\n    }\n    /**\n    @internal\n    */\n    static findGapCursorFrom($pos, dir, mustMove = false) {\n        search: for (;;) {\n            if (!mustMove && GapCursor.valid($pos))\n                return $pos;\n            let pos = $pos.pos, next = null;\n            // Scan up from this position\n            for (let d = $pos.depth;; d--) {\n                let parent = $pos.node(d);\n                if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {\n                    next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);\n                    break;\n                }\n                else if (d == 0) {\n                    return null;\n                }\n                pos += dir;\n                let $cur = $pos.doc.resolve(pos);\n                if (GapCursor.valid($cur))\n                    return $cur;\n            }\n            // And then down into the next node\n            for (;;) {\n                let inside = dir > 0 ? next.firstChild : next.lastChild;\n                if (!inside) {\n                    if (next.isAtom && !next.isText && !prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.isSelectable(next)) {\n                        $pos = $pos.doc.resolve(pos + next.nodeSize * dir);\n                        mustMove = false;\n                        continue search;\n                    }\n                    break;\n                }\n                next = inside;\n                pos += dir;\n                let $cur = $pos.doc.resolve(pos);\n                if (GapCursor.valid($cur))\n                    return $cur;\n            }\n            return null;\n        }\n    }\n}\nGapCursor.prototype.visible = false;\nGapCursor.findFrom = GapCursor.findGapCursorFrom;\nprosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.jsonID(\"gapcursor\", GapCursor);\nclass GapBookmark {\n    constructor(pos) {\n        this.pos = pos;\n    }\n    map(mapping) {\n        return new GapBookmark(mapping.map(this.pos));\n    }\n    resolve(doc) {\n        let $pos = doc.resolve(this.pos);\n        return GapCursor.valid($pos) ? new GapCursor($pos) : prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Selection.near($pos);\n    }\n}\nfunction needsGap(type) {\n    return type.isAtom || type.spec.isolating || type.spec.createGapCursor;\n}\nfunction closedBefore($pos) {\n    for (let d = $pos.depth; d >= 0; d--) {\n        let index = $pos.index(d), parent = $pos.node(d);\n        // At the start of this parent, look at next one\n        if (index == 0) {\n            if (parent.type.spec.isolating)\n                return true;\n            continue;\n        }\n        // See if the node before (or its first ancestor) is closed\n        for (let before = parent.child(index - 1);; before = before.lastChild) {\n            if ((before.childCount == 0 && !before.inlineContent) || needsGap(before.type))\n                return true;\n            if (before.inlineContent)\n                return false;\n        }\n    }\n    // Hit start of document\n    return true;\n}\nfunction closedAfter($pos) {\n    for (let d = $pos.depth; d >= 0; d--) {\n        let index = $pos.indexAfter(d), parent = $pos.node(d);\n        if (index == parent.childCount) {\n            if (parent.type.spec.isolating)\n                return true;\n            continue;\n        }\n        for (let after = parent.child(index);; after = after.firstChild) {\n            if ((after.childCount == 0 && !after.inlineContent) || needsGap(after.type))\n                return true;\n            if (after.inlineContent)\n                return false;\n        }\n    }\n    return true;\n}\n\n/**\nCreate a gap cursor plugin. When enabled, this will capture clicks\nnear and arrow-key-motion past places that don't have a normally\nselectable position nearby, and create a gap cursor selection for\nthem. The cursor is drawn as an element with class\n`ProseMirror-gapcursor`. You can either include\n`style/gapcursor.css` from the package's directory or add your own\nstyles to make it visible.\n*/\nfunction gapCursor() {\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.Plugin({\n        props: {\n            decorations: drawGapCursor,\n            createSelectionBetween(_view, $anchor, $head) {\n                return $anchor.pos == $head.pos && GapCursor.valid($head) ? new GapCursor($head) : null;\n            },\n            handleClick,\n            handleKeyDown,\n            handleDOMEvents: { beforeinput: beforeinput }\n        }\n    });\n}\nconst handleKeyDown = (0,prosemirror_keymap__WEBPACK_IMPORTED_MODULE_2__.keydownHandler)({\n    \"ArrowLeft\": arrow(\"horiz\", -1),\n    \"ArrowRight\": arrow(\"horiz\", 1),\n    \"ArrowUp\": arrow(\"vert\", -1),\n    \"ArrowDown\": arrow(\"vert\", 1)\n});\nfunction arrow(axis, dir) {\n    const dirStr = axis == \"vert\" ? (dir > 0 ? \"down\" : \"up\") : (dir > 0 ? \"right\" : \"left\");\n    return function (state, dispatch, view) {\n        let sel = state.selection;\n        let $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;\n        if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection) {\n            if (!view.endOfTextblock(dirStr) || $start.depth == 0)\n                return false;\n            mustMove = false;\n            $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());\n        }\n        let $found = GapCursor.findGapCursorFrom($start, dir, mustMove);\n        if (!$found)\n            return false;\n        if (dispatch)\n            dispatch(state.tr.setSelection(new GapCursor($found)));\n        return true;\n    };\n}\nfunction handleClick(view, pos, event) {\n    if (!view || !view.editable)\n        return false;\n    let $pos = view.state.doc.resolve(pos);\n    if (!GapCursor.valid($pos))\n        return false;\n    let clickPos = view.posAtCoords({ left: event.clientX, top: event.clientY });\n    if (clickPos && clickPos.inside > -1 && prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.NodeSelection.isSelectable(view.state.doc.nodeAt(clickPos.inside)))\n        return false;\n    view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));\n    return true;\n}\n// This is a hack that, when a composition starts while a gap cursor\n// is active, quickly creates an inline context for the composition to\n// happen in, to avoid it being aborted by the DOM selection being\n// moved into a valid position.\nfunction beforeinput(view, event) {\n    if (event.inputType != \"insertCompositionText\" || !(view.state.selection instanceof GapCursor))\n        return false;\n    let { $from } = view.state.selection;\n    let insert = $from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);\n    if (!insert)\n        return false;\n    let frag = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.empty;\n    for (let i = insert.length - 1; i >= 0; i--)\n        frag = prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Fragment.from(insert[i].createAndFill(null, frag));\n    let tr = view.state.tr.replace($from.pos, $from.pos, new prosemirror_model__WEBPACK_IMPORTED_MODULE_1__.Slice(frag, 0, 0));\n    tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_0__.TextSelection.near(tr.doc.resolve($from.pos + 1)));\n    view.dispatch(tr);\n    return false;\n}\nfunction drawGapCursor(state) {\n    if (!(state.selection instanceof GapCursor))\n        return null;\n    let node = document.createElement(\"div\");\n    node.className = \"ProseMirror-gapcursor\";\n    return prosemirror_view__WEBPACK_IMPORTED_MODULE_3__.DecorationSet.create(state.doc, [prosemirror_view__WEBPACK_IMPORTED_MODULE_3__.Decoration.widget(state.selection.head, node, { key: \"gapcursor\" })]);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1nYXBjdXJzb3IvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBb0Q7QUFDZ0M7QUFDaEM7QUFDUzs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isd0RBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCx3REFBUztBQUN0RTtBQUNBLGdCQUFnQixPQUFPLG9EQUFLO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLHdEQUF3RCw0REFBYTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCx3REFBUztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsUUFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFFBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFEQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQSxLQUFLO0FBQ0w7QUFDQSxzQkFBc0Isa0VBQWM7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw0REFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyx5Q0FBeUM7QUFDL0UsNENBQTRDLDREQUFhO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsZUFBZSx1REFBUTtBQUN2QixvQ0FBb0MsUUFBUTtBQUM1QyxlQUFlLHVEQUFRO0FBQ3ZCLDZEQUE2RCxvREFBSztBQUNsRSxvQkFBb0IsNERBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMkRBQWEsb0JBQW9CLHdEQUFVLHNDQUFzQyxrQkFBa0I7QUFDOUc7O0FBRWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1nYXBjdXJzb3IvZGlzdC9pbmRleC5qcz9jOGNhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGtleWRvd25IYW5kbGVyIH0gZnJvbSAncHJvc2VtaXJyb3Ita2V5bWFwJztcbmltcG9ydCB7IFNlbGVjdGlvbiwgTm9kZVNlbGVjdGlvbiwgVGV4dFNlbGVjdGlvbiwgUGx1Z2luIH0gZnJvbSAncHJvc2VtaXJyb3Itc3RhdGUnO1xuaW1wb3J0IHsgU2xpY2UsIEZyYWdtZW50IH0gZnJvbSAncHJvc2VtaXJyb3ItbW9kZWwnO1xuaW1wb3J0IHsgRGVjb3JhdGlvblNldCwgRGVjb3JhdGlvbiB9IGZyb20gJ3Byb3NlbWlycm9yLXZpZXcnO1xuXG4vKipcbkdhcCBjdXJzb3Igc2VsZWN0aW9ucyBhcmUgcmVwcmVzZW50ZWQgdXNpbmcgdGhpcyBjbGFzcy4gSXRzXG5gJGFuY2hvcmAgYW5kIGAkaGVhZGAgcHJvcGVydGllcyBib3RoIHBvaW50IGF0IHRoZSBjdXJzb3IgcG9zaXRpb24uXG4qL1xuY2xhc3MgR2FwQ3Vyc29yIGV4dGVuZHMgU2VsZWN0aW9uIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBnYXAgY3Vyc29yLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoJHBvcykge1xuICAgICAgICBzdXBlcigkcG9zLCAkcG9zKTtcbiAgICB9XG4gICAgbWFwKGRvYywgbWFwcGluZykge1xuICAgICAgICBsZXQgJHBvcyA9IGRvYy5yZXNvbHZlKG1hcHBpbmcubWFwKHRoaXMuaGVhZCkpO1xuICAgICAgICByZXR1cm4gR2FwQ3Vyc29yLnZhbGlkKCRwb3MpID8gbmV3IEdhcEN1cnNvcigkcG9zKSA6IFNlbGVjdGlvbi5uZWFyKCRwb3MpO1xuICAgIH1cbiAgICBjb250ZW50KCkgeyByZXR1cm4gU2xpY2UuZW1wdHk7IH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBHYXBDdXJzb3IgJiYgb3RoZXIuaGVhZCA9PSB0aGlzLmhlYWQ7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJnYXBjdXJzb3JcIiwgcG9zOiB0aGlzLmhlYWQgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oZG9jLCBqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5wb3MgIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgR2FwQ3Vyc29yLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEdhcEN1cnNvcihkb2MucmVzb2x2ZShqc29uLnBvcykpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldEJvb2ttYXJrKCkgeyByZXR1cm4gbmV3IEdhcEJvb2ttYXJrKHRoaXMuYW5jaG9yKTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIHZhbGlkKCRwb3MpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9ICRwb3MucGFyZW50O1xuICAgICAgICBpZiAocGFyZW50LmlzVGV4dGJsb2NrIHx8ICFjbG9zZWRCZWZvcmUoJHBvcykgfHwgIWNsb3NlZEFmdGVyKCRwb3MpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgb3ZlcnJpZGUgPSBwYXJlbnQudHlwZS5zcGVjLmFsbG93R2FwQ3Vyc29yO1xuICAgICAgICBpZiAob3ZlcnJpZGUgIT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBvdmVycmlkZTtcbiAgICAgICAgbGV0IGRlZmx0ID0gcGFyZW50LmNvbnRlbnRNYXRjaEF0KCRwb3MuaW5kZXgoKSkuZGVmYXVsdFR5cGU7XG4gICAgICAgIHJldHVybiBkZWZsdCAmJiBkZWZsdC5pc1RleHRibG9jaztcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZmluZEdhcEN1cnNvckZyb20oJHBvcywgZGlyLCBtdXN0TW92ZSA9IGZhbHNlKSB7XG4gICAgICAgIHNlYXJjaDogZm9yICg7Oykge1xuICAgICAgICAgICAgaWYgKCFtdXN0TW92ZSAmJiBHYXBDdXJzb3IudmFsaWQoJHBvcykpXG4gICAgICAgICAgICAgICAgcmV0dXJuICRwb3M7XG4gICAgICAgICAgICBsZXQgcG9zID0gJHBvcy5wb3MsIG5leHQgPSBudWxsO1xuICAgICAgICAgICAgLy8gU2NhbiB1cCBmcm9tIHRoaXMgcG9zaXRpb25cbiAgICAgICAgICAgIGZvciAobGV0IGQgPSAkcG9zLmRlcHRoOzsgZC0tKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBhcmVudCA9ICRwb3Mubm9kZShkKTtcbiAgICAgICAgICAgICAgICBpZiAoZGlyID4gMCA/ICRwb3MuaW5kZXhBZnRlcihkKSA8IHBhcmVudC5jaGlsZENvdW50IDogJHBvcy5pbmRleChkKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA9IHBhcmVudC5jaGlsZChkaXIgPiAwID8gJHBvcy5pbmRleEFmdGVyKGQpIDogJHBvcy5pbmRleChkKSAtIDEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb3MgKz0gZGlyO1xuICAgICAgICAgICAgICAgIGxldCAkY3VyID0gJHBvcy5kb2MucmVzb2x2ZShwb3MpO1xuICAgICAgICAgICAgICAgIGlmIChHYXBDdXJzb3IudmFsaWQoJGN1cikpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkY3VyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQW5kIHRoZW4gZG93biBpbnRvIHRoZSBuZXh0IG5vZGVcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5zaWRlID0gZGlyID4gMCA/IG5leHQuZmlyc3RDaGlsZCA6IG5leHQubGFzdENoaWxkO1xuICAgICAgICAgICAgICAgIGlmICghaW5zaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0LmlzQXRvbSAmJiAhbmV4dC5pc1RleHQgJiYgIU5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5leHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkcG9zID0gJHBvcy5kb2MucmVzb2x2ZShwb3MgKyBuZXh0Lm5vZGVTaXplICogZGlyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG11c3RNb3ZlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBzZWFyY2g7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHQgPSBpbnNpZGU7XG4gICAgICAgICAgICAgICAgcG9zICs9IGRpcjtcbiAgICAgICAgICAgICAgICBsZXQgJGN1ciA9ICRwb3MuZG9jLnJlc29sdmUocG9zKTtcbiAgICAgICAgICAgICAgICBpZiAoR2FwQ3Vyc29yLnZhbGlkKCRjdXIpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJGN1cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuR2FwQ3Vyc29yLnByb3RvdHlwZS52aXNpYmxlID0gZmFsc2U7XG5HYXBDdXJzb3IuZmluZEZyb20gPSBHYXBDdXJzb3IuZmluZEdhcEN1cnNvckZyb207XG5TZWxlY3Rpb24uanNvbklEKFwiZ2FwY3Vyc29yXCIsIEdhcEN1cnNvcik7XG5jbGFzcyBHYXBCb29rbWFyayB7XG4gICAgY29uc3RydWN0b3IocG9zKSB7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICByZXR1cm4gbmV3IEdhcEJvb2ttYXJrKG1hcHBpbmcubWFwKHRoaXMucG9zKSk7XG4gICAgfVxuICAgIHJlc29sdmUoZG9jKSB7XG4gICAgICAgIGxldCAkcG9zID0gZG9jLnJlc29sdmUodGhpcy5wb3MpO1xuICAgICAgICByZXR1cm4gR2FwQ3Vyc29yLnZhbGlkKCRwb3MpID8gbmV3IEdhcEN1cnNvcigkcG9zKSA6IFNlbGVjdGlvbi5uZWFyKCRwb3MpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5lZWRzR2FwKHR5cGUpIHtcbiAgICByZXR1cm4gdHlwZS5pc0F0b20gfHwgdHlwZS5zcGVjLmlzb2xhdGluZyB8fCB0eXBlLnNwZWMuY3JlYXRlR2FwQ3Vyc29yO1xufVxuZnVuY3Rpb24gY2xvc2VkQmVmb3JlKCRwb3MpIHtcbiAgICBmb3IgKGxldCBkID0gJHBvcy5kZXB0aDsgZCA+PSAwOyBkLS0pIHtcbiAgICAgICAgbGV0IGluZGV4ID0gJHBvcy5pbmRleChkKSwgcGFyZW50ID0gJHBvcy5ub2RlKGQpO1xuICAgICAgICAvLyBBdCB0aGUgc3RhcnQgb2YgdGhpcyBwYXJlbnQsIGxvb2sgYXQgbmV4dCBvbmVcbiAgICAgICAgaWYgKGluZGV4ID09IDApIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnQudHlwZS5zcGVjLmlzb2xhdGluZylcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNlZSBpZiB0aGUgbm9kZSBiZWZvcmUgKG9yIGl0cyBmaXJzdCBhbmNlc3RvcikgaXMgY2xvc2VkXG4gICAgICAgIGZvciAobGV0IGJlZm9yZSA9IHBhcmVudC5jaGlsZChpbmRleCAtIDEpOzsgYmVmb3JlID0gYmVmb3JlLmxhc3RDaGlsZCkge1xuICAgICAgICAgICAgaWYgKChiZWZvcmUuY2hpbGRDb3VudCA9PSAwICYmICFiZWZvcmUuaW5saW5lQ29udGVudCkgfHwgbmVlZHNHYXAoYmVmb3JlLnR5cGUpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKGJlZm9yZS5pbmxpbmVDb250ZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBIaXQgc3RhcnQgb2YgZG9jdW1lbnRcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGNsb3NlZEFmdGVyKCRwb3MpIHtcbiAgICBmb3IgKGxldCBkID0gJHBvcy5kZXB0aDsgZCA+PSAwOyBkLS0pIHtcbiAgICAgICAgbGV0IGluZGV4ID0gJHBvcy5pbmRleEFmdGVyKGQpLCBwYXJlbnQgPSAkcG9zLm5vZGUoZCk7XG4gICAgICAgIGlmIChpbmRleCA9PSBwYXJlbnQuY2hpbGRDb3VudCkge1xuICAgICAgICAgICAgaWYgKHBhcmVudC50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgYWZ0ZXIgPSBwYXJlbnQuY2hpbGQoaW5kZXgpOzsgYWZ0ZXIgPSBhZnRlci5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICBpZiAoKGFmdGVyLmNoaWxkQ291bnQgPT0gMCAmJiAhYWZ0ZXIuaW5saW5lQ29udGVudCkgfHwgbmVlZHNHYXAoYWZ0ZXIudHlwZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAoYWZ0ZXIuaW5saW5lQ29udGVudClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuQ3JlYXRlIGEgZ2FwIGN1cnNvciBwbHVnaW4uIFdoZW4gZW5hYmxlZCwgdGhpcyB3aWxsIGNhcHR1cmUgY2xpY2tzXG5uZWFyIGFuZCBhcnJvdy1rZXktbW90aW9uIHBhc3QgcGxhY2VzIHRoYXQgZG9uJ3QgaGF2ZSBhIG5vcm1hbGx5XG5zZWxlY3RhYmxlIHBvc2l0aW9uIG5lYXJieSwgYW5kIGNyZWF0ZSBhIGdhcCBjdXJzb3Igc2VsZWN0aW9uIGZvclxudGhlbS4gVGhlIGN1cnNvciBpcyBkcmF3biBhcyBhbiBlbGVtZW50IHdpdGggY2xhc3NcbmBQcm9zZU1pcnJvci1nYXBjdXJzb3JgLiBZb3UgY2FuIGVpdGhlciBpbmNsdWRlXG5gc3R5bGUvZ2FwY3Vyc29yLmNzc2AgZnJvbSB0aGUgcGFja2FnZSdzIGRpcmVjdG9yeSBvciBhZGQgeW91ciBvd25cbnN0eWxlcyB0byBtYWtlIGl0IHZpc2libGUuXG4qL1xuZnVuY3Rpb24gZ2FwQ3Vyc29yKCkge1xuICAgIHJldHVybiBuZXcgUGx1Z2luKHtcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIGRlY29yYXRpb25zOiBkcmF3R2FwQ3Vyc29yLFxuICAgICAgICAgICAgY3JlYXRlU2VsZWN0aW9uQmV0d2VlbihfdmlldywgJGFuY2hvciwgJGhlYWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJGFuY2hvci5wb3MgPT0gJGhlYWQucG9zICYmIEdhcEN1cnNvci52YWxpZCgkaGVhZCkgPyBuZXcgR2FwQ3Vyc29yKCRoZWFkKSA6IG51bGw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFuZGxlQ2xpY2ssXG4gICAgICAgICAgICBoYW5kbGVLZXlEb3duLFxuICAgICAgICAgICAgaGFuZGxlRE9NRXZlbnRzOiB7IGJlZm9yZWlucHV0OiBiZWZvcmVpbnB1dCB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmNvbnN0IGhhbmRsZUtleURvd24gPSBrZXlkb3duSGFuZGxlcih7XG4gICAgXCJBcnJvd0xlZnRcIjogYXJyb3coXCJob3JpelwiLCAtMSksXG4gICAgXCJBcnJvd1JpZ2h0XCI6IGFycm93KFwiaG9yaXpcIiwgMSksXG4gICAgXCJBcnJvd1VwXCI6IGFycm93KFwidmVydFwiLCAtMSksXG4gICAgXCJBcnJvd0Rvd25cIjogYXJyb3coXCJ2ZXJ0XCIsIDEpXG59KTtcbmZ1bmN0aW9uIGFycm93KGF4aXMsIGRpcikge1xuICAgIGNvbnN0IGRpclN0ciA9IGF4aXMgPT0gXCJ2ZXJ0XCIgPyAoZGlyID4gMCA/IFwiZG93blwiIDogXCJ1cFwiKSA6IChkaXIgPiAwID8gXCJyaWdodFwiIDogXCJsZWZ0XCIpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoLCB2aWV3KSB7XG4gICAgICAgIGxldCBzZWwgPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGxldCAkc3RhcnQgPSBkaXIgPiAwID8gc2VsLiR0byA6IHNlbC4kZnJvbSwgbXVzdE1vdmUgPSBzZWwuZW1wdHk7XG4gICAgICAgIGlmIChzZWwgaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBpZiAoIXZpZXcuZW5kT2ZUZXh0YmxvY2soZGlyU3RyKSB8fCAkc3RhcnQuZGVwdGggPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBtdXN0TW92ZSA9IGZhbHNlO1xuICAgICAgICAgICAgJHN0YXJ0ID0gc3RhdGUuZG9jLnJlc29sdmUoZGlyID4gMCA/ICRzdGFydC5hZnRlcigpIDogJHN0YXJ0LmJlZm9yZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgJGZvdW5kID0gR2FwQ3Vyc29yLmZpbmRHYXBDdXJzb3JGcm9tKCRzdGFydCwgZGlyLCBtdXN0TW92ZSk7XG4gICAgICAgIGlmICghJGZvdW5kKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpXG4gICAgICAgICAgICBkaXNwYXRjaChzdGF0ZS50ci5zZXRTZWxlY3Rpb24obmV3IEdhcEN1cnNvcigkZm91bmQpKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG5mdW5jdGlvbiBoYW5kbGVDbGljayh2aWV3LCBwb3MsIGV2ZW50KSB7XG4gICAgaWYgKCF2aWV3IHx8ICF2aWV3LmVkaXRhYmxlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0ICRwb3MgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKHBvcyk7XG4gICAgaWYgKCFHYXBDdXJzb3IudmFsaWQoJHBvcykpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgY2xpY2tQb3MgPSB2aWV3LnBvc0F0Q29vcmRzKHsgbGVmdDogZXZlbnQuY2xpZW50WCwgdG9wOiBldmVudC5jbGllbnRZIH0pO1xuICAgIGlmIChjbGlja1BvcyAmJiBjbGlja1Bvcy5pbnNpZGUgPiAtMSAmJiBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZSh2aWV3LnN0YXRlLmRvYy5ub2RlQXQoY2xpY2tQb3MuaW5zaWRlKSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2aWV3LmRpc3BhdGNoKHZpZXcuc3RhdGUudHIuc2V0U2VsZWN0aW9uKG5ldyBHYXBDdXJzb3IoJHBvcykpKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8vIFRoaXMgaXMgYSBoYWNrIHRoYXQsIHdoZW4gYSBjb21wb3NpdGlvbiBzdGFydHMgd2hpbGUgYSBnYXAgY3Vyc29yXG4vLyBpcyBhY3RpdmUsIHF1aWNrbHkgY3JlYXRlcyBhbiBpbmxpbmUgY29udGV4dCBmb3IgdGhlIGNvbXBvc2l0aW9uIHRvXG4vLyBoYXBwZW4gaW4sIHRvIGF2b2lkIGl0IGJlaW5nIGFib3J0ZWQgYnkgdGhlIERPTSBzZWxlY3Rpb24gYmVpbmdcbi8vIG1vdmVkIGludG8gYSB2YWxpZCBwb3NpdGlvbi5cbmZ1bmN0aW9uIGJlZm9yZWlucHV0KHZpZXcsIGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmlucHV0VHlwZSAhPSBcImluc2VydENvbXBvc2l0aW9uVGV4dFwiIHx8ICEodmlldy5zdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBHYXBDdXJzb3IpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHsgJGZyb20gfSA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIGxldCBpbnNlcnQgPSAkZnJvbS5wYXJlbnQuY29udGVudE1hdGNoQXQoJGZyb20uaW5kZXgoKSkuZmluZFdyYXBwaW5nKHZpZXcuc3RhdGUuc2NoZW1hLm5vZGVzLnRleHQpO1xuICAgIGlmICghaW5zZXJ0KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGZyYWcgPSBGcmFnbWVudC5lbXB0eTtcbiAgICBmb3IgKGxldCBpID0gaW5zZXJ0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICBmcmFnID0gRnJhZ21lbnQuZnJvbShpbnNlcnRbaV0uY3JlYXRlQW5kRmlsbChudWxsLCBmcmFnKSk7XG4gICAgbGV0IHRyID0gdmlldy5zdGF0ZS50ci5yZXBsYWNlKCRmcm9tLnBvcywgJGZyb20ucG9zLCBuZXcgU2xpY2UoZnJhZywgMCwgMCkpO1xuICAgIHRyLnNldFNlbGVjdGlvbihUZXh0U2VsZWN0aW9uLm5lYXIodHIuZG9jLnJlc29sdmUoJGZyb20ucG9zICsgMSkpKTtcbiAgICB2aWV3LmRpc3BhdGNoKHRyKTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBkcmF3R2FwQ3Vyc29yKHN0YXRlKSB7XG4gICAgaWYgKCEoc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgR2FwQ3Vyc29yKSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIG5vZGUuY2xhc3NOYW1lID0gXCJQcm9zZU1pcnJvci1nYXBjdXJzb3JcIjtcbiAgICByZXR1cm4gRGVjb3JhdGlvblNldC5jcmVhdGUoc3RhdGUuZG9jLCBbRGVjb3JhdGlvbi53aWRnZXQoc3RhdGUuc2VsZWN0aW9uLmhlYWQsIG5vZGUsIHsga2V5OiBcImdhcGN1cnNvclwiIH0pXSk7XG59XG5cbmV4cG9ydCB7IEdhcEN1cnNvciwgZ2FwQ3Vyc29yIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prosemirror-gapcursor/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prosemirror-history/dist/index.js":
/*!********************************************************!*\
  !*** ./node_modules/prosemirror-history/dist/index.js ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   closeHistory: function() { return /* binding */ closeHistory; },\n/* harmony export */   history: function() { return /* binding */ history; },\n/* harmony export */   redo: function() { return /* binding */ redo; },\n/* harmony export */   redoDepth: function() { return /* binding */ redoDepth; },\n/* harmony export */   redoNoScroll: function() { return /* binding */ redoNoScroll; },\n/* harmony export */   undo: function() { return /* binding */ undo; },\n/* harmony export */   undoDepth: function() { return /* binding */ undoDepth; },\n/* harmony export */   undoNoScroll: function() { return /* binding */ undoNoScroll; }\n/* harmony export */ });\n/* harmony import */ var rope_sequence__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! rope-sequence */ \"(app-pages-browser)/./node_modules/rope-sequence/dist/index.js\");\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-transform */ \"(app-pages-browser)/./node_modules/prosemirror-transform/dist/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-state */ \"(app-pages-browser)/./node_modules/prosemirror-state/dist/index.js\");\n\n\n\n\n// ProseMirror's history isn't simply a way to roll back to a previous\n// state, because ProseMirror supports applying changes without adding\n// them to the history (for example during collaboration).\n//\n// To this end, each 'Branch' (one for the undo history and one for\n// the redo history) keeps an array of 'Items', which can optionally\n// hold a step (an actual undoable change), and always hold a position\n// map (which is needed to move changes below them to apply to the\n// current document).\n//\n// An item that has both a step and a selection bookmark is the start\n// of an 'event' — a group of changes that will be undone or redone at\n// once. (It stores only the bookmark, since that way we don't have to\n// provide a document until the selection is actually applied, which\n// is useful when compressing.)\n// Used to schedule history compression\nconst max_empty_items = 500;\nclass Branch {\n    constructor(items, eventCount) {\n        this.items = items;\n        this.eventCount = eventCount;\n    }\n    // Pop the latest event off the branch's history and apply it\n    // to a document transform.\n    popEvent(state, preserveItems) {\n        if (this.eventCount == 0)\n            return null;\n        let end = this.items.length;\n        for (;; end--) {\n            let next = this.items.get(end - 1);\n            if (next.selection) {\n                --end;\n                break;\n            }\n        }\n        let remap, mapFrom;\n        if (preserveItems) {\n            remap = this.remapping(end, this.items.length);\n            mapFrom = remap.maps.length;\n        }\n        let transform = state.tr;\n        let selection, remaining;\n        let addAfter = [], addBefore = [];\n        this.items.forEach((item, i) => {\n            if (!item.step) {\n                if (!remap) {\n                    remap = this.remapping(end, i + 1);\n                    mapFrom = remap.maps.length;\n                }\n                mapFrom--;\n                addBefore.push(item);\n                return;\n            }\n            if (remap) {\n                addBefore.push(new Item(item.map));\n                let step = item.step.map(remap.slice(mapFrom)), map;\n                if (step && transform.maybeStep(step).doc) {\n                    map = transform.mapping.maps[transform.mapping.maps.length - 1];\n                    addAfter.push(new Item(map, undefined, undefined, addAfter.length + addBefore.length));\n                }\n                mapFrom--;\n                if (map)\n                    remap.appendMap(map, mapFrom);\n            }\n            else {\n                transform.maybeStep(item.step);\n            }\n            if (item.selection) {\n                selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;\n                remaining = new Branch(this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);\n                return false;\n            }\n        }, this.items.length, 0);\n        return { remaining: remaining, transform, selection: selection };\n    }\n    // Create a new branch with the given transform added.\n    addTransform(transform, selection, histOptions, preserveItems) {\n        let newItems = [], eventCount = this.eventCount;\n        let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;\n        for (let i = 0; i < transform.steps.length; i++) {\n            let step = transform.steps[i].invert(transform.docs[i]);\n            let item = new Item(transform.mapping.maps[i], step, selection), merged;\n            if (merged = lastItem && lastItem.merge(item)) {\n                item = merged;\n                if (i)\n                    newItems.pop();\n                else\n                    oldItems = oldItems.slice(0, oldItems.length - 1);\n            }\n            newItems.push(item);\n            if (selection) {\n                eventCount++;\n                selection = undefined;\n            }\n            if (!preserveItems)\n                lastItem = item;\n        }\n        let overflow = eventCount - histOptions.depth;\n        if (overflow > DEPTH_OVERFLOW) {\n            oldItems = cutOffEvents(oldItems, overflow);\n            eventCount -= overflow;\n        }\n        return new Branch(oldItems.append(newItems), eventCount);\n    }\n    remapping(from, to) {\n        let maps = new prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.Mapping;\n        this.items.forEach((item, i) => {\n            let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from\n                ? maps.maps.length - item.mirrorOffset : undefined;\n            maps.appendMap(item.map, mirrorPos);\n        }, from, to);\n        return maps;\n    }\n    addMaps(array) {\n        if (this.eventCount == 0)\n            return this;\n        return new Branch(this.items.append(array.map(map => new Item(map))), this.eventCount);\n    }\n    // When the collab module receives remote changes, the history has\n    // to know about those, so that it can adjust the steps that were\n    // rebased on top of the remote changes, and include the position\n    // maps for the remote changes in its array of items.\n    rebased(rebasedTransform, rebasedCount) {\n        if (!this.eventCount)\n            return this;\n        let rebasedItems = [], start = Math.max(0, this.items.length - rebasedCount);\n        let mapping = rebasedTransform.mapping;\n        let newUntil = rebasedTransform.steps.length;\n        let eventCount = this.eventCount;\n        this.items.forEach(item => { if (item.selection)\n            eventCount--; }, start);\n        let iRebased = rebasedCount;\n        this.items.forEach(item => {\n            let pos = mapping.getMirror(--iRebased);\n            if (pos == null)\n                return;\n            newUntil = Math.min(newUntil, pos);\n            let map = mapping.maps[pos];\n            if (item.step) {\n                let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);\n                let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));\n                if (selection)\n                    eventCount++;\n                rebasedItems.push(new Item(map, step, selection));\n            }\n            else {\n                rebasedItems.push(new Item(map));\n            }\n        }, start);\n        let newMaps = [];\n        for (let i = rebasedCount; i < newUntil; i++)\n            newMaps.push(new Item(mapping.maps[i]));\n        let items = this.items.slice(0, start).append(newMaps).append(rebasedItems);\n        let branch = new Branch(items, eventCount);\n        if (branch.emptyItemCount() > max_empty_items)\n            branch = branch.compress(this.items.length - rebasedItems.length);\n        return branch;\n    }\n    emptyItemCount() {\n        let count = 0;\n        this.items.forEach(item => { if (!item.step)\n            count++; });\n        return count;\n    }\n    // Compressing a branch means rewriting it to push the air (map-only\n    // items) out. During collaboration, these naturally accumulate\n    // because each remote change adds one. The `upto` argument is used\n    // to ensure that only the items below a given level are compressed,\n    // because `rebased` relies on a clean, untouched set of items in\n    // order to associate old items with rebased steps.\n    compress(upto = this.items.length) {\n        let remap = this.remapping(0, upto), mapFrom = remap.maps.length;\n        let items = [], events = 0;\n        this.items.forEach((item, i) => {\n            if (i >= upto) {\n                items.push(item);\n                if (item.selection)\n                    events++;\n            }\n            else if (item.step) {\n                let step = item.step.map(remap.slice(mapFrom)), map = step && step.getMap();\n                mapFrom--;\n                if (map)\n                    remap.appendMap(map, mapFrom);\n                if (step) {\n                    let selection = item.selection && item.selection.map(remap.slice(mapFrom));\n                    if (selection)\n                        events++;\n                    let newItem = new Item(map.invert(), step, selection), merged, last = items.length - 1;\n                    if (merged = items.length && items[last].merge(newItem))\n                        items[last] = merged;\n                    else\n                        items.push(newItem);\n                }\n            }\n            else if (item.map) {\n                mapFrom--;\n            }\n        }, this.items.length, 0);\n        return new Branch(rope_sequence__WEBPACK_IMPORTED_MODULE_0__[\"default\"].from(items.reverse()), events);\n    }\n}\nBranch.empty = new Branch(rope_sequence__WEBPACK_IMPORTED_MODULE_0__[\"default\"].empty, 0);\nfunction cutOffEvents(items, n) {\n    let cutPoint;\n    items.forEach((item, i) => {\n        if (item.selection && (n-- == 0)) {\n            cutPoint = i;\n            return false;\n        }\n    });\n    return items.slice(cutPoint);\n}\nclass Item {\n    constructor(\n    // The (forward) step map for this item.\n    map, \n    // The inverted step\n    step, \n    // If this is non-null, this item is the start of a group, and\n    // this selection is the starting selection for the group (the one\n    // that was active before the first step was applied)\n    selection, \n    // If this item is the inverse of a previous mapping on the stack,\n    // this points at the inverse's offset\n    mirrorOffset) {\n        this.map = map;\n        this.step = step;\n        this.selection = selection;\n        this.mirrorOffset = mirrorOffset;\n    }\n    merge(other) {\n        if (this.step && other.step && !other.selection) {\n            let step = other.step.merge(this.step);\n            if (step)\n                return new Item(step.getMap().invert(), step, this.selection);\n        }\n    }\n}\n// The value of the state field that tracks undo/redo history for that\n// state. Will be stored in the plugin state when the history plugin\n// is active.\nclass HistoryState {\n    constructor(done, undone, prevRanges, prevTime, prevComposition) {\n        this.done = done;\n        this.undone = undone;\n        this.prevRanges = prevRanges;\n        this.prevTime = prevTime;\n        this.prevComposition = prevComposition;\n    }\n}\nconst DEPTH_OVERFLOW = 20;\n// Record a transformation in undo history.\nfunction applyTransaction(history, state, tr, options) {\n    let historyTr = tr.getMeta(historyKey), rebased;\n    if (historyTr)\n        return historyTr.historyState;\n    if (tr.getMeta(closeHistoryKey))\n        history = new HistoryState(history.done, history.undone, null, 0, -1);\n    let appended = tr.getMeta(\"appendedTransaction\");\n    if (tr.steps.length == 0) {\n        return history;\n    }\n    else if (appended && appended.getMeta(historyKey)) {\n        if (appended.getMeta(historyKey).redo)\n            return new HistoryState(history.done.addTransform(tr, undefined, options, mustPreserveItems(state)), history.undone, rangesFor(tr.mapping.maps), history.prevTime, history.prevComposition);\n        else\n            return new HistoryState(history.done, history.undone.addTransform(tr, undefined, options, mustPreserveItems(state)), null, history.prevTime, history.prevComposition);\n    }\n    else if (tr.getMeta(\"addToHistory\") !== false && !(appended && appended.getMeta(\"addToHistory\") === false)) {\n        // Group transforms that occur in quick succession into one event.\n        let composition = tr.getMeta(\"composition\");\n        let newGroup = history.prevTime == 0 ||\n            (!appended && history.prevComposition != composition &&\n                (history.prevTime < (tr.time || 0) - options.newGroupDelay || !isAdjacentTo(tr, history.prevRanges)));\n        let prevRanges = appended ? mapRanges(history.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps);\n        return new HistoryState(history.done.addTransform(tr, newGroup ? state.selection.getBookmark() : undefined, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr.time, composition == null ? history.prevComposition : composition);\n    }\n    else if (rebased = tr.getMeta(\"rebased\")) {\n        // Used by the collab module to tell the history that some of its\n        // content has been rebased.\n        return new HistoryState(history.done.rebased(tr, rebased), history.undone.rebased(tr, rebased), mapRanges(history.prevRanges, tr.mapping), history.prevTime, history.prevComposition);\n    }\n    else {\n        return new HistoryState(history.done.addMaps(tr.mapping.maps), history.undone.addMaps(tr.mapping.maps), mapRanges(history.prevRanges, tr.mapping), history.prevTime, history.prevComposition);\n    }\n}\nfunction isAdjacentTo(transform, prevRanges) {\n    if (!prevRanges)\n        return false;\n    if (!transform.docChanged)\n        return true;\n    let adjacent = false;\n    transform.mapping.maps[0].forEach((start, end) => {\n        for (let i = 0; i < prevRanges.length; i += 2)\n            if (start <= prevRanges[i + 1] && end >= prevRanges[i])\n                adjacent = true;\n    });\n    return adjacent;\n}\nfunction rangesFor(maps) {\n    let result = [];\n    for (let i = maps.length - 1; i >= 0 && result.length == 0; i--)\n        maps[i].forEach((_from, _to, from, to) => result.push(from, to));\n    return result;\n}\nfunction mapRanges(ranges, mapping) {\n    if (!ranges)\n        return null;\n    let result = [];\n    for (let i = 0; i < ranges.length; i += 2) {\n        let from = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1);\n        if (from <= to)\n            result.push(from, to);\n    }\n    return result;\n}\n// Apply the latest event from one branch to the document and shift the event\n// onto the other branch.\nfunction histTransaction(history, state, redo) {\n    let preserveItems = mustPreserveItems(state);\n    let histOptions = historyKey.get(state).spec.config;\n    let pop = (redo ? history.undone : history.done).popEvent(state, preserveItems);\n    if (!pop)\n        return null;\n    let selection = pop.selection.resolve(pop.transform.doc);\n    let added = (redo ? history.done : history.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);\n    let newHist = new HistoryState(redo ? added : pop.remaining, redo ? pop.remaining : added, null, 0, -1);\n    return pop.transform.setSelection(selection).setMeta(historyKey, { redo, historyState: newHist });\n}\nlet cachedPreserveItems = false, cachedPreserveItemsPlugins = null;\n// Check whether any plugin in the given state has a\n// `historyPreserveItems` property in its spec, in which case we must\n// preserve steps exactly as they came in, so that they can be\n// rebased.\nfunction mustPreserveItems(state) {\n    let plugins = state.plugins;\n    if (cachedPreserveItemsPlugins != plugins) {\n        cachedPreserveItems = false;\n        cachedPreserveItemsPlugins = plugins;\n        for (let i = 0; i < plugins.length; i++)\n            if (plugins[i].spec.historyPreserveItems) {\n                cachedPreserveItems = true;\n                break;\n            }\n    }\n    return cachedPreserveItems;\n}\n/**\nSet a flag on the given transaction that will prevent further steps\nfrom being appended to an existing history event (so that they\nrequire a separate undo command to undo).\n*/\nfunction closeHistory(tr) {\n    return tr.setMeta(closeHistoryKey, true);\n}\nconst historyKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.PluginKey(\"history\");\nconst closeHistoryKey = new prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.PluginKey(\"closeHistory\");\n/**\nReturns a plugin that enables the undo history for an editor. The\nplugin will track undo and redo stacks, which can be used with the\n[`undo`](https://prosemirror.net/docs/ref/#history.undo) and [`redo`](https://prosemirror.net/docs/ref/#history.redo) commands.\n\nYou can set an `\"addToHistory\"` [metadata\nproperty](https://prosemirror.net/docs/ref/#state.Transaction.setMeta) of `false` on a transaction\nto prevent it from being rolled back by undo.\n*/\nfunction history(config = {}) {\n    config = { depth: config.depth || 100,\n        newGroupDelay: config.newGroupDelay || 500 };\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.Plugin({\n        key: historyKey,\n        state: {\n            init() {\n                return new HistoryState(Branch.empty, Branch.empty, null, 0, -1);\n            },\n            apply(tr, hist, state) {\n                return applyTransaction(hist, state, tr, config);\n            }\n        },\n        config,\n        props: {\n            handleDOMEvents: {\n                beforeinput(view, e) {\n                    let inputType = e.inputType;\n                    let command = inputType == \"historyUndo\" ? undo : inputType == \"historyRedo\" ? redo : null;\n                    if (!command)\n                        return false;\n                    e.preventDefault();\n                    return command(view.state, view.dispatch);\n                }\n            }\n        }\n    });\n}\nfunction buildCommand(redo, scroll) {\n    return (state, dispatch) => {\n        let hist = historyKey.getState(state);\n        if (!hist || (redo ? hist.undone : hist.done).eventCount == 0)\n            return false;\n        if (dispatch) {\n            let tr = histTransaction(hist, state, redo);\n            if (tr)\n                dispatch(scroll ? tr.scrollIntoView() : tr);\n        }\n        return true;\n    };\n}\n/**\nA command function that undoes the last change, if any.\n*/\nconst undo = buildCommand(false, true);\n/**\nA command function that redoes the last undone change, if any.\n*/\nconst redo = buildCommand(true, true);\n/**\nA command function that undoes the last change. Don't scroll the\nselection into view.\n*/\nconst undoNoScroll = buildCommand(false, false);\n/**\nA command function that redoes the last undone change. Don't\nscroll the selection into view.\n*/\nconst redoNoScroll = buildCommand(true, false);\n/**\nThe amount of undoable events available in a given state.\n*/\nfunction undoDepth(state) {\n    let hist = historyKey.getState(state);\n    return hist ? hist.done.eventCount : 0;\n}\n/**\nThe amount of redoable events available in a given editor state.\n*/\nfunction redoDepth(state) {\n    let hist = historyKey.getState(state);\n    return hist ? hist.undone.eventCount : 0;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1oaXN0b3J5L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBeUM7QUFDTztBQUNNOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw0QkFBNEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMERBQU87QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsbUNBQW1DLGNBQWM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsMEJBQTBCLHFEQUFZO0FBQ3RDO0FBQ0E7QUFDQSwwQkFBMEIscURBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyw4QkFBOEI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsNkJBQTZCO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3REFBUztBQUNoQyw0QkFBNEIsd0RBQVM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsZUFBZTtBQUNmO0FBQ0EsZUFBZSxxREFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRStGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1oaXN0b3J5L2Rpc3QvaW5kZXguanM/ZDhhZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUm9wZVNlcXVlbmNlIGZyb20gJ3JvcGUtc2VxdWVuY2UnO1xuaW1wb3J0IHsgTWFwcGluZyB9IGZyb20gJ3Byb3NlbWlycm9yLXRyYW5zZm9ybSc7XG5pbXBvcnQgeyBQbHVnaW5LZXksIFBsdWdpbiB9IGZyb20gJ3Byb3NlbWlycm9yLXN0YXRlJztcblxuLy8gUHJvc2VNaXJyb3IncyBoaXN0b3J5IGlzbid0IHNpbXBseSBhIHdheSB0byByb2xsIGJhY2sgdG8gYSBwcmV2aW91c1xuLy8gc3RhdGUsIGJlY2F1c2UgUHJvc2VNaXJyb3Igc3VwcG9ydHMgYXBwbHlpbmcgY2hhbmdlcyB3aXRob3V0IGFkZGluZ1xuLy8gdGhlbSB0byB0aGUgaGlzdG9yeSAoZm9yIGV4YW1wbGUgZHVyaW5nIGNvbGxhYm9yYXRpb24pLlxuLy9cbi8vIFRvIHRoaXMgZW5kLCBlYWNoICdCcmFuY2gnIChvbmUgZm9yIHRoZSB1bmRvIGhpc3RvcnkgYW5kIG9uZSBmb3Jcbi8vIHRoZSByZWRvIGhpc3RvcnkpIGtlZXBzIGFuIGFycmF5IG9mICdJdGVtcycsIHdoaWNoIGNhbiBvcHRpb25hbGx5XG4vLyBob2xkIGEgc3RlcCAoYW4gYWN0dWFsIHVuZG9hYmxlIGNoYW5nZSksIGFuZCBhbHdheXMgaG9sZCBhIHBvc2l0aW9uXG4vLyBtYXAgKHdoaWNoIGlzIG5lZWRlZCB0byBtb3ZlIGNoYW5nZXMgYmVsb3cgdGhlbSB0byBhcHBseSB0byB0aGVcbi8vIGN1cnJlbnQgZG9jdW1lbnQpLlxuLy9cbi8vIEFuIGl0ZW0gdGhhdCBoYXMgYm90aCBhIHN0ZXAgYW5kIGEgc2VsZWN0aW9uIGJvb2ttYXJrIGlzIHRoZSBzdGFydFxuLy8gb2YgYW4gJ2V2ZW50JyDigJQgYSBncm91cCBvZiBjaGFuZ2VzIHRoYXQgd2lsbCBiZSB1bmRvbmUgb3IgcmVkb25lIGF0XG4vLyBvbmNlLiAoSXQgc3RvcmVzIG9ubHkgdGhlIGJvb2ttYXJrLCBzaW5jZSB0aGF0IHdheSB3ZSBkb24ndCBoYXZlIHRvXG4vLyBwcm92aWRlIGEgZG9jdW1lbnQgdW50aWwgdGhlIHNlbGVjdGlvbiBpcyBhY3R1YWxseSBhcHBsaWVkLCB3aGljaFxuLy8gaXMgdXNlZnVsIHdoZW4gY29tcHJlc3NpbmcuKVxuLy8gVXNlZCB0byBzY2hlZHVsZSBoaXN0b3J5IGNvbXByZXNzaW9uXG5jb25zdCBtYXhfZW1wdHlfaXRlbXMgPSA1MDA7XG5jbGFzcyBCcmFuY2gge1xuICAgIGNvbnN0cnVjdG9yKGl0ZW1zLCBldmVudENvdW50KSB7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBpdGVtcztcbiAgICAgICAgdGhpcy5ldmVudENvdW50ID0gZXZlbnRDb3VudDtcbiAgICB9XG4gICAgLy8gUG9wIHRoZSBsYXRlc3QgZXZlbnQgb2ZmIHRoZSBicmFuY2gncyBoaXN0b3J5IGFuZCBhcHBseSBpdFxuICAgIC8vIHRvIGEgZG9jdW1lbnQgdHJhbnNmb3JtLlxuICAgIHBvcEV2ZW50KHN0YXRlLCBwcmVzZXJ2ZUl0ZW1zKSB7XG4gICAgICAgIGlmICh0aGlzLmV2ZW50Q291bnQgPT0gMClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgZW5kID0gdGhpcy5pdGVtcy5sZW5ndGg7XG4gICAgICAgIGZvciAoOzsgZW5kLS0pIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy5pdGVtcy5nZXQoZW5kIC0gMSk7XG4gICAgICAgICAgICBpZiAobmV4dC5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAtLWVuZDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVtYXAsIG1hcEZyb207XG4gICAgICAgIGlmIChwcmVzZXJ2ZUl0ZW1zKSB7XG4gICAgICAgICAgICByZW1hcCA9IHRoaXMucmVtYXBwaW5nKGVuZCwgdGhpcy5pdGVtcy5sZW5ndGgpO1xuICAgICAgICAgICAgbWFwRnJvbSA9IHJlbWFwLm1hcHMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0cmFuc2Zvcm0gPSBzdGF0ZS50cjtcbiAgICAgICAgbGV0IHNlbGVjdGlvbiwgcmVtYWluaW5nO1xuICAgICAgICBsZXQgYWRkQWZ0ZXIgPSBbXSwgYWRkQmVmb3JlID0gW107XG4gICAgICAgIHRoaXMuaXRlbXMuZm9yRWFjaCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFpdGVtLnN0ZXApIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlbWFwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbWFwID0gdGhpcy5yZW1hcHBpbmcoZW5kLCBpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIG1hcEZyb20gPSByZW1hcC5tYXBzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWFwRnJvbS0tO1xuICAgICAgICAgICAgICAgIGFkZEJlZm9yZS5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZW1hcCkge1xuICAgICAgICAgICAgICAgIGFkZEJlZm9yZS5wdXNoKG5ldyBJdGVtKGl0ZW0ubWFwKSk7XG4gICAgICAgICAgICAgICAgbGV0IHN0ZXAgPSBpdGVtLnN0ZXAubWFwKHJlbWFwLnNsaWNlKG1hcEZyb20pKSwgbWFwO1xuICAgICAgICAgICAgICAgIGlmIChzdGVwICYmIHRyYW5zZm9ybS5tYXliZVN0ZXAoc3RlcCkuZG9jKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcCA9IHRyYW5zZm9ybS5tYXBwaW5nLm1hcHNbdHJhbnNmb3JtLm1hcHBpbmcubWFwcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgYWRkQWZ0ZXIucHVzaChuZXcgSXRlbShtYXAsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhZGRBZnRlci5sZW5ndGggKyBhZGRCZWZvcmUubGVuZ3RoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1hcEZyb20tLTtcbiAgICAgICAgICAgICAgICBpZiAobWFwKVxuICAgICAgICAgICAgICAgICAgICByZW1hcC5hcHBlbmRNYXAobWFwLCBtYXBGcm9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybS5tYXliZVN0ZXAoaXRlbS5zdGVwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpdGVtLnNlbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbiA9IHJlbWFwID8gaXRlbS5zZWxlY3Rpb24ubWFwKHJlbWFwLnNsaWNlKG1hcEZyb20pKSA6IGl0ZW0uc2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgIHJlbWFpbmluZyA9IG5ldyBCcmFuY2godGhpcy5pdGVtcy5zbGljZSgwLCBlbmQpLmFwcGVuZChhZGRCZWZvcmUucmV2ZXJzZSgpLmNvbmNhdChhZGRBZnRlcikpLCB0aGlzLmV2ZW50Q291bnQgLSAxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMuaXRlbXMubGVuZ3RoLCAwKTtcbiAgICAgICAgcmV0dXJuIHsgcmVtYWluaW5nOiByZW1haW5pbmcsIHRyYW5zZm9ybSwgc2VsZWN0aW9uOiBzZWxlY3Rpb24gfTtcbiAgICB9XG4gICAgLy8gQ3JlYXRlIGEgbmV3IGJyYW5jaCB3aXRoIHRoZSBnaXZlbiB0cmFuc2Zvcm0gYWRkZWQuXG4gICAgYWRkVHJhbnNmb3JtKHRyYW5zZm9ybSwgc2VsZWN0aW9uLCBoaXN0T3B0aW9ucywgcHJlc2VydmVJdGVtcykge1xuICAgICAgICBsZXQgbmV3SXRlbXMgPSBbXSwgZXZlbnRDb3VudCA9IHRoaXMuZXZlbnRDb3VudDtcbiAgICAgICAgbGV0IG9sZEl0ZW1zID0gdGhpcy5pdGVtcywgbGFzdEl0ZW0gPSAhcHJlc2VydmVJdGVtcyAmJiBvbGRJdGVtcy5sZW5ndGggPyBvbGRJdGVtcy5nZXQob2xkSXRlbXMubGVuZ3RoIC0gMSkgOiBudWxsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyYW5zZm9ybS5zdGVwcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHN0ZXAgPSB0cmFuc2Zvcm0uc3RlcHNbaV0uaW52ZXJ0KHRyYW5zZm9ybS5kb2NzW2ldKTtcbiAgICAgICAgICAgIGxldCBpdGVtID0gbmV3IEl0ZW0odHJhbnNmb3JtLm1hcHBpbmcubWFwc1tpXSwgc3RlcCwgc2VsZWN0aW9uKSwgbWVyZ2VkO1xuICAgICAgICAgICAgaWYgKG1lcmdlZCA9IGxhc3RJdGVtICYmIGxhc3RJdGVtLm1lcmdlKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgaXRlbSA9IG1lcmdlZDtcbiAgICAgICAgICAgICAgICBpZiAoaSlcbiAgICAgICAgICAgICAgICAgICAgbmV3SXRlbXMucG9wKCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBvbGRJdGVtcyA9IG9sZEl0ZW1zLnNsaWNlKDAsIG9sZEl0ZW1zLmxlbmd0aCAtIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3SXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBldmVudENvdW50Kys7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFwcmVzZXJ2ZUl0ZW1zKVxuICAgICAgICAgICAgICAgIGxhc3RJdGVtID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3ZlcmZsb3cgPSBldmVudENvdW50IC0gaGlzdE9wdGlvbnMuZGVwdGg7XG4gICAgICAgIGlmIChvdmVyZmxvdyA+IERFUFRIX09WRVJGTE9XKSB7XG4gICAgICAgICAgICBvbGRJdGVtcyA9IGN1dE9mZkV2ZW50cyhvbGRJdGVtcywgb3ZlcmZsb3cpO1xuICAgICAgICAgICAgZXZlbnRDb3VudCAtPSBvdmVyZmxvdztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEJyYW5jaChvbGRJdGVtcy5hcHBlbmQobmV3SXRlbXMpLCBldmVudENvdW50KTtcbiAgICB9XG4gICAgcmVtYXBwaW5nKGZyb20sIHRvKSB7XG4gICAgICAgIGxldCBtYXBzID0gbmV3IE1hcHBpbmc7XG4gICAgICAgIHRoaXMuaXRlbXMuZm9yRWFjaCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICAgICAgbGV0IG1pcnJvclBvcyA9IGl0ZW0ubWlycm9yT2Zmc2V0ICE9IG51bGwgJiYgaSAtIGl0ZW0ubWlycm9yT2Zmc2V0ID49IGZyb21cbiAgICAgICAgICAgICAgICA/IG1hcHMubWFwcy5sZW5ndGggLSBpdGVtLm1pcnJvck9mZnNldCA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIG1hcHMuYXBwZW5kTWFwKGl0ZW0ubWFwLCBtaXJyb3JQb3MpO1xuICAgICAgICB9LCBmcm9tLCB0byk7XG4gICAgICAgIHJldHVybiBtYXBzO1xuICAgIH1cbiAgICBhZGRNYXBzKGFycmF5KSB7XG4gICAgICAgIGlmICh0aGlzLmV2ZW50Q291bnQgPT0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IEJyYW5jaCh0aGlzLml0ZW1zLmFwcGVuZChhcnJheS5tYXAobWFwID0+IG5ldyBJdGVtKG1hcCkpKSwgdGhpcy5ldmVudENvdW50KTtcbiAgICB9XG4gICAgLy8gV2hlbiB0aGUgY29sbGFiIG1vZHVsZSByZWNlaXZlcyByZW1vdGUgY2hhbmdlcywgdGhlIGhpc3RvcnkgaGFzXG4gICAgLy8gdG8ga25vdyBhYm91dCB0aG9zZSwgc28gdGhhdCBpdCBjYW4gYWRqdXN0IHRoZSBzdGVwcyB0aGF0IHdlcmVcbiAgICAvLyByZWJhc2VkIG9uIHRvcCBvZiB0aGUgcmVtb3RlIGNoYW5nZXMsIGFuZCBpbmNsdWRlIHRoZSBwb3NpdGlvblxuICAgIC8vIG1hcHMgZm9yIHRoZSByZW1vdGUgY2hhbmdlcyBpbiBpdHMgYXJyYXkgb2YgaXRlbXMuXG4gICAgcmViYXNlZChyZWJhc2VkVHJhbnNmb3JtLCByZWJhc2VkQ291bnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmV2ZW50Q291bnQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgbGV0IHJlYmFzZWRJdGVtcyA9IFtdLCBzdGFydCA9IE1hdGgubWF4KDAsIHRoaXMuaXRlbXMubGVuZ3RoIC0gcmViYXNlZENvdW50KTtcbiAgICAgICAgbGV0IG1hcHBpbmcgPSByZWJhc2VkVHJhbnNmb3JtLm1hcHBpbmc7XG4gICAgICAgIGxldCBuZXdVbnRpbCA9IHJlYmFzZWRUcmFuc2Zvcm0uc3RlcHMubGVuZ3RoO1xuICAgICAgICBsZXQgZXZlbnRDb3VudCA9IHRoaXMuZXZlbnRDb3VudDtcbiAgICAgICAgdGhpcy5pdGVtcy5mb3JFYWNoKGl0ZW0gPT4geyBpZiAoaXRlbS5zZWxlY3Rpb24pXG4gICAgICAgICAgICBldmVudENvdW50LS07IH0sIHN0YXJ0KTtcbiAgICAgICAgbGV0IGlSZWJhc2VkID0gcmViYXNlZENvdW50O1xuICAgICAgICB0aGlzLml0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICBsZXQgcG9zID0gbWFwcGluZy5nZXRNaXJyb3IoLS1pUmViYXNlZCk7XG4gICAgICAgICAgICBpZiAocG9zID09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbmV3VW50aWwgPSBNYXRoLm1pbihuZXdVbnRpbCwgcG9zKTtcbiAgICAgICAgICAgIGxldCBtYXAgPSBtYXBwaW5nLm1hcHNbcG9zXTtcbiAgICAgICAgICAgIGlmIChpdGVtLnN0ZXApIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RlcCA9IHJlYmFzZWRUcmFuc2Zvcm0uc3RlcHNbcG9zXS5pbnZlcnQocmViYXNlZFRyYW5zZm9ybS5kb2NzW3Bvc10pO1xuICAgICAgICAgICAgICAgIGxldCBzZWxlY3Rpb24gPSBpdGVtLnNlbGVjdGlvbiAmJiBpdGVtLnNlbGVjdGlvbi5tYXAobWFwcGluZy5zbGljZShpUmViYXNlZCArIDEsIHBvcykpO1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50Q291bnQrKztcbiAgICAgICAgICAgICAgICByZWJhc2VkSXRlbXMucHVzaChuZXcgSXRlbShtYXAsIHN0ZXAsIHNlbGVjdGlvbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmViYXNlZEl0ZW1zLnB1c2gobmV3IEl0ZW0obWFwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHN0YXJ0KTtcbiAgICAgICAgbGV0IG5ld01hcHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IHJlYmFzZWRDb3VudDsgaSA8IG5ld1VudGlsOyBpKyspXG4gICAgICAgICAgICBuZXdNYXBzLnB1c2gobmV3IEl0ZW0obWFwcGluZy5tYXBzW2ldKSk7XG4gICAgICAgIGxldCBpdGVtcyA9IHRoaXMuaXRlbXMuc2xpY2UoMCwgc3RhcnQpLmFwcGVuZChuZXdNYXBzKS5hcHBlbmQocmViYXNlZEl0ZW1zKTtcbiAgICAgICAgbGV0IGJyYW5jaCA9IG5ldyBCcmFuY2goaXRlbXMsIGV2ZW50Q291bnQpO1xuICAgICAgICBpZiAoYnJhbmNoLmVtcHR5SXRlbUNvdW50KCkgPiBtYXhfZW1wdHlfaXRlbXMpXG4gICAgICAgICAgICBicmFuY2ggPSBicmFuY2guY29tcHJlc3ModGhpcy5pdGVtcy5sZW5ndGggLSByZWJhc2VkSXRlbXMubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGJyYW5jaDtcbiAgICB9XG4gICAgZW1wdHlJdGVtQ291bnQoKSB7XG4gICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgIHRoaXMuaXRlbXMuZm9yRWFjaChpdGVtID0+IHsgaWYgKCFpdGVtLnN0ZXApXG4gICAgICAgICAgICBjb3VudCsrOyB9KTtcbiAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH1cbiAgICAvLyBDb21wcmVzc2luZyBhIGJyYW5jaCBtZWFucyByZXdyaXRpbmcgaXQgdG8gcHVzaCB0aGUgYWlyIChtYXAtb25seVxuICAgIC8vIGl0ZW1zKSBvdXQuIER1cmluZyBjb2xsYWJvcmF0aW9uLCB0aGVzZSBuYXR1cmFsbHkgYWNjdW11bGF0ZVxuICAgIC8vIGJlY2F1c2UgZWFjaCByZW1vdGUgY2hhbmdlIGFkZHMgb25lLiBUaGUgYHVwdG9gIGFyZ3VtZW50IGlzIHVzZWRcbiAgICAvLyB0byBlbnN1cmUgdGhhdCBvbmx5IHRoZSBpdGVtcyBiZWxvdyBhIGdpdmVuIGxldmVsIGFyZSBjb21wcmVzc2VkLFxuICAgIC8vIGJlY2F1c2UgYHJlYmFzZWRgIHJlbGllcyBvbiBhIGNsZWFuLCB1bnRvdWNoZWQgc2V0IG9mIGl0ZW1zIGluXG4gICAgLy8gb3JkZXIgdG8gYXNzb2NpYXRlIG9sZCBpdGVtcyB3aXRoIHJlYmFzZWQgc3RlcHMuXG4gICAgY29tcHJlc3ModXB0byA9IHRoaXMuaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIGxldCByZW1hcCA9IHRoaXMucmVtYXBwaW5nKDAsIHVwdG8pLCBtYXBGcm9tID0gcmVtYXAubWFwcy5sZW5ndGg7XG4gICAgICAgIGxldCBpdGVtcyA9IFtdLCBldmVudHMgPSAwO1xuICAgICAgICB0aGlzLml0ZW1zLmZvckVhY2goKGl0ZW0sIGkpID0+IHtcbiAgICAgICAgICAgIGlmIChpID49IHVwdG8pIHtcbiAgICAgICAgICAgICAgICBpdGVtcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLnNlbGVjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpdGVtLnN0ZXApIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RlcCA9IGl0ZW0uc3RlcC5tYXAocmVtYXAuc2xpY2UobWFwRnJvbSkpLCBtYXAgPSBzdGVwICYmIHN0ZXAuZ2V0TWFwKCk7XG4gICAgICAgICAgICAgICAgbWFwRnJvbS0tO1xuICAgICAgICAgICAgICAgIGlmIChtYXApXG4gICAgICAgICAgICAgICAgICAgIHJlbWFwLmFwcGVuZE1hcChtYXAsIG1hcEZyb20pO1xuICAgICAgICAgICAgICAgIGlmIChzdGVwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBzZWxlY3Rpb24gPSBpdGVtLnNlbGVjdGlvbiAmJiBpdGVtLnNlbGVjdGlvbi5tYXAocmVtYXAuc2xpY2UobWFwRnJvbSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzKys7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuZXdJdGVtID0gbmV3IEl0ZW0obWFwLmludmVydCgpLCBzdGVwLCBzZWxlY3Rpb24pLCBtZXJnZWQsIGxhc3QgPSBpdGVtcy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWVyZ2VkID0gaXRlbXMubGVuZ3RoICYmIGl0ZW1zW2xhc3RdLm1lcmdlKG5ld0l0ZW0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXNbbGFzdF0gPSBtZXJnZWQ7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1zLnB1c2gobmV3SXRlbSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXRlbS5tYXApIHtcbiAgICAgICAgICAgICAgICBtYXBGcm9tLS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMuaXRlbXMubGVuZ3RoLCAwKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCcmFuY2goUm9wZVNlcXVlbmNlLmZyb20oaXRlbXMucmV2ZXJzZSgpKSwgZXZlbnRzKTtcbiAgICB9XG59XG5CcmFuY2guZW1wdHkgPSBuZXcgQnJhbmNoKFJvcGVTZXF1ZW5jZS5lbXB0eSwgMCk7XG5mdW5jdGlvbiBjdXRPZmZFdmVudHMoaXRlbXMsIG4pIHtcbiAgICBsZXQgY3V0UG9pbnQ7XG4gICAgaXRlbXMuZm9yRWFjaCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICBpZiAoaXRlbS5zZWxlY3Rpb24gJiYgKG4tLSA9PSAwKSkge1xuICAgICAgICAgICAgY3V0UG9pbnQgPSBpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGl0ZW1zLnNsaWNlKGN1dFBvaW50KTtcbn1cbmNsYXNzIEl0ZW0ge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8vIFRoZSAoZm9yd2FyZCkgc3RlcCBtYXAgZm9yIHRoaXMgaXRlbS5cbiAgICBtYXAsIFxuICAgIC8vIFRoZSBpbnZlcnRlZCBzdGVwXG4gICAgc3RlcCwgXG4gICAgLy8gSWYgdGhpcyBpcyBub24tbnVsbCwgdGhpcyBpdGVtIGlzIHRoZSBzdGFydCBvZiBhIGdyb3VwLCBhbmRcbiAgICAvLyB0aGlzIHNlbGVjdGlvbiBpcyB0aGUgc3RhcnRpbmcgc2VsZWN0aW9uIGZvciB0aGUgZ3JvdXAgKHRoZSBvbmVcbiAgICAvLyB0aGF0IHdhcyBhY3RpdmUgYmVmb3JlIHRoZSBmaXJzdCBzdGVwIHdhcyBhcHBsaWVkKVxuICAgIHNlbGVjdGlvbiwgXG4gICAgLy8gSWYgdGhpcyBpdGVtIGlzIHRoZSBpbnZlcnNlIG9mIGEgcHJldmlvdXMgbWFwcGluZyBvbiB0aGUgc3RhY2ssXG4gICAgLy8gdGhpcyBwb2ludHMgYXQgdGhlIGludmVyc2UncyBvZmZzZXRcbiAgICBtaXJyb3JPZmZzZXQpIHtcbiAgICAgICAgdGhpcy5tYXAgPSBtYXA7XG4gICAgICAgIHRoaXMuc3RlcCA9IHN0ZXA7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uID0gc2VsZWN0aW9uO1xuICAgICAgICB0aGlzLm1pcnJvck9mZnNldCA9IG1pcnJvck9mZnNldDtcbiAgICB9XG4gICAgbWVyZ2Uob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RlcCAmJiBvdGhlci5zdGVwICYmICFvdGhlci5zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIGxldCBzdGVwID0gb3RoZXIuc3RlcC5tZXJnZSh0aGlzLnN0ZXApO1xuICAgICAgICAgICAgaWYgKHN0ZXApXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBJdGVtKHN0ZXAuZ2V0TWFwKCkuaW52ZXJ0KCksIHN0ZXAsIHRoaXMuc2VsZWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIFRoZSB2YWx1ZSBvZiB0aGUgc3RhdGUgZmllbGQgdGhhdCB0cmFja3MgdW5kby9yZWRvIGhpc3RvcnkgZm9yIHRoYXRcbi8vIHN0YXRlLiBXaWxsIGJlIHN0b3JlZCBpbiB0aGUgcGx1Z2luIHN0YXRlIHdoZW4gdGhlIGhpc3RvcnkgcGx1Z2luXG4vLyBpcyBhY3RpdmUuXG5jbGFzcyBIaXN0b3J5U3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKGRvbmUsIHVuZG9uZSwgcHJldlJhbmdlcywgcHJldlRpbWUsIHByZXZDb21wb3NpdGlvbikge1xuICAgICAgICB0aGlzLmRvbmUgPSBkb25lO1xuICAgICAgICB0aGlzLnVuZG9uZSA9IHVuZG9uZTtcbiAgICAgICAgdGhpcy5wcmV2UmFuZ2VzID0gcHJldlJhbmdlcztcbiAgICAgICAgdGhpcy5wcmV2VGltZSA9IHByZXZUaW1lO1xuICAgICAgICB0aGlzLnByZXZDb21wb3NpdGlvbiA9IHByZXZDb21wb3NpdGlvbjtcbiAgICB9XG59XG5jb25zdCBERVBUSF9PVkVSRkxPVyA9IDIwO1xuLy8gUmVjb3JkIGEgdHJhbnNmb3JtYXRpb24gaW4gdW5kbyBoaXN0b3J5LlxuZnVuY3Rpb24gYXBwbHlUcmFuc2FjdGlvbihoaXN0b3J5LCBzdGF0ZSwgdHIsIG9wdGlvbnMpIHtcbiAgICBsZXQgaGlzdG9yeVRyID0gdHIuZ2V0TWV0YShoaXN0b3J5S2V5KSwgcmViYXNlZDtcbiAgICBpZiAoaGlzdG9yeVRyKVxuICAgICAgICByZXR1cm4gaGlzdG9yeVRyLmhpc3RvcnlTdGF0ZTtcbiAgICBpZiAodHIuZ2V0TWV0YShjbG9zZUhpc3RvcnlLZXkpKVxuICAgICAgICBoaXN0b3J5ID0gbmV3IEhpc3RvcnlTdGF0ZShoaXN0b3J5LmRvbmUsIGhpc3RvcnkudW5kb25lLCBudWxsLCAwLCAtMSk7XG4gICAgbGV0IGFwcGVuZGVkID0gdHIuZ2V0TWV0YShcImFwcGVuZGVkVHJhbnNhY3Rpb25cIik7XG4gICAgaWYgKHRyLnN0ZXBzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIHJldHVybiBoaXN0b3J5O1xuICAgIH1cbiAgICBlbHNlIGlmIChhcHBlbmRlZCAmJiBhcHBlbmRlZC5nZXRNZXRhKGhpc3RvcnlLZXkpKSB7XG4gICAgICAgIGlmIChhcHBlbmRlZC5nZXRNZXRhKGhpc3RvcnlLZXkpLnJlZG8pXG4gICAgICAgICAgICByZXR1cm4gbmV3IEhpc3RvcnlTdGF0ZShoaXN0b3J5LmRvbmUuYWRkVHJhbnNmb3JtKHRyLCB1bmRlZmluZWQsIG9wdGlvbnMsIG11c3RQcmVzZXJ2ZUl0ZW1zKHN0YXRlKSksIGhpc3RvcnkudW5kb25lLCByYW5nZXNGb3IodHIubWFwcGluZy5tYXBzKSwgaGlzdG9yeS5wcmV2VGltZSwgaGlzdG9yeS5wcmV2Q29tcG9zaXRpb24pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbmV3IEhpc3RvcnlTdGF0ZShoaXN0b3J5LmRvbmUsIGhpc3RvcnkudW5kb25lLmFkZFRyYW5zZm9ybSh0ciwgdW5kZWZpbmVkLCBvcHRpb25zLCBtdXN0UHJlc2VydmVJdGVtcyhzdGF0ZSkpLCBudWxsLCBoaXN0b3J5LnByZXZUaW1lLCBoaXN0b3J5LnByZXZDb21wb3NpdGlvbik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRyLmdldE1ldGEoXCJhZGRUb0hpc3RvcnlcIikgIT09IGZhbHNlICYmICEoYXBwZW5kZWQgJiYgYXBwZW5kZWQuZ2V0TWV0YShcImFkZFRvSGlzdG9yeVwiKSA9PT0gZmFsc2UpKSB7XG4gICAgICAgIC8vIEdyb3VwIHRyYW5zZm9ybXMgdGhhdCBvY2N1ciBpbiBxdWljayBzdWNjZXNzaW9uIGludG8gb25lIGV2ZW50LlxuICAgICAgICBsZXQgY29tcG9zaXRpb24gPSB0ci5nZXRNZXRhKFwiY29tcG9zaXRpb25cIik7XG4gICAgICAgIGxldCBuZXdHcm91cCA9IGhpc3RvcnkucHJldlRpbWUgPT0gMCB8fFxuICAgICAgICAgICAgKCFhcHBlbmRlZCAmJiBoaXN0b3J5LnByZXZDb21wb3NpdGlvbiAhPSBjb21wb3NpdGlvbiAmJlxuICAgICAgICAgICAgICAgIChoaXN0b3J5LnByZXZUaW1lIDwgKHRyLnRpbWUgfHwgMCkgLSBvcHRpb25zLm5ld0dyb3VwRGVsYXkgfHwgIWlzQWRqYWNlbnRUbyh0ciwgaGlzdG9yeS5wcmV2UmFuZ2VzKSkpO1xuICAgICAgICBsZXQgcHJldlJhbmdlcyA9IGFwcGVuZGVkID8gbWFwUmFuZ2VzKGhpc3RvcnkucHJldlJhbmdlcywgdHIubWFwcGluZykgOiByYW5nZXNGb3IodHIubWFwcGluZy5tYXBzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoaGlzdG9yeS5kb25lLmFkZFRyYW5zZm9ybSh0ciwgbmV3R3JvdXAgPyBzdGF0ZS5zZWxlY3Rpb24uZ2V0Qm9va21hcmsoKSA6IHVuZGVmaW5lZCwgb3B0aW9ucywgbXVzdFByZXNlcnZlSXRlbXMoc3RhdGUpKSwgQnJhbmNoLmVtcHR5LCBwcmV2UmFuZ2VzLCB0ci50aW1lLCBjb21wb3NpdGlvbiA9PSBudWxsID8gaGlzdG9yeS5wcmV2Q29tcG9zaXRpb24gOiBjb21wb3NpdGlvbik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlYmFzZWQgPSB0ci5nZXRNZXRhKFwicmViYXNlZFwiKSkge1xuICAgICAgICAvLyBVc2VkIGJ5IHRoZSBjb2xsYWIgbW9kdWxlIHRvIHRlbGwgdGhlIGhpc3RvcnkgdGhhdCBzb21lIG9mIGl0c1xuICAgICAgICAvLyBjb250ZW50IGhhcyBiZWVuIHJlYmFzZWQuXG4gICAgICAgIHJldHVybiBuZXcgSGlzdG9yeVN0YXRlKGhpc3RvcnkuZG9uZS5yZWJhc2VkKHRyLCByZWJhc2VkKSwgaGlzdG9yeS51bmRvbmUucmViYXNlZCh0ciwgcmViYXNlZCksIG1hcFJhbmdlcyhoaXN0b3J5LnByZXZSYW5nZXMsIHRyLm1hcHBpbmcpLCBoaXN0b3J5LnByZXZUaW1lLCBoaXN0b3J5LnByZXZDb21wb3NpdGlvbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IEhpc3RvcnlTdGF0ZShoaXN0b3J5LmRvbmUuYWRkTWFwcyh0ci5tYXBwaW5nLm1hcHMpLCBoaXN0b3J5LnVuZG9uZS5hZGRNYXBzKHRyLm1hcHBpbmcubWFwcyksIG1hcFJhbmdlcyhoaXN0b3J5LnByZXZSYW5nZXMsIHRyLm1hcHBpbmcpLCBoaXN0b3J5LnByZXZUaW1lLCBoaXN0b3J5LnByZXZDb21wb3NpdGlvbik7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNBZGphY2VudFRvKHRyYW5zZm9ybSwgcHJldlJhbmdlcykge1xuICAgIGlmICghcHJldlJhbmdlcylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghdHJhbnNmb3JtLmRvY0NoYW5nZWQpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGxldCBhZGphY2VudCA9IGZhbHNlO1xuICAgIHRyYW5zZm9ybS5tYXBwaW5nLm1hcHNbMF0uZm9yRWFjaCgoc3RhcnQsIGVuZCkgPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZXZSYW5nZXMubGVuZ3RoOyBpICs9IDIpXG4gICAgICAgICAgICBpZiAoc3RhcnQgPD0gcHJldlJhbmdlc1tpICsgMV0gJiYgZW5kID49IHByZXZSYW5nZXNbaV0pXG4gICAgICAgICAgICAgICAgYWRqYWNlbnQgPSB0cnVlO1xuICAgIH0pO1xuICAgIHJldHVybiBhZGphY2VudDtcbn1cbmZ1bmN0aW9uIHJhbmdlc0ZvcihtYXBzKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSBtYXBzLmxlbmd0aCAtIDE7IGkgPj0gMCAmJiByZXN1bHQubGVuZ3RoID09IDA7IGktLSlcbiAgICAgICAgbWFwc1tpXS5mb3JFYWNoKChfZnJvbSwgX3RvLCBmcm9tLCB0bykgPT4gcmVzdWx0LnB1c2goZnJvbSwgdG8pKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbWFwUmFuZ2VzKHJhbmdlcywgbWFwcGluZykge1xuICAgIGlmICghcmFuZ2VzKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgbGV0IGZyb20gPSBtYXBwaW5nLm1hcChyYW5nZXNbaV0sIDEpLCB0byA9IG1hcHBpbmcubWFwKHJhbmdlc1tpICsgMV0sIC0xKTtcbiAgICAgICAgaWYgKGZyb20gPD0gdG8pXG4gICAgICAgICAgICByZXN1bHQucHVzaChmcm9tLCB0byk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyBBcHBseSB0aGUgbGF0ZXN0IGV2ZW50IGZyb20gb25lIGJyYW5jaCB0byB0aGUgZG9jdW1lbnQgYW5kIHNoaWZ0IHRoZSBldmVudFxuLy8gb250byB0aGUgb3RoZXIgYnJhbmNoLlxuZnVuY3Rpb24gaGlzdFRyYW5zYWN0aW9uKGhpc3RvcnksIHN0YXRlLCByZWRvKSB7XG4gICAgbGV0IHByZXNlcnZlSXRlbXMgPSBtdXN0UHJlc2VydmVJdGVtcyhzdGF0ZSk7XG4gICAgbGV0IGhpc3RPcHRpb25zID0gaGlzdG9yeUtleS5nZXQoc3RhdGUpLnNwZWMuY29uZmlnO1xuICAgIGxldCBwb3AgPSAocmVkbyA/IGhpc3RvcnkudW5kb25lIDogaGlzdG9yeS5kb25lKS5wb3BFdmVudChzdGF0ZSwgcHJlc2VydmVJdGVtcyk7XG4gICAgaWYgKCFwb3ApXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBzZWxlY3Rpb24gPSBwb3Auc2VsZWN0aW9uLnJlc29sdmUocG9wLnRyYW5zZm9ybS5kb2MpO1xuICAgIGxldCBhZGRlZCA9IChyZWRvID8gaGlzdG9yeS5kb25lIDogaGlzdG9yeS51bmRvbmUpLmFkZFRyYW5zZm9ybShwb3AudHJhbnNmb3JtLCBzdGF0ZS5zZWxlY3Rpb24uZ2V0Qm9va21hcmsoKSwgaGlzdE9wdGlvbnMsIHByZXNlcnZlSXRlbXMpO1xuICAgIGxldCBuZXdIaXN0ID0gbmV3IEhpc3RvcnlTdGF0ZShyZWRvID8gYWRkZWQgOiBwb3AucmVtYWluaW5nLCByZWRvID8gcG9wLnJlbWFpbmluZyA6IGFkZGVkLCBudWxsLCAwLCAtMSk7XG4gICAgcmV0dXJuIHBvcC50cmFuc2Zvcm0uc2V0U2VsZWN0aW9uKHNlbGVjdGlvbikuc2V0TWV0YShoaXN0b3J5S2V5LCB7IHJlZG8sIGhpc3RvcnlTdGF0ZTogbmV3SGlzdCB9KTtcbn1cbmxldCBjYWNoZWRQcmVzZXJ2ZUl0ZW1zID0gZmFsc2UsIGNhY2hlZFByZXNlcnZlSXRlbXNQbHVnaW5zID0gbnVsbDtcbi8vIENoZWNrIHdoZXRoZXIgYW55IHBsdWdpbiBpbiB0aGUgZ2l2ZW4gc3RhdGUgaGFzIGFcbi8vIGBoaXN0b3J5UHJlc2VydmVJdGVtc2AgcHJvcGVydHkgaW4gaXRzIHNwZWMsIGluIHdoaWNoIGNhc2Ugd2UgbXVzdFxuLy8gcHJlc2VydmUgc3RlcHMgZXhhY3RseSBhcyB0aGV5IGNhbWUgaW4sIHNvIHRoYXQgdGhleSBjYW4gYmVcbi8vIHJlYmFzZWQuXG5mdW5jdGlvbiBtdXN0UHJlc2VydmVJdGVtcyhzdGF0ZSkge1xuICAgIGxldCBwbHVnaW5zID0gc3RhdGUucGx1Z2lucztcbiAgICBpZiAoY2FjaGVkUHJlc2VydmVJdGVtc1BsdWdpbnMgIT0gcGx1Z2lucykge1xuICAgICAgICBjYWNoZWRQcmVzZXJ2ZUl0ZW1zID0gZmFsc2U7XG4gICAgICAgIGNhY2hlZFByZXNlcnZlSXRlbXNQbHVnaW5zID0gcGx1Z2lucztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKHBsdWdpbnNbaV0uc3BlYy5oaXN0b3J5UHJlc2VydmVJdGVtcykge1xuICAgICAgICAgICAgICAgIGNhY2hlZFByZXNlcnZlSXRlbXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2FjaGVkUHJlc2VydmVJdGVtcztcbn1cbi8qKlxuU2V0IGEgZmxhZyBvbiB0aGUgZ2l2ZW4gdHJhbnNhY3Rpb24gdGhhdCB3aWxsIHByZXZlbnQgZnVydGhlciBzdGVwc1xuZnJvbSBiZWluZyBhcHBlbmRlZCB0byBhbiBleGlzdGluZyBoaXN0b3J5IGV2ZW50IChzbyB0aGF0IHRoZXlcbnJlcXVpcmUgYSBzZXBhcmF0ZSB1bmRvIGNvbW1hbmQgdG8gdW5kbykuXG4qL1xuZnVuY3Rpb24gY2xvc2VIaXN0b3J5KHRyKSB7XG4gICAgcmV0dXJuIHRyLnNldE1ldGEoY2xvc2VIaXN0b3J5S2V5LCB0cnVlKTtcbn1cbmNvbnN0IGhpc3RvcnlLZXkgPSBuZXcgUGx1Z2luS2V5KFwiaGlzdG9yeVwiKTtcbmNvbnN0IGNsb3NlSGlzdG9yeUtleSA9IG5ldyBQbHVnaW5LZXkoXCJjbG9zZUhpc3RvcnlcIik7XG4vKipcblJldHVybnMgYSBwbHVnaW4gdGhhdCBlbmFibGVzIHRoZSB1bmRvIGhpc3RvcnkgZm9yIGFuIGVkaXRvci4gVGhlXG5wbHVnaW4gd2lsbCB0cmFjayB1bmRvIGFuZCByZWRvIHN0YWNrcywgd2hpY2ggY2FuIGJlIHVzZWQgd2l0aCB0aGVcbltgdW5kb2BdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNoaXN0b3J5LnVuZG8pIGFuZCBbYHJlZG9gXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jaGlzdG9yeS5yZWRvKSBjb21tYW5kcy5cblxuWW91IGNhbiBzZXQgYW4gYFwiYWRkVG9IaXN0b3J5XCJgIFttZXRhZGF0YVxucHJvcGVydHldKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5UcmFuc2FjdGlvbi5zZXRNZXRhKSBvZiBgZmFsc2VgIG9uIGEgdHJhbnNhY3Rpb25cbnRvIHByZXZlbnQgaXQgZnJvbSBiZWluZyByb2xsZWQgYmFjayBieSB1bmRvLlxuKi9cbmZ1bmN0aW9uIGhpc3RvcnkoY29uZmlnID0ge30pIHtcbiAgICBjb25maWcgPSB7IGRlcHRoOiBjb25maWcuZGVwdGggfHwgMTAwLFxuICAgICAgICBuZXdHcm91cERlbGF5OiBjb25maWcubmV3R3JvdXBEZWxheSB8fCA1MDAgfTtcbiAgICByZXR1cm4gbmV3IFBsdWdpbih7XG4gICAgICAgIGtleTogaGlzdG9yeUtleSxcbiAgICAgICAgc3RhdGU6IHtcbiAgICAgICAgICAgIGluaXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBIaXN0b3J5U3RhdGUoQnJhbmNoLmVtcHR5LCBCcmFuY2guZW1wdHksIG51bGwsIDAsIC0xKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcHBseSh0ciwgaGlzdCwgc3RhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwbHlUcmFuc2FjdGlvbihoaXN0LCBzdGF0ZSwgdHIsIGNvbmZpZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmZpZyxcbiAgICAgICAgcHJvcHM6IHtcbiAgICAgICAgICAgIGhhbmRsZURPTUV2ZW50czoge1xuICAgICAgICAgICAgICAgIGJlZm9yZWlucHV0KHZpZXcsIGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlucHV0VHlwZSA9IGUuaW5wdXRUeXBlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgY29tbWFuZCA9IGlucHV0VHlwZSA9PSBcImhpc3RvcnlVbmRvXCIgPyB1bmRvIDogaW5wdXRUeXBlID09IFwiaGlzdG9yeVJlZG9cIiA/IHJlZG8gOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbW1hbmQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbW1hbmQodmlldy5zdGF0ZSwgdmlldy5kaXNwYXRjaCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiBidWlsZENvbW1hbmQocmVkbywgc2Nyb2xsKSB7XG4gICAgcmV0dXJuIChzdGF0ZSwgZGlzcGF0Y2gpID0+IHtcbiAgICAgICAgbGV0IGhpc3QgPSBoaXN0b3J5S2V5LmdldFN0YXRlKHN0YXRlKTtcbiAgICAgICAgaWYgKCFoaXN0IHx8IChyZWRvID8gaGlzdC51bmRvbmUgOiBoaXN0LmRvbmUpLmV2ZW50Q291bnQgPT0gMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICBsZXQgdHIgPSBoaXN0VHJhbnNhY3Rpb24oaGlzdCwgc3RhdGUsIHJlZG8pO1xuICAgICAgICAgICAgaWYgKHRyKVxuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHNjcm9sbCA/IHRyLnNjcm9sbEludG9WaWV3KCkgOiB0cik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbn1cbi8qKlxuQSBjb21tYW5kIGZ1bmN0aW9uIHRoYXQgdW5kb2VzIHRoZSBsYXN0IGNoYW5nZSwgaWYgYW55LlxuKi9cbmNvbnN0IHVuZG8gPSBidWlsZENvbW1hbmQoZmFsc2UsIHRydWUpO1xuLyoqXG5BIGNvbW1hbmQgZnVuY3Rpb24gdGhhdCByZWRvZXMgdGhlIGxhc3QgdW5kb25lIGNoYW5nZSwgaWYgYW55LlxuKi9cbmNvbnN0IHJlZG8gPSBidWlsZENvbW1hbmQodHJ1ZSwgdHJ1ZSk7XG4vKipcbkEgY29tbWFuZCBmdW5jdGlvbiB0aGF0IHVuZG9lcyB0aGUgbGFzdCBjaGFuZ2UuIERvbid0IHNjcm9sbCB0aGVcbnNlbGVjdGlvbiBpbnRvIHZpZXcuXG4qL1xuY29uc3QgdW5kb05vU2Nyb2xsID0gYnVpbGRDb21tYW5kKGZhbHNlLCBmYWxzZSk7XG4vKipcbkEgY29tbWFuZCBmdW5jdGlvbiB0aGF0IHJlZG9lcyB0aGUgbGFzdCB1bmRvbmUgY2hhbmdlLiBEb24ndFxuc2Nyb2xsIHRoZSBzZWxlY3Rpb24gaW50byB2aWV3LlxuKi9cbmNvbnN0IHJlZG9Ob1Njcm9sbCA9IGJ1aWxkQ29tbWFuZCh0cnVlLCBmYWxzZSk7XG4vKipcblRoZSBhbW91bnQgb2YgdW5kb2FibGUgZXZlbnRzIGF2YWlsYWJsZSBpbiBhIGdpdmVuIHN0YXRlLlxuKi9cbmZ1bmN0aW9uIHVuZG9EZXB0aChzdGF0ZSkge1xuICAgIGxldCBoaXN0ID0gaGlzdG9yeUtleS5nZXRTdGF0ZShzdGF0ZSk7XG4gICAgcmV0dXJuIGhpc3QgPyBoaXN0LmRvbmUuZXZlbnRDb3VudCA6IDA7XG59XG4vKipcblRoZSBhbW91bnQgb2YgcmVkb2FibGUgZXZlbnRzIGF2YWlsYWJsZSBpbiBhIGdpdmVuIGVkaXRvciBzdGF0ZS5cbiovXG5mdW5jdGlvbiByZWRvRGVwdGgoc3RhdGUpIHtcbiAgICBsZXQgaGlzdCA9IGhpc3RvcnlLZXkuZ2V0U3RhdGUoc3RhdGUpO1xuICAgIHJldHVybiBoaXN0ID8gaGlzdC51bmRvbmUuZXZlbnRDb3VudCA6IDA7XG59XG5cbmV4cG9ydCB7IGNsb3NlSGlzdG9yeSwgaGlzdG9yeSwgcmVkbywgcmVkb0RlcHRoLCByZWRvTm9TY3JvbGwsIHVuZG8sIHVuZG9EZXB0aCwgdW5kb05vU2Nyb2xsIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prosemirror-history/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prosemirror-keymap/dist/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/prosemirror-keymap/dist/index.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   keydownHandler: function() { return /* binding */ keydownHandler; },\n/* harmony export */   keymap: function() { return /* binding */ keymap; }\n/* harmony export */ });\n/* harmony import */ var w3c_keyname__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! w3c-keyname */ \"(app-pages-browser)/./node_modules/w3c-keyname/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-state */ \"(app-pages-browser)/./node_modules/prosemirror-state/dist/index.js\");\n\n\n\nconst mac = typeof navigator != \"undefined\" && /Mac|iP(hone|[oa]d)/.test(navigator.platform);\nconst windows = typeof navigator != \"undefined\" && /Win/.test(navigator.platform);\nfunction normalizeKeyName(name) {\n    let parts = name.split(/-(?!$)/), result = parts[parts.length - 1];\n    if (result == \"Space\")\n        result = \" \";\n    let alt, ctrl, shift, meta;\n    for (let i = 0; i < parts.length - 1; i++) {\n        let mod = parts[i];\n        if (/^(cmd|meta|m)$/i.test(mod))\n            meta = true;\n        else if (/^a(lt)?$/i.test(mod))\n            alt = true;\n        else if (/^(c|ctrl|control)$/i.test(mod))\n            ctrl = true;\n        else if (/^s(hift)?$/i.test(mod))\n            shift = true;\n        else if (/^mod$/i.test(mod)) {\n            if (mac)\n                meta = true;\n            else\n                ctrl = true;\n        }\n        else\n            throw new Error(\"Unrecognized modifier name: \" + mod);\n    }\n    if (alt)\n        result = \"Alt-\" + result;\n    if (ctrl)\n        result = \"Ctrl-\" + result;\n    if (meta)\n        result = \"Meta-\" + result;\n    if (shift)\n        result = \"Shift-\" + result;\n    return result;\n}\nfunction normalize(map) {\n    let copy = Object.create(null);\n    for (let prop in map)\n        copy[normalizeKeyName(prop)] = map[prop];\n    return copy;\n}\nfunction modifiers(name, event, shift = true) {\n    if (event.altKey)\n        name = \"Alt-\" + name;\n    if (event.ctrlKey)\n        name = \"Ctrl-\" + name;\n    if (event.metaKey)\n        name = \"Meta-\" + name;\n    if (shift && event.shiftKey)\n        name = \"Shift-\" + name;\n    return name;\n}\n/**\nCreate a keymap plugin for the given set of bindings.\n\nBindings should map key names to [command](https://prosemirror.net/docs/ref/#commands)-style\nfunctions, which will be called with `(EditorState, dispatch,\nEditorView)` arguments, and should return true when they've handled\nthe key. Note that the view argument isn't part of the command\nprotocol, but can be used as an escape hatch if a binding needs to\ndirectly interact with the UI.\n\nKey names may be strings like `\"Shift-Ctrl-Enter\"`—a key\nidentifier prefixed with zero or more modifiers. Key identifiers\nare based on the strings that can appear in\n[`KeyEvent.key`](https:developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key).\nUse lowercase letters to refer to letter keys (or uppercase letters\nif you want shift to be held). You may use `\"Space\"` as an alias\nfor the `\" \"` name.\n\nModifiers can be given in any order. `Shift-` (or `s-`), `Alt-` (or\n`a-`), `Ctrl-` (or `c-` or `Control-`) and `Cmd-` (or `m-` or\n`Meta-`) are recognized. For characters that are created by holding\nshift, the `Shift-` prefix is implied, and should not be added\nexplicitly.\n\nYou can use `Mod-` as a shorthand for `Cmd-` on Mac and `Ctrl-` on\nother platforms.\n\nYou can add multiple keymap plugins to an editor. The order in\nwhich they appear determines their precedence (the ones early in\nthe array get to dispatch first).\n*/\nfunction keymap(bindings) {\n    return new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Plugin({ props: { handleKeyDown: keydownHandler(bindings) } });\n}\n/**\nGiven a set of bindings (using the same format as\n[`keymap`](https://prosemirror.net/docs/ref/#keymap.keymap)), return a [keydown\nhandler](https://prosemirror.net/docs/ref/#view.EditorProps.handleKeyDown) that handles them.\n*/\nfunction keydownHandler(bindings) {\n    let map = normalize(bindings);\n    return function (view, event) {\n        let name = (0,w3c_keyname__WEBPACK_IMPORTED_MODULE_0__.keyName)(event), baseName, direct = map[modifiers(name, event)];\n        if (direct && direct(view.state, view.dispatch, view))\n            return true;\n        // A character key\n        if (name.length == 1 && name != \" \") {\n            if (event.shiftKey) {\n                // In case the name was already modified by shift, try looking\n                // it up without its shift modifier\n                let noShift = map[modifiers(name, event, false)];\n                if (noShift && noShift(view.state, view.dispatch, view))\n                    return true;\n            }\n            if ((event.altKey || event.metaKey || event.ctrlKey) &&\n                // Ctrl-Alt may be used for AltGr on Windows\n                !(windows && event.ctrlKey && event.altKey) &&\n                (baseName = w3c_keyname__WEBPACK_IMPORTED_MODULE_0__.base[event.keyCode]) && baseName != name) {\n                // Try falling back to the keyCode when there's a modifier\n                // active or the character produced isn't ASCII, and our table\n                // produces a different name from the the keyCode. See #668,\n                // #1060, #1529.\n                let fromCode = map[modifiers(baseName, event)];\n                if (fromCode && fromCode(view.state, view.dispatch, view))\n                    return true;\n            }\n        }\n        return false;\n    };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1rZXltYXAvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTRDO0FBQ0Q7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscURBQU0sR0FBRyxTQUFTLDJDQUEyQztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0RBQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw2Q0FBSTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1rZXltYXAvZGlzdC9pbmRleC5qcz9jYzU2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGtleU5hbWUsIGJhc2UgfSBmcm9tICd3M2Mta2V5bmFtZSc7XG5pbXBvcnQgeyBQbHVnaW4gfSBmcm9tICdwcm9zZW1pcnJvci1zdGF0ZSc7XG5cbmNvbnN0IG1hYyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gXCJ1bmRlZmluZWRcIiAmJiAvTWFjfGlQKGhvbmV8W29hXWQpLy50ZXN0KG5hdmlnYXRvci5wbGF0Zm9ybSk7XG5jb25zdCB3aW5kb3dzID0gdHlwZW9mIG5hdmlnYXRvciAhPSBcInVuZGVmaW5lZFwiICYmIC9XaW4vLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKTtcbmZ1bmN0aW9uIG5vcm1hbGl6ZUtleU5hbWUobmFtZSkge1xuICAgIGxldCBwYXJ0cyA9IG5hbWUuc3BsaXQoLy0oPyEkKS8pLCByZXN1bHQgPSBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXTtcbiAgICBpZiAocmVzdWx0ID09IFwiU3BhY2VcIilcbiAgICAgICAgcmVzdWx0ID0gXCIgXCI7XG4gICAgbGV0IGFsdCwgY3RybCwgc2hpZnQsIG1ldGE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgbGV0IG1vZCA9IHBhcnRzW2ldO1xuICAgICAgICBpZiAoL14oY21kfG1ldGF8bSkkL2kudGVzdChtb2QpKVxuICAgICAgICAgICAgbWV0YSA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKC9eYShsdCk/JC9pLnRlc3QobW9kKSlcbiAgICAgICAgICAgIGFsdCA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKC9eKGN8Y3RybHxjb250cm9sKSQvaS50ZXN0KG1vZCkpXG4gICAgICAgICAgICBjdHJsID0gdHJ1ZTtcbiAgICAgICAgZWxzZSBpZiAoL15zKGhpZnQpPyQvaS50ZXN0KG1vZCkpXG4gICAgICAgICAgICBzaGlmdCA9IHRydWU7XG4gICAgICAgIGVsc2UgaWYgKC9ebW9kJC9pLnRlc3QobW9kKSkge1xuICAgICAgICAgICAgaWYgKG1hYylcbiAgICAgICAgICAgICAgICBtZXRhID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjdHJsID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnJlY29nbml6ZWQgbW9kaWZpZXIgbmFtZTogXCIgKyBtb2QpO1xuICAgIH1cbiAgICBpZiAoYWx0KVxuICAgICAgICByZXN1bHQgPSBcIkFsdC1cIiArIHJlc3VsdDtcbiAgICBpZiAoY3RybClcbiAgICAgICAgcmVzdWx0ID0gXCJDdHJsLVwiICsgcmVzdWx0O1xuICAgIGlmIChtZXRhKVxuICAgICAgICByZXN1bHQgPSBcIk1ldGEtXCIgKyByZXN1bHQ7XG4gICAgaWYgKHNoaWZ0KVxuICAgICAgICByZXN1bHQgPSBcIlNoaWZ0LVwiICsgcmVzdWx0O1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBub3JtYWxpemUobWFwKSB7XG4gICAgbGV0IGNvcHkgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAobGV0IHByb3AgaW4gbWFwKVxuICAgICAgICBjb3B5W25vcm1hbGl6ZUtleU5hbWUocHJvcCldID0gbWFwW3Byb3BdO1xuICAgIHJldHVybiBjb3B5O1xufVxuZnVuY3Rpb24gbW9kaWZpZXJzKG5hbWUsIGV2ZW50LCBzaGlmdCA9IHRydWUpIHtcbiAgICBpZiAoZXZlbnQuYWx0S2V5KVxuICAgICAgICBuYW1lID0gXCJBbHQtXCIgKyBuYW1lO1xuICAgIGlmIChldmVudC5jdHJsS2V5KVxuICAgICAgICBuYW1lID0gXCJDdHJsLVwiICsgbmFtZTtcbiAgICBpZiAoZXZlbnQubWV0YUtleSlcbiAgICAgICAgbmFtZSA9IFwiTWV0YS1cIiArIG5hbWU7XG4gICAgaWYgKHNoaWZ0ICYmIGV2ZW50LnNoaWZ0S2V5KVxuICAgICAgICBuYW1lID0gXCJTaGlmdC1cIiArIG5hbWU7XG4gICAgcmV0dXJuIG5hbWU7XG59XG4vKipcbkNyZWF0ZSBhIGtleW1hcCBwbHVnaW4gZm9yIHRoZSBnaXZlbiBzZXQgb2YgYmluZGluZ3MuXG5cbkJpbmRpbmdzIHNob3VsZCBtYXAga2V5IG5hbWVzIHRvIFtjb21tYW5kXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jY29tbWFuZHMpLXN0eWxlXG5mdW5jdGlvbnMsIHdoaWNoIHdpbGwgYmUgY2FsbGVkIHdpdGggYChFZGl0b3JTdGF0ZSwgZGlzcGF0Y2gsXG5FZGl0b3JWaWV3KWAgYXJndW1lbnRzLCBhbmQgc2hvdWxkIHJldHVybiB0cnVlIHdoZW4gdGhleSd2ZSBoYW5kbGVkXG50aGUga2V5LiBOb3RlIHRoYXQgdGhlIHZpZXcgYXJndW1lbnQgaXNuJ3QgcGFydCBvZiB0aGUgY29tbWFuZFxucHJvdG9jb2wsIGJ1dCBjYW4gYmUgdXNlZCBhcyBhbiBlc2NhcGUgaGF0Y2ggaWYgYSBiaW5kaW5nIG5lZWRzIHRvXG5kaXJlY3RseSBpbnRlcmFjdCB3aXRoIHRoZSBVSS5cblxuS2V5IG5hbWVzIG1heSBiZSBzdHJpbmdzIGxpa2UgYFwiU2hpZnQtQ3RybC1FbnRlclwiYOKAlGEga2V5XG5pZGVudGlmaWVyIHByZWZpeGVkIHdpdGggemVybyBvciBtb3JlIG1vZGlmaWVycy4gS2V5IGlkZW50aWZpZXJzXG5hcmUgYmFzZWQgb24gdGhlIHN0cmluZ3MgdGhhdCBjYW4gYXBwZWFyIGluXG5bYEtleUV2ZW50LmtleWBdKGh0dHBzOmRldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudC9rZXkpLlxuVXNlIGxvd2VyY2FzZSBsZXR0ZXJzIHRvIHJlZmVyIHRvIGxldHRlciBrZXlzIChvciB1cHBlcmNhc2UgbGV0dGVyc1xuaWYgeW91IHdhbnQgc2hpZnQgdG8gYmUgaGVsZCkuIFlvdSBtYXkgdXNlIGBcIlNwYWNlXCJgIGFzIGFuIGFsaWFzXG5mb3IgdGhlIGBcIiBcImAgbmFtZS5cblxuTW9kaWZpZXJzIGNhbiBiZSBnaXZlbiBpbiBhbnkgb3JkZXIuIGBTaGlmdC1gIChvciBgcy1gKSwgYEFsdC1gIChvclxuYGEtYCksIGBDdHJsLWAgKG9yIGBjLWAgb3IgYENvbnRyb2wtYCkgYW5kIGBDbWQtYCAob3IgYG0tYCBvclxuYE1ldGEtYCkgYXJlIHJlY29nbml6ZWQuIEZvciBjaGFyYWN0ZXJzIHRoYXQgYXJlIGNyZWF0ZWQgYnkgaG9sZGluZ1xuc2hpZnQsIHRoZSBgU2hpZnQtYCBwcmVmaXggaXMgaW1wbGllZCwgYW5kIHNob3VsZCBub3QgYmUgYWRkZWRcbmV4cGxpY2l0bHkuXG5cbllvdSBjYW4gdXNlIGBNb2QtYCBhcyBhIHNob3J0aGFuZCBmb3IgYENtZC1gIG9uIE1hYyBhbmQgYEN0cmwtYCBvblxub3RoZXIgcGxhdGZvcm1zLlxuXG5Zb3UgY2FuIGFkZCBtdWx0aXBsZSBrZXltYXAgcGx1Z2lucyB0byBhbiBlZGl0b3IuIFRoZSBvcmRlciBpblxud2hpY2ggdGhleSBhcHBlYXIgZGV0ZXJtaW5lcyB0aGVpciBwcmVjZWRlbmNlICh0aGUgb25lcyBlYXJseSBpblxudGhlIGFycmF5IGdldCB0byBkaXNwYXRjaCBmaXJzdCkuXG4qL1xuZnVuY3Rpb24ga2V5bWFwKGJpbmRpbmdzKSB7XG4gICAgcmV0dXJuIG5ldyBQbHVnaW4oeyBwcm9wczogeyBoYW5kbGVLZXlEb3duOiBrZXlkb3duSGFuZGxlcihiaW5kaW5ncykgfSB9KTtcbn1cbi8qKlxuR2l2ZW4gYSBzZXQgb2YgYmluZGluZ3MgKHVzaW5nIHRoZSBzYW1lIGZvcm1hdCBhc1xuW2BrZXltYXBgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8ja2V5bWFwLmtleW1hcCkpLCByZXR1cm4gYSBba2V5ZG93blxuaGFuZGxlcl0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yUHJvcHMuaGFuZGxlS2V5RG93bikgdGhhdCBoYW5kbGVzIHRoZW0uXG4qL1xuZnVuY3Rpb24ga2V5ZG93bkhhbmRsZXIoYmluZGluZ3MpIHtcbiAgICBsZXQgbWFwID0gbm9ybWFsaXplKGJpbmRpbmdzKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZpZXcsIGV2ZW50KSB7XG4gICAgICAgIGxldCBuYW1lID0ga2V5TmFtZShldmVudCksIGJhc2VOYW1lLCBkaXJlY3QgPSBtYXBbbW9kaWZpZXJzKG5hbWUsIGV2ZW50KV07XG4gICAgICAgIGlmIChkaXJlY3QgJiYgZGlyZWN0KHZpZXcuc3RhdGUsIHZpZXcuZGlzcGF0Y2gsIHZpZXcpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIC8vIEEgY2hhcmFjdGVyIGtleVxuICAgICAgICBpZiAobmFtZS5sZW5ndGggPT0gMSAmJiBuYW1lICE9IFwiIFwiKSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBjYXNlIHRoZSBuYW1lIHdhcyBhbHJlYWR5IG1vZGlmaWVkIGJ5IHNoaWZ0LCB0cnkgbG9va2luZ1xuICAgICAgICAgICAgICAgIC8vIGl0IHVwIHdpdGhvdXQgaXRzIHNoaWZ0IG1vZGlmaWVyXG4gICAgICAgICAgICAgICAgbGV0IG5vU2hpZnQgPSBtYXBbbW9kaWZpZXJzKG5hbWUsIGV2ZW50LCBmYWxzZSldO1xuICAgICAgICAgICAgICAgIGlmIChub1NoaWZ0ICYmIG5vU2hpZnQodmlldy5zdGF0ZSwgdmlldy5kaXNwYXRjaCwgdmlldykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChldmVudC5hbHRLZXkgfHwgZXZlbnQubWV0YUtleSB8fCBldmVudC5jdHJsS2V5KSAmJlxuICAgICAgICAgICAgICAgIC8vIEN0cmwtQWx0IG1heSBiZSB1c2VkIGZvciBBbHRHciBvbiBXaW5kb3dzXG4gICAgICAgICAgICAgICAgISh3aW5kb3dzICYmIGV2ZW50LmN0cmxLZXkgJiYgZXZlbnQuYWx0S2V5KSAmJlxuICAgICAgICAgICAgICAgIChiYXNlTmFtZSA9IGJhc2VbZXZlbnQua2V5Q29kZV0pICYmIGJhc2VOYW1lICE9IG5hbWUpIHtcbiAgICAgICAgICAgICAgICAvLyBUcnkgZmFsbGluZyBiYWNrIHRvIHRoZSBrZXlDb2RlIHdoZW4gdGhlcmUncyBhIG1vZGlmaWVyXG4gICAgICAgICAgICAgICAgLy8gYWN0aXZlIG9yIHRoZSBjaGFyYWN0ZXIgcHJvZHVjZWQgaXNuJ3QgQVNDSUksIGFuZCBvdXIgdGFibGVcbiAgICAgICAgICAgICAgICAvLyBwcm9kdWNlcyBhIGRpZmZlcmVudCBuYW1lIGZyb20gdGhlIHRoZSBrZXlDb2RlLiBTZWUgIzY2OCxcbiAgICAgICAgICAgICAgICAvLyAjMTA2MCwgIzE1MjkuXG4gICAgICAgICAgICAgICAgbGV0IGZyb21Db2RlID0gbWFwW21vZGlmaWVycyhiYXNlTmFtZSwgZXZlbnQpXTtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbUNvZGUgJiYgZnJvbUNvZGUodmlldy5zdGF0ZSwgdmlldy5kaXNwYXRjaCwgdmlldykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xufVxuXG5leHBvcnQgeyBrZXlkb3duSGFuZGxlciwga2V5bWFwIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prosemirror-keymap/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prosemirror-model/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/prosemirror-model/dist/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContentMatch: function() { return /* binding */ ContentMatch; },\n/* harmony export */   DOMParser: function() { return /* binding */ DOMParser; },\n/* harmony export */   DOMSerializer: function() { return /* binding */ DOMSerializer; },\n/* harmony export */   Fragment: function() { return /* binding */ Fragment; },\n/* harmony export */   Mark: function() { return /* binding */ Mark; },\n/* harmony export */   MarkType: function() { return /* binding */ MarkType; },\n/* harmony export */   Node: function() { return /* binding */ Node; },\n/* harmony export */   NodeRange: function() { return /* binding */ NodeRange; },\n/* harmony export */   NodeType: function() { return /* binding */ NodeType; },\n/* harmony export */   ReplaceError: function() { return /* binding */ ReplaceError; },\n/* harmony export */   ResolvedPos: function() { return /* binding */ ResolvedPos; },\n/* harmony export */   Schema: function() { return /* binding */ Schema; },\n/* harmony export */   Slice: function() { return /* binding */ Slice; }\n/* harmony export */ });\n/* harmony import */ var orderedmap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! orderedmap */ \"(app-pages-browser)/./node_modules/orderedmap/dist/index.js\");\n\n\nfunction findDiffStart(a, b, pos) {\n    for (let i = 0;; i++) {\n        if (i == a.childCount || i == b.childCount)\n            return a.childCount == b.childCount ? null : pos;\n        let childA = a.child(i), childB = b.child(i);\n        if (childA == childB) {\n            pos += childA.nodeSize;\n            continue;\n        }\n        if (!childA.sameMarkup(childB))\n            return pos;\n        if (childA.isText && childA.text != childB.text) {\n            for (let j = 0; childA.text[j] == childB.text[j]; j++)\n                pos++;\n            return pos;\n        }\n        if (childA.content.size || childB.content.size) {\n            let inner = findDiffStart(childA.content, childB.content, pos + 1);\n            if (inner != null)\n                return inner;\n        }\n        pos += childA.nodeSize;\n    }\n}\nfunction findDiffEnd(a, b, posA, posB) {\n    for (let iA = a.childCount, iB = b.childCount;;) {\n        if (iA == 0 || iB == 0)\n            return iA == iB ? null : { a: posA, b: posB };\n        let childA = a.child(--iA), childB = b.child(--iB), size = childA.nodeSize;\n        if (childA == childB) {\n            posA -= size;\n            posB -= size;\n            continue;\n        }\n        if (!childA.sameMarkup(childB))\n            return { a: posA, b: posB };\n        if (childA.isText && childA.text != childB.text) {\n            let same = 0, minSize = Math.min(childA.text.length, childB.text.length);\n            while (same < minSize && childA.text[childA.text.length - same - 1] == childB.text[childB.text.length - same - 1]) {\n                same++;\n                posA--;\n                posB--;\n            }\n            return { a: posA, b: posB };\n        }\n        if (childA.content.size || childB.content.size) {\n            let inner = findDiffEnd(childA.content, childB.content, posA - 1, posB - 1);\n            if (inner)\n                return inner;\n        }\n        posA -= size;\n        posB -= size;\n    }\n}\n\n/**\nA fragment represents a node's collection of child nodes.\n\nLike nodes, fragments are persistent data structures, and you\nshould not mutate them or their content. Rather, you create new\ninstances whenever needed. The API tries to make this easy.\n*/\nclass Fragment {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The child nodes in this fragment.\n    */\n    content, size) {\n        this.content = content;\n        this.size = size || 0;\n        if (size == null)\n            for (let i = 0; i < content.length; i++)\n                this.size += content[i].nodeSize;\n    }\n    /**\n    Invoke a callback for all descendant nodes between the given two\n    positions (relative to start of this fragment). Doesn't descend\n    into a node when the callback returns `false`.\n    */\n    nodesBetween(from, to, f, nodeStart = 0, parent) {\n        for (let i = 0, pos = 0; pos < to; i++) {\n            let child = this.content[i], end = pos + child.nodeSize;\n            if (end > from && f(child, nodeStart + pos, parent || null, i) !== false && child.content.size) {\n                let start = pos + 1;\n                child.nodesBetween(Math.max(0, from - start), Math.min(child.content.size, to - start), f, nodeStart + start);\n            }\n            pos = end;\n        }\n    }\n    /**\n    Call the given callback for every descendant node. `pos` will be\n    relative to the start of the fragment. The callback may return\n    `false` to prevent traversal of a given node's children.\n    */\n    descendants(f) {\n        this.nodesBetween(0, this.size, f);\n    }\n    /**\n    Extract the text between `from` and `to`. See the same method on\n    [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).\n    */\n    textBetween(from, to, blockSeparator, leafText) {\n        let text = \"\", first = true;\n        this.nodesBetween(from, to, (node, pos) => {\n            let nodeText = node.isText ? node.text.slice(Math.max(from, pos) - pos, to - pos)\n                : !node.isLeaf ? \"\"\n                    : leafText ? (typeof leafText === \"function\" ? leafText(node) : leafText)\n                        : node.type.spec.leafText ? node.type.spec.leafText(node)\n                            : \"\";\n            if (node.isBlock && (node.isLeaf && nodeText || node.isTextblock) && blockSeparator) {\n                if (first)\n                    first = false;\n                else\n                    text += blockSeparator;\n            }\n            text += nodeText;\n        }, 0);\n        return text;\n    }\n    /**\n    Create a new fragment containing the combined content of this\n    fragment and the other.\n    */\n    append(other) {\n        if (!other.size)\n            return this;\n        if (!this.size)\n            return other;\n        let last = this.lastChild, first = other.firstChild, content = this.content.slice(), i = 0;\n        if (last.isText && last.sameMarkup(first)) {\n            content[content.length - 1] = last.withText(last.text + first.text);\n            i = 1;\n        }\n        for (; i < other.content.length; i++)\n            content.push(other.content[i]);\n        return new Fragment(content, this.size + other.size);\n    }\n    /**\n    Cut out the sub-fragment between the two given positions.\n    */\n    cut(from, to = this.size) {\n        if (from == 0 && to == this.size)\n            return this;\n        let result = [], size = 0;\n        if (to > from)\n            for (let i = 0, pos = 0; pos < to; i++) {\n                let child = this.content[i], end = pos + child.nodeSize;\n                if (end > from) {\n                    if (pos < from || end > to) {\n                        if (child.isText)\n                            child = child.cut(Math.max(0, from - pos), Math.min(child.text.length, to - pos));\n                        else\n                            child = child.cut(Math.max(0, from - pos - 1), Math.min(child.content.size, to - pos - 1));\n                    }\n                    result.push(child);\n                    size += child.nodeSize;\n                }\n                pos = end;\n            }\n        return new Fragment(result, size);\n    }\n    /**\n    @internal\n    */\n    cutByIndex(from, to) {\n        if (from == to)\n            return Fragment.empty;\n        if (from == 0 && to == this.content.length)\n            return this;\n        return new Fragment(this.content.slice(from, to));\n    }\n    /**\n    Create a new fragment in which the node at the given index is\n    replaced by the given node.\n    */\n    replaceChild(index, node) {\n        let current = this.content[index];\n        if (current == node)\n            return this;\n        let copy = this.content.slice();\n        let size = this.size + node.nodeSize - current.nodeSize;\n        copy[index] = node;\n        return new Fragment(copy, size);\n    }\n    /**\n    Create a new fragment by prepending the given node to this\n    fragment.\n    */\n    addToStart(node) {\n        return new Fragment([node].concat(this.content), this.size + node.nodeSize);\n    }\n    /**\n    Create a new fragment by appending the given node to this\n    fragment.\n    */\n    addToEnd(node) {\n        return new Fragment(this.content.concat(node), this.size + node.nodeSize);\n    }\n    /**\n    Compare this fragment to another one.\n    */\n    eq(other) {\n        if (this.content.length != other.content.length)\n            return false;\n        for (let i = 0; i < this.content.length; i++)\n            if (!this.content[i].eq(other.content[i]))\n                return false;\n        return true;\n    }\n    /**\n    The first child of the fragment, or `null` if it is empty.\n    */\n    get firstChild() { return this.content.length ? this.content[0] : null; }\n    /**\n    The last child of the fragment, or `null` if it is empty.\n    */\n    get lastChild() { return this.content.length ? this.content[this.content.length - 1] : null; }\n    /**\n    The number of child nodes in this fragment.\n    */\n    get childCount() { return this.content.length; }\n    /**\n    Get the child node at the given index. Raise an error when the\n    index is out of range.\n    */\n    child(index) {\n        let found = this.content[index];\n        if (!found)\n            throw new RangeError(\"Index \" + index + \" out of range for \" + this);\n        return found;\n    }\n    /**\n    Get the child node at the given index, if it exists.\n    */\n    maybeChild(index) {\n        return this.content[index] || null;\n    }\n    /**\n    Call `f` for every child node, passing the node, its offset\n    into this parent node, and its index.\n    */\n    forEach(f) {\n        for (let i = 0, p = 0; i < this.content.length; i++) {\n            let child = this.content[i];\n            f(child, p, i);\n            p += child.nodeSize;\n        }\n    }\n    /**\n    Find the first position at which this fragment and another\n    fragment differ, or `null` if they are the same.\n    */\n    findDiffStart(other, pos = 0) {\n        return findDiffStart(this, other, pos);\n    }\n    /**\n    Find the first position, searching from the end, at which this\n    fragment and the given fragment differ, or `null` if they are\n    the same. Since this position will not be the same in both\n    nodes, an object with two separate positions is returned.\n    */\n    findDiffEnd(other, pos = this.size, otherPos = other.size) {\n        return findDiffEnd(this, other, pos, otherPos);\n    }\n    /**\n    Find the index and inner offset corresponding to a given relative\n    position in this fragment. The result object will be reused\n    (overwritten) the next time the function is called. @internal\n    */\n    findIndex(pos) {\n        if (pos == 0)\n            return retIndex(0, pos);\n        if (pos == this.size)\n            return retIndex(this.content.length, pos);\n        if (pos > this.size || pos < 0)\n            throw new RangeError(`Position ${pos} outside of fragment (${this})`);\n        for (let i = 0, curPos = 0;; i++) {\n            let cur = this.child(i), end = curPos + cur.nodeSize;\n            if (end >= pos) {\n                if (end == pos)\n                    return retIndex(i + 1, end);\n                return retIndex(i, curPos);\n            }\n            curPos = end;\n        }\n    }\n    /**\n    Return a debugging string that describes this fragment.\n    */\n    toString() { return \"<\" + this.toStringInner() + \">\"; }\n    /**\n    @internal\n    */\n    toStringInner() { return this.content.join(\", \"); }\n    /**\n    Create a JSON-serializeable representation of this fragment.\n    */\n    toJSON() {\n        return this.content.length ? this.content.map(n => n.toJSON()) : null;\n    }\n    /**\n    Deserialize a fragment from its JSON representation.\n    */\n    static fromJSON(schema, value) {\n        if (!value)\n            return Fragment.empty;\n        if (!Array.isArray(value))\n            throw new RangeError(\"Invalid input for Fragment.fromJSON\");\n        return new Fragment(value.map(schema.nodeFromJSON));\n    }\n    /**\n    Build a fragment from an array of nodes. Ensures that adjacent\n    text nodes with the same marks are joined together.\n    */\n    static fromArray(array) {\n        if (!array.length)\n            return Fragment.empty;\n        let joined, size = 0;\n        for (let i = 0; i < array.length; i++) {\n            let node = array[i];\n            size += node.nodeSize;\n            if (i && node.isText && array[i - 1].sameMarkup(node)) {\n                if (!joined)\n                    joined = array.slice(0, i);\n                joined[joined.length - 1] = node\n                    .withText(joined[joined.length - 1].text + node.text);\n            }\n            else if (joined) {\n                joined.push(node);\n            }\n        }\n        return new Fragment(joined || array, size);\n    }\n    /**\n    Create a fragment from something that can be interpreted as a\n    set of nodes. For `null`, it returns the empty fragment. For a\n    fragment, the fragment itself. For a node or array of nodes, a\n    fragment containing those nodes.\n    */\n    static from(nodes) {\n        if (!nodes)\n            return Fragment.empty;\n        if (nodes instanceof Fragment)\n            return nodes;\n        if (Array.isArray(nodes))\n            return this.fromArray(nodes);\n        if (nodes.attrs)\n            return new Fragment([nodes], nodes.nodeSize);\n        throw new RangeError(\"Can not convert \" + nodes + \" to a Fragment\" +\n            (nodes.nodesBetween ? \" (looks like multiple versions of prosemirror-model were loaded)\" : \"\"));\n    }\n}\n/**\nAn empty fragment. Intended to be reused whenever a node doesn't\ncontain anything (rather than allocating a new empty fragment for\neach leaf node).\n*/\nFragment.empty = new Fragment([], 0);\nconst found = { index: 0, offset: 0 };\nfunction retIndex(index, offset) {\n    found.index = index;\n    found.offset = offset;\n    return found;\n}\n\nfunction compareDeep(a, b) {\n    if (a === b)\n        return true;\n    if (!(a && typeof a == \"object\") ||\n        !(b && typeof b == \"object\"))\n        return false;\n    let array = Array.isArray(a);\n    if (Array.isArray(b) != array)\n        return false;\n    if (array) {\n        if (a.length != b.length)\n            return false;\n        for (let i = 0; i < a.length; i++)\n            if (!compareDeep(a[i], b[i]))\n                return false;\n    }\n    else {\n        for (let p in a)\n            if (!(p in b) || !compareDeep(a[p], b[p]))\n                return false;\n        for (let p in b)\n            if (!(p in a))\n                return false;\n    }\n    return true;\n}\n\n/**\nA mark is a piece of information that can be attached to a node,\nsuch as it being emphasized, in code font, or a link. It has a\ntype and optionally a set of attributes that provide further\ninformation (such as the target of the link). Marks are created\nthrough a `Schema`, which controls which types exist and which\nattributes they have.\n*/\nclass Mark {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The type of this mark.\n    */\n    type, \n    /**\n    The attributes associated with this mark.\n    */\n    attrs) {\n        this.type = type;\n        this.attrs = attrs;\n    }\n    /**\n    Given a set of marks, create a new set which contains this one as\n    well, in the right position. If this mark is already in the set,\n    the set itself is returned. If any marks that are set to be\n    [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,\n    those are replaced by this one.\n    */\n    addToSet(set) {\n        let copy, placed = false;\n        for (let i = 0; i < set.length; i++) {\n            let other = set[i];\n            if (this.eq(other))\n                return set;\n            if (this.type.excludes(other.type)) {\n                if (!copy)\n                    copy = set.slice(0, i);\n            }\n            else if (other.type.excludes(this.type)) {\n                return set;\n            }\n            else {\n                if (!placed && other.type.rank > this.type.rank) {\n                    if (!copy)\n                        copy = set.slice(0, i);\n                    copy.push(this);\n                    placed = true;\n                }\n                if (copy)\n                    copy.push(other);\n            }\n        }\n        if (!copy)\n            copy = set.slice();\n        if (!placed)\n            copy.push(this);\n        return copy;\n    }\n    /**\n    Remove this mark from the given set, returning a new set. If this\n    mark is not in the set, the set itself is returned.\n    */\n    removeFromSet(set) {\n        for (let i = 0; i < set.length; i++)\n            if (this.eq(set[i]))\n                return set.slice(0, i).concat(set.slice(i + 1));\n        return set;\n    }\n    /**\n    Test whether this mark is in the given set of marks.\n    */\n    isInSet(set) {\n        for (let i = 0; i < set.length; i++)\n            if (this.eq(set[i]))\n                return true;\n        return false;\n    }\n    /**\n    Test whether this mark has the same type and attributes as\n    another mark.\n    */\n    eq(other) {\n        return this == other ||\n            (this.type == other.type && compareDeep(this.attrs, other.attrs));\n    }\n    /**\n    Convert this mark to a JSON-serializeable representation.\n    */\n    toJSON() {\n        let obj = { type: this.type.name };\n        for (let _ in this.attrs) {\n            obj.attrs = this.attrs;\n            break;\n        }\n        return obj;\n    }\n    /**\n    Deserialize a mark from JSON.\n    */\n    static fromJSON(schema, json) {\n        if (!json)\n            throw new RangeError(\"Invalid input for Mark.fromJSON\");\n        let type = schema.marks[json.type];\n        if (!type)\n            throw new RangeError(`There is no mark type ${json.type} in this schema`);\n        let mark = type.create(json.attrs);\n        type.checkAttrs(mark.attrs);\n        return mark;\n    }\n    /**\n    Test whether two sets of marks are identical.\n    */\n    static sameSet(a, b) {\n        if (a == b)\n            return true;\n        if (a.length != b.length)\n            return false;\n        for (let i = 0; i < a.length; i++)\n            if (!a[i].eq(b[i]))\n                return false;\n        return true;\n    }\n    /**\n    Create a properly sorted mark set from null, a single mark, or an\n    unsorted array of marks.\n    */\n    static setFrom(marks) {\n        if (!marks || Array.isArray(marks) && marks.length == 0)\n            return Mark.none;\n        if (marks instanceof Mark)\n            return [marks];\n        let copy = marks.slice();\n        copy.sort((a, b) => a.type.rank - b.type.rank);\n        return copy;\n    }\n}\n/**\nThe empty set of marks.\n*/\nMark.none = [];\n\n/**\nError type raised by [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) when\ngiven an invalid replacement.\n*/\nclass ReplaceError extends Error {\n}\n/*\nReplaceError = function(this: any, message: string) {\n  let err = Error.call(this, message)\n  ;(err as any).__proto__ = ReplaceError.prototype\n  return err\n} as any\n\nReplaceError.prototype = Object.create(Error.prototype)\nReplaceError.prototype.constructor = ReplaceError\nReplaceError.prototype.name = \"ReplaceError\"\n*/\n/**\nA slice represents a piece cut out of a larger document. It\nstores not only a fragment, but also the depth up to which nodes on\nboth side are ‘open’ (cut through).\n*/\nclass Slice {\n    /**\n    Create a slice. When specifying a non-zero open depth, you must\n    make sure that there are nodes of at least that depth at the\n    appropriate side of the fragment—i.e. if the fragment is an\n    empty paragraph node, `openStart` and `openEnd` can't be greater\n    than 1.\n    \n    It is not necessary for the content of open nodes to conform to\n    the schema's content constraints, though it should be a valid\n    start/end/middle for such a node, depending on which sides are\n    open.\n    */\n    constructor(\n    /**\n    The slice's content.\n    */\n    content, \n    /**\n    The open depth at the start of the fragment.\n    */\n    openStart, \n    /**\n    The open depth at the end.\n    */\n    openEnd) {\n        this.content = content;\n        this.openStart = openStart;\n        this.openEnd = openEnd;\n    }\n    /**\n    The size this slice would add when inserted into a document.\n    */\n    get size() {\n        return this.content.size - this.openStart - this.openEnd;\n    }\n    /**\n    @internal\n    */\n    insertAt(pos, fragment) {\n        let content = insertInto(this.content, pos + this.openStart, fragment);\n        return content && new Slice(content, this.openStart, this.openEnd);\n    }\n    /**\n    @internal\n    */\n    removeBetween(from, to) {\n        return new Slice(removeRange(this.content, from + this.openStart, to + this.openStart), this.openStart, this.openEnd);\n    }\n    /**\n    Tests whether this slice is equal to another slice.\n    */\n    eq(other) {\n        return this.content.eq(other.content) && this.openStart == other.openStart && this.openEnd == other.openEnd;\n    }\n    /**\n    @internal\n    */\n    toString() {\n        return this.content + \"(\" + this.openStart + \",\" + this.openEnd + \")\";\n    }\n    /**\n    Convert a slice to a JSON-serializable representation.\n    */\n    toJSON() {\n        if (!this.content.size)\n            return null;\n        let json = { content: this.content.toJSON() };\n        if (this.openStart > 0)\n            json.openStart = this.openStart;\n        if (this.openEnd > 0)\n            json.openEnd = this.openEnd;\n        return json;\n    }\n    /**\n    Deserialize a slice from its JSON representation.\n    */\n    static fromJSON(schema, json) {\n        if (!json)\n            return Slice.empty;\n        let openStart = json.openStart || 0, openEnd = json.openEnd || 0;\n        if (typeof openStart != \"number\" || typeof openEnd != \"number\")\n            throw new RangeError(\"Invalid input for Slice.fromJSON\");\n        return new Slice(Fragment.fromJSON(schema, json.content), openStart, openEnd);\n    }\n    /**\n    Create a slice from a fragment by taking the maximum possible\n    open value on both side of the fragment.\n    */\n    static maxOpen(fragment, openIsolating = true) {\n        let openStart = 0, openEnd = 0;\n        for (let n = fragment.firstChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.firstChild)\n            openStart++;\n        for (let n = fragment.lastChild; n && !n.isLeaf && (openIsolating || !n.type.spec.isolating); n = n.lastChild)\n            openEnd++;\n        return new Slice(fragment, openStart, openEnd);\n    }\n}\n/**\nThe empty slice.\n*/\nSlice.empty = new Slice(Fragment.empty, 0, 0);\nfunction removeRange(content, from, to) {\n    let { index, offset } = content.findIndex(from), child = content.maybeChild(index);\n    let { index: indexTo, offset: offsetTo } = content.findIndex(to);\n    if (offset == from || child.isText) {\n        if (offsetTo != to && !content.child(indexTo).isText)\n            throw new RangeError(\"Removing non-flat range\");\n        return content.cut(0, from).append(content.cut(to));\n    }\n    if (index != indexTo)\n        throw new RangeError(\"Removing non-flat range\");\n    return content.replaceChild(index, child.copy(removeRange(child.content, from - offset - 1, to - offset - 1)));\n}\nfunction insertInto(content, dist, insert, parent) {\n    let { index, offset } = content.findIndex(dist), child = content.maybeChild(index);\n    if (offset == dist || child.isText) {\n        if (parent && !parent.canReplace(index, index, insert))\n            return null;\n        return content.cut(0, dist).append(insert).append(content.cut(dist));\n    }\n    let inner = insertInto(child.content, dist - offset - 1, insert, child);\n    return inner && content.replaceChild(index, child.copy(inner));\n}\nfunction replace($from, $to, slice) {\n    if (slice.openStart > $from.depth)\n        throw new ReplaceError(\"Inserted content deeper than insertion position\");\n    if ($from.depth - slice.openStart != $to.depth - slice.openEnd)\n        throw new ReplaceError(\"Inconsistent open depths\");\n    return replaceOuter($from, $to, slice, 0);\n}\nfunction replaceOuter($from, $to, slice, depth) {\n    let index = $from.index(depth), node = $from.node(depth);\n    if (index == $to.index(depth) && depth < $from.depth - slice.openStart) {\n        let inner = replaceOuter($from, $to, slice, depth + 1);\n        return node.copy(node.content.replaceChild(index, inner));\n    }\n    else if (!slice.content.size) {\n        return close(node, replaceTwoWay($from, $to, depth));\n    }\n    else if (!slice.openStart && !slice.openEnd && $from.depth == depth && $to.depth == depth) { // Simple, flat case\n        let parent = $from.parent, content = parent.content;\n        return close(parent, content.cut(0, $from.parentOffset).append(slice.content).append(content.cut($to.parentOffset)));\n    }\n    else {\n        let { start, end } = prepareSliceForReplace(slice, $from);\n        return close(node, replaceThreeWay($from, start, end, $to, depth));\n    }\n}\nfunction checkJoin(main, sub) {\n    if (!sub.type.compatibleContent(main.type))\n        throw new ReplaceError(\"Cannot join \" + sub.type.name + \" onto \" + main.type.name);\n}\nfunction joinable($before, $after, depth) {\n    let node = $before.node(depth);\n    checkJoin(node, $after.node(depth));\n    return node;\n}\nfunction addNode(child, target) {\n    let last = target.length - 1;\n    if (last >= 0 && child.isText && child.sameMarkup(target[last]))\n        target[last] = child.withText(target[last].text + child.text);\n    else\n        target.push(child);\n}\nfunction addRange($start, $end, depth, target) {\n    let node = ($end || $start).node(depth);\n    let startIndex = 0, endIndex = $end ? $end.index(depth) : node.childCount;\n    if ($start) {\n        startIndex = $start.index(depth);\n        if ($start.depth > depth) {\n            startIndex++;\n        }\n        else if ($start.textOffset) {\n            addNode($start.nodeAfter, target);\n            startIndex++;\n        }\n    }\n    for (let i = startIndex; i < endIndex; i++)\n        addNode(node.child(i), target);\n    if ($end && $end.depth == depth && $end.textOffset)\n        addNode($end.nodeBefore, target);\n}\nfunction close(node, content) {\n    node.type.checkContent(content);\n    return node.copy(content);\n}\nfunction replaceThreeWay($from, $start, $end, $to, depth) {\n    let openStart = $from.depth > depth && joinable($from, $start, depth + 1);\n    let openEnd = $to.depth > depth && joinable($end, $to, depth + 1);\n    let content = [];\n    addRange(null, $from, depth, content);\n    if (openStart && openEnd && $start.index(depth) == $end.index(depth)) {\n        checkJoin(openStart, openEnd);\n        addNode(close(openStart, replaceThreeWay($from, $start, $end, $to, depth + 1)), content);\n    }\n    else {\n        if (openStart)\n            addNode(close(openStart, replaceTwoWay($from, $start, depth + 1)), content);\n        addRange($start, $end, depth, content);\n        if (openEnd)\n            addNode(close(openEnd, replaceTwoWay($end, $to, depth + 1)), content);\n    }\n    addRange($to, null, depth, content);\n    return new Fragment(content);\n}\nfunction replaceTwoWay($from, $to, depth) {\n    let content = [];\n    addRange(null, $from, depth, content);\n    if ($from.depth > depth) {\n        let type = joinable($from, $to, depth + 1);\n        addNode(close(type, replaceTwoWay($from, $to, depth + 1)), content);\n    }\n    addRange($to, null, depth, content);\n    return new Fragment(content);\n}\nfunction prepareSliceForReplace(slice, $along) {\n    let extra = $along.depth - slice.openStart, parent = $along.node(extra);\n    let node = parent.copy(slice.content);\n    for (let i = extra - 1; i >= 0; i--)\n        node = $along.node(i).copy(Fragment.from(node));\n    return { start: node.resolveNoCache(slice.openStart + extra),\n        end: node.resolveNoCache(node.content.size - slice.openEnd - extra) };\n}\n\n/**\nYou can [_resolve_](https://prosemirror.net/docs/ref/#model.Node.resolve) a position to get more\ninformation about it. Objects of this class represent such a\nresolved position, providing various pieces of context\ninformation, and some helper methods.\n\nThroughout this interface, methods that take an optional `depth`\nparameter will interpret undefined as `this.depth` and negative\nnumbers as `this.depth + value`.\n*/\nclass ResolvedPos {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The position that was resolved.\n    */\n    pos, \n    /**\n    @internal\n    */\n    path, \n    /**\n    The offset this position has into its parent node.\n    */\n    parentOffset) {\n        this.pos = pos;\n        this.path = path;\n        this.parentOffset = parentOffset;\n        this.depth = path.length / 3 - 1;\n    }\n    /**\n    @internal\n    */\n    resolveDepth(val) {\n        if (val == null)\n            return this.depth;\n        if (val < 0)\n            return this.depth + val;\n        return val;\n    }\n    /**\n    The parent node that the position points into. Note that even if\n    a position points into a text node, that node is not considered\n    the parent—text nodes are ‘flat’ in this model, and have no content.\n    */\n    get parent() { return this.node(this.depth); }\n    /**\n    The root node in which the position was resolved.\n    */\n    get doc() { return this.node(0); }\n    /**\n    The ancestor node at the given level. `p.node(p.depth)` is the\n    same as `p.parent`.\n    */\n    node(depth) { return this.path[this.resolveDepth(depth) * 3]; }\n    /**\n    The index into the ancestor at the given level. If this points\n    at the 3rd node in the 2nd paragraph on the top level, for\n    example, `p.index(0)` is 1 and `p.index(1)` is 2.\n    */\n    index(depth) { return this.path[this.resolveDepth(depth) * 3 + 1]; }\n    /**\n    The index pointing after this position into the ancestor at the\n    given level.\n    */\n    indexAfter(depth) {\n        depth = this.resolveDepth(depth);\n        return this.index(depth) + (depth == this.depth && !this.textOffset ? 0 : 1);\n    }\n    /**\n    The (absolute) position at the start of the node at the given\n    level.\n    */\n    start(depth) {\n        depth = this.resolveDepth(depth);\n        return depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;\n    }\n    /**\n    The (absolute) position at the end of the node at the given\n    level.\n    */\n    end(depth) {\n        depth = this.resolveDepth(depth);\n        return this.start(depth) + this.node(depth).content.size;\n    }\n    /**\n    The (absolute) position directly before the wrapping node at the\n    given level, or, when `depth` is `this.depth + 1`, the original\n    position.\n    */\n    before(depth) {\n        depth = this.resolveDepth(depth);\n        if (!depth)\n            throw new RangeError(\"There is no position before the top-level node\");\n        return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1];\n    }\n    /**\n    The (absolute) position directly after the wrapping node at the\n    given level, or the original position when `depth` is `this.depth + 1`.\n    */\n    after(depth) {\n        depth = this.resolveDepth(depth);\n        if (!depth)\n            throw new RangeError(\"There is no position after the top-level node\");\n        return depth == this.depth + 1 ? this.pos : this.path[depth * 3 - 1] + this.path[depth * 3].nodeSize;\n    }\n    /**\n    When this position points into a text node, this returns the\n    distance between the position and the start of the text node.\n    Will be zero for positions that point between nodes.\n    */\n    get textOffset() { return this.pos - this.path[this.path.length - 1]; }\n    /**\n    Get the node directly after the position, if any. If the position\n    points into a text node, only the part of that node after the\n    position is returned.\n    */\n    get nodeAfter() {\n        let parent = this.parent, index = this.index(this.depth);\n        if (index == parent.childCount)\n            return null;\n        let dOff = this.pos - this.path[this.path.length - 1], child = parent.child(index);\n        return dOff ? parent.child(index).cut(dOff) : child;\n    }\n    /**\n    Get the node directly before the position, if any. If the\n    position points into a text node, only the part of that node\n    before the position is returned.\n    */\n    get nodeBefore() {\n        let index = this.index(this.depth);\n        let dOff = this.pos - this.path[this.path.length - 1];\n        if (dOff)\n            return this.parent.child(index).cut(0, dOff);\n        return index == 0 ? null : this.parent.child(index - 1);\n    }\n    /**\n    Get the position at the given index in the parent node at the\n    given depth (which defaults to `this.depth`).\n    */\n    posAtIndex(index, depth) {\n        depth = this.resolveDepth(depth);\n        let node = this.path[depth * 3], pos = depth == 0 ? 0 : this.path[depth * 3 - 1] + 1;\n        for (let i = 0; i < index; i++)\n            pos += node.child(i).nodeSize;\n        return pos;\n    }\n    /**\n    Get the marks at this position, factoring in the surrounding\n    marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the\n    position is at the start of a non-empty node, the marks of the\n    node after it (if any) are returned.\n    */\n    marks() {\n        let parent = this.parent, index = this.index();\n        // In an empty parent, return the empty array\n        if (parent.content.size == 0)\n            return Mark.none;\n        // When inside a text node, just return the text node's marks\n        if (this.textOffset)\n            return parent.child(index).marks;\n        let main = parent.maybeChild(index - 1), other = parent.maybeChild(index);\n        // If the `after` flag is true of there is no node before, make\n        // the node after this position the main reference.\n        if (!main) {\n            let tmp = main;\n            main = other;\n            other = tmp;\n        }\n        // Use all marks in the main node, except those that have\n        // `inclusive` set to false and are not present in the other node.\n        let marks = main.marks;\n        for (var i = 0; i < marks.length; i++)\n            if (marks[i].type.spec.inclusive === false && (!other || !marks[i].isInSet(other.marks)))\n                marks = marks[i--].removeFromSet(marks);\n        return marks;\n    }\n    /**\n    Get the marks after the current position, if any, except those\n    that are non-inclusive and not present at position `$end`. This\n    is mostly useful for getting the set of marks to preserve after a\n    deletion. Will return `null` if this position is at the end of\n    its parent node or its parent node isn't a textblock (in which\n    case no marks should be preserved).\n    */\n    marksAcross($end) {\n        let after = this.parent.maybeChild(this.index());\n        if (!after || !after.isInline)\n            return null;\n        let marks = after.marks, next = $end.parent.maybeChild($end.index());\n        for (var i = 0; i < marks.length; i++)\n            if (marks[i].type.spec.inclusive === false && (!next || !marks[i].isInSet(next.marks)))\n                marks = marks[i--].removeFromSet(marks);\n        return marks;\n    }\n    /**\n    The depth up to which this position and the given (non-resolved)\n    position share the same parent nodes.\n    */\n    sharedDepth(pos) {\n        for (let depth = this.depth; depth > 0; depth--)\n            if (this.start(depth) <= pos && this.end(depth) >= pos)\n                return depth;\n        return 0;\n    }\n    /**\n    Returns a range based on the place where this position and the\n    given position diverge around block content. If both point into\n    the same textblock, for example, a range around that textblock\n    will be returned. If they point into different blocks, the range\n    around those blocks in their shared ancestor is returned. You can\n    pass in an optional predicate that will be called with a parent\n    node to see if a range into that parent is acceptable.\n    */\n    blockRange(other = this, pred) {\n        if (other.pos < this.pos)\n            return other.blockRange(this);\n        for (let d = this.depth - (this.parent.inlineContent || this.pos == other.pos ? 1 : 0); d >= 0; d--)\n            if (other.pos <= this.end(d) && (!pred || pred(this.node(d))))\n                return new NodeRange(this, other, d);\n        return null;\n    }\n    /**\n    Query whether the given position shares the same parent node.\n    */\n    sameParent(other) {\n        return this.pos - this.parentOffset == other.pos - other.parentOffset;\n    }\n    /**\n    Return the greater of this and the given position.\n    */\n    max(other) {\n        return other.pos > this.pos ? other : this;\n    }\n    /**\n    Return the smaller of this and the given position.\n    */\n    min(other) {\n        return other.pos < this.pos ? other : this;\n    }\n    /**\n    @internal\n    */\n    toString() {\n        let str = \"\";\n        for (let i = 1; i <= this.depth; i++)\n            str += (str ? \"/\" : \"\") + this.node(i).type.name + \"_\" + this.index(i - 1);\n        return str + \":\" + this.parentOffset;\n    }\n    /**\n    @internal\n    */\n    static resolve(doc, pos) {\n        if (!(pos >= 0 && pos <= doc.content.size))\n            throw new RangeError(\"Position \" + pos + \" out of range\");\n        let path = [];\n        let start = 0, parentOffset = pos;\n        for (let node = doc;;) {\n            let { index, offset } = node.content.findIndex(parentOffset);\n            let rem = parentOffset - offset;\n            path.push(node, index, start + offset);\n            if (!rem)\n                break;\n            node = node.child(index);\n            if (node.isText)\n                break;\n            parentOffset = rem - 1;\n            start += offset + 1;\n        }\n        return new ResolvedPos(pos, path, parentOffset);\n    }\n    /**\n    @internal\n    */\n    static resolveCached(doc, pos) {\n        let cache = resolveCache.get(doc);\n        if (cache) {\n            for (let i = 0; i < cache.elts.length; i++) {\n                let elt = cache.elts[i];\n                if (elt.pos == pos)\n                    return elt;\n            }\n        }\n        else {\n            resolveCache.set(doc, cache = new ResolveCache);\n        }\n        let result = cache.elts[cache.i] = ResolvedPos.resolve(doc, pos);\n        cache.i = (cache.i + 1) % resolveCacheSize;\n        return result;\n    }\n}\nclass ResolveCache {\n    constructor() {\n        this.elts = [];\n        this.i = 0;\n    }\n}\nconst resolveCacheSize = 12, resolveCache = new WeakMap();\n/**\nRepresents a flat range of content, i.e. one that starts and\nends in the same node.\n*/\nclass NodeRange {\n    /**\n    Construct a node range. `$from` and `$to` should point into the\n    same node until at least the given `depth`, since a node range\n    denotes an adjacent set of nodes in a single parent node.\n    */\n    constructor(\n    /**\n    A resolved position along the start of the content. May have a\n    `depth` greater than this object's `depth` property, since\n    these are the positions that were used to compute the range,\n    not re-resolved positions directly at its boundaries.\n    */\n    $from, \n    /**\n    A position along the end of the content. See\n    caveat for [`$from`](https://prosemirror.net/docs/ref/#model.NodeRange.$from).\n    */\n    $to, \n    /**\n    The depth of the node that this range points into.\n    */\n    depth) {\n        this.$from = $from;\n        this.$to = $to;\n        this.depth = depth;\n    }\n    /**\n    The position at the start of the range.\n    */\n    get start() { return this.$from.before(this.depth + 1); }\n    /**\n    The position at the end of the range.\n    */\n    get end() { return this.$to.after(this.depth + 1); }\n    /**\n    The parent node that the range points into.\n    */\n    get parent() { return this.$from.node(this.depth); }\n    /**\n    The start index of the range in the parent node.\n    */\n    get startIndex() { return this.$from.index(this.depth); }\n    /**\n    The end index of the range in the parent node.\n    */\n    get endIndex() { return this.$to.indexAfter(this.depth); }\n}\n\nconst emptyAttrs = Object.create(null);\n/**\nThis class represents a node in the tree that makes up a\nProseMirror document. So a document is an instance of `Node`, with\nchildren that are also instances of `Node`.\n\nNodes are persistent data structures. Instead of changing them, you\ncreate new ones with the content you want. Old ones keep pointing\nat the old document shape. This is made cheaper by sharing\nstructure between the old and new data as much as possible, which a\ntree shape like this (without back pointers) makes easy.\n\n**Do not** directly mutate the properties of a `Node` object. See\n[the guide](https://prosemirror.net/docs/guide/#doc) for more information.\n*/\nclass Node {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The type of node that this is.\n    */\n    type, \n    /**\n    An object mapping attribute names to values. The kind of\n    attributes allowed and required are\n    [determined](https://prosemirror.net/docs/ref/#model.NodeSpec.attrs) by the node type.\n    */\n    attrs, \n    // A fragment holding the node's children.\n    content, \n    /**\n    The marks (things like whether it is emphasized or part of a\n    link) applied to this node.\n    */\n    marks = Mark.none) {\n        this.type = type;\n        this.attrs = attrs;\n        this.marks = marks;\n        this.content = content || Fragment.empty;\n    }\n    /**\n    The array of this node's child nodes.\n    */\n    get children() { return this.content.content; }\n    /**\n    The size of this node, as defined by the integer-based [indexing\n    scheme](https://prosemirror.net/docs/guide/#doc.indexing). For text nodes, this is the\n    amount of characters. For other leaf nodes, it is one. For\n    non-leaf nodes, it is the size of the content plus two (the\n    start and end token).\n    */\n    get nodeSize() { return this.isLeaf ? 1 : 2 + this.content.size; }\n    /**\n    The number of children that the node has.\n    */\n    get childCount() { return this.content.childCount; }\n    /**\n    Get the child node at the given index. Raises an error when the\n    index is out of range.\n    */\n    child(index) { return this.content.child(index); }\n    /**\n    Get the child node at the given index, if it exists.\n    */\n    maybeChild(index) { return this.content.maybeChild(index); }\n    /**\n    Call `f` for every child node, passing the node, its offset\n    into this parent node, and its index.\n    */\n    forEach(f) { this.content.forEach(f); }\n    /**\n    Invoke a callback for all descendant nodes recursively between\n    the given two positions that are relative to start of this\n    node's content. The callback is invoked with the node, its\n    position relative to the original node (method receiver),\n    its parent node, and its child index. When the callback returns\n    false for a given node, that node's children will not be\n    recursed over. The last parameter can be used to specify a\n    starting position to count from.\n    */\n    nodesBetween(from, to, f, startPos = 0) {\n        this.content.nodesBetween(from, to, f, startPos, this);\n    }\n    /**\n    Call the given callback for every descendant node. Doesn't\n    descend into a node when the callback returns `false`.\n    */\n    descendants(f) {\n        this.nodesBetween(0, this.content.size, f);\n    }\n    /**\n    Concatenates all the text nodes found in this fragment and its\n    children.\n    */\n    get textContent() {\n        return (this.isLeaf && this.type.spec.leafText)\n            ? this.type.spec.leafText(this)\n            : this.textBetween(0, this.content.size, \"\");\n    }\n    /**\n    Get all text between positions `from` and `to`. When\n    `blockSeparator` is given, it will be inserted to separate text\n    from different block nodes. If `leafText` is given, it'll be\n    inserted for every non-text leaf node encountered, otherwise\n    [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec.leafText) will be used.\n    */\n    textBetween(from, to, blockSeparator, leafText) {\n        return this.content.textBetween(from, to, blockSeparator, leafText);\n    }\n    /**\n    Returns this node's first child, or `null` if there are no\n    children.\n    */\n    get firstChild() { return this.content.firstChild; }\n    /**\n    Returns this node's last child, or `null` if there are no\n    children.\n    */\n    get lastChild() { return this.content.lastChild; }\n    /**\n    Test whether two nodes represent the same piece of document.\n    */\n    eq(other) {\n        return this == other || (this.sameMarkup(other) && this.content.eq(other.content));\n    }\n    /**\n    Compare the markup (type, attributes, and marks) of this node to\n    those of another. Returns `true` if both have the same markup.\n    */\n    sameMarkup(other) {\n        return this.hasMarkup(other.type, other.attrs, other.marks);\n    }\n    /**\n    Check whether this node's markup correspond to the given type,\n    attributes, and marks.\n    */\n    hasMarkup(type, attrs, marks) {\n        return this.type == type &&\n            compareDeep(this.attrs, attrs || type.defaultAttrs || emptyAttrs) &&\n            Mark.sameSet(this.marks, marks || Mark.none);\n    }\n    /**\n    Create a new node with the same markup as this node, containing\n    the given content (or empty, if no content is given).\n    */\n    copy(content = null) {\n        if (content == this.content)\n            return this;\n        return new Node(this.type, this.attrs, content, this.marks);\n    }\n    /**\n    Create a copy of this node, with the given set of marks instead\n    of the node's own marks.\n    */\n    mark(marks) {\n        return marks == this.marks ? this : new Node(this.type, this.attrs, this.content, marks);\n    }\n    /**\n    Create a copy of this node with only the content between the\n    given positions. If `to` is not given, it defaults to the end of\n    the node.\n    */\n    cut(from, to = this.content.size) {\n        if (from == 0 && to == this.content.size)\n            return this;\n        return this.copy(this.content.cut(from, to));\n    }\n    /**\n    Cut out the part of the document between the given positions, and\n    return it as a `Slice` object.\n    */\n    slice(from, to = this.content.size, includeParents = false) {\n        if (from == to)\n            return Slice.empty;\n        let $from = this.resolve(from), $to = this.resolve(to);\n        let depth = includeParents ? 0 : $from.sharedDepth(to);\n        let start = $from.start(depth), node = $from.node(depth);\n        let content = node.content.cut($from.pos - start, $to.pos - start);\n        return new Slice(content, $from.depth - depth, $to.depth - depth);\n    }\n    /**\n    Replace the part of the document between the given positions with\n    the given slice. The slice must 'fit', meaning its open sides\n    must be able to connect to the surrounding content, and its\n    content nodes must be valid children for the node they are placed\n    into. If any of this is violated, an error of type\n    [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.\n    */\n    replace(from, to, slice) {\n        return replace(this.resolve(from), this.resolve(to), slice);\n    }\n    /**\n    Find the node directly after the given position.\n    */\n    nodeAt(pos) {\n        for (let node = this;;) {\n            let { index, offset } = node.content.findIndex(pos);\n            node = node.maybeChild(index);\n            if (!node)\n                return null;\n            if (offset == pos || node.isText)\n                return node;\n            pos -= offset + 1;\n        }\n    }\n    /**\n    Find the (direct) child node after the given offset, if any,\n    and return it along with its index and offset relative to this\n    node.\n    */\n    childAfter(pos) {\n        let { index, offset } = this.content.findIndex(pos);\n        return { node: this.content.maybeChild(index), index, offset };\n    }\n    /**\n    Find the (direct) child node before the given offset, if any,\n    and return it along with its index and offset relative to this\n    node.\n    */\n    childBefore(pos) {\n        if (pos == 0)\n            return { node: null, index: 0, offset: 0 };\n        let { index, offset } = this.content.findIndex(pos);\n        if (offset < pos)\n            return { node: this.content.child(index), index, offset };\n        let node = this.content.child(index - 1);\n        return { node, index: index - 1, offset: offset - node.nodeSize };\n    }\n    /**\n    Resolve the given position in the document, returning an\n    [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.\n    */\n    resolve(pos) { return ResolvedPos.resolveCached(this, pos); }\n    /**\n    @internal\n    */\n    resolveNoCache(pos) { return ResolvedPos.resolve(this, pos); }\n    /**\n    Test whether a given mark or mark type occurs in this document\n    between the two given positions.\n    */\n    rangeHasMark(from, to, type) {\n        let found = false;\n        if (to > from)\n            this.nodesBetween(from, to, node => {\n                if (type.isInSet(node.marks))\n                    found = true;\n                return !found;\n            });\n        return found;\n    }\n    /**\n    True when this is a block (non-inline node)\n    */\n    get isBlock() { return this.type.isBlock; }\n    /**\n    True when this is a textblock node, a block node with inline\n    content.\n    */\n    get isTextblock() { return this.type.isTextblock; }\n    /**\n    True when this node allows inline content.\n    */\n    get inlineContent() { return this.type.inlineContent; }\n    /**\n    True when this is an inline node (a text node or a node that can\n    appear among text).\n    */\n    get isInline() { return this.type.isInline; }\n    /**\n    True when this is a text node.\n    */\n    get isText() { return this.type.isText; }\n    /**\n    True when this is a leaf node.\n    */\n    get isLeaf() { return this.type.isLeaf; }\n    /**\n    True when this is an atom, i.e. when it does not have directly\n    editable content. This is usually the same as `isLeaf`, but can\n    be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)\n    on a node's spec (typically used when the node is displayed as\n    an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).\n    */\n    get isAtom() { return this.type.isAtom; }\n    /**\n    Return a string representation of this node for debugging\n    purposes.\n    */\n    toString() {\n        if (this.type.spec.toDebugString)\n            return this.type.spec.toDebugString(this);\n        let name = this.type.name;\n        if (this.content.size)\n            name += \"(\" + this.content.toStringInner() + \")\";\n        return wrapMarks(this.marks, name);\n    }\n    /**\n    Get the content match in this node at the given index.\n    */\n    contentMatchAt(index) {\n        let match = this.type.contentMatch.matchFragment(this.content, 0, index);\n        if (!match)\n            throw new Error(\"Called contentMatchAt on a node with invalid content\");\n        return match;\n    }\n    /**\n    Test whether replacing the range between `from` and `to` (by\n    child index) with the given replacement fragment (which defaults\n    to the empty fragment) would leave the node's content valid. You\n    can optionally pass `start` and `end` indices into the\n    replacement fragment.\n    */\n    canReplace(from, to, replacement = Fragment.empty, start = 0, end = replacement.childCount) {\n        let one = this.contentMatchAt(from).matchFragment(replacement, start, end);\n        let two = one && one.matchFragment(this.content, to);\n        if (!two || !two.validEnd)\n            return false;\n        for (let i = start; i < end; i++)\n            if (!this.type.allowsMarks(replacement.child(i).marks))\n                return false;\n        return true;\n    }\n    /**\n    Test whether replacing the range `from` to `to` (by index) with\n    a node of the given type would leave the node's content valid.\n    */\n    canReplaceWith(from, to, type, marks) {\n        if (marks && !this.type.allowsMarks(marks))\n            return false;\n        let start = this.contentMatchAt(from).matchType(type);\n        let end = start && start.matchFragment(this.content, to);\n        return end ? end.validEnd : false;\n    }\n    /**\n    Test whether the given node's content could be appended to this\n    node. If that node is empty, this will only return true if there\n    is at least one node type that can appear in both nodes (to avoid\n    merging completely incompatible nodes).\n    */\n    canAppend(other) {\n        if (other.content.size)\n            return this.canReplace(this.childCount, this.childCount, other.content);\n        else\n            return this.type.compatibleContent(other.type);\n    }\n    /**\n    Check whether this node and its descendants conform to the\n    schema, and raise an exception when they do not.\n    */\n    check() {\n        this.type.checkContent(this.content);\n        this.type.checkAttrs(this.attrs);\n        let copy = Mark.none;\n        for (let i = 0; i < this.marks.length; i++) {\n            let mark = this.marks[i];\n            mark.type.checkAttrs(mark.attrs);\n            copy = mark.addToSet(copy);\n        }\n        if (!Mark.sameSet(copy, this.marks))\n            throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map(m => m.type.name)}`);\n        this.content.forEach(node => node.check());\n    }\n    /**\n    Return a JSON-serializeable representation of this node.\n    */\n    toJSON() {\n        let obj = { type: this.type.name };\n        for (let _ in this.attrs) {\n            obj.attrs = this.attrs;\n            break;\n        }\n        if (this.content.size)\n            obj.content = this.content.toJSON();\n        if (this.marks.length)\n            obj.marks = this.marks.map(n => n.toJSON());\n        return obj;\n    }\n    /**\n    Deserialize a node from its JSON representation.\n    */\n    static fromJSON(schema, json) {\n        if (!json)\n            throw new RangeError(\"Invalid input for Node.fromJSON\");\n        let marks = undefined;\n        if (json.marks) {\n            if (!Array.isArray(json.marks))\n                throw new RangeError(\"Invalid mark data for Node.fromJSON\");\n            marks = json.marks.map(schema.markFromJSON);\n        }\n        if (json.type == \"text\") {\n            if (typeof json.text != \"string\")\n                throw new RangeError(\"Invalid text node in JSON\");\n            return schema.text(json.text, marks);\n        }\n        let content = Fragment.fromJSON(schema, json.content);\n        let node = schema.nodeType(json.type).create(json.attrs, content, marks);\n        node.type.checkAttrs(node.attrs);\n        return node;\n    }\n}\nNode.prototype.text = undefined;\nclass TextNode extends Node {\n    /**\n    @internal\n    */\n    constructor(type, attrs, content, marks) {\n        super(type, attrs, null, marks);\n        if (!content)\n            throw new RangeError(\"Empty text nodes are not allowed\");\n        this.text = content;\n    }\n    toString() {\n        if (this.type.spec.toDebugString)\n            return this.type.spec.toDebugString(this);\n        return wrapMarks(this.marks, JSON.stringify(this.text));\n    }\n    get textContent() { return this.text; }\n    textBetween(from, to) { return this.text.slice(from, to); }\n    get nodeSize() { return this.text.length; }\n    mark(marks) {\n        return marks == this.marks ? this : new TextNode(this.type, this.attrs, this.text, marks);\n    }\n    withText(text) {\n        if (text == this.text)\n            return this;\n        return new TextNode(this.type, this.attrs, text, this.marks);\n    }\n    cut(from = 0, to = this.text.length) {\n        if (from == 0 && to == this.text.length)\n            return this;\n        return this.withText(this.text.slice(from, to));\n    }\n    eq(other) {\n        return this.sameMarkup(other) && this.text == other.text;\n    }\n    toJSON() {\n        let base = super.toJSON();\n        base.text = this.text;\n        return base;\n    }\n}\nfunction wrapMarks(marks, str) {\n    for (let i = marks.length - 1; i >= 0; i--)\n        str = marks[i].type.name + \"(\" + str + \")\";\n    return str;\n}\n\n/**\nInstances of this class represent a match state of a node type's\n[content expression](https://prosemirror.net/docs/ref/#model.NodeSpec.content), and can be used to\nfind out whether further content matches here, and whether a given\nposition is a valid end of the node.\n*/\nclass ContentMatch {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    True when this match state represents a valid end of the node.\n    */\n    validEnd) {\n        this.validEnd = validEnd;\n        /**\n        @internal\n        */\n        this.next = [];\n        /**\n        @internal\n        */\n        this.wrapCache = [];\n    }\n    /**\n    @internal\n    */\n    static parse(string, nodeTypes) {\n        let stream = new TokenStream(string, nodeTypes);\n        if (stream.next == null)\n            return ContentMatch.empty;\n        let expr = parseExpr(stream);\n        if (stream.next)\n            stream.err(\"Unexpected trailing text\");\n        let match = dfa(nfa(expr));\n        checkForDeadEnds(match, stream);\n        return match;\n    }\n    /**\n    Match a node type, returning a match after that node if\n    successful.\n    */\n    matchType(type) {\n        for (let i = 0; i < this.next.length; i++)\n            if (this.next[i].type == type)\n                return this.next[i].next;\n        return null;\n    }\n    /**\n    Try to match a fragment. Returns the resulting match when\n    successful.\n    */\n    matchFragment(frag, start = 0, end = frag.childCount) {\n        let cur = this;\n        for (let i = start; cur && i < end; i++)\n            cur = cur.matchType(frag.child(i).type);\n        return cur;\n    }\n    /**\n    @internal\n    */\n    get inlineContent() {\n        return this.next.length != 0 && this.next[0].type.isInline;\n    }\n    /**\n    Get the first matching node type at this match position that can\n    be generated.\n    */\n    get defaultType() {\n        for (let i = 0; i < this.next.length; i++) {\n            let { type } = this.next[i];\n            if (!(type.isText || type.hasRequiredAttrs()))\n                return type;\n        }\n        return null;\n    }\n    /**\n    @internal\n    */\n    compatible(other) {\n        for (let i = 0; i < this.next.length; i++)\n            for (let j = 0; j < other.next.length; j++)\n                if (this.next[i].type == other.next[j].type)\n                    return true;\n        return false;\n    }\n    /**\n    Try to match the given fragment, and if that fails, see if it can\n    be made to match by inserting nodes in front of it. When\n    successful, return a fragment of inserted nodes (which may be\n    empty if nothing had to be inserted). When `toEnd` is true, only\n    return a fragment if the resulting match goes to the end of the\n    content expression.\n    */\n    fillBefore(after, toEnd = false, startIndex = 0) {\n        let seen = [this];\n        function search(match, types) {\n            let finished = match.matchFragment(after, startIndex);\n            if (finished && (!toEnd || finished.validEnd))\n                return Fragment.from(types.map(tp => tp.createAndFill()));\n            for (let i = 0; i < match.next.length; i++) {\n                let { type, next } = match.next[i];\n                if (!(type.isText || type.hasRequiredAttrs()) && seen.indexOf(next) == -1) {\n                    seen.push(next);\n                    let found = search(next, types.concat(type));\n                    if (found)\n                        return found;\n                }\n            }\n            return null;\n        }\n        return search(this, []);\n    }\n    /**\n    Find a set of wrapping node types that would allow a node of the\n    given type to appear at this position. The result may be empty\n    (when it fits directly) and will be null when no such wrapping\n    exists.\n    */\n    findWrapping(target) {\n        for (let i = 0; i < this.wrapCache.length; i += 2)\n            if (this.wrapCache[i] == target)\n                return this.wrapCache[i + 1];\n        let computed = this.computeWrapping(target);\n        this.wrapCache.push(target, computed);\n        return computed;\n    }\n    /**\n    @internal\n    */\n    computeWrapping(target) {\n        let seen = Object.create(null), active = [{ match: this, type: null, via: null }];\n        while (active.length) {\n            let current = active.shift(), match = current.match;\n            if (match.matchType(target)) {\n                let result = [];\n                for (let obj = current; obj.type; obj = obj.via)\n                    result.push(obj.type);\n                return result.reverse();\n            }\n            for (let i = 0; i < match.next.length; i++) {\n                let { type, next } = match.next[i];\n                if (!type.isLeaf && !type.hasRequiredAttrs() && !(type.name in seen) && (!current.type || next.validEnd)) {\n                    active.push({ match: type.contentMatch, type, via: current });\n                    seen[type.name] = true;\n                }\n            }\n        }\n        return null;\n    }\n    /**\n    The number of outgoing edges this node has in the finite\n    automaton that describes the content expression.\n    */\n    get edgeCount() {\n        return this.next.length;\n    }\n    /**\n    Get the _n_​th outgoing edge from this node in the finite\n    automaton that describes the content expression.\n    */\n    edge(n) {\n        if (n >= this.next.length)\n            throw new RangeError(`There's no ${n}th edge in this content match`);\n        return this.next[n];\n    }\n    /**\n    @internal\n    */\n    toString() {\n        let seen = [];\n        function scan(m) {\n            seen.push(m);\n            for (let i = 0; i < m.next.length; i++)\n                if (seen.indexOf(m.next[i].next) == -1)\n                    scan(m.next[i].next);\n        }\n        scan(this);\n        return seen.map((m, i) => {\n            let out = i + (m.validEnd ? \"*\" : \" \") + \" \";\n            for (let i = 0; i < m.next.length; i++)\n                out += (i ? \", \" : \"\") + m.next[i].type.name + \"->\" + seen.indexOf(m.next[i].next);\n            return out;\n        }).join(\"\\n\");\n    }\n}\n/**\n@internal\n*/\nContentMatch.empty = new ContentMatch(true);\nclass TokenStream {\n    constructor(string, nodeTypes) {\n        this.string = string;\n        this.nodeTypes = nodeTypes;\n        this.inline = null;\n        this.pos = 0;\n        this.tokens = string.split(/\\s*(?=\\b|\\W|$)/);\n        if (this.tokens[this.tokens.length - 1] == \"\")\n            this.tokens.pop();\n        if (this.tokens[0] == \"\")\n            this.tokens.shift();\n    }\n    get next() { return this.tokens[this.pos]; }\n    eat(tok) { return this.next == tok && (this.pos++ || true); }\n    err(str) { throw new SyntaxError(str + \" (in content expression '\" + this.string + \"')\"); }\n}\nfunction parseExpr(stream) {\n    let exprs = [];\n    do {\n        exprs.push(parseExprSeq(stream));\n    } while (stream.eat(\"|\"));\n    return exprs.length == 1 ? exprs[0] : { type: \"choice\", exprs };\n}\nfunction parseExprSeq(stream) {\n    let exprs = [];\n    do {\n        exprs.push(parseExprSubscript(stream));\n    } while (stream.next && stream.next != \")\" && stream.next != \"|\");\n    return exprs.length == 1 ? exprs[0] : { type: \"seq\", exprs };\n}\nfunction parseExprSubscript(stream) {\n    let expr = parseExprAtom(stream);\n    for (;;) {\n        if (stream.eat(\"+\"))\n            expr = { type: \"plus\", expr };\n        else if (stream.eat(\"*\"))\n            expr = { type: \"star\", expr };\n        else if (stream.eat(\"?\"))\n            expr = { type: \"opt\", expr };\n        else if (stream.eat(\"{\"))\n            expr = parseExprRange(stream, expr);\n        else\n            break;\n    }\n    return expr;\n}\nfunction parseNum(stream) {\n    if (/\\D/.test(stream.next))\n        stream.err(\"Expected number, got '\" + stream.next + \"'\");\n    let result = Number(stream.next);\n    stream.pos++;\n    return result;\n}\nfunction parseExprRange(stream, expr) {\n    let min = parseNum(stream), max = min;\n    if (stream.eat(\",\")) {\n        if (stream.next != \"}\")\n            max = parseNum(stream);\n        else\n            max = -1;\n    }\n    if (!stream.eat(\"}\"))\n        stream.err(\"Unclosed braced range\");\n    return { type: \"range\", min, max, expr };\n}\nfunction resolveName(stream, name) {\n    let types = stream.nodeTypes, type = types[name];\n    if (type)\n        return [type];\n    let result = [];\n    for (let typeName in types) {\n        let type = types[typeName];\n        if (type.isInGroup(name))\n            result.push(type);\n    }\n    if (result.length == 0)\n        stream.err(\"No node type or group '\" + name + \"' found\");\n    return result;\n}\nfunction parseExprAtom(stream) {\n    if (stream.eat(\"(\")) {\n        let expr = parseExpr(stream);\n        if (!stream.eat(\")\"))\n            stream.err(\"Missing closing paren\");\n        return expr;\n    }\n    else if (!/\\W/.test(stream.next)) {\n        let exprs = resolveName(stream, stream.next).map(type => {\n            if (stream.inline == null)\n                stream.inline = type.isInline;\n            else if (stream.inline != type.isInline)\n                stream.err(\"Mixing inline and block content\");\n            return { type: \"name\", value: type };\n        });\n        stream.pos++;\n        return exprs.length == 1 ? exprs[0] : { type: \"choice\", exprs };\n    }\n    else {\n        stream.err(\"Unexpected token '\" + stream.next + \"'\");\n    }\n}\n// Construct an NFA from an expression as returned by the parser. The\n// NFA is represented as an array of states, which are themselves\n// arrays of edges, which are `{term, to}` objects. The first state is\n// the entry state and the last node is the success state.\n//\n// Note that unlike typical NFAs, the edge ordering in this one is\n// significant, in that it is used to contruct filler content when\n// necessary.\nfunction nfa(expr) {\n    let nfa = [[]];\n    connect(compile(expr, 0), node());\n    return nfa;\n    function node() { return nfa.push([]) - 1; }\n    function edge(from, to, term) {\n        let edge = { term, to };\n        nfa[from].push(edge);\n        return edge;\n    }\n    function connect(edges, to) {\n        edges.forEach(edge => edge.to = to);\n    }\n    function compile(expr, from) {\n        if (expr.type == \"choice\") {\n            return expr.exprs.reduce((out, expr) => out.concat(compile(expr, from)), []);\n        }\n        else if (expr.type == \"seq\") {\n            for (let i = 0;; i++) {\n                let next = compile(expr.exprs[i], from);\n                if (i == expr.exprs.length - 1)\n                    return next;\n                connect(next, from = node());\n            }\n        }\n        else if (expr.type == \"star\") {\n            let loop = node();\n            edge(from, loop);\n            connect(compile(expr.expr, loop), loop);\n            return [edge(loop)];\n        }\n        else if (expr.type == \"plus\") {\n            let loop = node();\n            connect(compile(expr.expr, from), loop);\n            connect(compile(expr.expr, loop), loop);\n            return [edge(loop)];\n        }\n        else if (expr.type == \"opt\") {\n            return [edge(from)].concat(compile(expr.expr, from));\n        }\n        else if (expr.type == \"range\") {\n            let cur = from;\n            for (let i = 0; i < expr.min; i++) {\n                let next = node();\n                connect(compile(expr.expr, cur), next);\n                cur = next;\n            }\n            if (expr.max == -1) {\n                connect(compile(expr.expr, cur), cur);\n            }\n            else {\n                for (let i = expr.min; i < expr.max; i++) {\n                    let next = node();\n                    edge(cur, next);\n                    connect(compile(expr.expr, cur), next);\n                    cur = next;\n                }\n            }\n            return [edge(cur)];\n        }\n        else if (expr.type == \"name\") {\n            return [edge(from, undefined, expr.value)];\n        }\n        else {\n            throw new Error(\"Unknown expr type\");\n        }\n    }\n}\nfunction cmp(a, b) { return b - a; }\n// Get the set of nodes reachable by null edges from `node`. Omit\n// nodes with only a single null-out-edge, since they may lead to\n// needless duplicated nodes.\nfunction nullFrom(nfa, node) {\n    let result = [];\n    scan(node);\n    return result.sort(cmp);\n    function scan(node) {\n        let edges = nfa[node];\n        if (edges.length == 1 && !edges[0].term)\n            return scan(edges[0].to);\n        result.push(node);\n        for (let i = 0; i < edges.length; i++) {\n            let { term, to } = edges[i];\n            if (!term && result.indexOf(to) == -1)\n                scan(to);\n        }\n    }\n}\n// Compiles an NFA as produced by `nfa` into a DFA, modeled as a set\n// of state objects (`ContentMatch` instances) with transitions\n// between them.\nfunction dfa(nfa) {\n    let labeled = Object.create(null);\n    return explore(nullFrom(nfa, 0));\n    function explore(states) {\n        let out = [];\n        states.forEach(node => {\n            nfa[node].forEach(({ term, to }) => {\n                if (!term)\n                    return;\n                let set;\n                for (let i = 0; i < out.length; i++)\n                    if (out[i][0] == term)\n                        set = out[i][1];\n                nullFrom(nfa, to).forEach(node => {\n                    if (!set)\n                        out.push([term, set = []]);\n                    if (set.indexOf(node) == -1)\n                        set.push(node);\n                });\n            });\n        });\n        let state = labeled[states.join(\",\")] = new ContentMatch(states.indexOf(nfa.length - 1) > -1);\n        for (let i = 0; i < out.length; i++) {\n            let states = out[i][1].sort(cmp);\n            state.next.push({ type: out[i][0], next: labeled[states.join(\",\")] || explore(states) });\n        }\n        return state;\n    }\n}\nfunction checkForDeadEnds(match, stream) {\n    for (let i = 0, work = [match]; i < work.length; i++) {\n        let state = work[i], dead = !state.validEnd, nodes = [];\n        for (let j = 0; j < state.next.length; j++) {\n            let { type, next } = state.next[j];\n            nodes.push(type.name);\n            if (dead && !(type.isText || type.hasRequiredAttrs()))\n                dead = false;\n            if (work.indexOf(next) == -1)\n                work.push(next);\n        }\n        if (dead)\n            stream.err(\"Only non-generatable nodes (\" + nodes.join(\", \") + \") in a required position (see https://prosemirror.net/docs/guide/#generatable)\");\n    }\n}\n\n// For node types where all attrs have a default value (or which don't\n// have any attributes), build up a single reusable default attribute\n// object, and use it for all nodes that don't specify specific\n// attributes.\nfunction defaultAttrs(attrs) {\n    let defaults = Object.create(null);\n    for (let attrName in attrs) {\n        let attr = attrs[attrName];\n        if (!attr.hasDefault)\n            return null;\n        defaults[attrName] = attr.default;\n    }\n    return defaults;\n}\nfunction computeAttrs(attrs, value) {\n    let built = Object.create(null);\n    for (let name in attrs) {\n        let given = value && value[name];\n        if (given === undefined) {\n            let attr = attrs[name];\n            if (attr.hasDefault)\n                given = attr.default;\n            else\n                throw new RangeError(\"No value supplied for attribute \" + name);\n        }\n        built[name] = given;\n    }\n    return built;\n}\nfunction checkAttrs(attrs, values, type, name) {\n    for (let name in values)\n        if (!(name in attrs))\n            throw new RangeError(`Unsupported attribute ${name} for ${type} of type ${name}`);\n    for (let name in attrs) {\n        let attr = attrs[name];\n        if (attr.validate)\n            attr.validate(values[name]);\n    }\n}\nfunction initAttrs(typeName, attrs) {\n    let result = Object.create(null);\n    if (attrs)\n        for (let name in attrs)\n            result[name] = new Attribute(typeName, name, attrs[name]);\n    return result;\n}\n/**\nNode types are objects allocated once per `Schema` and used to\n[tag](https://prosemirror.net/docs/ref/#model.Node.type) `Node` instances. They contain information\nabout the node type, such as its name and what kind of node it\nrepresents.\n*/\nclass NodeType {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The name the node type has in this schema.\n    */\n    name, \n    /**\n    A link back to the `Schema` the node type belongs to.\n    */\n    schema, \n    /**\n    The spec that this type is based on\n    */\n    spec) {\n        this.name = name;\n        this.schema = schema;\n        this.spec = spec;\n        /**\n        The set of marks allowed in this node. `null` means all marks\n        are allowed.\n        */\n        this.markSet = null;\n        this.groups = spec.group ? spec.group.split(\" \") : [];\n        this.attrs = initAttrs(name, spec.attrs);\n        this.defaultAttrs = defaultAttrs(this.attrs);\n        this.contentMatch = null;\n        this.inlineContent = null;\n        this.isBlock = !(spec.inline || name == \"text\");\n        this.isText = name == \"text\";\n    }\n    /**\n    True if this is an inline type.\n    */\n    get isInline() { return !this.isBlock; }\n    /**\n    True if this is a textblock type, a block that contains inline\n    content.\n    */\n    get isTextblock() { return this.isBlock && this.inlineContent; }\n    /**\n    True for node types that allow no content.\n    */\n    get isLeaf() { return this.contentMatch == ContentMatch.empty; }\n    /**\n    True when this node is an atom, i.e. when it does not have\n    directly editable content.\n    */\n    get isAtom() { return this.isLeaf || !!this.spec.atom; }\n    /**\n    Return true when this node type is part of the given\n    [group](https://prosemirror.net/docs/ref/#model.NodeSpec.group).\n    */\n    isInGroup(group) {\n        return this.groups.indexOf(group) > -1;\n    }\n    /**\n    The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.\n    */\n    get whitespace() {\n        return this.spec.whitespace || (this.spec.code ? \"pre\" : \"normal\");\n    }\n    /**\n    Tells you whether this node type has any required attributes.\n    */\n    hasRequiredAttrs() {\n        for (let n in this.attrs)\n            if (this.attrs[n].isRequired)\n                return true;\n        return false;\n    }\n    /**\n    Indicates whether this node allows some of the same content as\n    the given node type.\n    */\n    compatibleContent(other) {\n        return this == other || this.contentMatch.compatible(other.contentMatch);\n    }\n    /**\n    @internal\n    */\n    computeAttrs(attrs) {\n        if (!attrs && this.defaultAttrs)\n            return this.defaultAttrs;\n        else\n            return computeAttrs(this.attrs, attrs);\n    }\n    /**\n    Create a `Node` of this type. The given attributes are\n    checked and defaulted (you can pass `null` to use the type's\n    defaults entirely, if no required attributes exist). `content`\n    may be a `Fragment`, a node, an array of nodes, or\n    `null`. Similarly `marks` may be `null` to default to the empty\n    set of marks.\n    */\n    create(attrs = null, content, marks) {\n        if (this.isText)\n            throw new Error(\"NodeType.create can't construct text nodes\");\n        return new Node(this, this.computeAttrs(attrs), Fragment.from(content), Mark.setFrom(marks));\n    }\n    /**\n    Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content\n    against the node type's content restrictions, and throw an error\n    if it doesn't match.\n    */\n    createChecked(attrs = null, content, marks) {\n        content = Fragment.from(content);\n        this.checkContent(content);\n        return new Node(this, this.computeAttrs(attrs), content, Mark.setFrom(marks));\n    }\n    /**\n    Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is\n    necessary to add nodes to the start or end of the given fragment\n    to make it fit the node. If no fitting wrapping can be found,\n    return null. Note that, due to the fact that required nodes can\n    always be created, this will always succeed if you pass null or\n    `Fragment.empty` as content.\n    */\n    createAndFill(attrs = null, content, marks) {\n        attrs = this.computeAttrs(attrs);\n        content = Fragment.from(content);\n        if (content.size) {\n            let before = this.contentMatch.fillBefore(content);\n            if (!before)\n                return null;\n            content = before.append(content);\n        }\n        let matched = this.contentMatch.matchFragment(content);\n        let after = matched && matched.fillBefore(Fragment.empty, true);\n        if (!after)\n            return null;\n        return new Node(this, attrs, content.append(after), Mark.setFrom(marks));\n    }\n    /**\n    Returns true if the given fragment is valid content for this node\n    type.\n    */\n    validContent(content) {\n        let result = this.contentMatch.matchFragment(content);\n        if (!result || !result.validEnd)\n            return false;\n        for (let i = 0; i < content.childCount; i++)\n            if (!this.allowsMarks(content.child(i).marks))\n                return false;\n        return true;\n    }\n    /**\n    Throws a RangeError if the given fragment is not valid content for this\n    node type.\n    @internal\n    */\n    checkContent(content) {\n        if (!this.validContent(content))\n            throw new RangeError(`Invalid content for node ${this.name}: ${content.toString().slice(0, 50)}`);\n    }\n    /**\n    @internal\n    */\n    checkAttrs(attrs) {\n        checkAttrs(this.attrs, attrs, \"node\", this.name);\n    }\n    /**\n    Check whether the given mark type is allowed in this node.\n    */\n    allowsMarkType(markType) {\n        return this.markSet == null || this.markSet.indexOf(markType) > -1;\n    }\n    /**\n    Test whether the given set of marks are allowed in this node.\n    */\n    allowsMarks(marks) {\n        if (this.markSet == null)\n            return true;\n        for (let i = 0; i < marks.length; i++)\n            if (!this.allowsMarkType(marks[i].type))\n                return false;\n        return true;\n    }\n    /**\n    Removes the marks that are not allowed in this node from the given set.\n    */\n    allowedMarks(marks) {\n        if (this.markSet == null)\n            return marks;\n        let copy;\n        for (let i = 0; i < marks.length; i++) {\n            if (!this.allowsMarkType(marks[i].type)) {\n                if (!copy)\n                    copy = marks.slice(0, i);\n            }\n            else if (copy) {\n                copy.push(marks[i]);\n            }\n        }\n        return !copy ? marks : copy.length ? copy : Mark.none;\n    }\n    /**\n    @internal\n    */\n    static compile(nodes, schema) {\n        let result = Object.create(null);\n        nodes.forEach((name, spec) => result[name] = new NodeType(name, schema, spec));\n        let topType = schema.spec.topNode || \"doc\";\n        if (!result[topType])\n            throw new RangeError(\"Schema is missing its top node type ('\" + topType + \"')\");\n        if (!result.text)\n            throw new RangeError(\"Every schema needs a 'text' type\");\n        for (let _ in result.text.attrs)\n            throw new RangeError(\"The text node type should not have attributes\");\n        return result;\n    }\n}\nfunction validateType(typeName, attrName, type) {\n    let types = type.split(\"|\");\n    return (value) => {\n        let name = value === null ? \"null\" : typeof value;\n        if (types.indexOf(name) < 0)\n            throw new RangeError(`Expected value of type ${types} for attribute ${attrName} on type ${typeName}, got ${name}`);\n    };\n}\n// Attribute descriptors\nclass Attribute {\n    constructor(typeName, attrName, options) {\n        this.hasDefault = Object.prototype.hasOwnProperty.call(options, \"default\");\n        this.default = options.default;\n        this.validate = typeof options.validate == \"string\" ? validateType(typeName, attrName, options.validate) : options.validate;\n    }\n    get isRequired() {\n        return !this.hasDefault;\n    }\n}\n// Marks\n/**\nLike nodes, marks (which are associated with nodes to signify\nthings like emphasis or being part of a link) are\n[tagged](https://prosemirror.net/docs/ref/#model.Mark.type) with type objects, which are\ninstantiated once per `Schema`.\n*/\nclass MarkType {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The name of the mark type.\n    */\n    name, \n    /**\n    @internal\n    */\n    rank, \n    /**\n    The schema that this mark type instance is part of.\n    */\n    schema, \n    /**\n    The spec on which the type is based.\n    */\n    spec) {\n        this.name = name;\n        this.rank = rank;\n        this.schema = schema;\n        this.spec = spec;\n        this.attrs = initAttrs(name, spec.attrs);\n        this.excluded = null;\n        let defaults = defaultAttrs(this.attrs);\n        this.instance = defaults ? new Mark(this, defaults) : null;\n    }\n    /**\n    Create a mark of this type. `attrs` may be `null` or an object\n    containing only some of the mark's attributes. The others, if\n    they have defaults, will be added.\n    */\n    create(attrs = null) {\n        if (!attrs && this.instance)\n            return this.instance;\n        return new Mark(this, computeAttrs(this.attrs, attrs));\n    }\n    /**\n    @internal\n    */\n    static compile(marks, schema) {\n        let result = Object.create(null), rank = 0;\n        marks.forEach((name, spec) => result[name] = new MarkType(name, rank++, schema, spec));\n        return result;\n    }\n    /**\n    When there is a mark of this type in the given set, a new set\n    without it is returned. Otherwise, the input set is returned.\n    */\n    removeFromSet(set) {\n        for (var i = 0; i < set.length; i++)\n            if (set[i].type == this) {\n                set = set.slice(0, i).concat(set.slice(i + 1));\n                i--;\n            }\n        return set;\n    }\n    /**\n    Tests whether there is a mark of this type in the given set.\n    */\n    isInSet(set) {\n        for (let i = 0; i < set.length; i++)\n            if (set[i].type == this)\n                return set[i];\n    }\n    /**\n    @internal\n    */\n    checkAttrs(attrs) {\n        checkAttrs(this.attrs, attrs, \"mark\", this.name);\n    }\n    /**\n    Queries whether a given mark type is\n    [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.\n    */\n    excludes(other) {\n        return this.excluded.indexOf(other) > -1;\n    }\n}\n/**\nA document schema. Holds [node](https://prosemirror.net/docs/ref/#model.NodeType) and [mark\ntype](https://prosemirror.net/docs/ref/#model.MarkType) objects for the nodes and marks that may\noccur in conforming documents, and provides functionality for\ncreating and deserializing such documents.\n\nWhen given, the type parameters provide the names of the nodes and\nmarks in this schema.\n*/\nclass Schema {\n    /**\n    Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).\n    */\n    constructor(spec) {\n        /**\n        The [linebreak\n        replacement](https://prosemirror.net/docs/ref/#model.NodeSpec.linebreakReplacement) node defined\n        in this schema, if any.\n        */\n        this.linebreakReplacement = null;\n        /**\n        An object for storing whatever values modules may want to\n        compute and cache per schema. (If you want to store something\n        in it, try to use property names unlikely to clash.)\n        */\n        this.cached = Object.create(null);\n        let instanceSpec = this.spec = {};\n        for (let prop in spec)\n            instanceSpec[prop] = spec[prop];\n        instanceSpec.nodes = orderedmap__WEBPACK_IMPORTED_MODULE_0__[\"default\"].from(spec.nodes),\n            instanceSpec.marks = orderedmap__WEBPACK_IMPORTED_MODULE_0__[\"default\"].from(spec.marks || {}),\n            this.nodes = NodeType.compile(this.spec.nodes, this);\n        this.marks = MarkType.compile(this.spec.marks, this);\n        let contentExprCache = Object.create(null);\n        for (let prop in this.nodes) {\n            if (prop in this.marks)\n                throw new RangeError(prop + \" can not be both a node and a mark\");\n            let type = this.nodes[prop], contentExpr = type.spec.content || \"\", markExpr = type.spec.marks;\n            type.contentMatch = contentExprCache[contentExpr] ||\n                (contentExprCache[contentExpr] = ContentMatch.parse(contentExpr, this.nodes));\n            type.inlineContent = type.contentMatch.inlineContent;\n            if (type.spec.linebreakReplacement) {\n                if (this.linebreakReplacement)\n                    throw new RangeError(\"Multiple linebreak nodes defined\");\n                if (!type.isInline || !type.isLeaf)\n                    throw new RangeError(\"Linebreak replacement nodes must be inline leaf nodes\");\n                this.linebreakReplacement = type;\n            }\n            type.markSet = markExpr == \"_\" ? null :\n                markExpr ? gatherMarks(this, markExpr.split(\" \")) :\n                    markExpr == \"\" || !type.inlineContent ? [] : null;\n        }\n        for (let prop in this.marks) {\n            let type = this.marks[prop], excl = type.spec.excludes;\n            type.excluded = excl == null ? [type] : excl == \"\" ? [] : gatherMarks(this, excl.split(\" \"));\n        }\n        this.nodeFromJSON = json => Node.fromJSON(this, json);\n        this.markFromJSON = json => Mark.fromJSON(this, json);\n        this.topNodeType = this.nodes[this.spec.topNode || \"doc\"];\n        this.cached.wrappings = Object.create(null);\n    }\n    /**\n    Create a node in this schema. The `type` may be a string or a\n    `NodeType` instance. Attributes will be extended with defaults,\n    `content` may be a `Fragment`, `null`, a `Node`, or an array of\n    nodes.\n    */\n    node(type, attrs = null, content, marks) {\n        if (typeof type == \"string\")\n            type = this.nodeType(type);\n        else if (!(type instanceof NodeType))\n            throw new RangeError(\"Invalid node type: \" + type);\n        else if (type.schema != this)\n            throw new RangeError(\"Node type from different schema used (\" + type.name + \")\");\n        return type.createChecked(attrs, content, marks);\n    }\n    /**\n    Create a text node in the schema. Empty text nodes are not\n    allowed.\n    */\n    text(text, marks) {\n        let type = this.nodes.text;\n        return new TextNode(type, type.defaultAttrs, text, Mark.setFrom(marks));\n    }\n    /**\n    Create a mark with the given type and attributes.\n    */\n    mark(type, attrs) {\n        if (typeof type == \"string\")\n            type = this.marks[type];\n        return type.create(attrs);\n    }\n    /**\n    @internal\n    */\n    nodeType(name) {\n        let found = this.nodes[name];\n        if (!found)\n            throw new RangeError(\"Unknown node type: \" + name);\n        return found;\n    }\n}\nfunction gatherMarks(schema, marks) {\n    let found = [];\n    for (let i = 0; i < marks.length; i++) {\n        let name = marks[i], mark = schema.marks[name], ok = mark;\n        if (mark) {\n            found.push(mark);\n        }\n        else {\n            for (let prop in schema.marks) {\n                let mark = schema.marks[prop];\n                if (name == \"_\" || (mark.spec.group && mark.spec.group.split(\" \").indexOf(name) > -1))\n                    found.push(ok = mark);\n            }\n        }\n        if (!ok)\n            throw new SyntaxError(\"Unknown mark type: '\" + marks[i] + \"'\");\n    }\n    return found;\n}\n\nfunction isTagRule(rule) { return rule.tag != null; }\nfunction isStyleRule(rule) { return rule.style != null; }\n/**\nA DOM parser represents a strategy for parsing DOM content into a\nProseMirror document conforming to a given schema. Its behavior is\ndefined by an array of [rules](https://prosemirror.net/docs/ref/#model.ParseRule).\n*/\nclass DOMParser {\n    /**\n    Create a parser that targets the given schema, using the given\n    parsing rules.\n    */\n    constructor(\n    /**\n    The schema into which the parser parses.\n    */\n    schema, \n    /**\n    The set of [parse rules](https://prosemirror.net/docs/ref/#model.ParseRule) that the parser\n    uses, in order of precedence.\n    */\n    rules) {\n        this.schema = schema;\n        this.rules = rules;\n        /**\n        @internal\n        */\n        this.tags = [];\n        /**\n        @internal\n        */\n        this.styles = [];\n        let matchedStyles = this.matchedStyles = [];\n        rules.forEach(rule => {\n            if (isTagRule(rule)) {\n                this.tags.push(rule);\n            }\n            else if (isStyleRule(rule)) {\n                let prop = /[^=]*/.exec(rule.style)[0];\n                if (matchedStyles.indexOf(prop) < 0)\n                    matchedStyles.push(prop);\n                this.styles.push(rule);\n            }\n        });\n        // Only normalize list elements when lists in the schema can't directly contain themselves\n        this.normalizeLists = !this.tags.some(r => {\n            if (!/^(ul|ol)\\b/.test(r.tag) || !r.node)\n                return false;\n            let node = schema.nodes[r.node];\n            return node.contentMatch.matchType(node);\n        });\n    }\n    /**\n    Parse a document from the content of a DOM node.\n    */\n    parse(dom, options = {}) {\n        let context = new ParseContext(this, options, false);\n        context.addAll(dom, Mark.none, options.from, options.to);\n        return context.finish();\n    }\n    /**\n    Parses the content of the given DOM node, like\n    [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of\n    options. But unlike that method, which produces a whole node,\n    this one returns a slice that is open at the sides, meaning that\n    the schema constraints aren't applied to the start of nodes to\n    the left of the input and the end of nodes at the end.\n    */\n    parseSlice(dom, options = {}) {\n        let context = new ParseContext(this, options, true);\n        context.addAll(dom, Mark.none, options.from, options.to);\n        return Slice.maxOpen(context.finish());\n    }\n    /**\n    @internal\n    */\n    matchTag(dom, context, after) {\n        for (let i = after ? this.tags.indexOf(after) + 1 : 0; i < this.tags.length; i++) {\n            let rule = this.tags[i];\n            if (matches(dom, rule.tag) &&\n                (rule.namespace === undefined || dom.namespaceURI == rule.namespace) &&\n                (!rule.context || context.matchesContext(rule.context))) {\n                if (rule.getAttrs) {\n                    let result = rule.getAttrs(dom);\n                    if (result === false)\n                        continue;\n                    rule.attrs = result || undefined;\n                }\n                return rule;\n            }\n        }\n    }\n    /**\n    @internal\n    */\n    matchStyle(prop, value, context, after) {\n        for (let i = after ? this.styles.indexOf(after) + 1 : 0; i < this.styles.length; i++) {\n            let rule = this.styles[i], style = rule.style;\n            if (style.indexOf(prop) != 0 ||\n                rule.context && !context.matchesContext(rule.context) ||\n                // Test that the style string either precisely matches the prop,\n                // or has an '=' sign after the prop, followed by the given\n                // value.\n                style.length > prop.length &&\n                    (style.charCodeAt(prop.length) != 61 || style.slice(prop.length + 1) != value))\n                continue;\n            if (rule.getAttrs) {\n                let result = rule.getAttrs(value);\n                if (result === false)\n                    continue;\n                rule.attrs = result || undefined;\n            }\n            return rule;\n        }\n    }\n    /**\n    @internal\n    */\n    static schemaRules(schema) {\n        let result = [];\n        function insert(rule) {\n            let priority = rule.priority == null ? 50 : rule.priority, i = 0;\n            for (; i < result.length; i++) {\n                let next = result[i], nextPriority = next.priority == null ? 50 : next.priority;\n                if (nextPriority < priority)\n                    break;\n            }\n            result.splice(i, 0, rule);\n        }\n        for (let name in schema.marks) {\n            let rules = schema.marks[name].spec.parseDOM;\n            if (rules)\n                rules.forEach(rule => {\n                    insert(rule = copy(rule));\n                    if (!(rule.mark || rule.ignore || rule.clearMark))\n                        rule.mark = name;\n                });\n        }\n        for (let name in schema.nodes) {\n            let rules = schema.nodes[name].spec.parseDOM;\n            if (rules)\n                rules.forEach(rule => {\n                    insert(rule = copy(rule));\n                    if (!(rule.node || rule.ignore || rule.mark))\n                        rule.node = name;\n                });\n        }\n        return result;\n    }\n    /**\n    Construct a DOM parser using the parsing rules listed in a\n    schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by\n    [priority](https://prosemirror.net/docs/ref/#model.GenericParseRule.priority).\n    */\n    static fromSchema(schema) {\n        return schema.cached.domParser ||\n            (schema.cached.domParser = new DOMParser(schema, DOMParser.schemaRules(schema)));\n    }\n}\nconst blockTags = {\n    address: true, article: true, aside: true, blockquote: true, canvas: true,\n    dd: true, div: true, dl: true, fieldset: true, figcaption: true, figure: true,\n    footer: true, form: true, h1: true, h2: true, h3: true, h4: true, h5: true,\n    h6: true, header: true, hgroup: true, hr: true, li: true, noscript: true, ol: true,\n    output: true, p: true, pre: true, section: true, table: true, tfoot: true, ul: true\n};\nconst ignoreTags = {\n    head: true, noscript: true, object: true, script: true, style: true, title: true\n};\nconst listTags = { ol: true, ul: true };\n// Using a bitfield for node context options\nconst OPT_PRESERVE_WS = 1, OPT_PRESERVE_WS_FULL = 2, OPT_OPEN_LEFT = 4;\nfunction wsOptionsFor(type, preserveWhitespace, base) {\n    if (preserveWhitespace != null)\n        return (preserveWhitespace ? OPT_PRESERVE_WS : 0) |\n            (preserveWhitespace === \"full\" ? OPT_PRESERVE_WS_FULL : 0);\n    return type && type.whitespace == \"pre\" ? OPT_PRESERVE_WS | OPT_PRESERVE_WS_FULL : base & ~OPT_OPEN_LEFT;\n}\nclass NodeContext {\n    constructor(type, attrs, marks, solid, match, options) {\n        this.type = type;\n        this.attrs = attrs;\n        this.marks = marks;\n        this.solid = solid;\n        this.options = options;\n        this.content = [];\n        // Marks applied to the node's children\n        this.activeMarks = Mark.none;\n        this.match = match || (options & OPT_OPEN_LEFT ? null : type.contentMatch);\n    }\n    findWrapping(node) {\n        if (!this.match) {\n            if (!this.type)\n                return [];\n            let fill = this.type.contentMatch.fillBefore(Fragment.from(node));\n            if (fill) {\n                this.match = this.type.contentMatch.matchFragment(fill);\n            }\n            else {\n                let start = this.type.contentMatch, wrap;\n                if (wrap = start.findWrapping(node.type)) {\n                    this.match = start;\n                    return wrap;\n                }\n                else {\n                    return null;\n                }\n            }\n        }\n        return this.match.findWrapping(node.type);\n    }\n    finish(openEnd) {\n        if (!(this.options & OPT_PRESERVE_WS)) { // Strip trailing whitespace\n            let last = this.content[this.content.length - 1], m;\n            if (last && last.isText && (m = /[ \\t\\r\\n\\u000c]+$/.exec(last.text))) {\n                let text = last;\n                if (last.text.length == m[0].length)\n                    this.content.pop();\n                else\n                    this.content[this.content.length - 1] = text.withText(text.text.slice(0, text.text.length - m[0].length));\n            }\n        }\n        let content = Fragment.from(this.content);\n        if (!openEnd && this.match)\n            content = content.append(this.match.fillBefore(Fragment.empty, true));\n        return this.type ? this.type.create(this.attrs, content, this.marks) : content;\n    }\n    inlineContext(node) {\n        if (this.type)\n            return this.type.inlineContent;\n        if (this.content.length)\n            return this.content[0].isInline;\n        return node.parentNode && !blockTags.hasOwnProperty(node.parentNode.nodeName.toLowerCase());\n    }\n}\nclass ParseContext {\n    constructor(\n    // The parser we are using.\n    parser, \n    // The options passed to this parse.\n    options, isOpen) {\n        this.parser = parser;\n        this.options = options;\n        this.isOpen = isOpen;\n        this.open = 0;\n        this.localPreserveWS = false;\n        let topNode = options.topNode, topContext;\n        let topOptions = wsOptionsFor(null, options.preserveWhitespace, 0) | (isOpen ? OPT_OPEN_LEFT : 0);\n        if (topNode)\n            topContext = new NodeContext(topNode.type, topNode.attrs, Mark.none, true, options.topMatch || topNode.type.contentMatch, topOptions);\n        else if (isOpen)\n            topContext = new NodeContext(null, null, Mark.none, true, null, topOptions);\n        else\n            topContext = new NodeContext(parser.schema.topNodeType, null, Mark.none, true, null, topOptions);\n        this.nodes = [topContext];\n        this.find = options.findPositions;\n        this.needsBlock = false;\n    }\n    get top() {\n        return this.nodes[this.open];\n    }\n    // Add a DOM node to the content. Text is inserted as text node,\n    // otherwise, the node is passed to `addElement` or, if it has a\n    // `style` attribute, `addElementWithStyles`.\n    addDOM(dom, marks) {\n        if (dom.nodeType == 3)\n            this.addTextNode(dom, marks);\n        else if (dom.nodeType == 1)\n            this.addElement(dom, marks);\n    }\n    addTextNode(dom, marks) {\n        let value = dom.nodeValue;\n        let top = this.top, preserveWS = (top.options & OPT_PRESERVE_WS_FULL) ? \"full\"\n            : this.localPreserveWS || (top.options & OPT_PRESERVE_WS) > 0;\n        if (preserveWS === \"full\" ||\n            top.inlineContext(dom) ||\n            /[^ \\t\\r\\n\\u000c]/.test(value)) {\n            if (!preserveWS) {\n                value = value.replace(/[ \\t\\r\\n\\u000c]+/g, \" \");\n                // If this starts with whitespace, and there is no node before it, or\n                // a hard break, or a text node that ends with whitespace, strip the\n                // leading space.\n                if (/^[ \\t\\r\\n\\u000c]/.test(value) && this.open == this.nodes.length - 1) {\n                    let nodeBefore = top.content[top.content.length - 1];\n                    let domNodeBefore = dom.previousSibling;\n                    if (!nodeBefore ||\n                        (domNodeBefore && domNodeBefore.nodeName == 'BR') ||\n                        (nodeBefore.isText && /[ \\t\\r\\n\\u000c]$/.test(nodeBefore.text)))\n                        value = value.slice(1);\n                }\n            }\n            else if (preserveWS !== \"full\") {\n                value = value.replace(/\\r?\\n|\\r/g, \" \");\n            }\n            else {\n                value = value.replace(/\\r\\n?/g, \"\\n\");\n            }\n            if (value)\n                this.insertNode(this.parser.schema.text(value), marks, !/\\S/.test(value));\n            this.findInText(dom);\n        }\n        else {\n            this.findInside(dom);\n        }\n    }\n    // Try to find a handler for the given tag and use that to parse. If\n    // none is found, the element's content nodes are added directly.\n    addElement(dom, marks, matchAfter) {\n        let outerWS = this.localPreserveWS, top = this.top;\n        if (dom.tagName == \"PRE\" || /pre/.test(dom.style && dom.style.whiteSpace))\n            this.localPreserveWS = true;\n        let name = dom.nodeName.toLowerCase(), ruleID;\n        if (listTags.hasOwnProperty(name) && this.parser.normalizeLists)\n            normalizeList(dom);\n        let rule = (this.options.ruleFromNode && this.options.ruleFromNode(dom)) ||\n            (ruleID = this.parser.matchTag(dom, this, matchAfter));\n        out: if (rule ? rule.ignore : ignoreTags.hasOwnProperty(name)) {\n            this.findInside(dom);\n            this.ignoreFallback(dom, marks);\n        }\n        else if (!rule || rule.skip || rule.closeParent) {\n            if (rule && rule.closeParent)\n                this.open = Math.max(0, this.open - 1);\n            else if (rule && rule.skip.nodeType)\n                dom = rule.skip;\n            let sync, oldNeedsBlock = this.needsBlock;\n            if (blockTags.hasOwnProperty(name)) {\n                if (top.content.length && top.content[0].isInline && this.open) {\n                    this.open--;\n                    top = this.top;\n                }\n                sync = true;\n                if (!top.type)\n                    this.needsBlock = true;\n            }\n            else if (!dom.firstChild) {\n                this.leafFallback(dom, marks);\n                break out;\n            }\n            let innerMarks = rule && rule.skip ? marks : this.readStyles(dom, marks);\n            if (innerMarks)\n                this.addAll(dom, innerMarks);\n            if (sync)\n                this.sync(top);\n            this.needsBlock = oldNeedsBlock;\n        }\n        else {\n            let innerMarks = this.readStyles(dom, marks);\n            if (innerMarks)\n                this.addElementByRule(dom, rule, innerMarks, rule.consuming === false ? ruleID : undefined);\n        }\n        this.localPreserveWS = outerWS;\n    }\n    // Called for leaf DOM nodes that would otherwise be ignored\n    leafFallback(dom, marks) {\n        if (dom.nodeName == \"BR\" && this.top.type && this.top.type.inlineContent)\n            this.addTextNode(dom.ownerDocument.createTextNode(\"\\n\"), marks);\n    }\n    // Called for ignored nodes\n    ignoreFallback(dom, marks) {\n        // Ignored BR nodes should at least create an inline context\n        if (dom.nodeName == \"BR\" && (!this.top.type || !this.top.type.inlineContent))\n            this.findPlace(this.parser.schema.text(\"-\"), marks, true);\n    }\n    // Run any style parser associated with the node's styles. Either\n    // return an updated array of marks, or null to indicate some of the\n    // styles had a rule with `ignore` set.\n    readStyles(dom, marks) {\n        let styles = dom.style;\n        // Because many properties will only show up in 'normalized' form\n        // in `style.item` (i.e. text-decoration becomes\n        // text-decoration-line, text-decoration-color, etc), we directly\n        // query the styles mentioned in our rules instead of iterating\n        // over the items.\n        if (styles && styles.length)\n            for (let i = 0; i < this.parser.matchedStyles.length; i++) {\n                let name = this.parser.matchedStyles[i], value = styles.getPropertyValue(name);\n                if (value)\n                    for (let after = undefined;;) {\n                        let rule = this.parser.matchStyle(name, value, this, after);\n                        if (!rule)\n                            break;\n                        if (rule.ignore)\n                            return null;\n                        if (rule.clearMark)\n                            marks = marks.filter(m => !rule.clearMark(m));\n                        else\n                            marks = marks.concat(this.parser.schema.marks[rule.mark].create(rule.attrs));\n                        if (rule.consuming === false)\n                            after = rule;\n                        else\n                            break;\n                    }\n            }\n        return marks;\n    }\n    // Look up a handler for the given node. If none are found, return\n    // false. Otherwise, apply it, use its return value to drive the way\n    // the node's content is wrapped, and return true.\n    addElementByRule(dom, rule, marks, continueAfter) {\n        let sync, nodeType;\n        if (rule.node) {\n            nodeType = this.parser.schema.nodes[rule.node];\n            if (!nodeType.isLeaf) {\n                let inner = this.enter(nodeType, rule.attrs || null, marks, rule.preserveWhitespace);\n                if (inner) {\n                    sync = true;\n                    marks = inner;\n                }\n            }\n            else if (!this.insertNode(nodeType.create(rule.attrs), marks, dom.nodeName == \"BR\")) {\n                this.leafFallback(dom, marks);\n            }\n        }\n        else {\n            let markType = this.parser.schema.marks[rule.mark];\n            marks = marks.concat(markType.create(rule.attrs));\n        }\n        let startIn = this.top;\n        if (nodeType && nodeType.isLeaf) {\n            this.findInside(dom);\n        }\n        else if (continueAfter) {\n            this.addElement(dom, marks, continueAfter);\n        }\n        else if (rule.getContent) {\n            this.findInside(dom);\n            rule.getContent(dom, this.parser.schema).forEach(node => this.insertNode(node, marks, false));\n        }\n        else {\n            let contentDOM = dom;\n            if (typeof rule.contentElement == \"string\")\n                contentDOM = dom.querySelector(rule.contentElement);\n            else if (typeof rule.contentElement == \"function\")\n                contentDOM = rule.contentElement(dom);\n            else if (rule.contentElement)\n                contentDOM = rule.contentElement;\n            this.findAround(dom, contentDOM, true);\n            this.addAll(contentDOM, marks);\n            this.findAround(dom, contentDOM, false);\n        }\n        if (sync && this.sync(startIn))\n            this.open--;\n    }\n    // Add all child nodes between `startIndex` and `endIndex` (or the\n    // whole node, if not given). If `sync` is passed, use it to\n    // synchronize after every block element.\n    addAll(parent, marks, startIndex, endIndex) {\n        let index = startIndex || 0;\n        for (let dom = startIndex ? parent.childNodes[startIndex] : parent.firstChild, end = endIndex == null ? null : parent.childNodes[endIndex]; dom != end; dom = dom.nextSibling, ++index) {\n            this.findAtPoint(parent, index);\n            this.addDOM(dom, marks);\n        }\n        this.findAtPoint(parent, index);\n    }\n    // Try to find a way to fit the given node type into the current\n    // context. May add intermediate wrappers and/or leave non-solid\n    // nodes that we're in.\n    findPlace(node, marks, cautious) {\n        let route, sync;\n        for (let depth = this.open, penalty = 0; depth >= 0; depth--) {\n            let cx = this.nodes[depth];\n            let found = cx.findWrapping(node);\n            if (found && (!route || route.length > found.length + penalty)) {\n                route = found;\n                sync = cx;\n                if (!found.length)\n                    break;\n            }\n            if (cx.solid) {\n                if (cautious)\n                    break;\n                penalty += 2;\n            }\n        }\n        if (!route)\n            return null;\n        this.sync(sync);\n        for (let i = 0; i < route.length; i++)\n            marks = this.enterInner(route[i], null, marks, false);\n        return marks;\n    }\n    // Try to insert the given node, adjusting the context when needed.\n    insertNode(node, marks, cautious) {\n        if (node.isInline && this.needsBlock && !this.top.type) {\n            let block = this.textblockFromContext();\n            if (block)\n                marks = this.enterInner(block, null, marks);\n        }\n        let innerMarks = this.findPlace(node, marks, cautious);\n        if (innerMarks) {\n            this.closeExtra();\n            let top = this.top;\n            if (top.match)\n                top.match = top.match.matchType(node.type);\n            let nodeMarks = Mark.none;\n            for (let m of innerMarks.concat(node.marks))\n                if (top.type ? top.type.allowsMarkType(m.type) : markMayApply(m.type, node.type))\n                    nodeMarks = m.addToSet(nodeMarks);\n            top.content.push(node.mark(nodeMarks));\n            return true;\n        }\n        return false;\n    }\n    // Try to start a node of the given type, adjusting the context when\n    // necessary.\n    enter(type, attrs, marks, preserveWS) {\n        let innerMarks = this.findPlace(type.create(attrs), marks, false);\n        if (innerMarks)\n            innerMarks = this.enterInner(type, attrs, marks, true, preserveWS);\n        return innerMarks;\n    }\n    // Open a node of the given type\n    enterInner(type, attrs, marks, solid = false, preserveWS) {\n        this.closeExtra();\n        let top = this.top;\n        top.match = top.match && top.match.matchType(type);\n        let options = wsOptionsFor(type, preserveWS, top.options);\n        if ((top.options & OPT_OPEN_LEFT) && top.content.length == 0)\n            options |= OPT_OPEN_LEFT;\n        let applyMarks = Mark.none;\n        marks = marks.filter(m => {\n            if (top.type ? top.type.allowsMarkType(m.type) : markMayApply(m.type, type)) {\n                applyMarks = m.addToSet(applyMarks);\n                return false;\n            }\n            return true;\n        });\n        this.nodes.push(new NodeContext(type, attrs, applyMarks, solid, null, options));\n        this.open++;\n        return marks;\n    }\n    // Make sure all nodes above this.open are finished and added to\n    // their parents\n    closeExtra(openEnd = false) {\n        let i = this.nodes.length - 1;\n        if (i > this.open) {\n            for (; i > this.open; i--)\n                this.nodes[i - 1].content.push(this.nodes[i].finish(openEnd));\n            this.nodes.length = this.open + 1;\n        }\n    }\n    finish() {\n        this.open = 0;\n        this.closeExtra(this.isOpen);\n        return this.nodes[0].finish(!!(this.isOpen || this.options.topOpen));\n    }\n    sync(to) {\n        for (let i = this.open; i >= 0; i--) {\n            if (this.nodes[i] == to) {\n                this.open = i;\n                return true;\n            }\n            else if (this.localPreserveWS) {\n                this.nodes[i].options |= OPT_PRESERVE_WS;\n            }\n        }\n        return false;\n    }\n    get currentPos() {\n        this.closeExtra();\n        let pos = 0;\n        for (let i = this.open; i >= 0; i--) {\n            let content = this.nodes[i].content;\n            for (let j = content.length - 1; j >= 0; j--)\n                pos += content[j].nodeSize;\n            if (i)\n                pos++;\n        }\n        return pos;\n    }\n    findAtPoint(parent, offset) {\n        if (this.find)\n            for (let i = 0; i < this.find.length; i++) {\n                if (this.find[i].node == parent && this.find[i].offset == offset)\n                    this.find[i].pos = this.currentPos;\n            }\n    }\n    findInside(parent) {\n        if (this.find)\n            for (let i = 0; i < this.find.length; i++) {\n                if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node))\n                    this.find[i].pos = this.currentPos;\n            }\n    }\n    findAround(parent, content, before) {\n        if (parent != content && this.find)\n            for (let i = 0; i < this.find.length; i++) {\n                if (this.find[i].pos == null && parent.nodeType == 1 && parent.contains(this.find[i].node)) {\n                    let pos = content.compareDocumentPosition(this.find[i].node);\n                    if (pos & (before ? 2 : 4))\n                        this.find[i].pos = this.currentPos;\n                }\n            }\n    }\n    findInText(textNode) {\n        if (this.find)\n            for (let i = 0; i < this.find.length; i++) {\n                if (this.find[i].node == textNode)\n                    this.find[i].pos = this.currentPos - (textNode.nodeValue.length - this.find[i].offset);\n            }\n    }\n    // Determines whether the given context string matches this context.\n    matchesContext(context) {\n        if (context.indexOf(\"|\") > -1)\n            return context.split(/\\s*\\|\\s*/).some(this.matchesContext, this);\n        let parts = context.split(\"/\");\n        let option = this.options.context;\n        let useRoot = !this.isOpen && (!option || option.parent.type == this.nodes[0].type);\n        let minDepth = -(option ? option.depth + 1 : 0) + (useRoot ? 0 : 1);\n        let match = (i, depth) => {\n            for (; i >= 0; i--) {\n                let part = parts[i];\n                if (part == \"\") {\n                    if (i == parts.length - 1 || i == 0)\n                        continue;\n                    for (; depth >= minDepth; depth--)\n                        if (match(i - 1, depth))\n                            return true;\n                    return false;\n                }\n                else {\n                    let next = depth > 0 || (depth == 0 && useRoot) ? this.nodes[depth].type\n                        : option && depth >= minDepth ? option.node(depth - minDepth).type\n                            : null;\n                    if (!next || (next.name != part && !next.isInGroup(part)))\n                        return false;\n                    depth--;\n                }\n            }\n            return true;\n        };\n        return match(parts.length - 1, this.open);\n    }\n    textblockFromContext() {\n        let $context = this.options.context;\n        if ($context)\n            for (let d = $context.depth; d >= 0; d--) {\n                let deflt = $context.node(d).contentMatchAt($context.indexAfter(d)).defaultType;\n                if (deflt && deflt.isTextblock && deflt.defaultAttrs)\n                    return deflt;\n            }\n        for (let name in this.parser.schema.nodes) {\n            let type = this.parser.schema.nodes[name];\n            if (type.isTextblock && type.defaultAttrs)\n                return type;\n        }\n    }\n}\n// Kludge to work around directly nested list nodes produced by some\n// tools and allowed by browsers to mean that the nested list is\n// actually part of the list item above it.\nfunction normalizeList(dom) {\n    for (let child = dom.firstChild, prevItem = null; child; child = child.nextSibling) {\n        let name = child.nodeType == 1 ? child.nodeName.toLowerCase() : null;\n        if (name && listTags.hasOwnProperty(name) && prevItem) {\n            prevItem.appendChild(child);\n            child = prevItem;\n        }\n        else if (name == \"li\") {\n            prevItem = child;\n        }\n        else if (name) {\n            prevItem = null;\n        }\n    }\n}\n// Apply a CSS selector.\nfunction matches(dom, selector) {\n    return (dom.matches || dom.msMatchesSelector || dom.webkitMatchesSelector || dom.mozMatchesSelector).call(dom, selector);\n}\nfunction copy(obj) {\n    let copy = {};\n    for (let prop in obj)\n        copy[prop] = obj[prop];\n    return copy;\n}\n// Used when finding a mark at the top level of a fragment parse.\n// Checks whether it would be reasonable to apply a given mark type to\n// a given node, by looking at the way the mark occurs in the schema.\nfunction markMayApply(markType, nodeType) {\n    let nodes = nodeType.schema.nodes;\n    for (let name in nodes) {\n        let parent = nodes[name];\n        if (!parent.allowsMarkType(markType))\n            continue;\n        let seen = [], scan = (match) => {\n            seen.push(match);\n            for (let i = 0; i < match.edgeCount; i++) {\n                let { type, next } = match.edge(i);\n                if (type == nodeType)\n                    return true;\n                if (seen.indexOf(next) < 0 && scan(next))\n                    return true;\n            }\n        };\n        if (scan(parent.contentMatch))\n            return true;\n    }\n}\n\n/**\nA DOM serializer knows how to convert ProseMirror nodes and\nmarks of various types to DOM nodes.\n*/\nclass DOMSerializer {\n    /**\n    Create a serializer. `nodes` should map node names to functions\n    that take a node and return a description of the corresponding\n    DOM. `marks` does the same for mark names, but also gets an\n    argument that tells it whether the mark's content is block or\n    inline content (for typical use, it'll always be inline). A mark\n    serializer may be `null` to indicate that marks of that type\n    should not be serialized.\n    */\n    constructor(\n    /**\n    The node serialization functions.\n    */\n    nodes, \n    /**\n    The mark serialization functions.\n    */\n    marks) {\n        this.nodes = nodes;\n        this.marks = marks;\n    }\n    /**\n    Serialize the content of this fragment to a DOM fragment. When\n    not in the browser, the `document` option, containing a DOM\n    document, should be passed so that the serializer can create\n    nodes.\n    */\n    serializeFragment(fragment, options = {}, target) {\n        if (!target)\n            target = doc(options).createDocumentFragment();\n        let top = target, active = [];\n        fragment.forEach(node => {\n            if (active.length || node.marks.length) {\n                let keep = 0, rendered = 0;\n                while (keep < active.length && rendered < node.marks.length) {\n                    let next = node.marks[rendered];\n                    if (!this.marks[next.type.name]) {\n                        rendered++;\n                        continue;\n                    }\n                    if (!next.eq(active[keep][0]) || next.type.spec.spanning === false)\n                        break;\n                    keep++;\n                    rendered++;\n                }\n                while (keep < active.length)\n                    top = active.pop()[1];\n                while (rendered < node.marks.length) {\n                    let add = node.marks[rendered++];\n                    let markDOM = this.serializeMark(add, node.isInline, options);\n                    if (markDOM) {\n                        active.push([add, top]);\n                        top.appendChild(markDOM.dom);\n                        top = markDOM.contentDOM || markDOM.dom;\n                    }\n                }\n            }\n            top.appendChild(this.serializeNodeInner(node, options));\n        });\n        return target;\n    }\n    /**\n    @internal\n    */\n    serializeNodeInner(node, options) {\n        let { dom, contentDOM } = renderSpec(doc(options), this.nodes[node.type.name](node), null, node.attrs);\n        if (contentDOM) {\n            if (node.isLeaf)\n                throw new RangeError(\"Content hole not allowed in a leaf node spec\");\n            this.serializeFragment(node.content, options, contentDOM);\n        }\n        return dom;\n    }\n    /**\n    Serialize this node to a DOM node. This can be useful when you\n    need to serialize a part of a document, as opposed to the whole\n    document. To serialize a whole document, use\n    [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on\n    its [content](https://prosemirror.net/docs/ref/#model.Node.content).\n    */\n    serializeNode(node, options = {}) {\n        let dom = this.serializeNodeInner(node, options);\n        for (let i = node.marks.length - 1; i >= 0; i--) {\n            let wrap = this.serializeMark(node.marks[i], node.isInline, options);\n            if (wrap) {\n                (wrap.contentDOM || wrap.dom).appendChild(dom);\n                dom = wrap.dom;\n            }\n        }\n        return dom;\n    }\n    /**\n    @internal\n    */\n    serializeMark(mark, inline, options = {}) {\n        let toDOM = this.marks[mark.type.name];\n        return toDOM && renderSpec(doc(options), toDOM(mark, inline), null, mark.attrs);\n    }\n    static renderSpec(doc, structure, xmlNS = null, blockArraysIn) {\n        return renderSpec(doc, structure, xmlNS, blockArraysIn);\n    }\n    /**\n    Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)\n    properties in a schema's node and mark specs.\n    */\n    static fromSchema(schema) {\n        return schema.cached.domSerializer ||\n            (schema.cached.domSerializer = new DOMSerializer(this.nodesFromSchema(schema), this.marksFromSchema(schema)));\n    }\n    /**\n    Gather the serializers in a schema's node specs into an object.\n    This can be useful as a base to build a custom serializer from.\n    */\n    static nodesFromSchema(schema) {\n        let result = gatherToDOM(schema.nodes);\n        if (!result.text)\n            result.text = node => node.text;\n        return result;\n    }\n    /**\n    Gather the serializers in a schema's mark specs into an object.\n    */\n    static marksFromSchema(schema) {\n        return gatherToDOM(schema.marks);\n    }\n}\nfunction gatherToDOM(obj) {\n    let result = {};\n    for (let name in obj) {\n        let toDOM = obj[name].spec.toDOM;\n        if (toDOM)\n            result[name] = toDOM;\n    }\n    return result;\n}\nfunction doc(options) {\n    return options.document || window.document;\n}\nconst suspiciousAttributeCache = new WeakMap();\nfunction suspiciousAttributes(attrs) {\n    let value = suspiciousAttributeCache.get(attrs);\n    if (value === undefined)\n        suspiciousAttributeCache.set(attrs, value = suspiciousAttributesInner(attrs));\n    return value;\n}\nfunction suspiciousAttributesInner(attrs) {\n    let result = null;\n    function scan(value) {\n        if (value && typeof value == \"object\") {\n            if (Array.isArray(value)) {\n                if (typeof value[0] == \"string\") {\n                    if (!result)\n                        result = [];\n                    result.push(value);\n                }\n                else {\n                    for (let i = 0; i < value.length; i++)\n                        scan(value[i]);\n                }\n            }\n            else {\n                for (let prop in value)\n                    scan(value[prop]);\n            }\n        }\n    }\n    scan(attrs);\n    return result;\n}\nfunction renderSpec(doc, structure, xmlNS, blockArraysIn) {\n    if (typeof structure == \"string\")\n        return { dom: doc.createTextNode(structure) };\n    if (structure.nodeType != null)\n        return { dom: structure };\n    if (structure.dom && structure.dom.nodeType != null)\n        return structure;\n    let tagName = structure[0], suspicious;\n    if (typeof tagName != \"string\")\n        throw new RangeError(\"Invalid array passed to renderSpec\");\n    if (blockArraysIn && (suspicious = suspiciousAttributes(blockArraysIn)) &&\n        suspicious.indexOf(structure) > -1)\n        throw new RangeError(\"Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack.\");\n    let space = tagName.indexOf(\" \");\n    if (space > 0) {\n        xmlNS = tagName.slice(0, space);\n        tagName = tagName.slice(space + 1);\n    }\n    let contentDOM;\n    let dom = (xmlNS ? doc.createElementNS(xmlNS, tagName) : doc.createElement(tagName));\n    let attrs = structure[1], start = 1;\n    if (attrs && typeof attrs == \"object\" && attrs.nodeType == null && !Array.isArray(attrs)) {\n        start = 2;\n        for (let name in attrs)\n            if (attrs[name] != null) {\n                let space = name.indexOf(\" \");\n                if (space > 0)\n                    dom.setAttributeNS(name.slice(0, space), name.slice(space + 1), attrs[name]);\n                else if (name == \"style\" && dom.style)\n                    dom.style.cssText = attrs[name];\n                else\n                    dom.setAttribute(name, attrs[name]);\n            }\n    }\n    for (let i = start; i < structure.length; i++) {\n        let child = structure[i];\n        if (child === 0) {\n            if (i < structure.length - 1 || i > start)\n                throw new RangeError(\"Content hole must be the only child of its parent node\");\n            return { dom, contentDOM: dom };\n        }\n        else {\n            let { dom: inner, contentDOM: innerContent } = renderSpec(doc, child, xmlNS, blockArraysIn);\n            dom.appendChild(inner);\n            if (innerContent) {\n                if (contentDOM)\n                    throw new RangeError(\"Multiple content holes\");\n                contentDOM = innerContent;\n            }\n        }\n    }\n    return { dom, contentDOM };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1tb2RlbC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW9DOztBQUVwQztBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQ0FBa0M7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsb0JBQW9CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsVUFBVTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwQkFBMEI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxVQUFVO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix5QkFBeUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxLQUFLLHVCQUF1QixLQUFLO0FBQzlFLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFdBQVc7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDZEQUE2RDtBQUN2RztBQUNBLHlDQUF5Qyw2REFBNkQ7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnQkFBZ0I7QUFDMUIsVUFBVSxtQ0FBbUM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGdCQUFnQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUc7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGFBQWE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixjQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixXQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QXdCLHVCQUF1QjtBQUMvQyxrQkFBa0IsYUFBYTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELE1BQU0sTUFBTSxNQUFNLFVBQVUsS0FBSztBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxVQUFVLElBQUksZ0NBQWdDO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxPQUFPLGdCQUFnQixVQUFVLFVBQVUsU0FBUyxRQUFRLEtBQUs7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGtEQUFVO0FBQ3ZDLGlDQUFpQyxrREFBVSxzQkFBc0I7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Qsc0JBQXNCO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSx3QkFBd0I7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNDQUFzQztBQUNsRTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0pBQW9KLFlBQVk7QUFDaEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsWUFBWTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGVBQWU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsUUFBUTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzQkFBc0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0JBQXNCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixzQkFBc0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixtQkFBbUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxPQUFPO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRCxzQkFBc0IsYUFBYTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtCQUFrQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxrQkFBa0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHNCQUFzQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0Esa0JBQWtCLHVDQUF1QztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVpSiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3ItbW9kZWwvZGlzdC9pbmRleC5qcz82MTRkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBPcmRlcmVkTWFwIGZyb20gJ29yZGVyZWRtYXAnO1xuXG5mdW5jdGlvbiBmaW5kRGlmZlN0YXJ0KGEsIGIsIHBvcykge1xuICAgIGZvciAobGV0IGkgPSAwOzsgaSsrKSB7XG4gICAgICAgIGlmIChpID09IGEuY2hpbGRDb3VudCB8fCBpID09IGIuY2hpbGRDb3VudClcbiAgICAgICAgICAgIHJldHVybiBhLmNoaWxkQ291bnQgPT0gYi5jaGlsZENvdW50ID8gbnVsbCA6IHBvcztcbiAgICAgICAgbGV0IGNoaWxkQSA9IGEuY2hpbGQoaSksIGNoaWxkQiA9IGIuY2hpbGQoaSk7XG4gICAgICAgIGlmIChjaGlsZEEgPT0gY2hpbGRCKSB7XG4gICAgICAgICAgICBwb3MgKz0gY2hpbGRBLm5vZGVTaXplO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjaGlsZEEuc2FtZU1hcmt1cChjaGlsZEIpKVxuICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgaWYgKGNoaWxkQS5pc1RleHQgJiYgY2hpbGRBLnRleHQgIT0gY2hpbGRCLnRleHQpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBjaGlsZEEudGV4dFtqXSA9PSBjaGlsZEIudGV4dFtqXTsgaisrKVxuICAgICAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGRBLmNvbnRlbnQuc2l6ZSB8fCBjaGlsZEIuY29udGVudC5zaXplKSB7XG4gICAgICAgICAgICBsZXQgaW5uZXIgPSBmaW5kRGlmZlN0YXJ0KGNoaWxkQS5jb250ZW50LCBjaGlsZEIuY29udGVudCwgcG9zICsgMSk7XG4gICAgICAgICAgICBpZiAoaW5uZXIgIT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5uZXI7XG4gICAgICAgIH1cbiAgICAgICAgcG9zICs9IGNoaWxkQS5ub2RlU2l6ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBmaW5kRGlmZkVuZChhLCBiLCBwb3NBLCBwb3NCKSB7XG4gICAgZm9yIChsZXQgaUEgPSBhLmNoaWxkQ291bnQsIGlCID0gYi5jaGlsZENvdW50OzspIHtcbiAgICAgICAgaWYgKGlBID09IDAgfHwgaUIgPT0gMClcbiAgICAgICAgICAgIHJldHVybiBpQSA9PSBpQiA/IG51bGwgOiB7IGE6IHBvc0EsIGI6IHBvc0IgfTtcbiAgICAgICAgbGV0IGNoaWxkQSA9IGEuY2hpbGQoLS1pQSksIGNoaWxkQiA9IGIuY2hpbGQoLS1pQiksIHNpemUgPSBjaGlsZEEubm9kZVNpemU7XG4gICAgICAgIGlmIChjaGlsZEEgPT0gY2hpbGRCKSB7XG4gICAgICAgICAgICBwb3NBIC09IHNpemU7XG4gICAgICAgICAgICBwb3NCIC09IHNpemU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNoaWxkQS5zYW1lTWFya3VwKGNoaWxkQikpXG4gICAgICAgICAgICByZXR1cm4geyBhOiBwb3NBLCBiOiBwb3NCIH07XG4gICAgICAgIGlmIChjaGlsZEEuaXNUZXh0ICYmIGNoaWxkQS50ZXh0ICE9IGNoaWxkQi50ZXh0KSB7XG4gICAgICAgICAgICBsZXQgc2FtZSA9IDAsIG1pblNpemUgPSBNYXRoLm1pbihjaGlsZEEudGV4dC5sZW5ndGgsIGNoaWxkQi50ZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICB3aGlsZSAoc2FtZSA8IG1pblNpemUgJiYgY2hpbGRBLnRleHRbY2hpbGRBLnRleHQubGVuZ3RoIC0gc2FtZSAtIDFdID09IGNoaWxkQi50ZXh0W2NoaWxkQi50ZXh0Lmxlbmd0aCAtIHNhbWUgLSAxXSkge1xuICAgICAgICAgICAgICAgIHNhbWUrKztcbiAgICAgICAgICAgICAgICBwb3NBLS07XG4gICAgICAgICAgICAgICAgcG9zQi0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgYTogcG9zQSwgYjogcG9zQiB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZEEuY29udGVudC5zaXplIHx8IGNoaWxkQi5jb250ZW50LnNpemUpIHtcbiAgICAgICAgICAgIGxldCBpbm5lciA9IGZpbmREaWZmRW5kKGNoaWxkQS5jb250ZW50LCBjaGlsZEIuY29udGVudCwgcG9zQSAtIDEsIHBvc0IgLSAxKTtcbiAgICAgICAgICAgIGlmIChpbm5lcilcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5uZXI7XG4gICAgICAgIH1cbiAgICAgICAgcG9zQSAtPSBzaXplO1xuICAgICAgICBwb3NCIC09IHNpemU7XG4gICAgfVxufVxuXG4vKipcbkEgZnJhZ21lbnQgcmVwcmVzZW50cyBhIG5vZGUncyBjb2xsZWN0aW9uIG9mIGNoaWxkIG5vZGVzLlxuXG5MaWtlIG5vZGVzLCBmcmFnbWVudHMgYXJlIHBlcnNpc3RlbnQgZGF0YSBzdHJ1Y3R1cmVzLCBhbmQgeW91XG5zaG91bGQgbm90IG11dGF0ZSB0aGVtIG9yIHRoZWlyIGNvbnRlbnQuIFJhdGhlciwgeW91IGNyZWF0ZSBuZXdcbmluc3RhbmNlcyB3aGVuZXZlciBuZWVkZWQuIFRoZSBBUEkgdHJpZXMgdG8gbWFrZSB0aGlzIGVhc3kuXG4qL1xuY2xhc3MgRnJhZ21lbnQge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGNoaWxkIG5vZGVzIGluIHRoaXMgZnJhZ21lbnQuXG4gICAgKi9cbiAgICBjb250ZW50LCBzaXplKSB7XG4gICAgICAgIHRoaXMuY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHNpemUgfHwgMDtcbiAgICAgICAgaWYgKHNpemUgPT0gbnVsbClcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29udGVudC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICB0aGlzLnNpemUgKz0gY29udGVudFtpXS5ub2RlU2l6ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgSW52b2tlIGEgY2FsbGJhY2sgZm9yIGFsbCBkZXNjZW5kYW50IG5vZGVzIGJldHdlZW4gdGhlIGdpdmVuIHR3b1xuICAgIHBvc2l0aW9ucyAocmVsYXRpdmUgdG8gc3RhcnQgb2YgdGhpcyBmcmFnbWVudCkuIERvZXNuJ3QgZGVzY2VuZFxuICAgIGludG8gYSBub2RlIHdoZW4gdGhlIGNhbGxiYWNrIHJldHVybnMgYGZhbHNlYC5cbiAgICAqL1xuICAgIG5vZGVzQmV0d2Vlbihmcm9tLCB0bywgZiwgbm9kZVN0YXJ0ID0gMCwgcGFyZW50KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBwb3MgPSAwOyBwb3MgPCB0bzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNvbnRlbnRbaV0sIGVuZCA9IHBvcyArIGNoaWxkLm5vZGVTaXplO1xuICAgICAgICAgICAgaWYgKGVuZCA+IGZyb20gJiYgZihjaGlsZCwgbm9kZVN0YXJ0ICsgcG9zLCBwYXJlbnQgfHwgbnVsbCwgaSkgIT09IGZhbHNlICYmIGNoaWxkLmNvbnRlbnQuc2l6ZSkge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IHBvcyArIDE7XG4gICAgICAgICAgICAgICAgY2hpbGQubm9kZXNCZXR3ZWVuKE1hdGgubWF4KDAsIGZyb20gLSBzdGFydCksIE1hdGgubWluKGNoaWxkLmNvbnRlbnQuc2l6ZSwgdG8gLSBzdGFydCksIGYsIG5vZGVTdGFydCArIHN0YXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvcyA9IGVuZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBDYWxsIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgZXZlcnkgZGVzY2VuZGFudCBub2RlLiBgcG9zYCB3aWxsIGJlXG4gICAgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoZSBmcmFnbWVudC4gVGhlIGNhbGxiYWNrIG1heSByZXR1cm5cbiAgICBgZmFsc2VgIHRvIHByZXZlbnQgdHJhdmVyc2FsIG9mIGEgZ2l2ZW4gbm9kZSdzIGNoaWxkcmVuLlxuICAgICovXG4gICAgZGVzY2VuZGFudHMoZikge1xuICAgICAgICB0aGlzLm5vZGVzQmV0d2VlbigwLCB0aGlzLnNpemUsIGYpO1xuICAgIH1cbiAgICAvKipcbiAgICBFeHRyYWN0IHRoZSB0ZXh0IGJldHdlZW4gYGZyb21gIGFuZCBgdG9gLiBTZWUgdGhlIHNhbWUgbWV0aG9kIG9uXG4gICAgW2BOb2RlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGUudGV4dEJldHdlZW4pLlxuICAgICovXG4gICAgdGV4dEJldHdlZW4oZnJvbSwgdG8sIGJsb2NrU2VwYXJhdG9yLCBsZWFmVGV4dCkge1xuICAgICAgICBsZXQgdGV4dCA9IFwiXCIsIGZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgICAgIGxldCBub2RlVGV4dCA9IG5vZGUuaXNUZXh0ID8gbm9kZS50ZXh0LnNsaWNlKE1hdGgubWF4KGZyb20sIHBvcykgLSBwb3MsIHRvIC0gcG9zKVxuICAgICAgICAgICAgICAgIDogIW5vZGUuaXNMZWFmID8gXCJcIlxuICAgICAgICAgICAgICAgICAgICA6IGxlYWZUZXh0ID8gKHR5cGVvZiBsZWFmVGV4dCA9PT0gXCJmdW5jdGlvblwiID8gbGVhZlRleHQobm9kZSkgOiBsZWFmVGV4dClcbiAgICAgICAgICAgICAgICAgICAgICAgIDogbm9kZS50eXBlLnNwZWMubGVhZlRleHQgPyBub2RlLnR5cGUuc3BlYy5sZWFmVGV4dChub2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogXCJcIjtcbiAgICAgICAgICAgIGlmIChub2RlLmlzQmxvY2sgJiYgKG5vZGUuaXNMZWFmICYmIG5vZGVUZXh0IHx8IG5vZGUuaXNUZXh0YmxvY2spICYmIGJsb2NrU2VwYXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0KVxuICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGV4dCArPSBibG9ja1NlcGFyYXRvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRleHQgKz0gbm9kZVRleHQ7XG4gICAgICAgIH0sIDApO1xuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IGZyYWdtZW50IGNvbnRhaW5pbmcgdGhlIGNvbWJpbmVkIGNvbnRlbnQgb2YgdGhpc1xuICAgIGZyYWdtZW50IGFuZCB0aGUgb3RoZXIuXG4gICAgKi9cbiAgICBhcHBlbmQob3RoZXIpIHtcbiAgICAgICAgaWYgKCFvdGhlci5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIG90aGVyO1xuICAgICAgICBsZXQgbGFzdCA9IHRoaXMubGFzdENoaWxkLCBmaXJzdCA9IG90aGVyLmZpcnN0Q2hpbGQsIGNvbnRlbnQgPSB0aGlzLmNvbnRlbnQuc2xpY2UoKSwgaSA9IDA7XG4gICAgICAgIGlmIChsYXN0LmlzVGV4dCAmJiBsYXN0LnNhbWVNYXJrdXAoZmlyc3QpKSB7XG4gICAgICAgICAgICBjb250ZW50W2NvbnRlbnQubGVuZ3RoIC0gMV0gPSBsYXN0LndpdGhUZXh0KGxhc3QudGV4dCArIGZpcnN0LnRleHQpO1xuICAgICAgICAgICAgaSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IGkgPCBvdGhlci5jb250ZW50Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgY29udGVudC5wdXNoKG90aGVyLmNvbnRlbnRbaV0pO1xuICAgICAgICByZXR1cm4gbmV3IEZyYWdtZW50KGNvbnRlbnQsIHRoaXMuc2l6ZSArIG90aGVyLnNpemUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDdXQgb3V0IHRoZSBzdWItZnJhZ21lbnQgYmV0d2VlbiB0aGUgdHdvIGdpdmVuIHBvc2l0aW9ucy5cbiAgICAqL1xuICAgIGN1dChmcm9tLCB0byA9IHRoaXMuc2l6ZSkge1xuICAgICAgICBpZiAoZnJvbSA9PSAwICYmIHRvID09IHRoaXMuc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW10sIHNpemUgPSAwO1xuICAgICAgICBpZiAodG8gPiBmcm9tKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IDA7IHBvcyA8IHRvOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNvbnRlbnRbaV0sIGVuZCA9IHBvcyArIGNoaWxkLm5vZGVTaXplO1xuICAgICAgICAgICAgICAgIGlmIChlbmQgPiBmcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPCBmcm9tIHx8IGVuZCA+IHRvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQuaXNUZXh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGQuY3V0KE1hdGgubWF4KDAsIGZyb20gLSBwb3MpLCBNYXRoLm1pbihjaGlsZC50ZXh0Lmxlbmd0aCwgdG8gLSBwb3MpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkLmN1dChNYXRoLm1heCgwLCBmcm9tIC0gcG9zIC0gMSksIE1hdGgubWluKGNoaWxkLmNvbnRlbnQuc2l6ZSwgdG8gLSBwb3MgLSAxKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICBzaXplICs9IGNoaWxkLm5vZGVTaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwb3MgPSBlbmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRnJhZ21lbnQocmVzdWx0LCBzaXplKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjdXRCeUluZGV4KGZyb20sIHRvKSB7XG4gICAgICAgIGlmIChmcm9tID09IHRvKVxuICAgICAgICAgICAgcmV0dXJuIEZyYWdtZW50LmVtcHR5O1xuICAgICAgICBpZiAoZnJvbSA9PSAwICYmIHRvID09IHRoaXMuY29udGVudC5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudCh0aGlzLmNvbnRlbnQuc2xpY2UoZnJvbSwgdG8pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IGZyYWdtZW50IGluIHdoaWNoIHRoZSBub2RlIGF0IHRoZSBnaXZlbiBpbmRleCBpc1xuICAgIHJlcGxhY2VkIGJ5IHRoZSBnaXZlbiBub2RlLlxuICAgICovXG4gICAgcmVwbGFjZUNoaWxkKGluZGV4LCBub2RlKSB7XG4gICAgICAgIGxldCBjdXJyZW50ID0gdGhpcy5jb250ZW50W2luZGV4XTtcbiAgICAgICAgaWYgKGN1cnJlbnQgPT0gbm9kZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBsZXQgY29weSA9IHRoaXMuY29udGVudC5zbGljZSgpO1xuICAgICAgICBsZXQgc2l6ZSA9IHRoaXMuc2l6ZSArIG5vZGUubm9kZVNpemUgLSBjdXJyZW50Lm5vZGVTaXplO1xuICAgICAgICBjb3B5W2luZGV4XSA9IG5vZGU7XG4gICAgICAgIHJldHVybiBuZXcgRnJhZ21lbnQoY29weSwgc2l6ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBmcmFnbWVudCBieSBwcmVwZW5kaW5nIHRoZSBnaXZlbiBub2RlIHRvIHRoaXNcbiAgICBmcmFnbWVudC5cbiAgICAqL1xuICAgIGFkZFRvU3RhcnQobm9kZSkge1xuICAgICAgICByZXR1cm4gbmV3IEZyYWdtZW50KFtub2RlXS5jb25jYXQodGhpcy5jb250ZW50KSwgdGhpcy5zaXplICsgbm9kZS5ub2RlU2l6ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5ldyBmcmFnbWVudCBieSBhcHBlbmRpbmcgdGhlIGdpdmVuIG5vZGUgdG8gdGhpc1xuICAgIGZyYWdtZW50LlxuICAgICovXG4gICAgYWRkVG9FbmQobm9kZSkge1xuICAgICAgICByZXR1cm4gbmV3IEZyYWdtZW50KHRoaXMuY29udGVudC5jb25jYXQobm9kZSksIHRoaXMuc2l6ZSArIG5vZGUubm9kZVNpemUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb21wYXJlIHRoaXMgZnJhZ21lbnQgdG8gYW5vdGhlciBvbmUuXG4gICAgKi9cbiAgICBlcShvdGhlcikge1xuICAgICAgICBpZiAodGhpcy5jb250ZW50Lmxlbmd0aCAhPSBvdGhlci5jb250ZW50Lmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvbnRlbnQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIXRoaXMuY29udGVudFtpXS5lcShvdGhlci5jb250ZW50W2ldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgZmlyc3QgY2hpbGQgb2YgdGhlIGZyYWdtZW50LCBvciBgbnVsbGAgaWYgaXQgaXMgZW1wdHkuXG4gICAgKi9cbiAgICBnZXQgZmlyc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuY29udGVudC5sZW5ndGggPyB0aGlzLmNvbnRlbnRbMF0gOiBudWxsOyB9XG4gICAgLyoqXG4gICAgVGhlIGxhc3QgY2hpbGQgb2YgdGhlIGZyYWdtZW50LCBvciBgbnVsbGAgaWYgaXQgaXMgZW1wdHkuXG4gICAgKi9cbiAgICBnZXQgbGFzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5jb250ZW50Lmxlbmd0aCA/IHRoaXMuY29udGVudFt0aGlzLmNvbnRlbnQubGVuZ3RoIC0gMV0gOiBudWxsOyB9XG4gICAgLyoqXG4gICAgVGhlIG51bWJlciBvZiBjaGlsZCBub2RlcyBpbiB0aGlzIGZyYWdtZW50LlxuICAgICovXG4gICAgZ2V0IGNoaWxkQ291bnQoKSB7IHJldHVybiB0aGlzLmNvbnRlbnQubGVuZ3RoOyB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBjaGlsZCBub2RlIGF0IHRoZSBnaXZlbiBpbmRleC4gUmFpc2UgYW4gZXJyb3Igd2hlbiB0aGVcbiAgICBpbmRleCBpcyBvdXQgb2YgcmFuZ2UuXG4gICAgKi9cbiAgICBjaGlsZChpbmRleCkge1xuICAgICAgICBsZXQgZm91bmQgPSB0aGlzLmNvbnRlbnRbaW5kZXhdO1xuICAgICAgICBpZiAoIWZvdW5kKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBcIiArIGluZGV4ICsgXCIgb3V0IG9mIHJhbmdlIGZvciBcIiArIHRoaXMpO1xuICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgY2hpbGQgbm9kZSBhdCB0aGUgZ2l2ZW4gaW5kZXgsIGlmIGl0IGV4aXN0cy5cbiAgICAqL1xuICAgIG1heWJlQ2hpbGQoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudFtpbmRleF0gfHwgbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgQ2FsbCBgZmAgZm9yIGV2ZXJ5IGNoaWxkIG5vZGUsIHBhc3NpbmcgdGhlIG5vZGUsIGl0cyBvZmZzZXRcbiAgICBpbnRvIHRoaXMgcGFyZW50IG5vZGUsIGFuZCBpdHMgaW5kZXguXG4gICAgKi9cbiAgICBmb3JFYWNoKGYpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHAgPSAwOyBpIDwgdGhpcy5jb250ZW50Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNvbnRlbnRbaV07XG4gICAgICAgICAgICBmKGNoaWxkLCBwLCBpKTtcbiAgICAgICAgICAgIHAgKz0gY2hpbGQubm9kZVNpemU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgZmlyc3QgcG9zaXRpb24gYXQgd2hpY2ggdGhpcyBmcmFnbWVudCBhbmQgYW5vdGhlclxuICAgIGZyYWdtZW50IGRpZmZlciwgb3IgYG51bGxgIGlmIHRoZXkgYXJlIHRoZSBzYW1lLlxuICAgICovXG4gICAgZmluZERpZmZTdGFydChvdGhlciwgcG9zID0gMCkge1xuICAgICAgICByZXR1cm4gZmluZERpZmZTdGFydCh0aGlzLCBvdGhlciwgcG9zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgZmlyc3QgcG9zaXRpb24sIHNlYXJjaGluZyBmcm9tIHRoZSBlbmQsIGF0IHdoaWNoIHRoaXNcbiAgICBmcmFnbWVudCBhbmQgdGhlIGdpdmVuIGZyYWdtZW50IGRpZmZlciwgb3IgYG51bGxgIGlmIHRoZXkgYXJlXG4gICAgdGhlIHNhbWUuIFNpbmNlIHRoaXMgcG9zaXRpb24gd2lsbCBub3QgYmUgdGhlIHNhbWUgaW4gYm90aFxuICAgIG5vZGVzLCBhbiBvYmplY3Qgd2l0aCB0d28gc2VwYXJhdGUgcG9zaXRpb25zIGlzIHJldHVybmVkLlxuICAgICovXG4gICAgZmluZERpZmZFbmQob3RoZXIsIHBvcyA9IHRoaXMuc2l6ZSwgb3RoZXJQb3MgPSBvdGhlci5zaXplKSB7XG4gICAgICAgIHJldHVybiBmaW5kRGlmZkVuZCh0aGlzLCBvdGhlciwgcG9zLCBvdGhlclBvcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGluZGV4IGFuZCBpbm5lciBvZmZzZXQgY29ycmVzcG9uZGluZyB0byBhIGdpdmVuIHJlbGF0aXZlXG4gICAgcG9zaXRpb24gaW4gdGhpcyBmcmFnbWVudC4gVGhlIHJlc3VsdCBvYmplY3Qgd2lsbCBiZSByZXVzZWRcbiAgICAob3ZlcndyaXR0ZW4pIHRoZSBuZXh0IHRpbWUgdGhlIGZ1bmN0aW9uIGlzIGNhbGxlZC4gQGludGVybmFsXG4gICAgKi9cbiAgICBmaW5kSW5kZXgocG9zKSB7XG4gICAgICAgIGlmIChwb3MgPT0gMClcbiAgICAgICAgICAgIHJldHVybiByZXRJbmRleCgwLCBwb3MpO1xuICAgICAgICBpZiAocG9zID09IHRoaXMuc2l6ZSlcbiAgICAgICAgICAgIHJldHVybiByZXRJbmRleCh0aGlzLmNvbnRlbnQubGVuZ3RoLCBwb3MpO1xuICAgICAgICBpZiAocG9zID4gdGhpcy5zaXplIHx8IHBvcyA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgUG9zaXRpb24gJHtwb3N9IG91dHNpZGUgb2YgZnJhZ21lbnQgKCR7dGhpc30pYCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBjdXJQb3MgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY3VyID0gdGhpcy5jaGlsZChpKSwgZW5kID0gY3VyUG9zICsgY3VyLm5vZGVTaXplO1xuICAgICAgICAgICAgaWYgKGVuZCA+PSBwb3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoZW5kID09IHBvcylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJldEluZGV4KGkgKyAxLCBlbmQpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXRJbmRleChpLCBjdXJQb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VyUG9zID0gZW5kO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiBhIGRlYnVnZ2luZyBzdHJpbmcgdGhhdCBkZXNjcmliZXMgdGhpcyBmcmFnbWVudC5cbiAgICAqL1xuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gXCI8XCIgKyB0aGlzLnRvU3RyaW5nSW5uZXIoKSArIFwiPlwiOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZ0lubmVyKCkgeyByZXR1cm4gdGhpcy5jb250ZW50LmpvaW4oXCIsIFwiKTsgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIEpTT04tc2VyaWFsaXplYWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIGZyYWdtZW50LlxuICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50Lmxlbmd0aCA/IHRoaXMuY29udGVudC5tYXAobiA9PiBuLnRvSlNPTigpKSA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIERlc2VyaWFsaXplIGEgZnJhZ21lbnQgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUpXG4gICAgICAgICAgICByZXR1cm4gRnJhZ21lbnQuZW1wdHk7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIEZyYWdtZW50LmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEZyYWdtZW50KHZhbHVlLm1hcChzY2hlbWEubm9kZUZyb21KU09OKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEJ1aWxkIGEgZnJhZ21lbnQgZnJvbSBhbiBhcnJheSBvZiBub2Rlcy4gRW5zdXJlcyB0aGF0IGFkamFjZW50XG4gICAgdGV4dCBub2RlcyB3aXRoIHRoZSBzYW1lIG1hcmtzIGFyZSBqb2luZWQgdG9nZXRoZXIuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUFycmF5KGFycmF5KSB7XG4gICAgICAgIGlmICghYXJyYXkubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIEZyYWdtZW50LmVtcHR5O1xuICAgICAgICBsZXQgam9pbmVkLCBzaXplID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBhcnJheVtpXTtcbiAgICAgICAgICAgIHNpemUgKz0gbm9kZS5ub2RlU2l6ZTtcbiAgICAgICAgICAgIGlmIChpICYmIG5vZGUuaXNUZXh0ICYmIGFycmF5W2kgLSAxXS5zYW1lTWFya3VwKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFqb2luZWQpXG4gICAgICAgICAgICAgICAgICAgIGpvaW5lZCA9IGFycmF5LnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgICAgIGpvaW5lZFtqb2luZWQubGVuZ3RoIC0gMV0gPSBub2RlXG4gICAgICAgICAgICAgICAgICAgIC53aXRoVGV4dChqb2luZWRbam9pbmVkLmxlbmd0aCAtIDFdLnRleHQgKyBub2RlLnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoam9pbmVkKSB7XG4gICAgICAgICAgICAgICAgam9pbmVkLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudChqb2luZWQgfHwgYXJyYXksIHNpemUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBmcmFnbWVudCBmcm9tIHNvbWV0aGluZyB0aGF0IGNhbiBiZSBpbnRlcnByZXRlZCBhcyBhXG4gICAgc2V0IG9mIG5vZGVzLiBGb3IgYG51bGxgLCBpdCByZXR1cm5zIHRoZSBlbXB0eSBmcmFnbWVudC4gRm9yIGFcbiAgICBmcmFnbWVudCwgdGhlIGZyYWdtZW50IGl0c2VsZi4gRm9yIGEgbm9kZSBvciBhcnJheSBvZiBub2RlcywgYVxuICAgIGZyYWdtZW50IGNvbnRhaW5pbmcgdGhvc2Ugbm9kZXMuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbShub2Rlcykge1xuICAgICAgICBpZiAoIW5vZGVzKVxuICAgICAgICAgICAgcmV0dXJuIEZyYWdtZW50LmVtcHR5O1xuICAgICAgICBpZiAobm9kZXMgaW5zdGFuY2VvZiBGcmFnbWVudClcbiAgICAgICAgICAgIHJldHVybiBub2RlcztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobm9kZXMpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnJvbUFycmF5KG5vZGVzKTtcbiAgICAgICAgaWYgKG5vZGVzLmF0dHJzKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBGcmFnbWVudChbbm9kZXNdLCBub2Rlcy5ub2RlU2l6ZSk7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ2FuIG5vdCBjb252ZXJ0IFwiICsgbm9kZXMgKyBcIiB0byBhIEZyYWdtZW50XCIgK1xuICAgICAgICAgICAgKG5vZGVzLm5vZGVzQmV0d2VlbiA/IFwiIChsb29rcyBsaWtlIG11bHRpcGxlIHZlcnNpb25zIG9mIHByb3NlbWlycm9yLW1vZGVsIHdlcmUgbG9hZGVkKVwiIDogXCJcIikpO1xuICAgIH1cbn1cbi8qKlxuQW4gZW1wdHkgZnJhZ21lbnQuIEludGVuZGVkIHRvIGJlIHJldXNlZCB3aGVuZXZlciBhIG5vZGUgZG9lc24ndFxuY29udGFpbiBhbnl0aGluZyAocmF0aGVyIHRoYW4gYWxsb2NhdGluZyBhIG5ldyBlbXB0eSBmcmFnbWVudCBmb3JcbmVhY2ggbGVhZiBub2RlKS5cbiovXG5GcmFnbWVudC5lbXB0eSA9IG5ldyBGcmFnbWVudChbXSwgMCk7XG5jb25zdCBmb3VuZCA9IHsgaW5kZXg6IDAsIG9mZnNldDogMCB9O1xuZnVuY3Rpb24gcmV0SW5kZXgoaW5kZXgsIG9mZnNldCkge1xuICAgIGZvdW5kLmluZGV4ID0gaW5kZXg7XG4gICAgZm91bmQub2Zmc2V0ID0gb2Zmc2V0O1xuICAgIHJldHVybiBmb3VuZDtcbn1cblxuZnVuY3Rpb24gY29tcGFyZURlZXAoYSwgYikge1xuICAgIGlmIChhID09PSBiKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoIShhICYmIHR5cGVvZiBhID09IFwib2JqZWN0XCIpIHx8XG4gICAgICAgICEoYiAmJiB0eXBlb2YgYiA9PSBcIm9iamVjdFwiKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCBhcnJheSA9IEFycmF5LmlzQXJyYXkoYSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYikgIT0gYXJyYXkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIWNvbXBhcmVEZWVwKGFbaV0sIGJbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAobGV0IHAgaW4gYSlcbiAgICAgICAgICAgIGlmICghKHAgaW4gYikgfHwgIWNvbXBhcmVEZWVwKGFbcF0sIGJbcF0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgcCBpbiBiKVxuICAgICAgICAgICAgaWYgKCEocCBpbiBhKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG4vKipcbkEgbWFyayBpcyBhIHBpZWNlIG9mIGluZm9ybWF0aW9uIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGEgbm9kZSxcbnN1Y2ggYXMgaXQgYmVpbmcgZW1waGFzaXplZCwgaW4gY29kZSBmb250LCBvciBhIGxpbmsuIEl0IGhhcyBhXG50eXBlIGFuZCBvcHRpb25hbGx5IGEgc2V0IG9mIGF0dHJpYnV0ZXMgdGhhdCBwcm92aWRlIGZ1cnRoZXJcbmluZm9ybWF0aW9uIChzdWNoIGFzIHRoZSB0YXJnZXQgb2YgdGhlIGxpbmspLiBNYXJrcyBhcmUgY3JlYXRlZFxudGhyb3VnaCBhIGBTY2hlbWFgLCB3aGljaCBjb250cm9scyB3aGljaCB0eXBlcyBleGlzdCBhbmQgd2hpY2hcbmF0dHJpYnV0ZXMgdGhleSBoYXZlLlxuKi9cbmNsYXNzIE1hcmsge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHR5cGUgb2YgdGhpcyBtYXJrLlxuICAgICovXG4gICAgdHlwZSwgXG4gICAgLyoqXG4gICAgVGhlIGF0dHJpYnV0ZXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbWFyay5cbiAgICAqL1xuICAgIGF0dHJzKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICB9XG4gICAgLyoqXG4gICAgR2l2ZW4gYSBzZXQgb2YgbWFya3MsIGNyZWF0ZSBhIG5ldyBzZXQgd2hpY2ggY29udGFpbnMgdGhpcyBvbmUgYXNcbiAgICB3ZWxsLCBpbiB0aGUgcmlnaHQgcG9zaXRpb24uIElmIHRoaXMgbWFyayBpcyBhbHJlYWR5IGluIHRoZSBzZXQsXG4gICAgdGhlIHNldCBpdHNlbGYgaXMgcmV0dXJuZWQuIElmIGFueSBtYXJrcyB0aGF0IGFyZSBzZXQgdG8gYmVcbiAgICBbZXhjbHVzaXZlXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTWFya1NwZWMuZXhjbHVkZXMpIHdpdGggdGhpcyBtYXJrIGFyZSBwcmVzZW50LFxuICAgIHRob3NlIGFyZSByZXBsYWNlZCBieSB0aGlzIG9uZS5cbiAgICAqL1xuICAgIGFkZFRvU2V0KHNldCkge1xuICAgICAgICBsZXQgY29weSwgcGxhY2VkID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgb3RoZXIgPSBzZXRbaV07XG4gICAgICAgICAgICBpZiAodGhpcy5lcShvdGhlcikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldDtcbiAgICAgICAgICAgIGlmICh0aGlzLnR5cGUuZXhjbHVkZXMob3RoZXIudHlwZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNvcHkpXG4gICAgICAgICAgICAgICAgICAgIGNvcHkgPSBzZXQuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvdGhlci50eXBlLmV4Y2x1ZGVzKHRoaXMudHlwZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwbGFjZWQgJiYgb3RoZXIudHlwZS5yYW5rID4gdGhpcy50eXBlLnJhbmspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjb3B5KVxuICAgICAgICAgICAgICAgICAgICAgICAgY29weSA9IHNldC5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgICAgICAgICAgY29weS5wdXNoKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICBwbGFjZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29weSlcbiAgICAgICAgICAgICAgICAgICAgY29weS5wdXNoKG90aGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvcHkpXG4gICAgICAgICAgICBjb3B5ID0gc2V0LnNsaWNlKCk7XG4gICAgICAgIGlmICghcGxhY2VkKVxuICAgICAgICAgICAgY29weS5wdXNoKHRoaXMpO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVtb3ZlIHRoaXMgbWFyayBmcm9tIHRoZSBnaXZlbiBzZXQsIHJldHVybmluZyBhIG5ldyBzZXQuIElmIHRoaXNcbiAgICBtYXJrIGlzIG5vdCBpbiB0aGUgc2V0LCB0aGUgc2V0IGl0c2VsZiBpcyByZXR1cm5lZC5cbiAgICAqL1xuICAgIHJlbW92ZUZyb21TZXQoc2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKHRoaXMuZXEoc2V0W2ldKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0LnNsaWNlKDAsIGkpLmNvbmNhdChzZXQuc2xpY2UoaSArIDEpKTtcbiAgICAgICAgcmV0dXJuIHNldDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIHRoaXMgbWFyayBpcyBpbiB0aGUgZ2l2ZW4gc2V0IG9mIG1hcmtzLlxuICAgICovXG4gICAgaXNJblNldChzZXQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZXQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAodGhpcy5lcShzZXRbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciB0aGlzIG1hcmsgaGFzIHRoZSBzYW1lIHR5cGUgYW5kIGF0dHJpYnV0ZXMgYXNcbiAgICBhbm90aGVyIG1hcmsuXG4gICAgKi9cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcyA9PSBvdGhlciB8fFxuICAgICAgICAgICAgKHRoaXMudHlwZSA9PSBvdGhlci50eXBlICYmIGNvbXBhcmVEZWVwKHRoaXMuYXR0cnMsIG90aGVyLmF0dHJzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbnZlcnQgdGhpcyBtYXJrIHRvIGEgSlNPTi1zZXJpYWxpemVhYmxlIHJlcHJlc2VudGF0aW9uLlxuICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQgb2JqID0geyB0eXBlOiB0aGlzLnR5cGUubmFtZSB9O1xuICAgICAgICBmb3IgKGxldCBfIGluIHRoaXMuYXR0cnMpIHtcbiAgICAgICAgICAgIG9iai5hdHRycyA9IHRoaXMuYXR0cnM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICAvKipcbiAgICBEZXNlcmlhbGl6ZSBhIG1hcmsgZnJvbSBKU09OLlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAoIWpzb24pXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIE1hcmsuZnJvbUpTT05cIik7XG4gICAgICAgIGxldCB0eXBlID0gc2NoZW1hLm1hcmtzW2pzb24udHlwZV07XG4gICAgICAgIGlmICghdHlwZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBUaGVyZSBpcyBubyBtYXJrIHR5cGUgJHtqc29uLnR5cGV9IGluIHRoaXMgc2NoZW1hYCk7XG4gICAgICAgIGxldCBtYXJrID0gdHlwZS5jcmVhdGUoanNvbi5hdHRycyk7XG4gICAgICAgIHR5cGUuY2hlY2tBdHRycyhtYXJrLmF0dHJzKTtcbiAgICAgICAgcmV0dXJuIG1hcms7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciB0d28gc2V0cyBvZiBtYXJrcyBhcmUgaWRlbnRpY2FsLlxuICAgICovXG4gICAgc3RhdGljIHNhbWVTZXQoYSwgYikge1xuICAgICAgICBpZiAoYSA9PSBiKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChhLmxlbmd0aCAhPSBiLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKCFhW2ldLmVxKGJbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHByb3Blcmx5IHNvcnRlZCBtYXJrIHNldCBmcm9tIG51bGwsIGEgc2luZ2xlIG1hcmssIG9yIGFuXG4gICAgdW5zb3J0ZWQgYXJyYXkgb2YgbWFya3MuXG4gICAgKi9cbiAgICBzdGF0aWMgc2V0RnJvbShtYXJrcykge1xuICAgICAgICBpZiAoIW1hcmtzIHx8IEFycmF5LmlzQXJyYXkobWFya3MpICYmIG1hcmtzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIE1hcmsubm9uZTtcbiAgICAgICAgaWYgKG1hcmtzIGluc3RhbmNlb2YgTWFyaylcbiAgICAgICAgICAgIHJldHVybiBbbWFya3NdO1xuICAgICAgICBsZXQgY29weSA9IG1hcmtzLnNsaWNlKCk7XG4gICAgICAgIGNvcHkuc29ydCgoYSwgYikgPT4gYS50eXBlLnJhbmsgLSBiLnR5cGUucmFuayk7XG4gICAgICAgIHJldHVybiBjb3B5O1xuICAgIH1cbn1cbi8qKlxuVGhlIGVtcHR5IHNldCBvZiBtYXJrcy5cbiovXG5NYXJrLm5vbmUgPSBbXTtcblxuLyoqXG5FcnJvciB0eXBlIHJhaXNlZCBieSBbYE5vZGUucmVwbGFjZWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlLnJlcGxhY2UpIHdoZW5cbmdpdmVuIGFuIGludmFsaWQgcmVwbGFjZW1lbnQuXG4qL1xuY2xhc3MgUmVwbGFjZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xufVxuLypcblJlcGxhY2VFcnJvciA9IGZ1bmN0aW9uKHRoaXM6IGFueSwgbWVzc2FnZTogc3RyaW5nKSB7XG4gIGxldCBlcnIgPSBFcnJvci5jYWxsKHRoaXMsIG1lc3NhZ2UpXG4gIDsoZXJyIGFzIGFueSkuX19wcm90b19fID0gUmVwbGFjZUVycm9yLnByb3RvdHlwZVxuICByZXR1cm4gZXJyXG59IGFzIGFueVxuXG5SZXBsYWNlRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpXG5SZXBsYWNlRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmVwbGFjZUVycm9yXG5SZXBsYWNlRXJyb3IucHJvdG90eXBlLm5hbWUgPSBcIlJlcGxhY2VFcnJvclwiXG4qL1xuLyoqXG5BIHNsaWNlIHJlcHJlc2VudHMgYSBwaWVjZSBjdXQgb3V0IG9mIGEgbGFyZ2VyIGRvY3VtZW50LiBJdFxuc3RvcmVzIG5vdCBvbmx5IGEgZnJhZ21lbnQsIGJ1dCBhbHNvIHRoZSBkZXB0aCB1cCB0byB3aGljaCBub2RlcyBvblxuYm90aCBzaWRlIGFyZSDigJhvcGVu4oCZIChjdXQgdGhyb3VnaCkuXG4qL1xuY2xhc3MgU2xpY2Uge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNsaWNlLiBXaGVuIHNwZWNpZnlpbmcgYSBub24temVybyBvcGVuIGRlcHRoLCB5b3UgbXVzdFxuICAgIG1ha2Ugc3VyZSB0aGF0IHRoZXJlIGFyZSBub2RlcyBvZiBhdCBsZWFzdCB0aGF0IGRlcHRoIGF0IHRoZVxuICAgIGFwcHJvcHJpYXRlIHNpZGUgb2YgdGhlIGZyYWdtZW504oCUaS5lLiBpZiB0aGUgZnJhZ21lbnQgaXMgYW5cbiAgICBlbXB0eSBwYXJhZ3JhcGggbm9kZSwgYG9wZW5TdGFydGAgYW5kIGBvcGVuRW5kYCBjYW4ndCBiZSBncmVhdGVyXG4gICAgdGhhbiAxLlxuICAgIFxuICAgIEl0IGlzIG5vdCBuZWNlc3NhcnkgZm9yIHRoZSBjb250ZW50IG9mIG9wZW4gbm9kZXMgdG8gY29uZm9ybSB0b1xuICAgIHRoZSBzY2hlbWEncyBjb250ZW50IGNvbnN0cmFpbnRzLCB0aG91Z2ggaXQgc2hvdWxkIGJlIGEgdmFsaWRcbiAgICBzdGFydC9lbmQvbWlkZGxlIGZvciBzdWNoIGEgbm9kZSwgZGVwZW5kaW5nIG9uIHdoaWNoIHNpZGVzIGFyZVxuICAgIG9wZW4uXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgc2xpY2UncyBjb250ZW50LlxuICAgICovXG4gICAgY29udGVudCwgXG4gICAgLyoqXG4gICAgVGhlIG9wZW4gZGVwdGggYXQgdGhlIHN0YXJ0IG9mIHRoZSBmcmFnbWVudC5cbiAgICAqL1xuICAgIG9wZW5TdGFydCwgXG4gICAgLyoqXG4gICAgVGhlIG9wZW4gZGVwdGggYXQgdGhlIGVuZC5cbiAgICAqL1xuICAgIG9wZW5FbmQpIHtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICAgICAgdGhpcy5vcGVuU3RhcnQgPSBvcGVuU3RhcnQ7XG4gICAgICAgIHRoaXMub3BlbkVuZCA9IG9wZW5FbmQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBzaXplIHRoaXMgc2xpY2Ugd291bGQgYWRkIHdoZW4gaW5zZXJ0ZWQgaW50byBhIGRvY3VtZW50LlxuICAgICovXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQuc2l6ZSAtIHRoaXMub3BlblN0YXJ0IC0gdGhpcy5vcGVuRW5kO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGluc2VydEF0KHBvcywgZnJhZ21lbnQpIHtcbiAgICAgICAgbGV0IGNvbnRlbnQgPSBpbnNlcnRJbnRvKHRoaXMuY29udGVudCwgcG9zICsgdGhpcy5vcGVuU3RhcnQsIGZyYWdtZW50KTtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQgJiYgbmV3IFNsaWNlKGNvbnRlbnQsIHRoaXMub3BlblN0YXJ0LCB0aGlzLm9wZW5FbmQpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlbW92ZUJldHdlZW4oZnJvbSwgdG8pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTbGljZShyZW1vdmVSYW5nZSh0aGlzLmNvbnRlbnQsIGZyb20gKyB0aGlzLm9wZW5TdGFydCwgdG8gKyB0aGlzLm9wZW5TdGFydCksIHRoaXMub3BlblN0YXJ0LCB0aGlzLm9wZW5FbmQpO1xuICAgIH1cbiAgICAvKipcbiAgICBUZXN0cyB3aGV0aGVyIHRoaXMgc2xpY2UgaXMgZXF1YWwgdG8gYW5vdGhlciBzbGljZS5cbiAgICAqL1xuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnQuZXEob3RoZXIuY29udGVudCkgJiYgdGhpcy5vcGVuU3RhcnQgPT0gb3RoZXIub3BlblN0YXJ0ICYmIHRoaXMub3BlbkVuZCA9PSBvdGhlci5vcGVuRW5kO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50ICsgXCIoXCIgKyB0aGlzLm9wZW5TdGFydCArIFwiLFwiICsgdGhpcy5vcGVuRW5kICsgXCIpXCI7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbnZlcnQgYSBzbGljZSB0byBhIEpTT04tc2VyaWFsaXphYmxlIHJlcHJlc2VudGF0aW9uLlxuICAgICovXG4gICAgdG9KU09OKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29udGVudC5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCBqc29uID0geyBjb250ZW50OiB0aGlzLmNvbnRlbnQudG9KU09OKCkgfTtcbiAgICAgICAgaWYgKHRoaXMub3BlblN0YXJ0ID4gMClcbiAgICAgICAgICAgIGpzb24ub3BlblN0YXJ0ID0gdGhpcy5vcGVuU3RhcnQ7XG4gICAgICAgIGlmICh0aGlzLm9wZW5FbmQgPiAwKVxuICAgICAgICAgICAganNvbi5vcGVuRW5kID0gdGhpcy5vcGVuRW5kO1xuICAgICAgICByZXR1cm4ganNvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVzZXJpYWxpemUgYSBzbGljZSBmcm9tIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uLlxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAoIWpzb24pXG4gICAgICAgICAgICByZXR1cm4gU2xpY2UuZW1wdHk7XG4gICAgICAgIGxldCBvcGVuU3RhcnQgPSBqc29uLm9wZW5TdGFydCB8fCAwLCBvcGVuRW5kID0ganNvbi5vcGVuRW5kIHx8IDA7XG4gICAgICAgIGlmICh0eXBlb2Ygb3BlblN0YXJ0ICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIG9wZW5FbmQgIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgU2xpY2UuZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbUpTT04oc2NoZW1hLCBqc29uLmNvbnRlbnQpLCBvcGVuU3RhcnQsIG9wZW5FbmQpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBzbGljZSBmcm9tIGEgZnJhZ21lbnQgYnkgdGFraW5nIHRoZSBtYXhpbXVtIHBvc3NpYmxlXG4gICAgb3BlbiB2YWx1ZSBvbiBib3RoIHNpZGUgb2YgdGhlIGZyYWdtZW50LlxuICAgICovXG4gICAgc3RhdGljIG1heE9wZW4oZnJhZ21lbnQsIG9wZW5Jc29sYXRpbmcgPSB0cnVlKSB7XG4gICAgICAgIGxldCBvcGVuU3RhcnQgPSAwLCBvcGVuRW5kID0gMDtcbiAgICAgICAgZm9yIChsZXQgbiA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7IG4gJiYgIW4uaXNMZWFmICYmIChvcGVuSXNvbGF0aW5nIHx8ICFuLnR5cGUuc3BlYy5pc29sYXRpbmcpOyBuID0gbi5maXJzdENoaWxkKVxuICAgICAgICAgICAgb3BlblN0YXJ0Kys7XG4gICAgICAgIGZvciAobGV0IG4gPSBmcmFnbWVudC5sYXN0Q2hpbGQ7IG4gJiYgIW4uaXNMZWFmICYmIChvcGVuSXNvbGF0aW5nIHx8ICFuLnR5cGUuc3BlYy5pc29sYXRpbmcpOyBuID0gbi5sYXN0Q2hpbGQpXG4gICAgICAgICAgICBvcGVuRW5kKys7XG4gICAgICAgIHJldHVybiBuZXcgU2xpY2UoZnJhZ21lbnQsIG9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgfVxufVxuLyoqXG5UaGUgZW1wdHkgc2xpY2UuXG4qL1xuU2xpY2UuZW1wdHkgPSBuZXcgU2xpY2UoRnJhZ21lbnQuZW1wdHksIDAsIDApO1xuZnVuY3Rpb24gcmVtb3ZlUmFuZ2UoY29udGVudCwgZnJvbSwgdG8pIHtcbiAgICBsZXQgeyBpbmRleCwgb2Zmc2V0IH0gPSBjb250ZW50LmZpbmRJbmRleChmcm9tKSwgY2hpbGQgPSBjb250ZW50Lm1heWJlQ2hpbGQoaW5kZXgpO1xuICAgIGxldCB7IGluZGV4OiBpbmRleFRvLCBvZmZzZXQ6IG9mZnNldFRvIH0gPSBjb250ZW50LmZpbmRJbmRleCh0byk7XG4gICAgaWYgKG9mZnNldCA9PSBmcm9tIHx8IGNoaWxkLmlzVGV4dCkge1xuICAgICAgICBpZiAob2Zmc2V0VG8gIT0gdG8gJiYgIWNvbnRlbnQuY2hpbGQoaW5kZXhUbykuaXNUZXh0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJSZW1vdmluZyBub24tZmxhdCByYW5nZVwiKTtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQuY3V0KDAsIGZyb20pLmFwcGVuZChjb250ZW50LmN1dCh0bykpO1xuICAgIH1cbiAgICBpZiAoaW5kZXggIT0gaW5kZXhUbylcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJSZW1vdmluZyBub24tZmxhdCByYW5nZVwiKTtcbiAgICByZXR1cm4gY29udGVudC5yZXBsYWNlQ2hpbGQoaW5kZXgsIGNoaWxkLmNvcHkocmVtb3ZlUmFuZ2UoY2hpbGQuY29udGVudCwgZnJvbSAtIG9mZnNldCAtIDEsIHRvIC0gb2Zmc2V0IC0gMSkpKTtcbn1cbmZ1bmN0aW9uIGluc2VydEludG8oY29udGVudCwgZGlzdCwgaW5zZXJ0LCBwYXJlbnQpIHtcbiAgICBsZXQgeyBpbmRleCwgb2Zmc2V0IH0gPSBjb250ZW50LmZpbmRJbmRleChkaXN0KSwgY2hpbGQgPSBjb250ZW50Lm1heWJlQ2hpbGQoaW5kZXgpO1xuICAgIGlmIChvZmZzZXQgPT0gZGlzdCB8fCBjaGlsZC5pc1RleHQpIHtcbiAgICAgICAgaWYgKHBhcmVudCAmJiAhcGFyZW50LmNhblJlcGxhY2UoaW5kZXgsIGluZGV4LCBpbnNlcnQpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBjb250ZW50LmN1dCgwLCBkaXN0KS5hcHBlbmQoaW5zZXJ0KS5hcHBlbmQoY29udGVudC5jdXQoZGlzdCkpO1xuICAgIH1cbiAgICBsZXQgaW5uZXIgPSBpbnNlcnRJbnRvKGNoaWxkLmNvbnRlbnQsIGRpc3QgLSBvZmZzZXQgLSAxLCBpbnNlcnQsIGNoaWxkKTtcbiAgICByZXR1cm4gaW5uZXIgJiYgY29udGVudC5yZXBsYWNlQ2hpbGQoaW5kZXgsIGNoaWxkLmNvcHkoaW5uZXIpKTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2UoJGZyb20sICR0bywgc2xpY2UpIHtcbiAgICBpZiAoc2xpY2Uub3BlblN0YXJ0ID4gJGZyb20uZGVwdGgpXG4gICAgICAgIHRocm93IG5ldyBSZXBsYWNlRXJyb3IoXCJJbnNlcnRlZCBjb250ZW50IGRlZXBlciB0aGFuIGluc2VydGlvbiBwb3NpdGlvblwiKTtcbiAgICBpZiAoJGZyb20uZGVwdGggLSBzbGljZS5vcGVuU3RhcnQgIT0gJHRvLmRlcHRoIC0gc2xpY2Uub3BlbkVuZClcbiAgICAgICAgdGhyb3cgbmV3IFJlcGxhY2VFcnJvcihcIkluY29uc2lzdGVudCBvcGVuIGRlcHRoc1wiKTtcbiAgICByZXR1cm4gcmVwbGFjZU91dGVyKCRmcm9tLCAkdG8sIHNsaWNlLCAwKTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VPdXRlcigkZnJvbSwgJHRvLCBzbGljZSwgZGVwdGgpIHtcbiAgICBsZXQgaW5kZXggPSAkZnJvbS5pbmRleChkZXB0aCksIG5vZGUgPSAkZnJvbS5ub2RlKGRlcHRoKTtcbiAgICBpZiAoaW5kZXggPT0gJHRvLmluZGV4KGRlcHRoKSAmJiBkZXB0aCA8ICRmcm9tLmRlcHRoIC0gc2xpY2Uub3BlblN0YXJ0KSB7XG4gICAgICAgIGxldCBpbm5lciA9IHJlcGxhY2VPdXRlcigkZnJvbSwgJHRvLCBzbGljZSwgZGVwdGggKyAxKTtcbiAgICAgICAgcmV0dXJuIG5vZGUuY29weShub2RlLmNvbnRlbnQucmVwbGFjZUNoaWxkKGluZGV4LCBpbm5lcikpO1xuICAgIH1cbiAgICBlbHNlIGlmICghc2xpY2UuY29udGVudC5zaXplKSB7XG4gICAgICAgIHJldHVybiBjbG9zZShub2RlLCByZXBsYWNlVHdvV2F5KCRmcm9tLCAkdG8sIGRlcHRoKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFzbGljZS5vcGVuU3RhcnQgJiYgIXNsaWNlLm9wZW5FbmQgJiYgJGZyb20uZGVwdGggPT0gZGVwdGggJiYgJHRvLmRlcHRoID09IGRlcHRoKSB7IC8vIFNpbXBsZSwgZmxhdCBjYXNlXG4gICAgICAgIGxldCBwYXJlbnQgPSAkZnJvbS5wYXJlbnQsIGNvbnRlbnQgPSBwYXJlbnQuY29udGVudDtcbiAgICAgICAgcmV0dXJuIGNsb3NlKHBhcmVudCwgY29udGVudC5jdXQoMCwgJGZyb20ucGFyZW50T2Zmc2V0KS5hcHBlbmQoc2xpY2UuY29udGVudCkuYXBwZW5kKGNvbnRlbnQuY3V0KCR0by5wYXJlbnRPZmZzZXQpKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgeyBzdGFydCwgZW5kIH0gPSBwcmVwYXJlU2xpY2VGb3JSZXBsYWNlKHNsaWNlLCAkZnJvbSk7XG4gICAgICAgIHJldHVybiBjbG9zZShub2RlLCByZXBsYWNlVGhyZWVXYXkoJGZyb20sIHN0YXJ0LCBlbmQsICR0bywgZGVwdGgpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja0pvaW4obWFpbiwgc3ViKSB7XG4gICAgaWYgKCFzdWIudHlwZS5jb21wYXRpYmxlQ29udGVudChtYWluLnR5cGUpKVxuICAgICAgICB0aHJvdyBuZXcgUmVwbGFjZUVycm9yKFwiQ2Fubm90IGpvaW4gXCIgKyBzdWIudHlwZS5uYW1lICsgXCIgb250byBcIiArIG1haW4udHlwZS5uYW1lKTtcbn1cbmZ1bmN0aW9uIGpvaW5hYmxlKCRiZWZvcmUsICRhZnRlciwgZGVwdGgpIHtcbiAgICBsZXQgbm9kZSA9ICRiZWZvcmUubm9kZShkZXB0aCk7XG4gICAgY2hlY2tKb2luKG5vZGUsICRhZnRlci5ub2RlKGRlcHRoKSk7XG4gICAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBhZGROb2RlKGNoaWxkLCB0YXJnZXQpIHtcbiAgICBsZXQgbGFzdCA9IHRhcmdldC5sZW5ndGggLSAxO1xuICAgIGlmIChsYXN0ID49IDAgJiYgY2hpbGQuaXNUZXh0ICYmIGNoaWxkLnNhbWVNYXJrdXAodGFyZ2V0W2xhc3RdKSlcbiAgICAgICAgdGFyZ2V0W2xhc3RdID0gY2hpbGQud2l0aFRleHQodGFyZ2V0W2xhc3RdLnRleHQgKyBjaGlsZC50ZXh0KTtcbiAgICBlbHNlXG4gICAgICAgIHRhcmdldC5wdXNoKGNoaWxkKTtcbn1cbmZ1bmN0aW9uIGFkZFJhbmdlKCRzdGFydCwgJGVuZCwgZGVwdGgsIHRhcmdldCkge1xuICAgIGxldCBub2RlID0gKCRlbmQgfHwgJHN0YXJ0KS5ub2RlKGRlcHRoKTtcbiAgICBsZXQgc3RhcnRJbmRleCA9IDAsIGVuZEluZGV4ID0gJGVuZCA/ICRlbmQuaW5kZXgoZGVwdGgpIDogbm9kZS5jaGlsZENvdW50O1xuICAgIGlmICgkc3RhcnQpIHtcbiAgICAgICAgc3RhcnRJbmRleCA9ICRzdGFydC5pbmRleChkZXB0aCk7XG4gICAgICAgIGlmICgkc3RhcnQuZGVwdGggPiBkZXB0aCkge1xuICAgICAgICAgICAgc3RhcnRJbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCRzdGFydC50ZXh0T2Zmc2V0KSB7XG4gICAgICAgICAgICBhZGROb2RlKCRzdGFydC5ub2RlQWZ0ZXIsIHRhcmdldCk7XG4gICAgICAgICAgICBzdGFydEluZGV4Kys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGkgPCBlbmRJbmRleDsgaSsrKVxuICAgICAgICBhZGROb2RlKG5vZGUuY2hpbGQoaSksIHRhcmdldCk7XG4gICAgaWYgKCRlbmQgJiYgJGVuZC5kZXB0aCA9PSBkZXB0aCAmJiAkZW5kLnRleHRPZmZzZXQpXG4gICAgICAgIGFkZE5vZGUoJGVuZC5ub2RlQmVmb3JlLCB0YXJnZXQpO1xufVxuZnVuY3Rpb24gY2xvc2Uobm9kZSwgY29udGVudCkge1xuICAgIG5vZGUudHlwZS5jaGVja0NvbnRlbnQoY29udGVudCk7XG4gICAgcmV0dXJuIG5vZGUuY29weShjb250ZW50KTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VUaHJlZVdheSgkZnJvbSwgJHN0YXJ0LCAkZW5kLCAkdG8sIGRlcHRoKSB7XG4gICAgbGV0IG9wZW5TdGFydCA9ICRmcm9tLmRlcHRoID4gZGVwdGggJiYgam9pbmFibGUoJGZyb20sICRzdGFydCwgZGVwdGggKyAxKTtcbiAgICBsZXQgb3BlbkVuZCA9ICR0by5kZXB0aCA+IGRlcHRoICYmIGpvaW5hYmxlKCRlbmQsICR0bywgZGVwdGggKyAxKTtcbiAgICBsZXQgY29udGVudCA9IFtdO1xuICAgIGFkZFJhbmdlKG51bGwsICRmcm9tLCBkZXB0aCwgY29udGVudCk7XG4gICAgaWYgKG9wZW5TdGFydCAmJiBvcGVuRW5kICYmICRzdGFydC5pbmRleChkZXB0aCkgPT0gJGVuZC5pbmRleChkZXB0aCkpIHtcbiAgICAgICAgY2hlY2tKb2luKG9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgICAgIGFkZE5vZGUoY2xvc2Uob3BlblN0YXJ0LCByZXBsYWNlVGhyZWVXYXkoJGZyb20sICRzdGFydCwgJGVuZCwgJHRvLCBkZXB0aCArIDEpKSwgY29udGVudCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAob3BlblN0YXJ0KVxuICAgICAgICAgICAgYWRkTm9kZShjbG9zZShvcGVuU3RhcnQsIHJlcGxhY2VUd29XYXkoJGZyb20sICRzdGFydCwgZGVwdGggKyAxKSksIGNvbnRlbnQpO1xuICAgICAgICBhZGRSYW5nZSgkc3RhcnQsICRlbmQsIGRlcHRoLCBjb250ZW50KTtcbiAgICAgICAgaWYgKG9wZW5FbmQpXG4gICAgICAgICAgICBhZGROb2RlKGNsb3NlKG9wZW5FbmQsIHJlcGxhY2VUd29XYXkoJGVuZCwgJHRvLCBkZXB0aCArIDEpKSwgY29udGVudCk7XG4gICAgfVxuICAgIGFkZFJhbmdlKCR0bywgbnVsbCwgZGVwdGgsIGNvbnRlbnQpO1xuICAgIHJldHVybiBuZXcgRnJhZ21lbnQoY29udGVudCk7XG59XG5mdW5jdGlvbiByZXBsYWNlVHdvV2F5KCRmcm9tLCAkdG8sIGRlcHRoKSB7XG4gICAgbGV0IGNvbnRlbnQgPSBbXTtcbiAgICBhZGRSYW5nZShudWxsLCAkZnJvbSwgZGVwdGgsIGNvbnRlbnQpO1xuICAgIGlmICgkZnJvbS5kZXB0aCA+IGRlcHRoKSB7XG4gICAgICAgIGxldCB0eXBlID0gam9pbmFibGUoJGZyb20sICR0bywgZGVwdGggKyAxKTtcbiAgICAgICAgYWRkTm9kZShjbG9zZSh0eXBlLCByZXBsYWNlVHdvV2F5KCRmcm9tLCAkdG8sIGRlcHRoICsgMSkpLCBjb250ZW50KTtcbiAgICB9XG4gICAgYWRkUmFuZ2UoJHRvLCBudWxsLCBkZXB0aCwgY29udGVudCk7XG4gICAgcmV0dXJuIG5ldyBGcmFnbWVudChjb250ZW50KTtcbn1cbmZ1bmN0aW9uIHByZXBhcmVTbGljZUZvclJlcGxhY2Uoc2xpY2UsICRhbG9uZykge1xuICAgIGxldCBleHRyYSA9ICRhbG9uZy5kZXB0aCAtIHNsaWNlLm9wZW5TdGFydCwgcGFyZW50ID0gJGFsb25nLm5vZGUoZXh0cmEpO1xuICAgIGxldCBub2RlID0gcGFyZW50LmNvcHkoc2xpY2UuY29udGVudCk7XG4gICAgZm9yIChsZXQgaSA9IGV4dHJhIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIG5vZGUgPSAkYWxvbmcubm9kZShpKS5jb3B5KEZyYWdtZW50LmZyb20obm9kZSkpO1xuICAgIHJldHVybiB7IHN0YXJ0OiBub2RlLnJlc29sdmVOb0NhY2hlKHNsaWNlLm9wZW5TdGFydCArIGV4dHJhKSxcbiAgICAgICAgZW5kOiBub2RlLnJlc29sdmVOb0NhY2hlKG5vZGUuY29udGVudC5zaXplIC0gc2xpY2Uub3BlbkVuZCAtIGV4dHJhKSB9O1xufVxuXG4vKipcbllvdSBjYW4gW19yZXNvbHZlX10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGUucmVzb2x2ZSkgYSBwb3NpdGlvbiB0byBnZXQgbW9yZVxuaW5mb3JtYXRpb24gYWJvdXQgaXQuIE9iamVjdHMgb2YgdGhpcyBjbGFzcyByZXByZXNlbnQgc3VjaCBhXG5yZXNvbHZlZCBwb3NpdGlvbiwgcHJvdmlkaW5nIHZhcmlvdXMgcGllY2VzIG9mIGNvbnRleHRcbmluZm9ybWF0aW9uLCBhbmQgc29tZSBoZWxwZXIgbWV0aG9kcy5cblxuVGhyb3VnaG91dCB0aGlzIGludGVyZmFjZSwgbWV0aG9kcyB0aGF0IHRha2UgYW4gb3B0aW9uYWwgYGRlcHRoYFxucGFyYW1ldGVyIHdpbGwgaW50ZXJwcmV0IHVuZGVmaW5lZCBhcyBgdGhpcy5kZXB0aGAgYW5kIG5lZ2F0aXZlXG5udW1iZXJzIGFzIGB0aGlzLmRlcHRoICsgdmFsdWVgLlxuKi9cbmNsYXNzIFJlc29sdmVkUG9zIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiB0aGF0IHdhcyByZXNvbHZlZC5cbiAgICAqL1xuICAgIHBvcywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBwYXRoLCBcbiAgICAvKipcbiAgICBUaGUgb2Zmc2V0IHRoaXMgcG9zaXRpb24gaGFzIGludG8gaXRzIHBhcmVudCBub2RlLlxuICAgICovXG4gICAgcGFyZW50T2Zmc2V0KSB7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICB0aGlzLnBhcmVudE9mZnNldCA9IHBhcmVudE9mZnNldDtcbiAgICAgICAgdGhpcy5kZXB0aCA9IHBhdGgubGVuZ3RoIC8gMyAtIDE7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVzb2x2ZURlcHRoKHZhbCkge1xuICAgICAgICBpZiAodmFsID09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZXB0aDtcbiAgICAgICAgaWYgKHZhbCA8IDApXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kZXB0aCArIHZhbDtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHBhcmVudCBub2RlIHRoYXQgdGhlIHBvc2l0aW9uIHBvaW50cyBpbnRvLiBOb3RlIHRoYXQgZXZlbiBpZlxuICAgIGEgcG9zaXRpb24gcG9pbnRzIGludG8gYSB0ZXh0IG5vZGUsIHRoYXQgbm9kZSBpcyBub3QgY29uc2lkZXJlZFxuICAgIHRoZSBwYXJlbnTigJR0ZXh0IG5vZGVzIGFyZSDigJhmbGF04oCZIGluIHRoaXMgbW9kZWwsIGFuZCBoYXZlIG5vIGNvbnRlbnQuXG4gICAgKi9cbiAgICBnZXQgcGFyZW50KCkgeyByZXR1cm4gdGhpcy5ub2RlKHRoaXMuZGVwdGgpOyB9XG4gICAgLyoqXG4gICAgVGhlIHJvb3Qgbm9kZSBpbiB3aGljaCB0aGUgcG9zaXRpb24gd2FzIHJlc29sdmVkLlxuICAgICovXG4gICAgZ2V0IGRvYygpIHsgcmV0dXJuIHRoaXMubm9kZSgwKTsgfVxuICAgIC8qKlxuICAgIFRoZSBhbmNlc3RvciBub2RlIGF0IHRoZSBnaXZlbiBsZXZlbC4gYHAubm9kZShwLmRlcHRoKWAgaXMgdGhlXG4gICAgc2FtZSBhcyBgcC5wYXJlbnRgLlxuICAgICovXG4gICAgbm9kZShkZXB0aCkgeyByZXR1cm4gdGhpcy5wYXRoW3RoaXMucmVzb2x2ZURlcHRoKGRlcHRoKSAqIDNdOyB9XG4gICAgLyoqXG4gICAgVGhlIGluZGV4IGludG8gdGhlIGFuY2VzdG9yIGF0IHRoZSBnaXZlbiBsZXZlbC4gSWYgdGhpcyBwb2ludHNcbiAgICBhdCB0aGUgM3JkIG5vZGUgaW4gdGhlIDJuZCBwYXJhZ3JhcGggb24gdGhlIHRvcCBsZXZlbCwgZm9yXG4gICAgZXhhbXBsZSwgYHAuaW5kZXgoMClgIGlzIDEgYW5kIGBwLmluZGV4KDEpYCBpcyAyLlxuICAgICovXG4gICAgaW5kZXgoZGVwdGgpIHsgcmV0dXJuIHRoaXMucGF0aFt0aGlzLnJlc29sdmVEZXB0aChkZXB0aCkgKiAzICsgMV07IH1cbiAgICAvKipcbiAgICBUaGUgaW5kZXggcG9pbnRpbmcgYWZ0ZXIgdGhpcyBwb3NpdGlvbiBpbnRvIHRoZSBhbmNlc3RvciBhdCB0aGVcbiAgICBnaXZlbiBsZXZlbC5cbiAgICAqL1xuICAgIGluZGV4QWZ0ZXIoZGVwdGgpIHtcbiAgICAgICAgZGVwdGggPSB0aGlzLnJlc29sdmVEZXB0aChkZXB0aCk7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4KGRlcHRoKSArIChkZXB0aCA9PSB0aGlzLmRlcHRoICYmICF0aGlzLnRleHRPZmZzZXQgPyAwIDogMSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSAoYWJzb2x1dGUpIHBvc2l0aW9uIGF0IHRoZSBzdGFydCBvZiB0aGUgbm9kZSBhdCB0aGUgZ2l2ZW5cbiAgICBsZXZlbC5cbiAgICAqL1xuICAgIHN0YXJ0KGRlcHRoKSB7XG4gICAgICAgIGRlcHRoID0gdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpO1xuICAgICAgICByZXR1cm4gZGVwdGggPT0gMCA/IDAgOiB0aGlzLnBhdGhbZGVwdGggKiAzIC0gMV0gKyAxO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgKGFic29sdXRlKSBwb3NpdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBub2RlIGF0IHRoZSBnaXZlblxuICAgIGxldmVsLlxuICAgICovXG4gICAgZW5kKGRlcHRoKSB7XG4gICAgICAgIGRlcHRoID0gdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFydChkZXB0aCkgKyB0aGlzLm5vZGUoZGVwdGgpLmNvbnRlbnQuc2l6ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIChhYnNvbHV0ZSkgcG9zaXRpb24gZGlyZWN0bHkgYmVmb3JlIHRoZSB3cmFwcGluZyBub2RlIGF0IHRoZVxuICAgIGdpdmVuIGxldmVsLCBvciwgd2hlbiBgZGVwdGhgIGlzIGB0aGlzLmRlcHRoICsgMWAsIHRoZSBvcmlnaW5hbFxuICAgIHBvc2l0aW9uLlxuICAgICovXG4gICAgYmVmb3JlKGRlcHRoKSB7XG4gICAgICAgIGRlcHRoID0gdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpO1xuICAgICAgICBpZiAoIWRlcHRoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGVyZSBpcyBubyBwb3NpdGlvbiBiZWZvcmUgdGhlIHRvcC1sZXZlbCBub2RlXCIpO1xuICAgICAgICByZXR1cm4gZGVwdGggPT0gdGhpcy5kZXB0aCArIDEgPyB0aGlzLnBvcyA6IHRoaXMucGF0aFtkZXB0aCAqIDMgLSAxXTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIChhYnNvbHV0ZSkgcG9zaXRpb24gZGlyZWN0bHkgYWZ0ZXIgdGhlIHdyYXBwaW5nIG5vZGUgYXQgdGhlXG4gICAgZ2l2ZW4gbGV2ZWwsIG9yIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiB3aGVuIGBkZXB0aGAgaXMgYHRoaXMuZGVwdGggKyAxYC5cbiAgICAqL1xuICAgIGFmdGVyKGRlcHRoKSB7XG4gICAgICAgIGRlcHRoID0gdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpO1xuICAgICAgICBpZiAoIWRlcHRoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGVyZSBpcyBubyBwb3NpdGlvbiBhZnRlciB0aGUgdG9wLWxldmVsIG5vZGVcIik7XG4gICAgICAgIHJldHVybiBkZXB0aCA9PSB0aGlzLmRlcHRoICsgMSA/IHRoaXMucG9zIDogdGhpcy5wYXRoW2RlcHRoICogMyAtIDFdICsgdGhpcy5wYXRoW2RlcHRoICogM10ubm9kZVNpemU7XG4gICAgfVxuICAgIC8qKlxuICAgIFdoZW4gdGhpcyBwb3NpdGlvbiBwb2ludHMgaW50byBhIHRleHQgbm9kZSwgdGhpcyByZXR1cm5zIHRoZVxuICAgIGRpc3RhbmNlIGJldHdlZW4gdGhlIHBvc2l0aW9uIGFuZCB0aGUgc3RhcnQgb2YgdGhlIHRleHQgbm9kZS5cbiAgICBXaWxsIGJlIHplcm8gZm9yIHBvc2l0aW9ucyB0aGF0IHBvaW50IGJldHdlZW4gbm9kZXMuXG4gICAgKi9cbiAgICBnZXQgdGV4dE9mZnNldCgpIHsgcmV0dXJuIHRoaXMucG9zIC0gdGhpcy5wYXRoW3RoaXMucGF0aC5sZW5ndGggLSAxXTsgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgbm9kZSBkaXJlY3RseSBhZnRlciB0aGUgcG9zaXRpb24sIGlmIGFueS4gSWYgdGhlIHBvc2l0aW9uXG4gICAgcG9pbnRzIGludG8gYSB0ZXh0IG5vZGUsIG9ubHkgdGhlIHBhcnQgb2YgdGhhdCBub2RlIGFmdGVyIHRoZVxuICAgIHBvc2l0aW9uIGlzIHJldHVybmVkLlxuICAgICovXG4gICAgZ2V0IG5vZGVBZnRlcigpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9IHRoaXMucGFyZW50LCBpbmRleCA9IHRoaXMuaW5kZXgodGhpcy5kZXB0aCk7XG4gICAgICAgIGlmIChpbmRleCA9PSBwYXJlbnQuY2hpbGRDb3VudClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgZE9mZiA9IHRoaXMucG9zIC0gdGhpcy5wYXRoW3RoaXMucGF0aC5sZW5ndGggLSAxXSwgY2hpbGQgPSBwYXJlbnQuY2hpbGQoaW5kZXgpO1xuICAgICAgICByZXR1cm4gZE9mZiA/IHBhcmVudC5jaGlsZChpbmRleCkuY3V0KGRPZmYpIDogY2hpbGQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgbm9kZSBkaXJlY3RseSBiZWZvcmUgdGhlIHBvc2l0aW9uLCBpZiBhbnkuIElmIHRoZVxuICAgIHBvc2l0aW9uIHBvaW50cyBpbnRvIGEgdGV4dCBub2RlLCBvbmx5IHRoZSBwYXJ0IG9mIHRoYXQgbm9kZVxuICAgIGJlZm9yZSB0aGUgcG9zaXRpb24gaXMgcmV0dXJuZWQuXG4gICAgKi9cbiAgICBnZXQgbm9kZUJlZm9yZSgpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5pbmRleCh0aGlzLmRlcHRoKTtcbiAgICAgICAgbGV0IGRPZmYgPSB0aGlzLnBvcyAtIHRoaXMucGF0aFt0aGlzLnBhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChkT2ZmKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmNoaWxkKGluZGV4KS5jdXQoMCwgZE9mZik7XG4gICAgICAgIHJldHVybiBpbmRleCA9PSAwID8gbnVsbCA6IHRoaXMucGFyZW50LmNoaWxkKGluZGV4IC0gMSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgcG9zaXRpb24gYXQgdGhlIGdpdmVuIGluZGV4IGluIHRoZSBwYXJlbnQgbm9kZSBhdCB0aGVcbiAgICBnaXZlbiBkZXB0aCAod2hpY2ggZGVmYXVsdHMgdG8gYHRoaXMuZGVwdGhgKS5cbiAgICAqL1xuICAgIHBvc0F0SW5kZXgoaW5kZXgsIGRlcHRoKSB7XG4gICAgICAgIGRlcHRoID0gdGhpcy5yZXNvbHZlRGVwdGgoZGVwdGgpO1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMucGF0aFtkZXB0aCAqIDNdLCBwb3MgPSBkZXB0aCA9PSAwID8gMCA6IHRoaXMucGF0aFtkZXB0aCAqIDMgLSAxXSArIDE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXg7IGkrKylcbiAgICAgICAgICAgIHBvcyArPSBub2RlLmNoaWxkKGkpLm5vZGVTaXplO1xuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIG1hcmtzIGF0IHRoaXMgcG9zaXRpb24sIGZhY3RvcmluZyBpbiB0aGUgc3Vycm91bmRpbmdcbiAgICBtYXJrcycgW2BpbmNsdXNpdmVgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTWFya1NwZWMuaW5jbHVzaXZlKSBwcm9wZXJ0eS4gSWYgdGhlXG4gICAgcG9zaXRpb24gaXMgYXQgdGhlIHN0YXJ0IG9mIGEgbm9uLWVtcHR5IG5vZGUsIHRoZSBtYXJrcyBvZiB0aGVcbiAgICBub2RlIGFmdGVyIGl0IChpZiBhbnkpIGFyZSByZXR1cm5lZC5cbiAgICAqL1xuICAgIG1hcmtzKCkge1xuICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5wYXJlbnQsIGluZGV4ID0gdGhpcy5pbmRleCgpO1xuICAgICAgICAvLyBJbiBhbiBlbXB0eSBwYXJlbnQsIHJldHVybiB0aGUgZW1wdHkgYXJyYXlcbiAgICAgICAgaWYgKHBhcmVudC5jb250ZW50LnNpemUgPT0gMClcbiAgICAgICAgICAgIHJldHVybiBNYXJrLm5vbmU7XG4gICAgICAgIC8vIFdoZW4gaW5zaWRlIGEgdGV4dCBub2RlLCBqdXN0IHJldHVybiB0aGUgdGV4dCBub2RlJ3MgbWFya3NcbiAgICAgICAgaWYgKHRoaXMudGV4dE9mZnNldClcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnQuY2hpbGQoaW5kZXgpLm1hcmtzO1xuICAgICAgICBsZXQgbWFpbiA9IHBhcmVudC5tYXliZUNoaWxkKGluZGV4IC0gMSksIG90aGVyID0gcGFyZW50Lm1heWJlQ2hpbGQoaW5kZXgpO1xuICAgICAgICAvLyBJZiB0aGUgYGFmdGVyYCBmbGFnIGlzIHRydWUgb2YgdGhlcmUgaXMgbm8gbm9kZSBiZWZvcmUsIG1ha2VcbiAgICAgICAgLy8gdGhlIG5vZGUgYWZ0ZXIgdGhpcyBwb3NpdGlvbiB0aGUgbWFpbiByZWZlcmVuY2UuXG4gICAgICAgIGlmICghbWFpbikge1xuICAgICAgICAgICAgbGV0IHRtcCA9IG1haW47XG4gICAgICAgICAgICBtYWluID0gb3RoZXI7XG4gICAgICAgICAgICBvdGhlciA9IHRtcDtcbiAgICAgICAgfVxuICAgICAgICAvLyBVc2UgYWxsIG1hcmtzIGluIHRoZSBtYWluIG5vZGUsIGV4Y2VwdCB0aG9zZSB0aGF0IGhhdmVcbiAgICAgICAgLy8gYGluY2x1c2l2ZWAgc2V0IHRvIGZhbHNlIGFuZCBhcmUgbm90IHByZXNlbnQgaW4gdGhlIG90aGVyIG5vZGUuXG4gICAgICAgIGxldCBtYXJrcyA9IG1haW4ubWFya3M7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFya3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAobWFya3NbaV0udHlwZS5zcGVjLmluY2x1c2l2ZSA9PT0gZmFsc2UgJiYgKCFvdGhlciB8fCAhbWFya3NbaV0uaXNJblNldChvdGhlci5tYXJrcykpKVxuICAgICAgICAgICAgICAgIG1hcmtzID0gbWFya3NbaS0tXS5yZW1vdmVGcm9tU2V0KG1hcmtzKTtcbiAgICAgICAgcmV0dXJuIG1hcmtzO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIG1hcmtzIGFmdGVyIHRoZSBjdXJyZW50IHBvc2l0aW9uLCBpZiBhbnksIGV4Y2VwdCB0aG9zZVxuICAgIHRoYXQgYXJlIG5vbi1pbmNsdXNpdmUgYW5kIG5vdCBwcmVzZW50IGF0IHBvc2l0aW9uIGAkZW5kYC4gVGhpc1xuICAgIGlzIG1vc3RseSB1c2VmdWwgZm9yIGdldHRpbmcgdGhlIHNldCBvZiBtYXJrcyB0byBwcmVzZXJ2ZSBhZnRlciBhXG4gICAgZGVsZXRpb24uIFdpbGwgcmV0dXJuIGBudWxsYCBpZiB0aGlzIHBvc2l0aW9uIGlzIGF0IHRoZSBlbmQgb2ZcbiAgICBpdHMgcGFyZW50IG5vZGUgb3IgaXRzIHBhcmVudCBub2RlIGlzbid0IGEgdGV4dGJsb2NrIChpbiB3aGljaFxuICAgIGNhc2Ugbm8gbWFya3Mgc2hvdWxkIGJlIHByZXNlcnZlZCkuXG4gICAgKi9cbiAgICBtYXJrc0Fjcm9zcygkZW5kKSB7XG4gICAgICAgIGxldCBhZnRlciA9IHRoaXMucGFyZW50Lm1heWJlQ2hpbGQodGhpcy5pbmRleCgpKTtcbiAgICAgICAgaWYgKCFhZnRlciB8fCAhYWZ0ZXIuaXNJbmxpbmUpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IG1hcmtzID0gYWZ0ZXIubWFya3MsIG5leHQgPSAkZW5kLnBhcmVudC5tYXliZUNoaWxkKCRlbmQuaW5kZXgoKSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFya3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAobWFya3NbaV0udHlwZS5zcGVjLmluY2x1c2l2ZSA9PT0gZmFsc2UgJiYgKCFuZXh0IHx8ICFtYXJrc1tpXS5pc0luU2V0KG5leHQubWFya3MpKSlcbiAgICAgICAgICAgICAgICBtYXJrcyA9IG1hcmtzW2ktLV0ucmVtb3ZlRnJvbVNldChtYXJrcyk7XG4gICAgICAgIHJldHVybiBtYXJrcztcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGRlcHRoIHVwIHRvIHdoaWNoIHRoaXMgcG9zaXRpb24gYW5kIHRoZSBnaXZlbiAobm9uLXJlc29sdmVkKVxuICAgIHBvc2l0aW9uIHNoYXJlIHRoZSBzYW1lIHBhcmVudCBub2Rlcy5cbiAgICAqL1xuICAgIHNoYXJlZERlcHRoKHBvcykge1xuICAgICAgICBmb3IgKGxldCBkZXB0aCA9IHRoaXMuZGVwdGg7IGRlcHRoID4gMDsgZGVwdGgtLSlcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXJ0KGRlcHRoKSA8PSBwb3MgJiYgdGhpcy5lbmQoZGVwdGgpID49IHBvcylcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVwdGg7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIGEgcmFuZ2UgYmFzZWQgb24gdGhlIHBsYWNlIHdoZXJlIHRoaXMgcG9zaXRpb24gYW5kIHRoZVxuICAgIGdpdmVuIHBvc2l0aW9uIGRpdmVyZ2UgYXJvdW5kIGJsb2NrIGNvbnRlbnQuIElmIGJvdGggcG9pbnQgaW50b1xuICAgIHRoZSBzYW1lIHRleHRibG9jaywgZm9yIGV4YW1wbGUsIGEgcmFuZ2UgYXJvdW5kIHRoYXQgdGV4dGJsb2NrXG4gICAgd2lsbCBiZSByZXR1cm5lZC4gSWYgdGhleSBwb2ludCBpbnRvIGRpZmZlcmVudCBibG9ja3MsIHRoZSByYW5nZVxuICAgIGFyb3VuZCB0aG9zZSBibG9ja3MgaW4gdGhlaXIgc2hhcmVkIGFuY2VzdG9yIGlzIHJldHVybmVkLiBZb3UgY2FuXG4gICAgcGFzcyBpbiBhbiBvcHRpb25hbCBwcmVkaWNhdGUgdGhhdCB3aWxsIGJlIGNhbGxlZCB3aXRoIGEgcGFyZW50XG4gICAgbm9kZSB0byBzZWUgaWYgYSByYW5nZSBpbnRvIHRoYXQgcGFyZW50IGlzIGFjY2VwdGFibGUuXG4gICAgKi9cbiAgICBibG9ja1JhbmdlKG90aGVyID0gdGhpcywgcHJlZCkge1xuICAgICAgICBpZiAob3RoZXIucG9zIDwgdGhpcy5wb3MpXG4gICAgICAgICAgICByZXR1cm4gb3RoZXIuYmxvY2tSYW5nZSh0aGlzKTtcbiAgICAgICAgZm9yIChsZXQgZCA9IHRoaXMuZGVwdGggLSAodGhpcy5wYXJlbnQuaW5saW5lQ29udGVudCB8fCB0aGlzLnBvcyA9PSBvdGhlci5wb3MgPyAxIDogMCk7IGQgPj0gMDsgZC0tKVxuICAgICAgICAgICAgaWYgKG90aGVyLnBvcyA8PSB0aGlzLmVuZChkKSAmJiAoIXByZWQgfHwgcHJlZCh0aGlzLm5vZGUoZCkpKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE5vZGVSYW5nZSh0aGlzLCBvdGhlciwgZCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBRdWVyeSB3aGV0aGVyIHRoZSBnaXZlbiBwb3NpdGlvbiBzaGFyZXMgdGhlIHNhbWUgcGFyZW50IG5vZGUuXG4gICAgKi9cbiAgICBzYW1lUGFyZW50KG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvcyAtIHRoaXMucGFyZW50T2Zmc2V0ID09IG90aGVyLnBvcyAtIG90aGVyLnBhcmVudE9mZnNldDtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJuIHRoZSBncmVhdGVyIG9mIHRoaXMgYW5kIHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIG1heChvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIucG9zID4gdGhpcy5wb3MgPyBvdGhlciA6IHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiB0aGUgc21hbGxlciBvZiB0aGlzIGFuZCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgKi9cbiAgICBtaW4ob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyLnBvcyA8IHRoaXMucG9zID8gb3RoZXIgOiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgc3RyID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gdGhpcy5kZXB0aDsgaSsrKVxuICAgICAgICAgICAgc3RyICs9IChzdHIgPyBcIi9cIiA6IFwiXCIpICsgdGhpcy5ub2RlKGkpLnR5cGUubmFtZSArIFwiX1wiICsgdGhpcy5pbmRleChpIC0gMSk7XG4gICAgICAgIHJldHVybiBzdHIgKyBcIjpcIiArIHRoaXMucGFyZW50T2Zmc2V0O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyByZXNvbHZlKGRvYywgcG9zKSB7XG4gICAgICAgIGlmICghKHBvcyA+PSAwICYmIHBvcyA8PSBkb2MuY29udGVudC5zaXplKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiUG9zaXRpb24gXCIgKyBwb3MgKyBcIiBvdXQgb2YgcmFuZ2VcIik7XG4gICAgICAgIGxldCBwYXRoID0gW107XG4gICAgICAgIGxldCBzdGFydCA9IDAsIHBhcmVudE9mZnNldCA9IHBvcztcbiAgICAgICAgZm9yIChsZXQgbm9kZSA9IGRvYzs7KSB7XG4gICAgICAgICAgICBsZXQgeyBpbmRleCwgb2Zmc2V0IH0gPSBub2RlLmNvbnRlbnQuZmluZEluZGV4KHBhcmVudE9mZnNldCk7XG4gICAgICAgICAgICBsZXQgcmVtID0gcGFyZW50T2Zmc2V0IC0gb2Zmc2V0O1xuICAgICAgICAgICAgcGF0aC5wdXNoKG5vZGUsIGluZGV4LCBzdGFydCArIG9mZnNldCk7XG4gICAgICAgICAgICBpZiAoIXJlbSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkKGluZGV4KTtcbiAgICAgICAgICAgIGlmIChub2RlLmlzVGV4dClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHBhcmVudE9mZnNldCA9IHJlbSAtIDE7XG4gICAgICAgICAgICBzdGFydCArPSBvZmZzZXQgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUmVzb2x2ZWRQb3MocG9zLCBwYXRoLCBwYXJlbnRPZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyByZXNvbHZlQ2FjaGVkKGRvYywgcG9zKSB7XG4gICAgICAgIGxldCBjYWNoZSA9IHJlc29sdmVDYWNoZS5nZXQoZG9jKTtcbiAgICAgICAgaWYgKGNhY2hlKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNhY2hlLmVsdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgZWx0ID0gY2FjaGUuZWx0c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoZWx0LnBvcyA9PSBwb3MpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXNvbHZlQ2FjaGUuc2V0KGRvYywgY2FjaGUgPSBuZXcgUmVzb2x2ZUNhY2hlKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gY2FjaGUuZWx0c1tjYWNoZS5pXSA9IFJlc29sdmVkUG9zLnJlc29sdmUoZG9jLCBwb3MpO1xuICAgICAgICBjYWNoZS5pID0gKGNhY2hlLmkgKyAxKSAlIHJlc29sdmVDYWNoZVNpemU7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuY2xhc3MgUmVzb2x2ZUNhY2hlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5lbHRzID0gW107XG4gICAgICAgIHRoaXMuaSA9IDA7XG4gICAgfVxufVxuY29uc3QgcmVzb2x2ZUNhY2hlU2l6ZSA9IDEyLCByZXNvbHZlQ2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuLyoqXG5SZXByZXNlbnRzIGEgZmxhdCByYW5nZSBvZiBjb250ZW50LCBpLmUuIG9uZSB0aGF0IHN0YXJ0cyBhbmRcbmVuZHMgaW4gdGhlIHNhbWUgbm9kZS5cbiovXG5jbGFzcyBOb2RlUmFuZ2Uge1xuICAgIC8qKlxuICAgIENvbnN0cnVjdCBhIG5vZGUgcmFuZ2UuIGAkZnJvbWAgYW5kIGAkdG9gIHNob3VsZCBwb2ludCBpbnRvIHRoZVxuICAgIHNhbWUgbm9kZSB1bnRpbCBhdCBsZWFzdCB0aGUgZ2l2ZW4gYGRlcHRoYCwgc2luY2UgYSBub2RlIHJhbmdlXG4gICAgZGVub3RlcyBhbiBhZGphY2VudCBzZXQgb2Ygbm9kZXMgaW4gYSBzaW5nbGUgcGFyZW50IG5vZGUuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBBIHJlc29sdmVkIHBvc2l0aW9uIGFsb25nIHRoZSBzdGFydCBvZiB0aGUgY29udGVudC4gTWF5IGhhdmUgYVxuICAgIGBkZXB0aGAgZ3JlYXRlciB0aGFuIHRoaXMgb2JqZWN0J3MgYGRlcHRoYCBwcm9wZXJ0eSwgc2luY2VcbiAgICB0aGVzZSBhcmUgdGhlIHBvc2l0aW9ucyB0aGF0IHdlcmUgdXNlZCB0byBjb21wdXRlIHRoZSByYW5nZSxcbiAgICBub3QgcmUtcmVzb2x2ZWQgcG9zaXRpb25zIGRpcmVjdGx5IGF0IGl0cyBib3VuZGFyaWVzLlxuICAgICovXG4gICAgJGZyb20sIFxuICAgIC8qKlxuICAgIEEgcG9zaXRpb24gYWxvbmcgdGhlIGVuZCBvZiB0aGUgY29udGVudC4gU2VlXG4gICAgY2F2ZWF0IGZvciBbYCRmcm9tYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVSYW5nZS4kZnJvbSkuXG4gICAgKi9cbiAgICAkdG8sIFxuICAgIC8qKlxuICAgIFRoZSBkZXB0aCBvZiB0aGUgbm9kZSB0aGF0IHRoaXMgcmFuZ2UgcG9pbnRzIGludG8uXG4gICAgKi9cbiAgICBkZXB0aCkge1xuICAgICAgICB0aGlzLiRmcm9tID0gJGZyb207XG4gICAgICAgIHRoaXMuJHRvID0gJHRvO1xuICAgICAgICB0aGlzLmRlcHRoID0gZGVwdGg7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbiBhdCB0aGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICovXG4gICAgZ2V0IHN0YXJ0KCkgeyByZXR1cm4gdGhpcy4kZnJvbS5iZWZvcmUodGhpcy5kZXB0aCArIDEpOyB9XG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIGF0IHRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICovXG4gICAgZ2V0IGVuZCgpIHsgcmV0dXJuIHRoaXMuJHRvLmFmdGVyKHRoaXMuZGVwdGggKyAxKTsgfVxuICAgIC8qKlxuICAgIFRoZSBwYXJlbnQgbm9kZSB0aGF0IHRoZSByYW5nZSBwb2ludHMgaW50by5cbiAgICAqL1xuICAgIGdldCBwYXJlbnQoKSB7IHJldHVybiB0aGlzLiRmcm9tLm5vZGUodGhpcy5kZXB0aCk7IH1cbiAgICAvKipcbiAgICBUaGUgc3RhcnQgaW5kZXggb2YgdGhlIHJhbmdlIGluIHRoZSBwYXJlbnQgbm9kZS5cbiAgICAqL1xuICAgIGdldCBzdGFydEluZGV4KCkgeyByZXR1cm4gdGhpcy4kZnJvbS5pbmRleCh0aGlzLmRlcHRoKTsgfVxuICAgIC8qKlxuICAgIFRoZSBlbmQgaW5kZXggb2YgdGhlIHJhbmdlIGluIHRoZSBwYXJlbnQgbm9kZS5cbiAgICAqL1xuICAgIGdldCBlbmRJbmRleCgpIHsgcmV0dXJuIHRoaXMuJHRvLmluZGV4QWZ0ZXIodGhpcy5kZXB0aCk7IH1cbn1cblxuY29uc3QgZW1wdHlBdHRycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vKipcblRoaXMgY2xhc3MgcmVwcmVzZW50cyBhIG5vZGUgaW4gdGhlIHRyZWUgdGhhdCBtYWtlcyB1cCBhXG5Qcm9zZU1pcnJvciBkb2N1bWVudC4gU28gYSBkb2N1bWVudCBpcyBhbiBpbnN0YW5jZSBvZiBgTm9kZWAsIHdpdGhcbmNoaWxkcmVuIHRoYXQgYXJlIGFsc28gaW5zdGFuY2VzIG9mIGBOb2RlYC5cblxuTm9kZXMgYXJlIHBlcnNpc3RlbnQgZGF0YSBzdHJ1Y3R1cmVzLiBJbnN0ZWFkIG9mIGNoYW5naW5nIHRoZW0sIHlvdVxuY3JlYXRlIG5ldyBvbmVzIHdpdGggdGhlIGNvbnRlbnQgeW91IHdhbnQuIE9sZCBvbmVzIGtlZXAgcG9pbnRpbmdcbmF0IHRoZSBvbGQgZG9jdW1lbnQgc2hhcGUuIFRoaXMgaXMgbWFkZSBjaGVhcGVyIGJ5IHNoYXJpbmdcbnN0cnVjdHVyZSBiZXR3ZWVuIHRoZSBvbGQgYW5kIG5ldyBkYXRhIGFzIG11Y2ggYXMgcG9zc2libGUsIHdoaWNoIGFcbnRyZWUgc2hhcGUgbGlrZSB0aGlzICh3aXRob3V0IGJhY2sgcG9pbnRlcnMpIG1ha2VzIGVhc3kuXG5cbioqRG8gbm90KiogZGlyZWN0bHkgbXV0YXRlIHRoZSBwcm9wZXJ0aWVzIG9mIGEgYE5vZGVgIG9iamVjdC4gU2VlXG5bdGhlIGd1aWRlXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL2d1aWRlLyNkb2MpIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuKi9cbmNsYXNzIE5vZGUge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHR5cGUgb2Ygbm9kZSB0aGF0IHRoaXMgaXMuXG4gICAgKi9cbiAgICB0eXBlLCBcbiAgICAvKipcbiAgICBBbiBvYmplY3QgbWFwcGluZyBhdHRyaWJ1dGUgbmFtZXMgdG8gdmFsdWVzLiBUaGUga2luZCBvZlxuICAgIGF0dHJpYnV0ZXMgYWxsb3dlZCBhbmQgcmVxdWlyZWQgYXJlXG4gICAgW2RldGVybWluZWRdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy5hdHRycykgYnkgdGhlIG5vZGUgdHlwZS5cbiAgICAqL1xuICAgIGF0dHJzLCBcbiAgICAvLyBBIGZyYWdtZW50IGhvbGRpbmcgdGhlIG5vZGUncyBjaGlsZHJlbi5cbiAgICBjb250ZW50LCBcbiAgICAvKipcbiAgICBUaGUgbWFya3MgKHRoaW5ncyBsaWtlIHdoZXRoZXIgaXQgaXMgZW1waGFzaXplZCBvciBwYXJ0IG9mIGFcbiAgICBsaW5rKSBhcHBsaWVkIHRvIHRoaXMgbm9kZS5cbiAgICAqL1xuICAgIG1hcmtzID0gTWFyay5ub25lKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgdGhpcy5tYXJrcyA9IG1hcmtzO1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50IHx8IEZyYWdtZW50LmVtcHR5O1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgYXJyYXkgb2YgdGhpcyBub2RlJ3MgY2hpbGQgbm9kZXMuXG4gICAgKi9cbiAgICBnZXQgY2hpbGRyZW4oKSB7IHJldHVybiB0aGlzLmNvbnRlbnQuY29udGVudDsgfVxuICAgIC8qKlxuICAgIFRoZSBzaXplIG9mIHRoaXMgbm9kZSwgYXMgZGVmaW5lZCBieSB0aGUgaW50ZWdlci1iYXNlZCBbaW5kZXhpbmdcbiAgICBzY2hlbWVdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvZ3VpZGUvI2RvYy5pbmRleGluZykuIEZvciB0ZXh0IG5vZGVzLCB0aGlzIGlzIHRoZVxuICAgIGFtb3VudCBvZiBjaGFyYWN0ZXJzLiBGb3Igb3RoZXIgbGVhZiBub2RlcywgaXQgaXMgb25lLiBGb3JcbiAgICBub24tbGVhZiBub2RlcywgaXQgaXMgdGhlIHNpemUgb2YgdGhlIGNvbnRlbnQgcGx1cyB0d28gKHRoZVxuICAgIHN0YXJ0IGFuZCBlbmQgdG9rZW4pLlxuICAgICovXG4gICAgZ2V0IG5vZGVTaXplKCkgeyByZXR1cm4gdGhpcy5pc0xlYWYgPyAxIDogMiArIHRoaXMuY29udGVudC5zaXplOyB9XG4gICAgLyoqXG4gICAgVGhlIG51bWJlciBvZiBjaGlsZHJlbiB0aGF0IHRoZSBub2RlIGhhcy5cbiAgICAqL1xuICAgIGdldCBjaGlsZENvdW50KCkgeyByZXR1cm4gdGhpcy5jb250ZW50LmNoaWxkQ291bnQ7IH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGNoaWxkIG5vZGUgYXQgdGhlIGdpdmVuIGluZGV4LiBSYWlzZXMgYW4gZXJyb3Igd2hlbiB0aGVcbiAgICBpbmRleCBpcyBvdXQgb2YgcmFuZ2UuXG4gICAgKi9cbiAgICBjaGlsZChpbmRleCkgeyByZXR1cm4gdGhpcy5jb250ZW50LmNoaWxkKGluZGV4KTsgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgY2hpbGQgbm9kZSBhdCB0aGUgZ2l2ZW4gaW5kZXgsIGlmIGl0IGV4aXN0cy5cbiAgICAqL1xuICAgIG1heWJlQ2hpbGQoaW5kZXgpIHsgcmV0dXJuIHRoaXMuY29udGVudC5tYXliZUNoaWxkKGluZGV4KTsgfVxuICAgIC8qKlxuICAgIENhbGwgYGZgIGZvciBldmVyeSBjaGlsZCBub2RlLCBwYXNzaW5nIHRoZSBub2RlLCBpdHMgb2Zmc2V0XG4gICAgaW50byB0aGlzIHBhcmVudCBub2RlLCBhbmQgaXRzIGluZGV4LlxuICAgICovXG4gICAgZm9yRWFjaChmKSB7IHRoaXMuY29udGVudC5mb3JFYWNoKGYpOyB9XG4gICAgLyoqXG4gICAgSW52b2tlIGEgY2FsbGJhY2sgZm9yIGFsbCBkZXNjZW5kYW50IG5vZGVzIHJlY3Vyc2l2ZWx5IGJldHdlZW5cbiAgICB0aGUgZ2l2ZW4gdHdvIHBvc2l0aW9ucyB0aGF0IGFyZSByZWxhdGl2ZSB0byBzdGFydCBvZiB0aGlzXG4gICAgbm9kZSdzIGNvbnRlbnQuIFRoZSBjYWxsYmFjayBpcyBpbnZva2VkIHdpdGggdGhlIG5vZGUsIGl0c1xuICAgIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHRoZSBvcmlnaW5hbCBub2RlIChtZXRob2QgcmVjZWl2ZXIpLFxuICAgIGl0cyBwYXJlbnQgbm9kZSwgYW5kIGl0cyBjaGlsZCBpbmRleC4gV2hlbiB0aGUgY2FsbGJhY2sgcmV0dXJuc1xuICAgIGZhbHNlIGZvciBhIGdpdmVuIG5vZGUsIHRoYXQgbm9kZSdzIGNoaWxkcmVuIHdpbGwgbm90IGJlXG4gICAgcmVjdXJzZWQgb3Zlci4gVGhlIGxhc3QgcGFyYW1ldGVyIGNhbiBiZSB1c2VkIHRvIHNwZWNpZnkgYVxuICAgIHN0YXJ0aW5nIHBvc2l0aW9uIHRvIGNvdW50IGZyb20uXG4gICAgKi9cbiAgICBub2Rlc0JldHdlZW4oZnJvbSwgdG8sIGYsIHN0YXJ0UG9zID0gMCkge1xuICAgICAgICB0aGlzLmNvbnRlbnQubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCBmLCBzdGFydFBvcywgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIENhbGwgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBldmVyeSBkZXNjZW5kYW50IG5vZGUuIERvZXNuJ3RcbiAgICBkZXNjZW5kIGludG8gYSBub2RlIHdoZW4gdGhlIGNhbGxiYWNrIHJldHVybnMgYGZhbHNlYC5cbiAgICAqL1xuICAgIGRlc2NlbmRhbnRzKGYpIHtcbiAgICAgICAgdGhpcy5ub2Rlc0JldHdlZW4oMCwgdGhpcy5jb250ZW50LnNpemUsIGYpO1xuICAgIH1cbiAgICAvKipcbiAgICBDb25jYXRlbmF0ZXMgYWxsIHRoZSB0ZXh0IG5vZGVzIGZvdW5kIGluIHRoaXMgZnJhZ21lbnQgYW5kIGl0c1xuICAgIGNoaWxkcmVuLlxuICAgICovXG4gICAgZ2V0IHRleHRDb250ZW50KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuaXNMZWFmICYmIHRoaXMudHlwZS5zcGVjLmxlYWZUZXh0KVxuICAgICAgICAgICAgPyB0aGlzLnR5cGUuc3BlYy5sZWFmVGV4dCh0aGlzKVxuICAgICAgICAgICAgOiB0aGlzLnRleHRCZXR3ZWVuKDAsIHRoaXMuY29udGVudC5zaXplLCBcIlwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IGFsbCB0ZXh0IGJldHdlZW4gcG9zaXRpb25zIGBmcm9tYCBhbmQgYHRvYC4gV2hlblxuICAgIGBibG9ja1NlcGFyYXRvcmAgaXMgZ2l2ZW4sIGl0IHdpbGwgYmUgaW5zZXJ0ZWQgdG8gc2VwYXJhdGUgdGV4dFxuICAgIGZyb20gZGlmZmVyZW50IGJsb2NrIG5vZGVzLiBJZiBgbGVhZlRleHRgIGlzIGdpdmVuLCBpdCdsbCBiZVxuICAgIGluc2VydGVkIGZvciBldmVyeSBub24tdGV4dCBsZWFmIG5vZGUgZW5jb3VudGVyZWQsIG90aGVyd2lzZVxuICAgIFtgbGVhZlRleHRgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMubGVhZlRleHQpIHdpbGwgYmUgdXNlZC5cbiAgICAqL1xuICAgIHRleHRCZXR3ZWVuKGZyb20sIHRvLCBibG9ja1NlcGFyYXRvciwgbGVhZlRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudC50ZXh0QmV0d2Vlbihmcm9tLCB0bywgYmxvY2tTZXBhcmF0b3IsIGxlYWZUZXh0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0aGlzIG5vZGUncyBmaXJzdCBjaGlsZCwgb3IgYG51bGxgIGlmIHRoZXJlIGFyZSBub1xuICAgIGNoaWxkcmVuLlxuICAgICovXG4gICAgZ2V0IGZpcnN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmNvbnRlbnQuZmlyc3RDaGlsZDsgfVxuICAgIC8qKlxuICAgIFJldHVybnMgdGhpcyBub2RlJ3MgbGFzdCBjaGlsZCwgb3IgYG51bGxgIGlmIHRoZXJlIGFyZSBub1xuICAgIGNoaWxkcmVuLlxuICAgICovXG4gICAgZ2V0IGxhc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuY29udGVudC5sYXN0Q2hpbGQ7IH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgdHdvIG5vZGVzIHJlcHJlc2VudCB0aGUgc2FtZSBwaWVjZSBvZiBkb2N1bWVudC5cbiAgICAqL1xuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8ICh0aGlzLnNhbWVNYXJrdXAob3RoZXIpICYmIHRoaXMuY29udGVudC5lcShvdGhlci5jb250ZW50KSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbXBhcmUgdGhlIG1hcmt1cCAodHlwZSwgYXR0cmlidXRlcywgYW5kIG1hcmtzKSBvZiB0aGlzIG5vZGUgdG9cbiAgICB0aG9zZSBvZiBhbm90aGVyLiBSZXR1cm5zIGB0cnVlYCBpZiBib3RoIGhhdmUgdGhlIHNhbWUgbWFya3VwLlxuICAgICovXG4gICAgc2FtZU1hcmt1cChvdGhlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNNYXJrdXAob3RoZXIudHlwZSwgb3RoZXIuYXR0cnMsIG90aGVyLm1hcmtzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ2hlY2sgd2hldGhlciB0aGlzIG5vZGUncyBtYXJrdXAgY29ycmVzcG9uZCB0byB0aGUgZ2l2ZW4gdHlwZSxcbiAgICBhdHRyaWJ1dGVzLCBhbmQgbWFya3MuXG4gICAgKi9cbiAgICBoYXNNYXJrdXAodHlwZSwgYXR0cnMsIG1hcmtzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT0gdHlwZSAmJlxuICAgICAgICAgICAgY29tcGFyZURlZXAodGhpcy5hdHRycywgYXR0cnMgfHwgdHlwZS5kZWZhdWx0QXR0cnMgfHwgZW1wdHlBdHRycykgJiZcbiAgICAgICAgICAgIE1hcmsuc2FtZVNldCh0aGlzLm1hcmtzLCBtYXJrcyB8fCBNYXJrLm5vbmUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgbm9kZSB3aXRoIHRoZSBzYW1lIG1hcmt1cCBhcyB0aGlzIG5vZGUsIGNvbnRhaW5pbmdcbiAgICB0aGUgZ2l2ZW4gY29udGVudCAob3IgZW1wdHksIGlmIG5vIGNvbnRlbnQgaXMgZ2l2ZW4pLlxuICAgICovXG4gICAgY29weShjb250ZW50ID0gbnVsbCkge1xuICAgICAgICBpZiAoY29udGVudCA9PSB0aGlzLmNvbnRlbnQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlKHRoaXMudHlwZSwgdGhpcy5hdHRycywgY29udGVudCwgdGhpcy5tYXJrcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGNvcHkgb2YgdGhpcyBub2RlLCB3aXRoIHRoZSBnaXZlbiBzZXQgb2YgbWFya3MgaW5zdGVhZFxuICAgIG9mIHRoZSBub2RlJ3Mgb3duIG1hcmtzLlxuICAgICovXG4gICAgbWFyayhtYXJrcykge1xuICAgICAgICByZXR1cm4gbWFya3MgPT0gdGhpcy5tYXJrcyA/IHRoaXMgOiBuZXcgTm9kZSh0aGlzLnR5cGUsIHRoaXMuYXR0cnMsIHRoaXMuY29udGVudCwgbWFya3MpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBjb3B5IG9mIHRoaXMgbm9kZSB3aXRoIG9ubHkgdGhlIGNvbnRlbnQgYmV0d2VlbiB0aGVcbiAgICBnaXZlbiBwb3NpdGlvbnMuIElmIGB0b2AgaXMgbm90IGdpdmVuLCBpdCBkZWZhdWx0cyB0byB0aGUgZW5kIG9mXG4gICAgdGhlIG5vZGUuXG4gICAgKi9cbiAgICBjdXQoZnJvbSwgdG8gPSB0aGlzLmNvbnRlbnQuc2l6ZSkge1xuICAgICAgICBpZiAoZnJvbSA9PSAwICYmIHRvID09IHRoaXMuY29udGVudC5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmNvcHkodGhpcy5jb250ZW50LmN1dChmcm9tLCB0bykpO1xuICAgIH1cbiAgICAvKipcbiAgICBDdXQgb3V0IHRoZSBwYXJ0IG9mIHRoZSBkb2N1bWVudCBiZXR3ZWVuIHRoZSBnaXZlbiBwb3NpdGlvbnMsIGFuZFxuICAgIHJldHVybiBpdCBhcyBhIGBTbGljZWAgb2JqZWN0LlxuICAgICovXG4gICAgc2xpY2UoZnJvbSwgdG8gPSB0aGlzLmNvbnRlbnQuc2l6ZSwgaW5jbHVkZVBhcmVudHMgPSBmYWxzZSkge1xuICAgICAgICBpZiAoZnJvbSA9PSB0bylcbiAgICAgICAgICAgIHJldHVybiBTbGljZS5lbXB0eTtcbiAgICAgICAgbGV0ICRmcm9tID0gdGhpcy5yZXNvbHZlKGZyb20pLCAkdG8gPSB0aGlzLnJlc29sdmUodG8pO1xuICAgICAgICBsZXQgZGVwdGggPSBpbmNsdWRlUGFyZW50cyA/IDAgOiAkZnJvbS5zaGFyZWREZXB0aCh0byk7XG4gICAgICAgIGxldCBzdGFydCA9ICRmcm9tLnN0YXJ0KGRlcHRoKSwgbm9kZSA9ICRmcm9tLm5vZGUoZGVwdGgpO1xuICAgICAgICBsZXQgY29udGVudCA9IG5vZGUuY29udGVudC5jdXQoJGZyb20ucG9zIC0gc3RhcnQsICR0by5wb3MgLSBzdGFydCk7XG4gICAgICAgIHJldHVybiBuZXcgU2xpY2UoY29udGVudCwgJGZyb20uZGVwdGggLSBkZXB0aCwgJHRvLmRlcHRoIC0gZGVwdGgpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIHRoZSBwYXJ0IG9mIHRoZSBkb2N1bWVudCBiZXR3ZWVuIHRoZSBnaXZlbiBwb3NpdGlvbnMgd2l0aFxuICAgIHRoZSBnaXZlbiBzbGljZS4gVGhlIHNsaWNlIG11c3QgJ2ZpdCcsIG1lYW5pbmcgaXRzIG9wZW4gc2lkZXNcbiAgICBtdXN0IGJlIGFibGUgdG8gY29ubmVjdCB0byB0aGUgc3Vycm91bmRpbmcgY29udGVudCwgYW5kIGl0c1xuICAgIGNvbnRlbnQgbm9kZXMgbXVzdCBiZSB2YWxpZCBjaGlsZHJlbiBmb3IgdGhlIG5vZGUgdGhleSBhcmUgcGxhY2VkXG4gICAgaW50by4gSWYgYW55IG9mIHRoaXMgaXMgdmlvbGF0ZWQsIGFuIGVycm9yIG9mIHR5cGVcbiAgICBbYFJlcGxhY2VFcnJvcmBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5SZXBsYWNlRXJyb3IpIGlzIHRocm93bi5cbiAgICAqL1xuICAgIHJlcGxhY2UoZnJvbSwgdG8sIHNsaWNlKSB7XG4gICAgICAgIHJldHVybiByZXBsYWNlKHRoaXMucmVzb2x2ZShmcm9tKSwgdGhpcy5yZXNvbHZlKHRvKSwgc2xpY2UpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBub2RlIGRpcmVjdGx5IGFmdGVyIHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIG5vZGVBdChwb3MpIHtcbiAgICAgICAgZm9yIChsZXQgbm9kZSA9IHRoaXM7Oykge1xuICAgICAgICAgICAgbGV0IHsgaW5kZXgsIG9mZnNldCB9ID0gbm9kZS5jb250ZW50LmZpbmRJbmRleChwb3MpO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUubWF5YmVDaGlsZChpbmRleCk7XG4gICAgICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID09IHBvcyB8fCBub2RlLmlzVGV4dClcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIHBvcyAtPSBvZmZzZXQgKyAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIChkaXJlY3QpIGNoaWxkIG5vZGUgYWZ0ZXIgdGhlIGdpdmVuIG9mZnNldCwgaWYgYW55LFxuICAgIGFuZCByZXR1cm4gaXQgYWxvbmcgd2l0aCBpdHMgaW5kZXggYW5kIG9mZnNldCByZWxhdGl2ZSB0byB0aGlzXG4gICAgbm9kZS5cbiAgICAqL1xuICAgIGNoaWxkQWZ0ZXIocG9zKSB7XG4gICAgICAgIGxldCB7IGluZGV4LCBvZmZzZXQgfSA9IHRoaXMuY29udGVudC5maW5kSW5kZXgocG9zKTtcbiAgICAgICAgcmV0dXJuIHsgbm9kZTogdGhpcy5jb250ZW50Lm1heWJlQ2hpbGQoaW5kZXgpLCBpbmRleCwgb2Zmc2V0IH07XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIChkaXJlY3QpIGNoaWxkIG5vZGUgYmVmb3JlIHRoZSBnaXZlbiBvZmZzZXQsIGlmIGFueSxcbiAgICBhbmQgcmV0dXJuIGl0IGFsb25nIHdpdGggaXRzIGluZGV4IGFuZCBvZmZzZXQgcmVsYXRpdmUgdG8gdGhpc1xuICAgIG5vZGUuXG4gICAgKi9cbiAgICBjaGlsZEJlZm9yZShwb3MpIHtcbiAgICAgICAgaWYgKHBvcyA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogbnVsbCwgaW5kZXg6IDAsIG9mZnNldDogMCB9O1xuICAgICAgICBsZXQgeyBpbmRleCwgb2Zmc2V0IH0gPSB0aGlzLmNvbnRlbnQuZmluZEluZGV4KHBvcyk7XG4gICAgICAgIGlmIChvZmZzZXQgPCBwb3MpXG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLmNvbnRlbnQuY2hpbGQoaW5kZXgpLCBpbmRleCwgb2Zmc2V0IH07XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5jb250ZW50LmNoaWxkKGluZGV4IC0gMSk7XG4gICAgICAgIHJldHVybiB7IG5vZGUsIGluZGV4OiBpbmRleCAtIDEsIG9mZnNldDogb2Zmc2V0IC0gbm9kZS5ub2RlU2l6ZSB9O1xuICAgIH1cbiAgICAvKipcbiAgICBSZXNvbHZlIHRoZSBnaXZlbiBwb3NpdGlvbiBpbiB0aGUgZG9jdW1lbnQsIHJldHVybmluZyBhblxuICAgIFtvYmplY3RdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5SZXNvbHZlZFBvcykgd2l0aCBpbmZvcm1hdGlvbiBhYm91dCBpdHMgY29udGV4dC5cbiAgICAqL1xuICAgIHJlc29sdmUocG9zKSB7IHJldHVybiBSZXNvbHZlZFBvcy5yZXNvbHZlQ2FjaGVkKHRoaXMsIHBvcyk7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlc29sdmVOb0NhY2hlKHBvcykgeyByZXR1cm4gUmVzb2x2ZWRQb3MucmVzb2x2ZSh0aGlzLCBwb3MpOyB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIGEgZ2l2ZW4gbWFyayBvciBtYXJrIHR5cGUgb2NjdXJzIGluIHRoaXMgZG9jdW1lbnRcbiAgICBiZXR3ZWVuIHRoZSB0d28gZ2l2ZW4gcG9zaXRpb25zLlxuICAgICovXG4gICAgcmFuZ2VIYXNNYXJrKGZyb20sIHRvLCB0eXBlKSB7XG4gICAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgICAgICBpZiAodG8gPiBmcm9tKVxuICAgICAgICAgICAgdGhpcy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIG5vZGUgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlLmlzSW5TZXQobm9kZS5tYXJrcykpXG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWZvdW5kO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmb3VuZDtcbiAgICB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgaXMgYSBibG9jayAobm9uLWlubGluZSBub2RlKVxuICAgICovXG4gICAgZ2V0IGlzQmxvY2soKSB7IHJldHVybiB0aGlzLnR5cGUuaXNCbG9jazsgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIGlzIGEgdGV4dGJsb2NrIG5vZGUsIGEgYmxvY2sgbm9kZSB3aXRoIGlubGluZVxuICAgIGNvbnRlbnQuXG4gICAgKi9cbiAgICBnZXQgaXNUZXh0YmxvY2soKSB7IHJldHVybiB0aGlzLnR5cGUuaXNUZXh0YmxvY2s7IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBub2RlIGFsbG93cyBpbmxpbmUgY29udGVudC5cbiAgICAqL1xuICAgIGdldCBpbmxpbmVDb250ZW50KCkgeyByZXR1cm4gdGhpcy50eXBlLmlubGluZUNvbnRlbnQ7IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBpcyBhbiBpbmxpbmUgbm9kZSAoYSB0ZXh0IG5vZGUgb3IgYSBub2RlIHRoYXQgY2FuXG4gICAgYXBwZWFyIGFtb25nIHRleHQpLlxuICAgICovXG4gICAgZ2V0IGlzSW5saW5lKCkgeyByZXR1cm4gdGhpcy50eXBlLmlzSW5saW5lOyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgaXMgYSB0ZXh0IG5vZGUuXG4gICAgKi9cbiAgICBnZXQgaXNUZXh0KCkgeyByZXR1cm4gdGhpcy50eXBlLmlzVGV4dDsgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIGlzIGEgbGVhZiBub2RlLlxuICAgICovXG4gICAgZ2V0IGlzTGVhZigpIHsgcmV0dXJuIHRoaXMudHlwZS5pc0xlYWY7IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBpcyBhbiBhdG9tLCBpLmUuIHdoZW4gaXQgZG9lcyBub3QgaGF2ZSBkaXJlY3RseVxuICAgIGVkaXRhYmxlIGNvbnRlbnQuIFRoaXMgaXMgdXN1YWxseSB0aGUgc2FtZSBhcyBgaXNMZWFmYCwgYnV0IGNhblxuICAgIGJlIGNvbmZpZ3VyZWQgd2l0aCB0aGUgW2BhdG9tYCBwcm9wZXJ0eV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLmF0b20pXG4gICAgb24gYSBub2RlJ3Mgc3BlYyAodHlwaWNhbGx5IHVzZWQgd2hlbiB0aGUgbm9kZSBpcyBkaXNwbGF5ZWQgYXNcbiAgICBhbiB1bmVkaXRhYmxlIFtub2RlIHZpZXddKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3Lk5vZGVWaWV3KSkuXG4gICAgKi9cbiAgICBnZXQgaXNBdG9tKCkgeyByZXR1cm4gdGhpcy50eXBlLmlzQXRvbTsgfVxuICAgIC8qKlxuICAgIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG5vZGUgZm9yIGRlYnVnZ2luZ1xuICAgIHB1cnBvc2VzLlxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLnR5cGUuc3BlYy50b0RlYnVnU3RyaW5nKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHlwZS5zcGVjLnRvRGVidWdTdHJpbmcodGhpcyk7XG4gICAgICAgIGxldCBuYW1lID0gdGhpcy50eXBlLm5hbWU7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgICAgIG5hbWUgKz0gXCIoXCIgKyB0aGlzLmNvbnRlbnQudG9TdHJpbmdJbm5lcigpICsgXCIpXCI7XG4gICAgICAgIHJldHVybiB3cmFwTWFya3ModGhpcy5tYXJrcywgbmFtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgY29udGVudCBtYXRjaCBpbiB0aGlzIG5vZGUgYXQgdGhlIGdpdmVuIGluZGV4LlxuICAgICovXG4gICAgY29udGVudE1hdGNoQXQoaW5kZXgpIHtcbiAgICAgICAgbGV0IG1hdGNoID0gdGhpcy50eXBlLmNvbnRlbnRNYXRjaC5tYXRjaEZyYWdtZW50KHRoaXMuY29udGVudCwgMCwgaW5kZXgpO1xuICAgICAgICBpZiAoIW1hdGNoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FsbGVkIGNvbnRlbnRNYXRjaEF0IG9uIGEgbm9kZSB3aXRoIGludmFsaWQgY29udGVudFwiKTtcbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgcmVwbGFjaW5nIHRoZSByYW5nZSBiZXR3ZWVuIGBmcm9tYCBhbmQgYHRvYCAoYnlcbiAgICBjaGlsZCBpbmRleCkgd2l0aCB0aGUgZ2l2ZW4gcmVwbGFjZW1lbnQgZnJhZ21lbnQgKHdoaWNoIGRlZmF1bHRzXG4gICAgdG8gdGhlIGVtcHR5IGZyYWdtZW50KSB3b3VsZCBsZWF2ZSB0aGUgbm9kZSdzIGNvbnRlbnQgdmFsaWQuIFlvdVxuICAgIGNhbiBvcHRpb25hbGx5IHBhc3MgYHN0YXJ0YCBhbmQgYGVuZGAgaW5kaWNlcyBpbnRvIHRoZVxuICAgIHJlcGxhY2VtZW50IGZyYWdtZW50LlxuICAgICovXG4gICAgY2FuUmVwbGFjZShmcm9tLCB0bywgcmVwbGFjZW1lbnQgPSBGcmFnbWVudC5lbXB0eSwgc3RhcnQgPSAwLCBlbmQgPSByZXBsYWNlbWVudC5jaGlsZENvdW50KSB7XG4gICAgICAgIGxldCBvbmUgPSB0aGlzLmNvbnRlbnRNYXRjaEF0KGZyb20pLm1hdGNoRnJhZ21lbnQocmVwbGFjZW1lbnQsIHN0YXJ0LCBlbmQpO1xuICAgICAgICBsZXQgdHdvID0gb25lICYmIG9uZS5tYXRjaEZyYWdtZW50KHRoaXMuY29udGVudCwgdG8pO1xuICAgICAgICBpZiAoIXR3byB8fCAhdHdvLnZhbGlkRW5kKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKylcbiAgICAgICAgICAgIGlmICghdGhpcy50eXBlLmFsbG93c01hcmtzKHJlcGxhY2VtZW50LmNoaWxkKGkpLm1hcmtzKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBUZXN0IHdoZXRoZXIgcmVwbGFjaW5nIHRoZSByYW5nZSBgZnJvbWAgdG8gYHRvYCAoYnkgaW5kZXgpIHdpdGhcbiAgICBhIG5vZGUgb2YgdGhlIGdpdmVuIHR5cGUgd291bGQgbGVhdmUgdGhlIG5vZGUncyBjb250ZW50IHZhbGlkLlxuICAgICovXG4gICAgY2FuUmVwbGFjZVdpdGgoZnJvbSwgdG8sIHR5cGUsIG1hcmtzKSB7XG4gICAgICAgIGlmIChtYXJrcyAmJiAhdGhpcy50eXBlLmFsbG93c01hcmtzKG1hcmtzKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5jb250ZW50TWF0Y2hBdChmcm9tKS5tYXRjaFR5cGUodHlwZSk7XG4gICAgICAgIGxldCBlbmQgPSBzdGFydCAmJiBzdGFydC5tYXRjaEZyYWdtZW50KHRoaXMuY29udGVudCwgdG8pO1xuICAgICAgICByZXR1cm4gZW5kID8gZW5kLnZhbGlkRW5kIDogZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciB0aGUgZ2l2ZW4gbm9kZSdzIGNvbnRlbnQgY291bGQgYmUgYXBwZW5kZWQgdG8gdGhpc1xuICAgIG5vZGUuIElmIHRoYXQgbm9kZSBpcyBlbXB0eSwgdGhpcyB3aWxsIG9ubHkgcmV0dXJuIHRydWUgaWYgdGhlcmVcbiAgICBpcyBhdCBsZWFzdCBvbmUgbm9kZSB0eXBlIHRoYXQgY2FuIGFwcGVhciBpbiBib3RoIG5vZGVzICh0byBhdm9pZFxuICAgIG1lcmdpbmcgY29tcGxldGVseSBpbmNvbXBhdGlibGUgbm9kZXMpLlxuICAgICovXG4gICAgY2FuQXBwZW5kKG90aGVyKSB7XG4gICAgICAgIGlmIChvdGhlci5jb250ZW50LnNpemUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jYW5SZXBsYWNlKHRoaXMuY2hpbGRDb3VudCwgdGhpcy5jaGlsZENvdW50LCBvdGhlci5jb250ZW50KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHlwZS5jb21wYXRpYmxlQ29udGVudChvdGhlci50eXBlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ2hlY2sgd2hldGhlciB0aGlzIG5vZGUgYW5kIGl0cyBkZXNjZW5kYW50cyBjb25mb3JtIHRvIHRoZVxuICAgIHNjaGVtYSwgYW5kIHJhaXNlIGFuIGV4Y2VwdGlvbiB3aGVuIHRoZXkgZG8gbm90LlxuICAgICovXG4gICAgY2hlY2soKSB7XG4gICAgICAgIHRoaXMudHlwZS5jaGVja0NvbnRlbnQodGhpcy5jb250ZW50KTtcbiAgICAgICAgdGhpcy50eXBlLmNoZWNrQXR0cnModGhpcy5hdHRycyk7XG4gICAgICAgIGxldCBjb3B5ID0gTWFyay5ub25lO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWFya3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBtYXJrID0gdGhpcy5tYXJrc1tpXTtcbiAgICAgICAgICAgIG1hcmsudHlwZS5jaGVja0F0dHJzKG1hcmsuYXR0cnMpO1xuICAgICAgICAgICAgY29weSA9IG1hcmsuYWRkVG9TZXQoY29weSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFNYXJrLnNhbWVTZXQoY29weSwgdGhpcy5tYXJrcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgSW52YWxpZCBjb2xsZWN0aW9uIG9mIG1hcmtzIGZvciBub2RlICR7dGhpcy50eXBlLm5hbWV9OiAke3RoaXMubWFya3MubWFwKG0gPT4gbS50eXBlLm5hbWUpfWApO1xuICAgICAgICB0aGlzLmNvbnRlbnQuZm9yRWFjaChub2RlID0+IG5vZGUuY2hlY2soKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybiBhIEpTT04tc2VyaWFsaXplYWJsZSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIG5vZGUuXG4gICAgKi9cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBvYmogPSB7IHR5cGU6IHRoaXMudHlwZS5uYW1lIH07XG4gICAgICAgIGZvciAobGV0IF8gaW4gdGhpcy5hdHRycykge1xuICAgICAgICAgICAgb2JqLmF0dHJzID0gdGhpcy5hdHRycztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgICAgIG9iai5jb250ZW50ID0gdGhpcy5jb250ZW50LnRvSlNPTigpO1xuICAgICAgICBpZiAodGhpcy5tYXJrcy5sZW5ndGgpXG4gICAgICAgICAgICBvYmoubWFya3MgPSB0aGlzLm1hcmtzLm1hcChuID0+IG4udG9KU09OKCkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICAvKipcbiAgICBEZXNlcmlhbGl6ZSBhIG5vZGUgZnJvbSBpdHMgSlNPTiByZXByZXNlbnRhdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKCFqc29uKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBOb2RlLmZyb21KU09OXCIpO1xuICAgICAgICBsZXQgbWFya3MgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChqc29uLm1hcmtzKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoanNvbi5tYXJrcykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIG1hcmsgZGF0YSBmb3IgTm9kZS5mcm9tSlNPTlwiKTtcbiAgICAgICAgICAgIG1hcmtzID0ganNvbi5tYXJrcy5tYXAoc2NoZW1hLm1hcmtGcm9tSlNPTik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGpzb24udHlwZSA9PSBcInRleHRcIikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBqc29uLnRleHQgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgdGV4dCBub2RlIGluIEpTT05cIik7XG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hLnRleHQoanNvbi50ZXh0LCBtYXJrcyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbnRlbnQgPSBGcmFnbWVudC5mcm9tSlNPTihzY2hlbWEsIGpzb24uY29udGVudCk7XG4gICAgICAgIGxldCBub2RlID0gc2NoZW1hLm5vZGVUeXBlKGpzb24udHlwZSkuY3JlYXRlKGpzb24uYXR0cnMsIGNvbnRlbnQsIG1hcmtzKTtcbiAgICAgICAgbm9kZS50eXBlLmNoZWNrQXR0cnMobm9kZS5hdHRycyk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbn1cbk5vZGUucHJvdG90eXBlLnRleHQgPSB1bmRlZmluZWQ7XG5jbGFzcyBUZXh0Tm9kZSBleHRlbmRzIE5vZGUge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IodHlwZSwgYXR0cnMsIGNvbnRlbnQsIG1hcmtzKSB7XG4gICAgICAgIHN1cGVyKHR5cGUsIGF0dHJzLCBudWxsLCBtYXJrcyk7XG4gICAgICAgIGlmICghY29udGVudClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRW1wdHkgdGV4dCBub2RlcyBhcmUgbm90IGFsbG93ZWRcIik7XG4gICAgICAgIHRoaXMudGV4dCA9IGNvbnRlbnQ7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBpZiAodGhpcy50eXBlLnNwZWMudG9EZWJ1Z1N0cmluZylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnR5cGUuc3BlYy50b0RlYnVnU3RyaW5nKHRoaXMpO1xuICAgICAgICByZXR1cm4gd3JhcE1hcmtzKHRoaXMubWFya3MsIEpTT04uc3RyaW5naWZ5KHRoaXMudGV4dCkpO1xuICAgIH1cbiAgICBnZXQgdGV4dENvbnRlbnQoKSB7IHJldHVybiB0aGlzLnRleHQ7IH1cbiAgICB0ZXh0QmV0d2Vlbihmcm9tLCB0bykgeyByZXR1cm4gdGhpcy50ZXh0LnNsaWNlKGZyb20sIHRvKTsgfVxuICAgIGdldCBub2RlU2l6ZSgpIHsgcmV0dXJuIHRoaXMudGV4dC5sZW5ndGg7IH1cbiAgICBtYXJrKG1hcmtzKSB7XG4gICAgICAgIHJldHVybiBtYXJrcyA9PSB0aGlzLm1hcmtzID8gdGhpcyA6IG5ldyBUZXh0Tm9kZSh0aGlzLnR5cGUsIHRoaXMuYXR0cnMsIHRoaXMudGV4dCwgbWFya3MpO1xuICAgIH1cbiAgICB3aXRoVGV4dCh0ZXh0KSB7XG4gICAgICAgIGlmICh0ZXh0ID09IHRoaXMudGV4dClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IFRleHROb2RlKHRoaXMudHlwZSwgdGhpcy5hdHRycywgdGV4dCwgdGhpcy5tYXJrcyk7XG4gICAgfVxuICAgIGN1dChmcm9tID0gMCwgdG8gPSB0aGlzLnRleHQubGVuZ3RoKSB7XG4gICAgICAgIGlmIChmcm9tID09IDAgJiYgdG8gPT0gdGhpcy50ZXh0Lmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy53aXRoVGV4dCh0aGlzLnRleHQuc2xpY2UoZnJvbSwgdG8pKTtcbiAgICB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2FtZU1hcmt1cChvdGhlcikgJiYgdGhpcy50ZXh0ID09IG90aGVyLnRleHQ7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgbGV0IGJhc2UgPSBzdXBlci50b0pTT04oKTtcbiAgICAgICAgYmFzZS50ZXh0ID0gdGhpcy50ZXh0O1xuICAgICAgICByZXR1cm4gYmFzZTtcbiAgICB9XG59XG5mdW5jdGlvbiB3cmFwTWFya3MobWFya3MsIHN0cikge1xuICAgIGZvciAobGV0IGkgPSBtYXJrcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgc3RyID0gbWFya3NbaV0udHlwZS5uYW1lICsgXCIoXCIgKyBzdHIgKyBcIilcIjtcbiAgICByZXR1cm4gc3RyO1xufVxuXG4vKipcbkluc3RhbmNlcyBvZiB0aGlzIGNsYXNzIHJlcHJlc2VudCBhIG1hdGNoIHN0YXRlIG9mIGEgbm9kZSB0eXBlJ3Ncbltjb250ZW50IGV4cHJlc3Npb25dKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy5jb250ZW50KSwgYW5kIGNhbiBiZSB1c2VkIHRvXG5maW5kIG91dCB3aGV0aGVyIGZ1cnRoZXIgY29udGVudCBtYXRjaGVzIGhlcmUsIGFuZCB3aGV0aGVyIGEgZ2l2ZW5cbnBvc2l0aW9uIGlzIGEgdmFsaWQgZW5kIG9mIHRoZSBub2RlLlxuKi9cbmNsYXNzIENvbnRlbnRNYXRjaCB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBtYXRjaCBzdGF0ZSByZXByZXNlbnRzIGEgdmFsaWQgZW5kIG9mIHRoZSBub2RlLlxuICAgICovXG4gICAgdmFsaWRFbmQpIHtcbiAgICAgICAgdGhpcy52YWxpZEVuZCA9IHZhbGlkRW5kO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMubmV4dCA9IFtdO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMud3JhcENhY2hlID0gW107XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIHBhcnNlKHN0cmluZywgbm9kZVR5cGVzKSB7XG4gICAgICAgIGxldCBzdHJlYW0gPSBuZXcgVG9rZW5TdHJlYW0oc3RyaW5nLCBub2RlVHlwZXMpO1xuICAgICAgICBpZiAoc3RyZWFtLm5leHQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBDb250ZW50TWF0Y2guZW1wdHk7XG4gICAgICAgIGxldCBleHByID0gcGFyc2VFeHByKHN0cmVhbSk7XG4gICAgICAgIGlmIChzdHJlYW0ubmV4dClcbiAgICAgICAgICAgIHN0cmVhbS5lcnIoXCJVbmV4cGVjdGVkIHRyYWlsaW5nIHRleHRcIik7XG4gICAgICAgIGxldCBtYXRjaCA9IGRmYShuZmEoZXhwcikpO1xuICAgICAgICBjaGVja0ZvckRlYWRFbmRzKG1hdGNoLCBzdHJlYW0pO1xuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfVxuICAgIC8qKlxuICAgIE1hdGNoIGEgbm9kZSB0eXBlLCByZXR1cm5pbmcgYSBtYXRjaCBhZnRlciB0aGF0IG5vZGUgaWZcbiAgICBzdWNjZXNzZnVsLlxuICAgICovXG4gICAgbWF0Y2hUeXBlKHR5cGUpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm5leHQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAodGhpcy5uZXh0W2ldLnR5cGUgPT0gdHlwZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZXh0W2ldLm5leHQ7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBUcnkgdG8gbWF0Y2ggYSBmcmFnbWVudC4gUmV0dXJucyB0aGUgcmVzdWx0aW5nIG1hdGNoIHdoZW5cbiAgICBzdWNjZXNzZnVsLlxuICAgICovXG4gICAgbWF0Y2hGcmFnbWVudChmcmFnLCBzdGFydCA9IDAsIGVuZCA9IGZyYWcuY2hpbGRDb3VudCkge1xuICAgICAgICBsZXQgY3VyID0gdGhpcztcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBjdXIgJiYgaSA8IGVuZDsgaSsrKVxuICAgICAgICAgICAgY3VyID0gY3VyLm1hdGNoVHlwZShmcmFnLmNoaWxkKGkpLnR5cGUpO1xuICAgICAgICByZXR1cm4gY3VyO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCBpbmxpbmVDb250ZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0Lmxlbmd0aCAhPSAwICYmIHRoaXMubmV4dFswXS50eXBlLmlzSW5saW5lO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGZpcnN0IG1hdGNoaW5nIG5vZGUgdHlwZSBhdCB0aGlzIG1hdGNoIHBvc2l0aW9uIHRoYXQgY2FuXG4gICAgYmUgZ2VuZXJhdGVkLlxuICAgICovXG4gICAgZ2V0IGRlZmF1bHRUeXBlKCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubmV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHsgdHlwZSB9ID0gdGhpcy5uZXh0W2ldO1xuICAgICAgICAgICAgaWYgKCEodHlwZS5pc1RleHQgfHwgdHlwZS5oYXNSZXF1aXJlZEF0dHJzKCkpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbXBhdGlibGUob3RoZXIpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm5leHQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG90aGVyLm5leHQubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubmV4dFtpXS50eXBlID09IG90aGVyLm5leHRbal0udHlwZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVHJ5IHRvIG1hdGNoIHRoZSBnaXZlbiBmcmFnbWVudCwgYW5kIGlmIHRoYXQgZmFpbHMsIHNlZSBpZiBpdCBjYW5cbiAgICBiZSBtYWRlIHRvIG1hdGNoIGJ5IGluc2VydGluZyBub2RlcyBpbiBmcm9udCBvZiBpdC4gV2hlblxuICAgIHN1Y2Nlc3NmdWwsIHJldHVybiBhIGZyYWdtZW50IG9mIGluc2VydGVkIG5vZGVzICh3aGljaCBtYXkgYmVcbiAgICBlbXB0eSBpZiBub3RoaW5nIGhhZCB0byBiZSBpbnNlcnRlZCkuIFdoZW4gYHRvRW5kYCBpcyB0cnVlLCBvbmx5XG4gICAgcmV0dXJuIGEgZnJhZ21lbnQgaWYgdGhlIHJlc3VsdGluZyBtYXRjaCBnb2VzIHRvIHRoZSBlbmQgb2YgdGhlXG4gICAgY29udGVudCBleHByZXNzaW9uLlxuICAgICovXG4gICAgZmlsbEJlZm9yZShhZnRlciwgdG9FbmQgPSBmYWxzZSwgc3RhcnRJbmRleCA9IDApIHtcbiAgICAgICAgbGV0IHNlZW4gPSBbdGhpc107XG4gICAgICAgIGZ1bmN0aW9uIHNlYXJjaChtYXRjaCwgdHlwZXMpIHtcbiAgICAgICAgICAgIGxldCBmaW5pc2hlZCA9IG1hdGNoLm1hdGNoRnJhZ21lbnQoYWZ0ZXIsIHN0YXJ0SW5kZXgpO1xuICAgICAgICAgICAgaWYgKGZpbmlzaGVkICYmICghdG9FbmQgfHwgZmluaXNoZWQudmFsaWRFbmQpKVxuICAgICAgICAgICAgICAgIHJldHVybiBGcmFnbWVudC5mcm9tKHR5cGVzLm1hcCh0cCA9PiB0cC5jcmVhdGVBbmRGaWxsKCkpKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0Y2gubmV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCB7IHR5cGUsIG5leHQgfSA9IG1hdGNoLm5leHRbaV07XG4gICAgICAgICAgICAgICAgaWYgKCEodHlwZS5pc1RleHQgfHwgdHlwZS5oYXNSZXF1aXJlZEF0dHJzKCkpICYmIHNlZW4uaW5kZXhPZihuZXh0KSA9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBzZWVuLnB1c2gobmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IHNlYXJjaChuZXh0LCB0eXBlcy5jb25jYXQodHlwZSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlYXJjaCh0aGlzLCBbXSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgYSBzZXQgb2Ygd3JhcHBpbmcgbm9kZSB0eXBlcyB0aGF0IHdvdWxkIGFsbG93IGEgbm9kZSBvZiB0aGVcbiAgICBnaXZlbiB0eXBlIHRvIGFwcGVhciBhdCB0aGlzIHBvc2l0aW9uLiBUaGUgcmVzdWx0IG1heSBiZSBlbXB0eVxuICAgICh3aGVuIGl0IGZpdHMgZGlyZWN0bHkpIGFuZCB3aWxsIGJlIG51bGwgd2hlbiBubyBzdWNoIHdyYXBwaW5nXG4gICAgZXhpc3RzLlxuICAgICovXG4gICAgZmluZFdyYXBwaW5nKHRhcmdldCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMud3JhcENhY2hlLmxlbmd0aDsgaSArPSAyKVxuICAgICAgICAgICAgaWYgKHRoaXMud3JhcENhY2hlW2ldID09IHRhcmdldClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy53cmFwQ2FjaGVbaSArIDFdO1xuICAgICAgICBsZXQgY29tcHV0ZWQgPSB0aGlzLmNvbXB1dGVXcmFwcGluZyh0YXJnZXQpO1xuICAgICAgICB0aGlzLndyYXBDYWNoZS5wdXNoKHRhcmdldCwgY29tcHV0ZWQpO1xuICAgICAgICByZXR1cm4gY29tcHV0ZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29tcHV0ZVdyYXBwaW5nKHRhcmdldCkge1xuICAgICAgICBsZXQgc2VlbiA9IE9iamVjdC5jcmVhdGUobnVsbCksIGFjdGl2ZSA9IFt7IG1hdGNoOiB0aGlzLCB0eXBlOiBudWxsLCB2aWE6IG51bGwgfV07XG4gICAgICAgIHdoaWxlIChhY3RpdmUubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudCA9IGFjdGl2ZS5zaGlmdCgpLCBtYXRjaCA9IGN1cnJlbnQubWF0Y2g7XG4gICAgICAgICAgICBpZiAobWF0Y2gubWF0Y2hUeXBlKHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgb2JqID0gY3VycmVudDsgb2JqLnR5cGU7IG9iaiA9IG9iai52aWEpXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG9iai50eXBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnJldmVyc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0Y2gubmV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCB7IHR5cGUsIG5leHQgfSA9IG1hdGNoLm5leHRbaV07XG4gICAgICAgICAgICAgICAgaWYgKCF0eXBlLmlzTGVhZiAmJiAhdHlwZS5oYXNSZXF1aXJlZEF0dHJzKCkgJiYgISh0eXBlLm5hbWUgaW4gc2VlbikgJiYgKCFjdXJyZW50LnR5cGUgfHwgbmV4dC52YWxpZEVuZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlLnB1c2goeyBtYXRjaDogdHlwZS5jb250ZW50TWF0Y2gsIHR5cGUsIHZpYTogY3VycmVudCB9KTtcbiAgICAgICAgICAgICAgICAgICAgc2Vlblt0eXBlLm5hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBudW1iZXIgb2Ygb3V0Z29pbmcgZWRnZXMgdGhpcyBub2RlIGhhcyBpbiB0aGUgZmluaXRlXG4gICAgYXV0b21hdG9uIHRoYXQgZGVzY3JpYmVzIHRoZSBjb250ZW50IGV4cHJlc3Npb24uXG4gICAgKi9cbiAgICBnZXQgZWRnZUNvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0Lmxlbmd0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBfbl/igIt0aCBvdXRnb2luZyBlZGdlIGZyb20gdGhpcyBub2RlIGluIHRoZSBmaW5pdGVcbiAgICBhdXRvbWF0b24gdGhhdCBkZXNjcmliZXMgdGhlIGNvbnRlbnQgZXhwcmVzc2lvbi5cbiAgICAqL1xuICAgIGVkZ2Uobikge1xuICAgICAgICBpZiAobiA+PSB0aGlzLm5leHQubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYFRoZXJlJ3Mgbm8gJHtufXRoIGVkZ2UgaW4gdGhpcyBjb250ZW50IG1hdGNoYCk7XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRbbl07XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCBzZWVuID0gW107XG4gICAgICAgIGZ1bmN0aW9uIHNjYW4obSkge1xuICAgICAgICAgICAgc2Vlbi5wdXNoKG0pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtLm5leHQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKHNlZW4uaW5kZXhPZihtLm5leHRbaV0ubmV4dCkgPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIHNjYW4obS5uZXh0W2ldLm5leHQpO1xuICAgICAgICB9XG4gICAgICAgIHNjYW4odGhpcyk7XG4gICAgICAgIHJldHVybiBzZWVuLm1hcCgobSwgaSkgPT4ge1xuICAgICAgICAgICAgbGV0IG91dCA9IGkgKyAobS52YWxpZEVuZCA/IFwiKlwiIDogXCIgXCIpICsgXCIgXCI7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG0ubmV4dC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICBvdXQgKz0gKGkgPyBcIiwgXCIgOiBcIlwiKSArIG0ubmV4dFtpXS50eXBlLm5hbWUgKyBcIi0+XCIgKyBzZWVuLmluZGV4T2YobS5uZXh0W2ldLm5leHQpO1xuICAgICAgICAgICAgcmV0dXJuIG91dDtcbiAgICAgICAgfSkuam9pbihcIlxcblwiKTtcbiAgICB9XG59XG4vKipcbkBpbnRlcm5hbFxuKi9cbkNvbnRlbnRNYXRjaC5lbXB0eSA9IG5ldyBDb250ZW50TWF0Y2godHJ1ZSk7XG5jbGFzcyBUb2tlblN0cmVhbSB7XG4gICAgY29uc3RydWN0b3Ioc3RyaW5nLCBub2RlVHlwZXMpIHtcbiAgICAgICAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgICAgIHRoaXMubm9kZVR5cGVzID0gbm9kZVR5cGVzO1xuICAgICAgICB0aGlzLmlubGluZSA9IG51bGw7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy50b2tlbnMgPSBzdHJpbmcuc3BsaXQoL1xccyooPz1cXGJ8XFxXfCQpLyk7XG4gICAgICAgIGlmICh0aGlzLnRva2Vuc1t0aGlzLnRva2Vucy5sZW5ndGggLSAxXSA9PSBcIlwiKVxuICAgICAgICAgICAgdGhpcy50b2tlbnMucG9wKCk7XG4gICAgICAgIGlmICh0aGlzLnRva2Vuc1swXSA9PSBcIlwiKVxuICAgICAgICAgICAgdGhpcy50b2tlbnMuc2hpZnQoKTtcbiAgICB9XG4gICAgZ2V0IG5leHQoKSB7IHJldHVybiB0aGlzLnRva2Vuc1t0aGlzLnBvc107IH1cbiAgICBlYXQodG9rKSB7IHJldHVybiB0aGlzLm5leHQgPT0gdG9rICYmICh0aGlzLnBvcysrIHx8IHRydWUpOyB9XG4gICAgZXJyKHN0cikgeyB0aHJvdyBuZXcgU3ludGF4RXJyb3Ioc3RyICsgXCIgKGluIGNvbnRlbnQgZXhwcmVzc2lvbiAnXCIgKyB0aGlzLnN0cmluZyArIFwiJylcIik7IH1cbn1cbmZ1bmN0aW9uIHBhcnNlRXhwcihzdHJlYW0pIHtcbiAgICBsZXQgZXhwcnMgPSBbXTtcbiAgICBkbyB7XG4gICAgICAgIGV4cHJzLnB1c2gocGFyc2VFeHByU2VxKHN0cmVhbSkpO1xuICAgIH0gd2hpbGUgKHN0cmVhbS5lYXQoXCJ8XCIpKTtcbiAgICByZXR1cm4gZXhwcnMubGVuZ3RoID09IDEgPyBleHByc1swXSA6IHsgdHlwZTogXCJjaG9pY2VcIiwgZXhwcnMgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlRXhwclNlcShzdHJlYW0pIHtcbiAgICBsZXQgZXhwcnMgPSBbXTtcbiAgICBkbyB7XG4gICAgICAgIGV4cHJzLnB1c2gocGFyc2VFeHByU3Vic2NyaXB0KHN0cmVhbSkpO1xuICAgIH0gd2hpbGUgKHN0cmVhbS5uZXh0ICYmIHN0cmVhbS5uZXh0ICE9IFwiKVwiICYmIHN0cmVhbS5uZXh0ICE9IFwifFwiKTtcbiAgICByZXR1cm4gZXhwcnMubGVuZ3RoID09IDEgPyBleHByc1swXSA6IHsgdHlwZTogXCJzZXFcIiwgZXhwcnMgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlRXhwclN1YnNjcmlwdChzdHJlYW0pIHtcbiAgICBsZXQgZXhwciA9IHBhcnNlRXhwckF0b20oc3RyZWFtKTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChzdHJlYW0uZWF0KFwiK1wiKSlcbiAgICAgICAgICAgIGV4cHIgPSB7IHR5cGU6IFwicGx1c1wiLCBleHByIH07XG4gICAgICAgIGVsc2UgaWYgKHN0cmVhbS5lYXQoXCIqXCIpKVxuICAgICAgICAgICAgZXhwciA9IHsgdHlwZTogXCJzdGFyXCIsIGV4cHIgfTtcbiAgICAgICAgZWxzZSBpZiAoc3RyZWFtLmVhdChcIj9cIikpXG4gICAgICAgICAgICBleHByID0geyB0eXBlOiBcIm9wdFwiLCBleHByIH07XG4gICAgICAgIGVsc2UgaWYgKHN0cmVhbS5lYXQoXCJ7XCIpKVxuICAgICAgICAgICAgZXhwciA9IHBhcnNlRXhwclJhbmdlKHN0cmVhbSwgZXhwcik7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gZXhwcjtcbn1cbmZ1bmN0aW9uIHBhcnNlTnVtKHN0cmVhbSkge1xuICAgIGlmICgvXFxELy50ZXN0KHN0cmVhbS5uZXh0KSlcbiAgICAgICAgc3RyZWFtLmVycihcIkV4cGVjdGVkIG51bWJlciwgZ290ICdcIiArIHN0cmVhbS5uZXh0ICsgXCInXCIpO1xuICAgIGxldCByZXN1bHQgPSBOdW1iZXIoc3RyZWFtLm5leHQpO1xuICAgIHN0cmVhbS5wb3MrKztcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGFyc2VFeHByUmFuZ2Uoc3RyZWFtLCBleHByKSB7XG4gICAgbGV0IG1pbiA9IHBhcnNlTnVtKHN0cmVhbSksIG1heCA9IG1pbjtcbiAgICBpZiAoc3RyZWFtLmVhdChcIixcIikpIHtcbiAgICAgICAgaWYgKHN0cmVhbS5uZXh0ICE9IFwifVwiKVxuICAgICAgICAgICAgbWF4ID0gcGFyc2VOdW0oc3RyZWFtKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgbWF4ID0gLTE7XG4gICAgfVxuICAgIGlmICghc3RyZWFtLmVhdChcIn1cIikpXG4gICAgICAgIHN0cmVhbS5lcnIoXCJVbmNsb3NlZCBicmFjZWQgcmFuZ2VcIik7XG4gICAgcmV0dXJuIHsgdHlwZTogXCJyYW5nZVwiLCBtaW4sIG1heCwgZXhwciB9O1xufVxuZnVuY3Rpb24gcmVzb2x2ZU5hbWUoc3RyZWFtLCBuYW1lKSB7XG4gICAgbGV0IHR5cGVzID0gc3RyZWFtLm5vZGVUeXBlcywgdHlwZSA9IHR5cGVzW25hbWVdO1xuICAgIGlmICh0eXBlKVxuICAgICAgICByZXR1cm4gW3R5cGVdO1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCB0eXBlTmFtZSBpbiB0eXBlcykge1xuICAgICAgICBsZXQgdHlwZSA9IHR5cGVzW3R5cGVOYW1lXTtcbiAgICAgICAgaWYgKHR5cGUuaXNJbkdyb3VwKG5hbWUpKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2godHlwZSk7XG4gICAgfVxuICAgIGlmIChyZXN1bHQubGVuZ3RoID09IDApXG4gICAgICAgIHN0cmVhbS5lcnIoXCJObyBub2RlIHR5cGUgb3IgZ3JvdXAgJ1wiICsgbmFtZSArIFwiJyBmb3VuZFwiKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGFyc2VFeHByQXRvbShzdHJlYW0pIHtcbiAgICBpZiAoc3RyZWFtLmVhdChcIihcIikpIHtcbiAgICAgICAgbGV0IGV4cHIgPSBwYXJzZUV4cHIoc3RyZWFtKTtcbiAgICAgICAgaWYgKCFzdHJlYW0uZWF0KFwiKVwiKSlcbiAgICAgICAgICAgIHN0cmVhbS5lcnIoXCJNaXNzaW5nIGNsb3NpbmcgcGFyZW5cIik7XG4gICAgICAgIHJldHVybiBleHByO1xuICAgIH1cbiAgICBlbHNlIGlmICghL1xcVy8udGVzdChzdHJlYW0ubmV4dCkpIHtcbiAgICAgICAgbGV0IGV4cHJzID0gcmVzb2x2ZU5hbWUoc3RyZWFtLCBzdHJlYW0ubmV4dCkubWFwKHR5cGUgPT4ge1xuICAgICAgICAgICAgaWYgKHN0cmVhbS5pbmxpbmUgPT0gbnVsbClcbiAgICAgICAgICAgICAgICBzdHJlYW0uaW5saW5lID0gdHlwZS5pc0lubGluZTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHN0cmVhbS5pbmxpbmUgIT0gdHlwZS5pc0lubGluZSlcbiAgICAgICAgICAgICAgICBzdHJlYW0uZXJyKFwiTWl4aW5nIGlubGluZSBhbmQgYmxvY2sgY29udGVudFwiKTtcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwibmFtZVwiLCB2YWx1ZTogdHlwZSB9O1xuICAgICAgICB9KTtcbiAgICAgICAgc3RyZWFtLnBvcysrO1xuICAgICAgICByZXR1cm4gZXhwcnMubGVuZ3RoID09IDEgPyBleHByc1swXSA6IHsgdHlwZTogXCJjaG9pY2VcIiwgZXhwcnMgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN0cmVhbS5lcnIoXCJVbmV4cGVjdGVkIHRva2VuICdcIiArIHN0cmVhbS5uZXh0ICsgXCInXCIpO1xuICAgIH1cbn1cbi8vIENvbnN0cnVjdCBhbiBORkEgZnJvbSBhbiBleHByZXNzaW9uIGFzIHJldHVybmVkIGJ5IHRoZSBwYXJzZXIuIFRoZVxuLy8gTkZBIGlzIHJlcHJlc2VudGVkIGFzIGFuIGFycmF5IG9mIHN0YXRlcywgd2hpY2ggYXJlIHRoZW1zZWx2ZXNcbi8vIGFycmF5cyBvZiBlZGdlcywgd2hpY2ggYXJlIGB7dGVybSwgdG99YCBvYmplY3RzLiBUaGUgZmlyc3Qgc3RhdGUgaXNcbi8vIHRoZSBlbnRyeSBzdGF0ZSBhbmQgdGhlIGxhc3Qgbm9kZSBpcyB0aGUgc3VjY2VzcyBzdGF0ZS5cbi8vXG4vLyBOb3RlIHRoYXQgdW5saWtlIHR5cGljYWwgTkZBcywgdGhlIGVkZ2Ugb3JkZXJpbmcgaW4gdGhpcyBvbmUgaXNcbi8vIHNpZ25pZmljYW50LCBpbiB0aGF0IGl0IGlzIHVzZWQgdG8gY29udHJ1Y3QgZmlsbGVyIGNvbnRlbnQgd2hlblxuLy8gbmVjZXNzYXJ5LlxuZnVuY3Rpb24gbmZhKGV4cHIpIHtcbiAgICBsZXQgbmZhID0gW1tdXTtcbiAgICBjb25uZWN0KGNvbXBpbGUoZXhwciwgMCksIG5vZGUoKSk7XG4gICAgcmV0dXJuIG5mYTtcbiAgICBmdW5jdGlvbiBub2RlKCkgeyByZXR1cm4gbmZhLnB1c2goW10pIC0gMTsgfVxuICAgIGZ1bmN0aW9uIGVkZ2UoZnJvbSwgdG8sIHRlcm0pIHtcbiAgICAgICAgbGV0IGVkZ2UgPSB7IHRlcm0sIHRvIH07XG4gICAgICAgIG5mYVtmcm9tXS5wdXNoKGVkZ2UpO1xuICAgICAgICByZXR1cm4gZWRnZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29ubmVjdChlZGdlcywgdG8pIHtcbiAgICAgICAgZWRnZXMuZm9yRWFjaChlZGdlID0+IGVkZ2UudG8gPSB0byk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbXBpbGUoZXhwciwgZnJvbSkge1xuICAgICAgICBpZiAoZXhwci50eXBlID09IFwiY2hvaWNlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBleHByLmV4cHJzLnJlZHVjZSgob3V0LCBleHByKSA9PiBvdXQuY29uY2F0KGNvbXBpbGUoZXhwciwgZnJvbSkpLCBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhwci50eXBlID09IFwic2VxXCIpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSBjb21waWxlKGV4cHIuZXhwcnNbaV0sIGZyb20pO1xuICAgICAgICAgICAgICAgIGlmIChpID09IGV4cHIuZXhwcnMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICAgICAgY29ubmVjdChuZXh0LCBmcm9tID0gbm9kZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChleHByLnR5cGUgPT0gXCJzdGFyXCIpIHtcbiAgICAgICAgICAgIGxldCBsb29wID0gbm9kZSgpO1xuICAgICAgICAgICAgZWRnZShmcm9tLCBsb29wKTtcbiAgICAgICAgICAgIGNvbm5lY3QoY29tcGlsZShleHByLmV4cHIsIGxvb3ApLCBsb29wKTtcbiAgICAgICAgICAgIHJldHVybiBbZWRnZShsb29wKV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhwci50eXBlID09IFwicGx1c1wiKSB7XG4gICAgICAgICAgICBsZXQgbG9vcCA9IG5vZGUoKTtcbiAgICAgICAgICAgIGNvbm5lY3QoY29tcGlsZShleHByLmV4cHIsIGZyb20pLCBsb29wKTtcbiAgICAgICAgICAgIGNvbm5lY3QoY29tcGlsZShleHByLmV4cHIsIGxvb3ApLCBsb29wKTtcbiAgICAgICAgICAgIHJldHVybiBbZWRnZShsb29wKV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhwci50eXBlID09IFwib3B0XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBbZWRnZShmcm9tKV0uY29uY2F0KGNvbXBpbGUoZXhwci5leHByLCBmcm9tKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXhwci50eXBlID09IFwicmFuZ2VcIikge1xuICAgICAgICAgICAgbGV0IGN1ciA9IGZyb207XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4cHIubWluOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IG5vZGUoKTtcbiAgICAgICAgICAgICAgICBjb25uZWN0KGNvbXBpbGUoZXhwci5leHByLCBjdXIpLCBuZXh0KTtcbiAgICAgICAgICAgICAgICBjdXIgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGV4cHIubWF4ID09IC0xKSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdChjb21waWxlKGV4cHIuZXhwciwgY3VyKSwgY3VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBleHByLm1pbjsgaSA8IGV4cHIubWF4OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHQgPSBub2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIGVkZ2UoY3VyLCBuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdChjb21waWxlKGV4cHIuZXhwciwgY3VyKSwgbmV4dCk7XG4gICAgICAgICAgICAgICAgICAgIGN1ciA9IG5leHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFtlZGdlKGN1cildO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV4cHIudHlwZSA9PSBcIm5hbWVcIikge1xuICAgICAgICAgICAgcmV0dXJuIFtlZGdlKGZyb20sIHVuZGVmaW5lZCwgZXhwci52YWx1ZSldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBleHByIHR5cGVcIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjbXAoYSwgYikgeyByZXR1cm4gYiAtIGE7IH1cbi8vIEdldCB0aGUgc2V0IG9mIG5vZGVzIHJlYWNoYWJsZSBieSBudWxsIGVkZ2VzIGZyb20gYG5vZGVgLiBPbWl0XG4vLyBub2RlcyB3aXRoIG9ubHkgYSBzaW5nbGUgbnVsbC1vdXQtZWRnZSwgc2luY2UgdGhleSBtYXkgbGVhZCB0b1xuLy8gbmVlZGxlc3MgZHVwbGljYXRlZCBub2Rlcy5cbmZ1bmN0aW9uIG51bGxGcm9tKG5mYSwgbm9kZSkge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBzY2FuKG5vZGUpO1xuICAgIHJldHVybiByZXN1bHQuc29ydChjbXApO1xuICAgIGZ1bmN0aW9uIHNjYW4obm9kZSkge1xuICAgICAgICBsZXQgZWRnZXMgPSBuZmFbbm9kZV07XG4gICAgICAgIGlmIChlZGdlcy5sZW5ndGggPT0gMSAmJiAhZWRnZXNbMF0udGVybSlcbiAgICAgICAgICAgIHJldHVybiBzY2FuKGVkZ2VzWzBdLnRvKTtcbiAgICAgICAgcmVzdWx0LnB1c2gobm9kZSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB7IHRlcm0sIHRvIH0gPSBlZGdlc1tpXTtcbiAgICAgICAgICAgIGlmICghdGVybSAmJiByZXN1bHQuaW5kZXhPZih0bykgPT0gLTEpXG4gICAgICAgICAgICAgICAgc2Nhbih0byk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBDb21waWxlcyBhbiBORkEgYXMgcHJvZHVjZWQgYnkgYG5mYWAgaW50byBhIERGQSwgbW9kZWxlZCBhcyBhIHNldFxuLy8gb2Ygc3RhdGUgb2JqZWN0cyAoYENvbnRlbnRNYXRjaGAgaW5zdGFuY2VzKSB3aXRoIHRyYW5zaXRpb25zXG4vLyBiZXR3ZWVuIHRoZW0uXG5mdW5jdGlvbiBkZmEobmZhKSB7XG4gICAgbGV0IGxhYmVsZWQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHJldHVybiBleHBsb3JlKG51bGxGcm9tKG5mYSwgMCkpO1xuICAgIGZ1bmN0aW9uIGV4cGxvcmUoc3RhdGVzKSB7XG4gICAgICAgIGxldCBvdXQgPSBbXTtcbiAgICAgICAgc3RhdGVzLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgICBuZmFbbm9kZV0uZm9yRWFjaCgoeyB0ZXJtLCB0byB9KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0ZXJtKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgbGV0IHNldDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dFtpXVswXSA9PSB0ZXJtKVxuICAgICAgICAgICAgICAgICAgICAgICAgc2V0ID0gb3V0W2ldWzFdO1xuICAgICAgICAgICAgICAgIG51bGxGcm9tKG5mYSwgdG8pLmZvckVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2V0KVxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0LnB1c2goW3Rlcm0sIHNldCA9IFtdXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXQuaW5kZXhPZihub2RlKSA9PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgc3RhdGUgPSBsYWJlbGVkW3N0YXRlcy5qb2luKFwiLFwiKV0gPSBuZXcgQ29udGVudE1hdGNoKHN0YXRlcy5pbmRleE9mKG5mYS5sZW5ndGggLSAxKSA+IC0xKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzdGF0ZXMgPSBvdXRbaV1bMV0uc29ydChjbXApO1xuICAgICAgICAgICAgc3RhdGUubmV4dC5wdXNoKHsgdHlwZTogb3V0W2ldWzBdLCBuZXh0OiBsYWJlbGVkW3N0YXRlcy5qb2luKFwiLFwiKV0gfHwgZXhwbG9yZShzdGF0ZXMpIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBjaGVja0ZvckRlYWRFbmRzKG1hdGNoLCBzdHJlYW0pIHtcbiAgICBmb3IgKGxldCBpID0gMCwgd29yayA9IFttYXRjaF07IGkgPCB3b3JrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBzdGF0ZSA9IHdvcmtbaV0sIGRlYWQgPSAhc3RhdGUudmFsaWRFbmQsIG5vZGVzID0gW107XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc3RhdGUubmV4dC5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgbGV0IHsgdHlwZSwgbmV4dCB9ID0gc3RhdGUubmV4dFtqXTtcbiAgICAgICAgICAgIG5vZGVzLnB1c2godHlwZS5uYW1lKTtcbiAgICAgICAgICAgIGlmIChkZWFkICYmICEodHlwZS5pc1RleHQgfHwgdHlwZS5oYXNSZXF1aXJlZEF0dHJzKCkpKVxuICAgICAgICAgICAgICAgIGRlYWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh3b3JrLmluZGV4T2YobmV4dCkgPT0gLTEpXG4gICAgICAgICAgICAgICAgd29yay5wdXNoKG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWFkKVxuICAgICAgICAgICAgc3RyZWFtLmVycihcIk9ubHkgbm9uLWdlbmVyYXRhYmxlIG5vZGVzIChcIiArIG5vZGVzLmpvaW4oXCIsIFwiKSArIFwiKSBpbiBhIHJlcXVpcmVkIHBvc2l0aW9uIChzZWUgaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9ndWlkZS8jZ2VuZXJhdGFibGUpXCIpO1xuICAgIH1cbn1cblxuLy8gRm9yIG5vZGUgdHlwZXMgd2hlcmUgYWxsIGF0dHJzIGhhdmUgYSBkZWZhdWx0IHZhbHVlIChvciB3aGljaCBkb24ndFxuLy8gaGF2ZSBhbnkgYXR0cmlidXRlcyksIGJ1aWxkIHVwIGEgc2luZ2xlIHJldXNhYmxlIGRlZmF1bHQgYXR0cmlidXRlXG4vLyBvYmplY3QsIGFuZCB1c2UgaXQgZm9yIGFsbCBub2RlcyB0aGF0IGRvbid0IHNwZWNpZnkgc3BlY2lmaWNcbi8vIGF0dHJpYnV0ZXMuXG5mdW5jdGlvbiBkZWZhdWx0QXR0cnMoYXR0cnMpIHtcbiAgICBsZXQgZGVmYXVsdHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAobGV0IGF0dHJOYW1lIGluIGF0dHJzKSB7XG4gICAgICAgIGxldCBhdHRyID0gYXR0cnNbYXR0ck5hbWVdO1xuICAgICAgICBpZiAoIWF0dHIuaGFzRGVmYXVsdClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBkZWZhdWx0c1thdHRyTmFtZV0gPSBhdHRyLmRlZmF1bHQ7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0cztcbn1cbmZ1bmN0aW9uIGNvbXB1dGVBdHRycyhhdHRycywgdmFsdWUpIHtcbiAgICBsZXQgYnVpbHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGZvciAobGV0IG5hbWUgaW4gYXR0cnMpIHtcbiAgICAgICAgbGV0IGdpdmVuID0gdmFsdWUgJiYgdmFsdWVbbmFtZV07XG4gICAgICAgIGlmIChnaXZlbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXQgYXR0ciA9IGF0dHJzW25hbWVdO1xuICAgICAgICAgICAgaWYgKGF0dHIuaGFzRGVmYXVsdClcbiAgICAgICAgICAgICAgICBnaXZlbiA9IGF0dHIuZGVmYXVsdDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vIHZhbHVlIHN1cHBsaWVkIGZvciBhdHRyaWJ1dGUgXCIgKyBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBidWlsdFtuYW1lXSA9IGdpdmVuO1xuICAgIH1cbiAgICByZXR1cm4gYnVpbHQ7XG59XG5mdW5jdGlvbiBjaGVja0F0dHJzKGF0dHJzLCB2YWx1ZXMsIHR5cGUsIG5hbWUpIHtcbiAgICBmb3IgKGxldCBuYW1lIGluIHZhbHVlcylcbiAgICAgICAgaWYgKCEobmFtZSBpbiBhdHRycykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVW5zdXBwb3J0ZWQgYXR0cmlidXRlICR7bmFtZX0gZm9yICR7dHlwZX0gb2YgdHlwZSAke25hbWV9YCk7XG4gICAgZm9yIChsZXQgbmFtZSBpbiBhdHRycykge1xuICAgICAgICBsZXQgYXR0ciA9IGF0dHJzW25hbWVdO1xuICAgICAgICBpZiAoYXR0ci52YWxpZGF0ZSlcbiAgICAgICAgICAgIGF0dHIudmFsaWRhdGUodmFsdWVzW25hbWVdKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpbml0QXR0cnModHlwZU5hbWUsIGF0dHJzKSB7XG4gICAgbGV0IHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgaWYgKGF0dHJzKVxuICAgICAgICBmb3IgKGxldCBuYW1lIGluIGF0dHJzKVxuICAgICAgICAgICAgcmVzdWx0W25hbWVdID0gbmV3IEF0dHJpYnV0ZSh0eXBlTmFtZSwgbmFtZSwgYXR0cnNbbmFtZV0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbk5vZGUgdHlwZXMgYXJlIG9iamVjdHMgYWxsb2NhdGVkIG9uY2UgcGVyIGBTY2hlbWFgIGFuZCB1c2VkIHRvXG5bdGFnXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZS50eXBlKSBgTm9kZWAgaW5zdGFuY2VzLiBUaGV5IGNvbnRhaW4gaW5mb3JtYXRpb25cbmFib3V0IHRoZSBub2RlIHR5cGUsIHN1Y2ggYXMgaXRzIG5hbWUgYW5kIHdoYXQga2luZCBvZiBub2RlIGl0XG5yZXByZXNlbnRzLlxuKi9cbmNsYXNzIE5vZGVUeXBlIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBuYW1lIHRoZSBub2RlIHR5cGUgaGFzIGluIHRoaXMgc2NoZW1hLlxuICAgICovXG4gICAgbmFtZSwgXG4gICAgLyoqXG4gICAgQSBsaW5rIGJhY2sgdG8gdGhlIGBTY2hlbWFgIHRoZSBub2RlIHR5cGUgYmVsb25ncyB0by5cbiAgICAqL1xuICAgIHNjaGVtYSwgXG4gICAgLyoqXG4gICAgVGhlIHNwZWMgdGhhdCB0aGlzIHR5cGUgaXMgYmFzZWQgb25cbiAgICAqL1xuICAgIHNwZWMpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgICAgIC8qKlxuICAgICAgICBUaGUgc2V0IG9mIG1hcmtzIGFsbG93ZWQgaW4gdGhpcyBub2RlLiBgbnVsbGAgbWVhbnMgYWxsIG1hcmtzXG4gICAgICAgIGFyZSBhbGxvd2VkLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLm1hcmtTZXQgPSBudWxsO1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHNwZWMuZ3JvdXAgPyBzcGVjLmdyb3VwLnNwbGl0KFwiIFwiKSA6IFtdO1xuICAgICAgICB0aGlzLmF0dHJzID0gaW5pdEF0dHJzKG5hbWUsIHNwZWMuYXR0cnMpO1xuICAgICAgICB0aGlzLmRlZmF1bHRBdHRycyA9IGRlZmF1bHRBdHRycyh0aGlzLmF0dHJzKTtcbiAgICAgICAgdGhpcy5jb250ZW50TWF0Y2ggPSBudWxsO1xuICAgICAgICB0aGlzLmlubGluZUNvbnRlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLmlzQmxvY2sgPSAhKHNwZWMuaW5saW5lIHx8IG5hbWUgPT0gXCJ0ZXh0XCIpO1xuICAgICAgICB0aGlzLmlzVGV4dCA9IG5hbWUgPT0gXCJ0ZXh0XCI7XG4gICAgfVxuICAgIC8qKlxuICAgIFRydWUgaWYgdGhpcyBpcyBhbiBpbmxpbmUgdHlwZS5cbiAgICAqL1xuICAgIGdldCBpc0lubGluZSgpIHsgcmV0dXJuICF0aGlzLmlzQmxvY2s7IH1cbiAgICAvKipcbiAgICBUcnVlIGlmIHRoaXMgaXMgYSB0ZXh0YmxvY2sgdHlwZSwgYSBibG9jayB0aGF0IGNvbnRhaW5zIGlubGluZVxuICAgIGNvbnRlbnQuXG4gICAgKi9cbiAgICBnZXQgaXNUZXh0YmxvY2soKSB7IHJldHVybiB0aGlzLmlzQmxvY2sgJiYgdGhpcy5pbmxpbmVDb250ZW50OyB9XG4gICAgLyoqXG4gICAgVHJ1ZSBmb3Igbm9kZSB0eXBlcyB0aGF0IGFsbG93IG5vIGNvbnRlbnQuXG4gICAgKi9cbiAgICBnZXQgaXNMZWFmKCkgeyByZXR1cm4gdGhpcy5jb250ZW50TWF0Y2ggPT0gQ29udGVudE1hdGNoLmVtcHR5OyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgbm9kZSBpcyBhbiBhdG9tLCBpLmUuIHdoZW4gaXQgZG9lcyBub3QgaGF2ZVxuICAgIGRpcmVjdGx5IGVkaXRhYmxlIGNvbnRlbnQuXG4gICAgKi9cbiAgICBnZXQgaXNBdG9tKCkgeyByZXR1cm4gdGhpcy5pc0xlYWYgfHwgISF0aGlzLnNwZWMuYXRvbTsgfVxuICAgIC8qKlxuICAgIFJldHVybiB0cnVlIHdoZW4gdGhpcyBub2RlIHR5cGUgaXMgcGFydCBvZiB0aGUgZ2l2ZW5cbiAgICBbZ3JvdXBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy5ncm91cCkuXG4gICAgKi9cbiAgICBpc0luR3JvdXAoZ3JvdXApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JvdXBzLmluZGV4T2YoZ3JvdXApID4gLTE7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBub2RlIHR5cGUncyBbd2hpdGVzcGFjZV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLndoaXRlc3BhY2UpIG9wdGlvbi5cbiAgICAqL1xuICAgIGdldCB3aGl0ZXNwYWNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zcGVjLndoaXRlc3BhY2UgfHwgKHRoaXMuc3BlYy5jb2RlID8gXCJwcmVcIiA6IFwibm9ybWFsXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICBUZWxscyB5b3Ugd2hldGhlciB0aGlzIG5vZGUgdHlwZSBoYXMgYW55IHJlcXVpcmVkIGF0dHJpYnV0ZXMuXG4gICAgKi9cbiAgICBoYXNSZXF1aXJlZEF0dHJzKCkge1xuICAgICAgICBmb3IgKGxldCBuIGluIHRoaXMuYXR0cnMpXG4gICAgICAgICAgICBpZiAodGhpcy5hdHRyc1tuXS5pc1JlcXVpcmVkKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgIEluZGljYXRlcyB3aGV0aGVyIHRoaXMgbm9kZSBhbGxvd3Mgc29tZSBvZiB0aGUgc2FtZSBjb250ZW50IGFzXG4gICAgdGhlIGdpdmVuIG5vZGUgdHlwZS5cbiAgICAqL1xuICAgIGNvbXBhdGlibGVDb250ZW50KG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8IHRoaXMuY29udGVudE1hdGNoLmNvbXBhdGlibGUob3RoZXIuY29udGVudE1hdGNoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb21wdXRlQXR0cnMoYXR0cnMpIHtcbiAgICAgICAgaWYgKCFhdHRycyAmJiB0aGlzLmRlZmF1bHRBdHRycylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRBdHRycztcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIGNvbXB1dGVBdHRycyh0aGlzLmF0dHJzLCBhdHRycyk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGBOb2RlYCBvZiB0aGlzIHR5cGUuIFRoZSBnaXZlbiBhdHRyaWJ1dGVzIGFyZVxuICAgIGNoZWNrZWQgYW5kIGRlZmF1bHRlZCAoeW91IGNhbiBwYXNzIGBudWxsYCB0byB1c2UgdGhlIHR5cGUnc1xuICAgIGRlZmF1bHRzIGVudGlyZWx5LCBpZiBubyByZXF1aXJlZCBhdHRyaWJ1dGVzIGV4aXN0KS4gYGNvbnRlbnRgXG4gICAgbWF5IGJlIGEgYEZyYWdtZW50YCwgYSBub2RlLCBhbiBhcnJheSBvZiBub2Rlcywgb3JcbiAgICBgbnVsbGAuIFNpbWlsYXJseSBgbWFya3NgIG1heSBiZSBgbnVsbGAgdG8gZGVmYXVsdCB0byB0aGUgZW1wdHlcbiAgICBzZXQgb2YgbWFya3MuXG4gICAgKi9cbiAgICBjcmVhdGUoYXR0cnMgPSBudWxsLCBjb250ZW50LCBtYXJrcykge1xuICAgICAgICBpZiAodGhpcy5pc1RleHQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb2RlVHlwZS5jcmVhdGUgY2FuJ3QgY29uc3RydWN0IHRleHQgbm9kZXNcIik7XG4gICAgICAgIHJldHVybiBuZXcgTm9kZSh0aGlzLCB0aGlzLmNvbXB1dGVBdHRycyhhdHRycyksIEZyYWdtZW50LmZyb20oY29udGVudCksIE1hcmsuc2V0RnJvbShtYXJrcykpO1xuICAgIH1cbiAgICAvKipcbiAgICBMaWtlIFtgY3JlYXRlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVUeXBlLmNyZWF0ZSksIGJ1dCBjaGVjayB0aGUgZ2l2ZW4gY29udGVudFxuICAgIGFnYWluc3QgdGhlIG5vZGUgdHlwZSdzIGNvbnRlbnQgcmVzdHJpY3Rpb25zLCBhbmQgdGhyb3cgYW4gZXJyb3JcbiAgICBpZiBpdCBkb2Vzbid0IG1hdGNoLlxuICAgICovXG4gICAgY3JlYXRlQ2hlY2tlZChhdHRycyA9IG51bGwsIGNvbnRlbnQsIG1hcmtzKSB7XG4gICAgICAgIGNvbnRlbnQgPSBGcmFnbWVudC5mcm9tKGNvbnRlbnQpO1xuICAgICAgICB0aGlzLmNoZWNrQ29udGVudChjb250ZW50KTtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlKHRoaXMsIHRoaXMuY29tcHV0ZUF0dHJzKGF0dHJzKSwgY29udGVudCwgTWFyay5zZXRGcm9tKG1hcmtzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIExpa2UgW2BjcmVhdGVgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVR5cGUuY3JlYXRlKSwgYnV0IHNlZSBpZiBpdCBpc1xuICAgIG5lY2Vzc2FyeSB0byBhZGQgbm9kZXMgdG8gdGhlIHN0YXJ0IG9yIGVuZCBvZiB0aGUgZ2l2ZW4gZnJhZ21lbnRcbiAgICB0byBtYWtlIGl0IGZpdCB0aGUgbm9kZS4gSWYgbm8gZml0dGluZyB3cmFwcGluZyBjYW4gYmUgZm91bmQsXG4gICAgcmV0dXJuIG51bGwuIE5vdGUgdGhhdCwgZHVlIHRvIHRoZSBmYWN0IHRoYXQgcmVxdWlyZWQgbm9kZXMgY2FuXG4gICAgYWx3YXlzIGJlIGNyZWF0ZWQsIHRoaXMgd2lsbCBhbHdheXMgc3VjY2VlZCBpZiB5b3UgcGFzcyBudWxsIG9yXG4gICAgYEZyYWdtZW50LmVtcHR5YCBhcyBjb250ZW50LlxuICAgICovXG4gICAgY3JlYXRlQW5kRmlsbChhdHRycyA9IG51bGwsIGNvbnRlbnQsIG1hcmtzKSB7XG4gICAgICAgIGF0dHJzID0gdGhpcy5jb21wdXRlQXR0cnMoYXR0cnMpO1xuICAgICAgICBjb250ZW50ID0gRnJhZ21lbnQuZnJvbShjb250ZW50KTtcbiAgICAgICAgaWYgKGNvbnRlbnQuc2l6ZSkge1xuICAgICAgICAgICAgbGV0IGJlZm9yZSA9IHRoaXMuY29udGVudE1hdGNoLmZpbGxCZWZvcmUoY29udGVudCk7XG4gICAgICAgICAgICBpZiAoIWJlZm9yZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBiZWZvcmUuYXBwZW5kKGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtYXRjaGVkID0gdGhpcy5jb250ZW50TWF0Y2gubWF0Y2hGcmFnbWVudChjb250ZW50KTtcbiAgICAgICAgbGV0IGFmdGVyID0gbWF0Y2hlZCAmJiBtYXRjaGVkLmZpbGxCZWZvcmUoRnJhZ21lbnQuZW1wdHksIHRydWUpO1xuICAgICAgICBpZiAoIWFmdGVyKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgTm9kZSh0aGlzLCBhdHRycywgY29udGVudC5hcHBlbmQoYWZ0ZXIpLCBNYXJrLnNldEZyb20obWFya3MpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBmcmFnbWVudCBpcyB2YWxpZCBjb250ZW50IGZvciB0aGlzIG5vZGVcbiAgICB0eXBlLlxuICAgICovXG4gICAgdmFsaWRDb250ZW50KGNvbnRlbnQpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuY29udGVudE1hdGNoLm1hdGNoRnJhZ21lbnQoY29udGVudCk7XG4gICAgICAgIGlmICghcmVzdWx0IHx8ICFyZXN1bHQudmFsaWRFbmQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29udGVudC5jaGlsZENvdW50OyBpKyspXG4gICAgICAgICAgICBpZiAoIXRoaXMuYWxsb3dzTWFya3MoY29udGVudC5jaGlsZChpKS5tYXJrcykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhyb3dzIGEgUmFuZ2VFcnJvciBpZiB0aGUgZ2l2ZW4gZnJhZ21lbnQgaXMgbm90IHZhbGlkIGNvbnRlbnQgZm9yIHRoaXNcbiAgICBub2RlIHR5cGUuXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjaGVja0NvbnRlbnQoY29udGVudCkge1xuICAgICAgICBpZiAoIXRoaXMudmFsaWRDb250ZW50KGNvbnRlbnQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEludmFsaWQgY29udGVudCBmb3Igbm9kZSAke3RoaXMubmFtZX06ICR7Y29udGVudC50b1N0cmluZygpLnNsaWNlKDAsIDUwKX1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjaGVja0F0dHJzKGF0dHJzKSB7XG4gICAgICAgIGNoZWNrQXR0cnModGhpcy5hdHRycywgYXR0cnMsIFwibm9kZVwiLCB0aGlzLm5hbWUpO1xuICAgIH1cbiAgICAvKipcbiAgICBDaGVjayB3aGV0aGVyIHRoZSBnaXZlbiBtYXJrIHR5cGUgaXMgYWxsb3dlZCBpbiB0aGlzIG5vZGUuXG4gICAgKi9cbiAgICBhbGxvd3NNYXJrVHlwZShtYXJrVHlwZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXJrU2V0ID09IG51bGwgfHwgdGhpcy5tYXJrU2V0LmluZGV4T2YobWFya1R5cGUpID4gLTE7XG4gICAgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciB0aGUgZ2l2ZW4gc2V0IG9mIG1hcmtzIGFyZSBhbGxvd2VkIGluIHRoaXMgbm9kZS5cbiAgICAqL1xuICAgIGFsbG93c01hcmtzKG1hcmtzKSB7XG4gICAgICAgIGlmICh0aGlzLm1hcmtTZXQgPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKCF0aGlzLmFsbG93c01hcmtUeXBlKG1hcmtzW2ldLnR5cGUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlbW92ZXMgdGhlIG1hcmtzIHRoYXQgYXJlIG5vdCBhbGxvd2VkIGluIHRoaXMgbm9kZSBmcm9tIHRoZSBnaXZlbiBzZXQuXG4gICAgKi9cbiAgICBhbGxvd2VkTWFya3MobWFya3MpIHtcbiAgICAgICAgaWYgKHRoaXMubWFya1NldCA9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIG1hcmtzO1xuICAgICAgICBsZXQgY29weTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXJrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmFsbG93c01hcmtUeXBlKG1hcmtzW2ldLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjb3B5KVxuICAgICAgICAgICAgICAgICAgICBjb3B5ID0gbWFya3Muc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb3B5KSB7XG4gICAgICAgICAgICAgICAgY29weS5wdXNoKG1hcmtzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIWNvcHkgPyBtYXJrcyA6IGNvcHkubGVuZ3RoID8gY29weSA6IE1hcmsubm9uZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgY29tcGlsZShub2Rlcywgc2NoZW1hKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBub2Rlcy5mb3JFYWNoKChuYW1lLCBzcGVjKSA9PiByZXN1bHRbbmFtZV0gPSBuZXcgTm9kZVR5cGUobmFtZSwgc2NoZW1hLCBzcGVjKSk7XG4gICAgICAgIGxldCB0b3BUeXBlID0gc2NoZW1hLnNwZWMudG9wTm9kZSB8fCBcImRvY1wiO1xuICAgICAgICBpZiAoIXJlc3VsdFt0b3BUeXBlXSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiU2NoZW1hIGlzIG1pc3NpbmcgaXRzIHRvcCBub2RlIHR5cGUgKCdcIiArIHRvcFR5cGUgKyBcIicpXCIpO1xuICAgICAgICBpZiAoIXJlc3VsdC50ZXh0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJFdmVyeSBzY2hlbWEgbmVlZHMgYSAndGV4dCcgdHlwZVwiKTtcbiAgICAgICAgZm9yIChsZXQgXyBpbiByZXN1bHQudGV4dC5hdHRycylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlIHRleHQgbm9kZSB0eXBlIHNob3VsZCBub3QgaGF2ZSBhdHRyaWJ1dGVzXCIpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlVHlwZSh0eXBlTmFtZSwgYXR0ck5hbWUsIHR5cGUpIHtcbiAgICBsZXQgdHlwZXMgPSB0eXBlLnNwbGl0KFwifFwiKTtcbiAgICByZXR1cm4gKHZhbHVlKSA9PiB7XG4gICAgICAgIGxldCBuYW1lID0gdmFsdWUgPT09IG51bGwgPyBcIm51bGxcIiA6IHR5cGVvZiB2YWx1ZTtcbiAgICAgICAgaWYgKHR5cGVzLmluZGV4T2YobmFtZSkgPCAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYEV4cGVjdGVkIHZhbHVlIG9mIHR5cGUgJHt0eXBlc30gZm9yIGF0dHJpYnV0ZSAke2F0dHJOYW1lfSBvbiB0eXBlICR7dHlwZU5hbWV9LCBnb3QgJHtuYW1lfWApO1xuICAgIH07XG59XG4vLyBBdHRyaWJ1dGUgZGVzY3JpcHRvcnNcbmNsYXNzIEF0dHJpYnV0ZSB7XG4gICAgY29uc3RydWN0b3IodHlwZU5hbWUsIGF0dHJOYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaGFzRGVmYXVsdCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCBcImRlZmF1bHRcIik7XG4gICAgICAgIHRoaXMuZGVmYXVsdCA9IG9wdGlvbnMuZGVmYXVsdDtcbiAgICAgICAgdGhpcy52YWxpZGF0ZSA9IHR5cGVvZiBvcHRpb25zLnZhbGlkYXRlID09IFwic3RyaW5nXCIgPyB2YWxpZGF0ZVR5cGUodHlwZU5hbWUsIGF0dHJOYW1lLCBvcHRpb25zLnZhbGlkYXRlKSA6IG9wdGlvbnMudmFsaWRhdGU7XG4gICAgfVxuICAgIGdldCBpc1JlcXVpcmVkKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuaGFzRGVmYXVsdDtcbiAgICB9XG59XG4vLyBNYXJrc1xuLyoqXG5MaWtlIG5vZGVzLCBtYXJrcyAod2hpY2ggYXJlIGFzc29jaWF0ZWQgd2l0aCBub2RlcyB0byBzaWduaWZ5XG50aGluZ3MgbGlrZSBlbXBoYXNpcyBvciBiZWluZyBwYXJ0IG9mIGEgbGluaykgYXJlXG5bdGFnZ2VkXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTWFyay50eXBlKSB3aXRoIHR5cGUgb2JqZWN0cywgd2hpY2ggYXJlXG5pbnN0YW50aWF0ZWQgb25jZSBwZXIgYFNjaGVtYWAuXG4qL1xuY2xhc3MgTWFya1R5cGUge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIG5hbWUgb2YgdGhlIG1hcmsgdHlwZS5cbiAgICAqL1xuICAgIG5hbWUsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmFuaywgXG4gICAgLyoqXG4gICAgVGhlIHNjaGVtYSB0aGF0IHRoaXMgbWFyayB0eXBlIGluc3RhbmNlIGlzIHBhcnQgb2YuXG4gICAgKi9cbiAgICBzY2hlbWEsIFxuICAgIC8qKlxuICAgIFRoZSBzcGVjIG9uIHdoaWNoIHRoZSB0eXBlIGlzIGJhc2VkLlxuICAgICovXG4gICAgc3BlYykge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnJhbmsgPSByYW5rO1xuICAgICAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYztcbiAgICAgICAgdGhpcy5hdHRycyA9IGluaXRBdHRycyhuYW1lLCBzcGVjLmF0dHJzKTtcbiAgICAgICAgdGhpcy5leGNsdWRlZCA9IG51bGw7XG4gICAgICAgIGxldCBkZWZhdWx0cyA9IGRlZmF1bHRBdHRycyh0aGlzLmF0dHJzKTtcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IGRlZmF1bHRzID8gbmV3IE1hcmsodGhpcywgZGVmYXVsdHMpIDogbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbWFyayBvZiB0aGlzIHR5cGUuIGBhdHRyc2AgbWF5IGJlIGBudWxsYCBvciBhbiBvYmplY3RcbiAgICBjb250YWluaW5nIG9ubHkgc29tZSBvZiB0aGUgbWFyaydzIGF0dHJpYnV0ZXMuIFRoZSBvdGhlcnMsIGlmXG4gICAgdGhleSBoYXZlIGRlZmF1bHRzLCB3aWxsIGJlIGFkZGVkLlxuICAgICovXG4gICAgY3JlYXRlKGF0dHJzID0gbnVsbCkge1xuICAgICAgICBpZiAoIWF0dHJzICYmIHRoaXMuaW5zdGFuY2UpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZTtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXJrKHRoaXMsIGNvbXB1dGVBdHRycyh0aGlzLmF0dHJzLCBhdHRycykpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjb21waWxlKG1hcmtzLCBzY2hlbWEpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCksIHJhbmsgPSAwO1xuICAgICAgICBtYXJrcy5mb3JFYWNoKChuYW1lLCBzcGVjKSA9PiByZXN1bHRbbmFtZV0gPSBuZXcgTWFya1R5cGUobmFtZSwgcmFuaysrLCBzY2hlbWEsIHNwZWMpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgV2hlbiB0aGVyZSBpcyBhIG1hcmsgb2YgdGhpcyB0eXBlIGluIHRoZSBnaXZlbiBzZXQsIGEgbmV3IHNldFxuICAgIHdpdGhvdXQgaXQgaXMgcmV0dXJuZWQuIE90aGVyd2lzZSwgdGhlIGlucHV0IHNldCBpcyByZXR1cm5lZC5cbiAgICAqL1xuICAgIHJlbW92ZUZyb21TZXQoc2V0KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0Lmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKHNldFtpXS50eXBlID09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICBzZXQgPSBzZXQuc2xpY2UoMCwgaSkuY29uY2F0KHNldC5zbGljZShpICsgMSkpO1xuICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNldDtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdHMgd2hldGhlciB0aGVyZSBpcyBhIG1hcmsgb2YgdGhpcyB0eXBlIGluIHRoZSBnaXZlbiBzZXQuXG4gICAgKi9cbiAgICBpc0luU2V0KHNldCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChzZXRbaV0udHlwZSA9PSB0aGlzKVxuICAgICAgICAgICAgICAgIHJldHVybiBzZXRbaV07XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY2hlY2tBdHRycyhhdHRycykge1xuICAgICAgICBjaGVja0F0dHJzKHRoaXMuYXR0cnMsIGF0dHJzLCBcIm1hcmtcIiwgdGhpcy5uYW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUXVlcmllcyB3aGV0aGVyIGEgZ2l2ZW4gbWFyayB0eXBlIGlzXG4gICAgW2V4Y2x1ZGVkXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTWFya1NwZWMuZXhjbHVkZXMpIGJ5IHRoaXMgb25lLlxuICAgICovXG4gICAgZXhjbHVkZXMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXhjbHVkZWQuaW5kZXhPZihvdGhlcikgPiAtMTtcbiAgICB9XG59XG4vKipcbkEgZG9jdW1lbnQgc2NoZW1hLiBIb2xkcyBbbm9kZV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVUeXBlKSBhbmQgW21hcmtcbnR5cGVdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5NYXJrVHlwZSkgb2JqZWN0cyBmb3IgdGhlIG5vZGVzIGFuZCBtYXJrcyB0aGF0IG1heVxub2NjdXIgaW4gY29uZm9ybWluZyBkb2N1bWVudHMsIGFuZCBwcm92aWRlcyBmdW5jdGlvbmFsaXR5IGZvclxuY3JlYXRpbmcgYW5kIGRlc2VyaWFsaXppbmcgc3VjaCBkb2N1bWVudHMuXG5cbldoZW4gZ2l2ZW4sIHRoZSB0eXBlIHBhcmFtZXRlcnMgcHJvdmlkZSB0aGUgbmFtZXMgb2YgdGhlIG5vZGVzIGFuZFxubWFya3MgaW4gdGhpcyBzY2hlbWEuXG4qL1xuY2xhc3MgU2NoZW1hIHtcbiAgICAvKipcbiAgICBDb25zdHJ1Y3QgYSBzY2hlbWEgZnJvbSBhIHNjaGVtYSBbc3BlY2lmaWNhdGlvbl0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLlNjaGVtYVNwZWMpLlxuICAgICovXG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICAvKipcbiAgICAgICAgVGhlIFtsaW5lYnJlYWtcbiAgICAgICAgcmVwbGFjZW1lbnRdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy5saW5lYnJlYWtSZXBsYWNlbWVudCkgbm9kZSBkZWZpbmVkXG4gICAgICAgIGluIHRoaXMgc2NoZW1hLCBpZiBhbnkuXG4gICAgICAgICovXG4gICAgICAgIHRoaXMubGluZWJyZWFrUmVwbGFjZW1lbnQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgQW4gb2JqZWN0IGZvciBzdG9yaW5nIHdoYXRldmVyIHZhbHVlcyBtb2R1bGVzIG1heSB3YW50IHRvXG4gICAgICAgIGNvbXB1dGUgYW5kIGNhY2hlIHBlciBzY2hlbWEuIChJZiB5b3Ugd2FudCB0byBzdG9yZSBzb21ldGhpbmdcbiAgICAgICAgaW4gaXQsIHRyeSB0byB1c2UgcHJvcGVydHkgbmFtZXMgdW5saWtlbHkgdG8gY2xhc2guKVxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmNhY2hlZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGxldCBpbnN0YW5jZVNwZWMgPSB0aGlzLnNwZWMgPSB7fTtcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBzcGVjKVxuICAgICAgICAgICAgaW5zdGFuY2VTcGVjW3Byb3BdID0gc3BlY1twcm9wXTtcbiAgICAgICAgaW5zdGFuY2VTcGVjLm5vZGVzID0gT3JkZXJlZE1hcC5mcm9tKHNwZWMubm9kZXMpLFxuICAgICAgICAgICAgaW5zdGFuY2VTcGVjLm1hcmtzID0gT3JkZXJlZE1hcC5mcm9tKHNwZWMubWFya3MgfHwge30pLFxuICAgICAgICAgICAgdGhpcy5ub2RlcyA9IE5vZGVUeXBlLmNvbXBpbGUodGhpcy5zcGVjLm5vZGVzLCB0aGlzKTtcbiAgICAgICAgdGhpcy5tYXJrcyA9IE1hcmtUeXBlLmNvbXBpbGUodGhpcy5zcGVjLm1hcmtzLCB0aGlzKTtcbiAgICAgICAgbGV0IGNvbnRlbnRFeHByQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBmb3IgKGxldCBwcm9wIGluIHRoaXMubm9kZXMpIHtcbiAgICAgICAgICAgIGlmIChwcm9wIGluIHRoaXMubWFya3MpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IocHJvcCArIFwiIGNhbiBub3QgYmUgYm90aCBhIG5vZGUgYW5kIGEgbWFya1wiKTtcbiAgICAgICAgICAgIGxldCB0eXBlID0gdGhpcy5ub2Rlc1twcm9wXSwgY29udGVudEV4cHIgPSB0eXBlLnNwZWMuY29udGVudCB8fCBcIlwiLCBtYXJrRXhwciA9IHR5cGUuc3BlYy5tYXJrcztcbiAgICAgICAgICAgIHR5cGUuY29udGVudE1hdGNoID0gY29udGVudEV4cHJDYWNoZVtjb250ZW50RXhwcl0gfHxcbiAgICAgICAgICAgICAgICAoY29udGVudEV4cHJDYWNoZVtjb250ZW50RXhwcl0gPSBDb250ZW50TWF0Y2gucGFyc2UoY29udGVudEV4cHIsIHRoaXMubm9kZXMpKTtcbiAgICAgICAgICAgIHR5cGUuaW5saW5lQ29udGVudCA9IHR5cGUuY29udGVudE1hdGNoLmlubGluZUNvbnRlbnQ7XG4gICAgICAgICAgICBpZiAodHlwZS5zcGVjLmxpbmVicmVha1JlcGxhY2VtZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubGluZWJyZWFrUmVwbGFjZW1lbnQpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTXVsdGlwbGUgbGluZWJyZWFrIG5vZGVzIGRlZmluZWRcIik7XG4gICAgICAgICAgICAgICAgaWYgKCF0eXBlLmlzSW5saW5lIHx8ICF0eXBlLmlzTGVhZilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJMaW5lYnJlYWsgcmVwbGFjZW1lbnQgbm9kZXMgbXVzdCBiZSBpbmxpbmUgbGVhZiBub2Rlc1wiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmxpbmVicmVha1JlcGxhY2VtZW50ID0gdHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHR5cGUubWFya1NldCA9IG1hcmtFeHByID09IFwiX1wiID8gbnVsbCA6XG4gICAgICAgICAgICAgICAgbWFya0V4cHIgPyBnYXRoZXJNYXJrcyh0aGlzLCBtYXJrRXhwci5zcGxpdChcIiBcIikpIDpcbiAgICAgICAgICAgICAgICAgICAgbWFya0V4cHIgPT0gXCJcIiB8fCAhdHlwZS5pbmxpbmVDb250ZW50ID8gW10gOiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gdGhpcy5tYXJrcykge1xuICAgICAgICAgICAgbGV0IHR5cGUgPSB0aGlzLm1hcmtzW3Byb3BdLCBleGNsID0gdHlwZS5zcGVjLmV4Y2x1ZGVzO1xuICAgICAgICAgICAgdHlwZS5leGNsdWRlZCA9IGV4Y2wgPT0gbnVsbCA/IFt0eXBlXSA6IGV4Y2wgPT0gXCJcIiA/IFtdIDogZ2F0aGVyTWFya3ModGhpcywgZXhjbC5zcGxpdChcIiBcIikpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubm9kZUZyb21KU09OID0ganNvbiA9PiBOb2RlLmZyb21KU09OKHRoaXMsIGpzb24pO1xuICAgICAgICB0aGlzLm1hcmtGcm9tSlNPTiA9IGpzb24gPT4gTWFyay5mcm9tSlNPTih0aGlzLCBqc29uKTtcbiAgICAgICAgdGhpcy50b3BOb2RlVHlwZSA9IHRoaXMubm9kZXNbdGhpcy5zcGVjLnRvcE5vZGUgfHwgXCJkb2NcIl07XG4gICAgICAgIHRoaXMuY2FjaGVkLndyYXBwaW5ncyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5vZGUgaW4gdGhpcyBzY2hlbWEuIFRoZSBgdHlwZWAgbWF5IGJlIGEgc3RyaW5nIG9yIGFcbiAgICBgTm9kZVR5cGVgIGluc3RhbmNlLiBBdHRyaWJ1dGVzIHdpbGwgYmUgZXh0ZW5kZWQgd2l0aCBkZWZhdWx0cyxcbiAgICBgY29udGVudGAgbWF5IGJlIGEgYEZyYWdtZW50YCwgYG51bGxgLCBhIGBOb2RlYCwgb3IgYW4gYXJyYXkgb2ZcbiAgICBub2Rlcy5cbiAgICAqL1xuICAgIG5vZGUodHlwZSwgYXR0cnMgPSBudWxsLCBjb250ZW50LCBtYXJrcykge1xuICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHR5cGUgPSB0aGlzLm5vZGVUeXBlKHR5cGUpO1xuICAgICAgICBlbHNlIGlmICghKHR5cGUgaW5zdGFuY2VvZiBOb2RlVHlwZSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgbm9kZSB0eXBlOiBcIiArIHR5cGUpO1xuICAgICAgICBlbHNlIGlmICh0eXBlLnNjaGVtYSAhPSB0aGlzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJOb2RlIHR5cGUgZnJvbSBkaWZmZXJlbnQgc2NoZW1hIHVzZWQgKFwiICsgdHlwZS5uYW1lICsgXCIpXCIpO1xuICAgICAgICByZXR1cm4gdHlwZS5jcmVhdGVDaGVja2VkKGF0dHJzLCBjb250ZW50LCBtYXJrcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHRleHQgbm9kZSBpbiB0aGUgc2NoZW1hLiBFbXB0eSB0ZXh0IG5vZGVzIGFyZSBub3RcbiAgICBhbGxvd2VkLlxuICAgICovXG4gICAgdGV4dCh0ZXh0LCBtYXJrcykge1xuICAgICAgICBsZXQgdHlwZSA9IHRoaXMubm9kZXMudGV4dDtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0Tm9kZSh0eXBlLCB0eXBlLmRlZmF1bHRBdHRycywgdGV4dCwgTWFyay5zZXRGcm9tKG1hcmtzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIG1hcmsgd2l0aCB0aGUgZ2l2ZW4gdHlwZSBhbmQgYXR0cmlidXRlcy5cbiAgICAqL1xuICAgIG1hcmsodHlwZSwgYXR0cnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICB0eXBlID0gdGhpcy5tYXJrc1t0eXBlXTtcbiAgICAgICAgcmV0dXJuIHR5cGUuY3JlYXRlKGF0dHJzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBub2RlVHlwZShuYW1lKSB7XG4gICAgICAgIGxldCBmb3VuZCA9IHRoaXMubm9kZXNbbmFtZV07XG4gICAgICAgIGlmICghZm91bmQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlVua25vd24gbm9kZSB0eXBlOiBcIiArIG5hbWUpO1xuICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2F0aGVyTWFya3Moc2NoZW1hLCBtYXJrcykge1xuICAgIGxldCBmb3VuZCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWFya3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG5hbWUgPSBtYXJrc1tpXSwgbWFyayA9IHNjaGVtYS5tYXJrc1tuYW1lXSwgb2sgPSBtYXJrO1xuICAgICAgICBpZiAobWFyaykge1xuICAgICAgICAgICAgZm91bmQucHVzaChtYXJrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IHByb3AgaW4gc2NoZW1hLm1hcmtzKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1hcmsgPSBzY2hlbWEubWFya3NbcHJvcF07XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUgPT0gXCJfXCIgfHwgKG1hcmsuc3BlYy5ncm91cCAmJiBtYXJrLnNwZWMuZ3JvdXAuc3BsaXQoXCIgXCIpLmluZGV4T2YobmFtZSkgPiAtMSkpXG4gICAgICAgICAgICAgICAgICAgIGZvdW5kLnB1c2gob2sgPSBtYXJrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIW9rKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVW5rbm93biBtYXJrIHR5cGU6ICdcIiArIG1hcmtzW2ldICsgXCInXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZm91bmQ7XG59XG5cbmZ1bmN0aW9uIGlzVGFnUnVsZShydWxlKSB7IHJldHVybiBydWxlLnRhZyAhPSBudWxsOyB9XG5mdW5jdGlvbiBpc1N0eWxlUnVsZShydWxlKSB7IHJldHVybiBydWxlLnN0eWxlICE9IG51bGw7IH1cbi8qKlxuQSBET00gcGFyc2VyIHJlcHJlc2VudHMgYSBzdHJhdGVneSBmb3IgcGFyc2luZyBET00gY29udGVudCBpbnRvIGFcblByb3NlTWlycm9yIGRvY3VtZW50IGNvbmZvcm1pbmcgdG8gYSBnaXZlbiBzY2hlbWEuIEl0cyBiZWhhdmlvciBpc1xuZGVmaW5lZCBieSBhbiBhcnJheSBvZiBbcnVsZXNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5QYXJzZVJ1bGUpLlxuKi9cbmNsYXNzIERPTVBhcnNlciB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgcGFyc2VyIHRoYXQgdGFyZ2V0cyB0aGUgZ2l2ZW4gc2NoZW1hLCB1c2luZyB0aGUgZ2l2ZW5cbiAgICBwYXJzaW5nIHJ1bGVzLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHNjaGVtYSBpbnRvIHdoaWNoIHRoZSBwYXJzZXIgcGFyc2VzLlxuICAgICovXG4gICAgc2NoZW1hLCBcbiAgICAvKipcbiAgICBUaGUgc2V0IG9mIFtwYXJzZSBydWxlc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLlBhcnNlUnVsZSkgdGhhdCB0aGUgcGFyc2VyXG4gICAgdXNlcywgaW4gb3JkZXIgb2YgcHJlY2VkZW5jZS5cbiAgICAqL1xuICAgIHJ1bGVzKSB7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICAgICAgICB0aGlzLnJ1bGVzID0gcnVsZXM7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy50YWdzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdHlsZXMgPSBbXTtcbiAgICAgICAgbGV0IG1hdGNoZWRTdHlsZXMgPSB0aGlzLm1hdGNoZWRTdHlsZXMgPSBbXTtcbiAgICAgICAgcnVsZXMuZm9yRWFjaChydWxlID0+IHtcbiAgICAgICAgICAgIGlmIChpc1RhZ1J1bGUocnVsZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRhZ3MucHVzaChydWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzU3R5bGVSdWxlKHJ1bGUpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHByb3AgPSAvW149XSovLmV4ZWMocnVsZS5zdHlsZSlbMF07XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZWRTdHlsZXMuaW5kZXhPZihwcm9wKSA8IDApXG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZWRTdHlsZXMucHVzaChwcm9wKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0eWxlcy5wdXNoKHJ1bGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gT25seSBub3JtYWxpemUgbGlzdCBlbGVtZW50cyB3aGVuIGxpc3RzIGluIHRoZSBzY2hlbWEgY2FuJ3QgZGlyZWN0bHkgY29udGFpbiB0aGVtc2VsdmVzXG4gICAgICAgIHRoaXMubm9ybWFsaXplTGlzdHMgPSAhdGhpcy50YWdzLnNvbWUociA9PiB7XG4gICAgICAgICAgICBpZiAoIS9eKHVsfG9sKVxcYi8udGVzdChyLnRhZykgfHwgIXIubm9kZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IHNjaGVtYS5ub2Rlc1tyLm5vZGVdO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUuY29udGVudE1hdGNoLm1hdGNoVHlwZShub2RlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFBhcnNlIGEgZG9jdW1lbnQgZnJvbSB0aGUgY29udGVudCBvZiBhIERPTSBub2RlLlxuICAgICovXG4gICAgcGFyc2UoZG9tLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgbGV0IGNvbnRleHQgPSBuZXcgUGFyc2VDb250ZXh0KHRoaXMsIG9wdGlvbnMsIGZhbHNlKTtcbiAgICAgICAgY29udGV4dC5hZGRBbGwoZG9tLCBNYXJrLm5vbmUsIG9wdGlvbnMuZnJvbSwgb3B0aW9ucy50byk7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmZpbmlzaCgpO1xuICAgIH1cbiAgICAvKipcbiAgICBQYXJzZXMgdGhlIGNvbnRlbnQgb2YgdGhlIGdpdmVuIERPTSBub2RlLCBsaWtlXG4gICAgW2BwYXJzZWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5ET01QYXJzZXIucGFyc2UpLCBhbmQgdGFrZXMgdGhlIHNhbWUgc2V0IG9mXG4gICAgb3B0aW9ucy4gQnV0IHVubGlrZSB0aGF0IG1ldGhvZCwgd2hpY2ggcHJvZHVjZXMgYSB3aG9sZSBub2RlLFxuICAgIHRoaXMgb25lIHJldHVybnMgYSBzbGljZSB0aGF0IGlzIG9wZW4gYXQgdGhlIHNpZGVzLCBtZWFuaW5nIHRoYXRcbiAgICB0aGUgc2NoZW1hIGNvbnN0cmFpbnRzIGFyZW4ndCBhcHBsaWVkIHRvIHRoZSBzdGFydCBvZiBub2RlcyB0b1xuICAgIHRoZSBsZWZ0IG9mIHRoZSBpbnB1dCBhbmQgdGhlIGVuZCBvZiBub2RlcyBhdCB0aGUgZW5kLlxuICAgICovXG4gICAgcGFyc2VTbGljZShkb20sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgY29udGV4dCA9IG5ldyBQYXJzZUNvbnRleHQodGhpcywgb3B0aW9ucywgdHJ1ZSk7XG4gICAgICAgIGNvbnRleHQuYWRkQWxsKGRvbSwgTWFyay5ub25lLCBvcHRpb25zLmZyb20sIG9wdGlvbnMudG8pO1xuICAgICAgICByZXR1cm4gU2xpY2UubWF4T3Blbihjb250ZXh0LmZpbmlzaCgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtYXRjaFRhZyhkb20sIGNvbnRleHQsIGFmdGVyKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBhZnRlciA/IHRoaXMudGFncy5pbmRleE9mKGFmdGVyKSArIDEgOiAwOyBpIDwgdGhpcy50YWdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcnVsZSA9IHRoaXMudGFnc1tpXTtcbiAgICAgICAgICAgIGlmIChtYXRjaGVzKGRvbSwgcnVsZS50YWcpICYmXG4gICAgICAgICAgICAgICAgKHJ1bGUubmFtZXNwYWNlID09PSB1bmRlZmluZWQgfHwgZG9tLm5hbWVzcGFjZVVSSSA9PSBydWxlLm5hbWVzcGFjZSkgJiZcbiAgICAgICAgICAgICAgICAoIXJ1bGUuY29udGV4dCB8fCBjb250ZXh0Lm1hdGNoZXNDb250ZXh0KHJ1bGUuY29udGV4dCkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJ1bGUuZ2V0QXR0cnMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHJ1bGUuZ2V0QXR0cnMoZG9tKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgcnVsZS5hdHRycyA9IHJlc3VsdCB8fCB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBydWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgbWF0Y2hTdHlsZShwcm9wLCB2YWx1ZSwgY29udGV4dCwgYWZ0ZXIpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IGFmdGVyID8gdGhpcy5zdHlsZXMuaW5kZXhPZihhZnRlcikgKyAxIDogMDsgaSA8IHRoaXMuc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcnVsZSA9IHRoaXMuc3R5bGVzW2ldLCBzdHlsZSA9IHJ1bGUuc3R5bGU7XG4gICAgICAgICAgICBpZiAoc3R5bGUuaW5kZXhPZihwcm9wKSAhPSAwIHx8XG4gICAgICAgICAgICAgICAgcnVsZS5jb250ZXh0ICYmICFjb250ZXh0Lm1hdGNoZXNDb250ZXh0KHJ1bGUuY29udGV4dCkgfHxcbiAgICAgICAgICAgICAgICAvLyBUZXN0IHRoYXQgdGhlIHN0eWxlIHN0cmluZyBlaXRoZXIgcHJlY2lzZWx5IG1hdGNoZXMgdGhlIHByb3AsXG4gICAgICAgICAgICAgICAgLy8gb3IgaGFzIGFuICc9JyBzaWduIGFmdGVyIHRoZSBwcm9wLCBmb2xsb3dlZCBieSB0aGUgZ2l2ZW5cbiAgICAgICAgICAgICAgICAvLyB2YWx1ZS5cbiAgICAgICAgICAgICAgICBzdHlsZS5sZW5ndGggPiBwcm9wLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICAoc3R5bGUuY2hhckNvZGVBdChwcm9wLmxlbmd0aCkgIT0gNjEgfHwgc3R5bGUuc2xpY2UocHJvcC5sZW5ndGggKyAxKSAhPSB2YWx1ZSkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAocnVsZS5nZXRBdHRycykge1xuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSBydWxlLmdldEF0dHJzKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgcnVsZS5hdHRycyA9IHJlc3VsdCB8fCB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcnVsZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBzY2hlbWFSdWxlcyhzY2hlbWEpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmdW5jdGlvbiBpbnNlcnQocnVsZSkge1xuICAgICAgICAgICAgbGV0IHByaW9yaXR5ID0gcnVsZS5wcmlvcml0eSA9PSBudWxsID8gNTAgOiBydWxlLnByaW9yaXR5LCBpID0gMDtcbiAgICAgICAgICAgIGZvciAoOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5leHQgPSByZXN1bHRbaV0sIG5leHRQcmlvcml0eSA9IG5leHQucHJpb3JpdHkgPT0gbnVsbCA/IDUwIDogbmV4dC5wcmlvcml0eTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dFByaW9yaXR5IDwgcHJpb3JpdHkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnNwbGljZShpLCAwLCBydWxlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBuYW1lIGluIHNjaGVtYS5tYXJrcykge1xuICAgICAgICAgICAgbGV0IHJ1bGVzID0gc2NoZW1hLm1hcmtzW25hbWVdLnNwZWMucGFyc2VET007XG4gICAgICAgICAgICBpZiAocnVsZXMpXG4gICAgICAgICAgICAgICAgcnVsZXMuZm9yRWFjaChydWxlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaW5zZXJ0KHJ1bGUgPSBjb3B5KHJ1bGUpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEocnVsZS5tYXJrIHx8IHJ1bGUuaWdub3JlIHx8IHJ1bGUuY2xlYXJNYXJrKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGUubWFyayA9IG5hbWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgbmFtZSBpbiBzY2hlbWEubm9kZXMpIHtcbiAgICAgICAgICAgIGxldCBydWxlcyA9IHNjaGVtYS5ub2Rlc1tuYW1lXS5zcGVjLnBhcnNlRE9NO1xuICAgICAgICAgICAgaWYgKHJ1bGVzKVxuICAgICAgICAgICAgICAgIHJ1bGVzLmZvckVhY2gocnVsZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGluc2VydChydWxlID0gY29weShydWxlKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHJ1bGUubm9kZSB8fCBydWxlLmlnbm9yZSB8fCBydWxlLm1hcmspKVxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5ub2RlID0gbmFtZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBDb25zdHJ1Y3QgYSBET00gcGFyc2VyIHVzaW5nIHRoZSBwYXJzaW5nIHJ1bGVzIGxpc3RlZCBpbiBhXG4gICAgc2NoZW1hJ3MgW25vZGUgc3BlY3NdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy5wYXJzZURPTSksIHJlb3JkZXJlZCBieVxuICAgIFtwcmlvcml0eV0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLkdlbmVyaWNQYXJzZVJ1bGUucHJpb3JpdHkpLlxuICAgICovXG4gICAgc3RhdGljIGZyb21TY2hlbWEoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWEuY2FjaGVkLmRvbVBhcnNlciB8fFxuICAgICAgICAgICAgKHNjaGVtYS5jYWNoZWQuZG9tUGFyc2VyID0gbmV3IERPTVBhcnNlcihzY2hlbWEsIERPTVBhcnNlci5zY2hlbWFSdWxlcyhzY2hlbWEpKSk7XG4gICAgfVxufVxuY29uc3QgYmxvY2tUYWdzID0ge1xuICAgIGFkZHJlc3M6IHRydWUsIGFydGljbGU6IHRydWUsIGFzaWRlOiB0cnVlLCBibG9ja3F1b3RlOiB0cnVlLCBjYW52YXM6IHRydWUsXG4gICAgZGQ6IHRydWUsIGRpdjogdHJ1ZSwgZGw6IHRydWUsIGZpZWxkc2V0OiB0cnVlLCBmaWdjYXB0aW9uOiB0cnVlLCBmaWd1cmU6IHRydWUsXG4gICAgZm9vdGVyOiB0cnVlLCBmb3JtOiB0cnVlLCBoMTogdHJ1ZSwgaDI6IHRydWUsIGgzOiB0cnVlLCBoNDogdHJ1ZSwgaDU6IHRydWUsXG4gICAgaDY6IHRydWUsIGhlYWRlcjogdHJ1ZSwgaGdyb3VwOiB0cnVlLCBocjogdHJ1ZSwgbGk6IHRydWUsIG5vc2NyaXB0OiB0cnVlLCBvbDogdHJ1ZSxcbiAgICBvdXRwdXQ6IHRydWUsIHA6IHRydWUsIHByZTogdHJ1ZSwgc2VjdGlvbjogdHJ1ZSwgdGFibGU6IHRydWUsIHRmb290OiB0cnVlLCB1bDogdHJ1ZVxufTtcbmNvbnN0IGlnbm9yZVRhZ3MgPSB7XG4gICAgaGVhZDogdHJ1ZSwgbm9zY3JpcHQ6IHRydWUsIG9iamVjdDogdHJ1ZSwgc2NyaXB0OiB0cnVlLCBzdHlsZTogdHJ1ZSwgdGl0bGU6IHRydWVcbn07XG5jb25zdCBsaXN0VGFncyA9IHsgb2w6IHRydWUsIHVsOiB0cnVlIH07XG4vLyBVc2luZyBhIGJpdGZpZWxkIGZvciBub2RlIGNvbnRleHQgb3B0aW9uc1xuY29uc3QgT1BUX1BSRVNFUlZFX1dTID0gMSwgT1BUX1BSRVNFUlZFX1dTX0ZVTEwgPSAyLCBPUFRfT1BFTl9MRUZUID0gNDtcbmZ1bmN0aW9uIHdzT3B0aW9uc0Zvcih0eXBlLCBwcmVzZXJ2ZVdoaXRlc3BhY2UsIGJhc2UpIHtcbiAgICBpZiAocHJlc2VydmVXaGl0ZXNwYWNlICE9IG51bGwpXG4gICAgICAgIHJldHVybiAocHJlc2VydmVXaGl0ZXNwYWNlID8gT1BUX1BSRVNFUlZFX1dTIDogMCkgfFxuICAgICAgICAgICAgKHByZXNlcnZlV2hpdGVzcGFjZSA9PT0gXCJmdWxsXCIgPyBPUFRfUFJFU0VSVkVfV1NfRlVMTCA6IDApO1xuICAgIHJldHVybiB0eXBlICYmIHR5cGUud2hpdGVzcGFjZSA9PSBcInByZVwiID8gT1BUX1BSRVNFUlZFX1dTIHwgT1BUX1BSRVNFUlZFX1dTX0ZVTEwgOiBiYXNlICYgfk9QVF9PUEVOX0xFRlQ7XG59XG5jbGFzcyBOb2RlQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgYXR0cnMsIG1hcmtzLCBzb2xpZCwgbWF0Y2gsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICB0aGlzLm1hcmtzID0gbWFya3M7XG4gICAgICAgIHRoaXMuc29saWQgPSBzb2xpZDtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5jb250ZW50ID0gW107XG4gICAgICAgIC8vIE1hcmtzIGFwcGxpZWQgdG8gdGhlIG5vZGUncyBjaGlsZHJlblxuICAgICAgICB0aGlzLmFjdGl2ZU1hcmtzID0gTWFyay5ub25lO1xuICAgICAgICB0aGlzLm1hdGNoID0gbWF0Y2ggfHwgKG9wdGlvbnMgJiBPUFRfT1BFTl9MRUZUID8gbnVsbCA6IHR5cGUuY29udGVudE1hdGNoKTtcbiAgICB9XG4gICAgZmluZFdyYXBwaW5nKG5vZGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1hdGNoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMudHlwZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICBsZXQgZmlsbCA9IHRoaXMudHlwZS5jb250ZW50TWF0Y2guZmlsbEJlZm9yZShGcmFnbWVudC5mcm9tKG5vZGUpKTtcbiAgICAgICAgICAgIGlmIChmaWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tYXRjaCA9IHRoaXMudHlwZS5jb250ZW50TWF0Y2gubWF0Y2hGcmFnbWVudChmaWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMudHlwZS5jb250ZW50TWF0Y2gsIHdyYXA7XG4gICAgICAgICAgICAgICAgaWYgKHdyYXAgPSBzdGFydC5maW5kV3JhcHBpbmcobm9kZS50eXBlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoID0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3cmFwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm1hdGNoLmZpbmRXcmFwcGluZyhub2RlLnR5cGUpO1xuICAgIH1cbiAgICBmaW5pc2gob3BlbkVuZCkge1xuICAgICAgICBpZiAoISh0aGlzLm9wdGlvbnMgJiBPUFRfUFJFU0VSVkVfV1MpKSB7IC8vIFN0cmlwIHRyYWlsaW5nIHdoaXRlc3BhY2VcbiAgICAgICAgICAgIGxldCBsYXN0ID0gdGhpcy5jb250ZW50W3RoaXMuY29udGVudC5sZW5ndGggLSAxXSwgbTtcbiAgICAgICAgICAgIGlmIChsYXN0ICYmIGxhc3QuaXNUZXh0ICYmIChtID0gL1sgXFx0XFxyXFxuXFx1MDAwY10rJC8uZXhlYyhsYXN0LnRleHQpKSkge1xuICAgICAgICAgICAgICAgIGxldCB0ZXh0ID0gbGFzdDtcbiAgICAgICAgICAgICAgICBpZiAobGFzdC50ZXh0Lmxlbmd0aCA9PSBtWzBdLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZW50LnBvcCgpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250ZW50W3RoaXMuY29udGVudC5sZW5ndGggLSAxXSA9IHRleHQud2l0aFRleHQodGV4dC50ZXh0LnNsaWNlKDAsIHRleHQudGV4dC5sZW5ndGggLSBtWzBdLmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBjb250ZW50ID0gRnJhZ21lbnQuZnJvbSh0aGlzLmNvbnRlbnQpO1xuICAgICAgICBpZiAoIW9wZW5FbmQgJiYgdGhpcy5tYXRjaClcbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LmFwcGVuZCh0aGlzLm1hdGNoLmZpbGxCZWZvcmUoRnJhZ21lbnQuZW1wdHksIHRydWUpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA/IHRoaXMudHlwZS5jcmVhdGUodGhpcy5hdHRycywgY29udGVudCwgdGhpcy5tYXJrcykgOiBjb250ZW50O1xuICAgIH1cbiAgICBpbmxpbmVDb250ZXh0KG5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMudHlwZSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnR5cGUuaW5saW5lQ29udGVudDtcbiAgICAgICAgaWYgKHRoaXMuY29udGVudC5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50WzBdLmlzSW5saW5lO1xuICAgICAgICByZXR1cm4gbm9kZS5wYXJlbnROb2RlICYmICFibG9ja1RhZ3MuaGFzT3duUHJvcGVydHkobm9kZS5wYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICAgIH1cbn1cbmNsYXNzIFBhcnNlQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8gVGhlIHBhcnNlciB3ZSBhcmUgdXNpbmcuXG4gICAgcGFyc2VyLCBcbiAgICAvLyBUaGUgb3B0aW9ucyBwYXNzZWQgdG8gdGhpcyBwYXJzZS5cbiAgICBvcHRpb25zLCBpc09wZW4pIHtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuaXNPcGVuID0gaXNPcGVuO1xuICAgICAgICB0aGlzLm9wZW4gPSAwO1xuICAgICAgICB0aGlzLmxvY2FsUHJlc2VydmVXUyA9IGZhbHNlO1xuICAgICAgICBsZXQgdG9wTm9kZSA9IG9wdGlvbnMudG9wTm9kZSwgdG9wQ29udGV4dDtcbiAgICAgICAgbGV0IHRvcE9wdGlvbnMgPSB3c09wdGlvbnNGb3IobnVsbCwgb3B0aW9ucy5wcmVzZXJ2ZVdoaXRlc3BhY2UsIDApIHwgKGlzT3BlbiA/IE9QVF9PUEVOX0xFRlQgOiAwKTtcbiAgICAgICAgaWYgKHRvcE5vZGUpXG4gICAgICAgICAgICB0b3BDb250ZXh0ID0gbmV3IE5vZGVDb250ZXh0KHRvcE5vZGUudHlwZSwgdG9wTm9kZS5hdHRycywgTWFyay5ub25lLCB0cnVlLCBvcHRpb25zLnRvcE1hdGNoIHx8IHRvcE5vZGUudHlwZS5jb250ZW50TWF0Y2gsIHRvcE9wdGlvbnMpO1xuICAgICAgICBlbHNlIGlmIChpc09wZW4pXG4gICAgICAgICAgICB0b3BDb250ZXh0ID0gbmV3IE5vZGVDb250ZXh0KG51bGwsIG51bGwsIE1hcmsubm9uZSwgdHJ1ZSwgbnVsbCwgdG9wT3B0aW9ucyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRvcENvbnRleHQgPSBuZXcgTm9kZUNvbnRleHQocGFyc2VyLnNjaGVtYS50b3BOb2RlVHlwZSwgbnVsbCwgTWFyay5ub25lLCB0cnVlLCBudWxsLCB0b3BPcHRpb25zKTtcbiAgICAgICAgdGhpcy5ub2RlcyA9IFt0b3BDb250ZXh0XTtcbiAgICAgICAgdGhpcy5maW5kID0gb3B0aW9ucy5maW5kUG9zaXRpb25zO1xuICAgICAgICB0aGlzLm5lZWRzQmxvY2sgPSBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IHRvcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZXNbdGhpcy5vcGVuXTtcbiAgICB9XG4gICAgLy8gQWRkIGEgRE9NIG5vZGUgdG8gdGhlIGNvbnRlbnQuIFRleHQgaXMgaW5zZXJ0ZWQgYXMgdGV4dCBub2RlLFxuICAgIC8vIG90aGVyd2lzZSwgdGhlIG5vZGUgaXMgcGFzc2VkIHRvIGBhZGRFbGVtZW50YCBvciwgaWYgaXQgaGFzIGFcbiAgICAvLyBgc3R5bGVgIGF0dHJpYnV0ZSwgYGFkZEVsZW1lbnRXaXRoU3R5bGVzYC5cbiAgICBhZGRET00oZG9tLCBtYXJrcykge1xuICAgICAgICBpZiAoZG9tLm5vZGVUeXBlID09IDMpXG4gICAgICAgICAgICB0aGlzLmFkZFRleHROb2RlKGRvbSwgbWFya3MpO1xuICAgICAgICBlbHNlIGlmIChkb20ubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgICAgIHRoaXMuYWRkRWxlbWVudChkb20sIG1hcmtzKTtcbiAgICB9XG4gICAgYWRkVGV4dE5vZGUoZG9tLCBtYXJrcykge1xuICAgICAgICBsZXQgdmFsdWUgPSBkb20ubm9kZVZhbHVlO1xuICAgICAgICBsZXQgdG9wID0gdGhpcy50b3AsIHByZXNlcnZlV1MgPSAodG9wLm9wdGlvbnMgJiBPUFRfUFJFU0VSVkVfV1NfRlVMTCkgPyBcImZ1bGxcIlxuICAgICAgICAgICAgOiB0aGlzLmxvY2FsUHJlc2VydmVXUyB8fCAodG9wLm9wdGlvbnMgJiBPUFRfUFJFU0VSVkVfV1MpID4gMDtcbiAgICAgICAgaWYgKHByZXNlcnZlV1MgPT09IFwiZnVsbFwiIHx8XG4gICAgICAgICAgICB0b3AuaW5saW5lQ29udGV4dChkb20pIHx8XG4gICAgICAgICAgICAvW14gXFx0XFxyXFxuXFx1MDAwY10vLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAoIXByZXNlcnZlV1MpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1sgXFx0XFxyXFxuXFx1MDAwY10rL2csIFwiIFwiKTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIHN0YXJ0cyB3aXRoIHdoaXRlc3BhY2UsIGFuZCB0aGVyZSBpcyBubyBub2RlIGJlZm9yZSBpdCwgb3JcbiAgICAgICAgICAgICAgICAvLyBhIGhhcmQgYnJlYWssIG9yIGEgdGV4dCBub2RlIHRoYXQgZW5kcyB3aXRoIHdoaXRlc3BhY2UsIHN0cmlwIHRoZVxuICAgICAgICAgICAgICAgIC8vIGxlYWRpbmcgc3BhY2UuXG4gICAgICAgICAgICAgICAgaWYgKC9eWyBcXHRcXHJcXG5cXHUwMDBjXS8udGVzdCh2YWx1ZSkgJiYgdGhpcy5vcGVuID09IHRoaXMubm9kZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbm9kZUJlZm9yZSA9IHRvcC5jb250ZW50W3RvcC5jb250ZW50Lmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZG9tTm9kZUJlZm9yZSA9IGRvbS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9kZUJlZm9yZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKGRvbU5vZGVCZWZvcmUgJiYgZG9tTm9kZUJlZm9yZS5ub2RlTmFtZSA9PSAnQlInKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKG5vZGVCZWZvcmUuaXNUZXh0ICYmIC9bIFxcdFxcclxcblxcdTAwMGNdJC8udGVzdChub2RlQmVmb3JlLnRleHQpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJlc2VydmVXUyAhPT0gXCJmdWxsXCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xccj9cXG58XFxyL2csIFwiIFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxyXFxuPy9nLCBcIlxcblwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSlcbiAgICAgICAgICAgICAgICB0aGlzLmluc2VydE5vZGUodGhpcy5wYXJzZXIuc2NoZW1hLnRleHQodmFsdWUpLCBtYXJrcywgIS9cXFMvLnRlc3QodmFsdWUpKTtcbiAgICAgICAgICAgIHRoaXMuZmluZEluVGV4dChkb20pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5maW5kSW5zaWRlKGRvbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVHJ5IHRvIGZpbmQgYSBoYW5kbGVyIGZvciB0aGUgZ2l2ZW4gdGFnIGFuZCB1c2UgdGhhdCB0byBwYXJzZS4gSWZcbiAgICAvLyBub25lIGlzIGZvdW5kLCB0aGUgZWxlbWVudCdzIGNvbnRlbnQgbm9kZXMgYXJlIGFkZGVkIGRpcmVjdGx5LlxuICAgIGFkZEVsZW1lbnQoZG9tLCBtYXJrcywgbWF0Y2hBZnRlcikge1xuICAgICAgICBsZXQgb3V0ZXJXUyA9IHRoaXMubG9jYWxQcmVzZXJ2ZVdTLCB0b3AgPSB0aGlzLnRvcDtcbiAgICAgICAgaWYgKGRvbS50YWdOYW1lID09IFwiUFJFXCIgfHwgL3ByZS8udGVzdChkb20uc3R5bGUgJiYgZG9tLnN0eWxlLndoaXRlU3BhY2UpKVxuICAgICAgICAgICAgdGhpcy5sb2NhbFByZXNlcnZlV1MgPSB0cnVlO1xuICAgICAgICBsZXQgbmFtZSA9IGRvbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLCBydWxlSUQ7XG4gICAgICAgIGlmIChsaXN0VGFncy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB0aGlzLnBhcnNlci5ub3JtYWxpemVMaXN0cylcbiAgICAgICAgICAgIG5vcm1hbGl6ZUxpc3QoZG9tKTtcbiAgICAgICAgbGV0IHJ1bGUgPSAodGhpcy5vcHRpb25zLnJ1bGVGcm9tTm9kZSAmJiB0aGlzLm9wdGlvbnMucnVsZUZyb21Ob2RlKGRvbSkpIHx8XG4gICAgICAgICAgICAocnVsZUlEID0gdGhpcy5wYXJzZXIubWF0Y2hUYWcoZG9tLCB0aGlzLCBtYXRjaEFmdGVyKSk7XG4gICAgICAgIG91dDogaWYgKHJ1bGUgPyBydWxlLmlnbm9yZSA6IGlnbm9yZVRhZ3MuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuZmluZEluc2lkZShkb20pO1xuICAgICAgICAgICAgdGhpcy5pZ25vcmVGYWxsYmFjayhkb20sIG1hcmtzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghcnVsZSB8fCBydWxlLnNraXAgfHwgcnVsZS5jbG9zZVBhcmVudCkge1xuICAgICAgICAgICAgaWYgKHJ1bGUgJiYgcnVsZS5jbG9zZVBhcmVudClcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW4gPSBNYXRoLm1heCgwLCB0aGlzLm9wZW4gLSAxKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHJ1bGUgJiYgcnVsZS5za2lwLm5vZGVUeXBlKVxuICAgICAgICAgICAgICAgIGRvbSA9IHJ1bGUuc2tpcDtcbiAgICAgICAgICAgIGxldCBzeW5jLCBvbGROZWVkc0Jsb2NrID0gdGhpcy5uZWVkc0Jsb2NrO1xuICAgICAgICAgICAgaWYgKGJsb2NrVGFncy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgIGlmICh0b3AuY29udGVudC5sZW5ndGggJiYgdG9wLmNvbnRlbnRbMF0uaXNJbmxpbmUgJiYgdGhpcy5vcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3Blbi0tO1xuICAgICAgICAgICAgICAgICAgICB0b3AgPSB0aGlzLnRvcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3luYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKCF0b3AudHlwZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZWVkc0Jsb2NrID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFkb20uZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgIHRoaXMubGVhZkZhbGxiYWNrKGRvbSwgbWFya3MpO1xuICAgICAgICAgICAgICAgIGJyZWFrIG91dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBpbm5lck1hcmtzID0gcnVsZSAmJiBydWxlLnNraXAgPyBtYXJrcyA6IHRoaXMucmVhZFN0eWxlcyhkb20sIG1hcmtzKTtcbiAgICAgICAgICAgIGlmIChpbm5lck1hcmtzKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkQWxsKGRvbSwgaW5uZXJNYXJrcyk7XG4gICAgICAgICAgICBpZiAoc3luYylcbiAgICAgICAgICAgICAgICB0aGlzLnN5bmModG9wKTtcbiAgICAgICAgICAgIHRoaXMubmVlZHNCbG9jayA9IG9sZE5lZWRzQmxvY2s7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgaW5uZXJNYXJrcyA9IHRoaXMucmVhZFN0eWxlcyhkb20sIG1hcmtzKTtcbiAgICAgICAgICAgIGlmIChpbm5lck1hcmtzKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkRWxlbWVudEJ5UnVsZShkb20sIHJ1bGUsIGlubmVyTWFya3MsIHJ1bGUuY29uc3VtaW5nID09PSBmYWxzZSA/IHJ1bGVJRCA6IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2NhbFByZXNlcnZlV1MgPSBvdXRlcldTO1xuICAgIH1cbiAgICAvLyBDYWxsZWQgZm9yIGxlYWYgRE9NIG5vZGVzIHRoYXQgd291bGQgb3RoZXJ3aXNlIGJlIGlnbm9yZWRcbiAgICBsZWFmRmFsbGJhY2soZG9tLCBtYXJrcykge1xuICAgICAgICBpZiAoZG9tLm5vZGVOYW1lID09IFwiQlJcIiAmJiB0aGlzLnRvcC50eXBlICYmIHRoaXMudG9wLnR5cGUuaW5saW5lQ29udGVudClcbiAgICAgICAgICAgIHRoaXMuYWRkVGV4dE5vZGUoZG9tLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcXG5cIiksIG1hcmtzKTtcbiAgICB9XG4gICAgLy8gQ2FsbGVkIGZvciBpZ25vcmVkIG5vZGVzXG4gICAgaWdub3JlRmFsbGJhY2soZG9tLCBtYXJrcykge1xuICAgICAgICAvLyBJZ25vcmVkIEJSIG5vZGVzIHNob3VsZCBhdCBsZWFzdCBjcmVhdGUgYW4gaW5saW5lIGNvbnRleHRcbiAgICAgICAgaWYgKGRvbS5ub2RlTmFtZSA9PSBcIkJSXCIgJiYgKCF0aGlzLnRvcC50eXBlIHx8ICF0aGlzLnRvcC50eXBlLmlubGluZUNvbnRlbnQpKVxuICAgICAgICAgICAgdGhpcy5maW5kUGxhY2UodGhpcy5wYXJzZXIuc2NoZW1hLnRleHQoXCItXCIpLCBtYXJrcywgdHJ1ZSk7XG4gICAgfVxuICAgIC8vIFJ1biBhbnkgc3R5bGUgcGFyc2VyIGFzc29jaWF0ZWQgd2l0aCB0aGUgbm9kZSdzIHN0eWxlcy4gRWl0aGVyXG4gICAgLy8gcmV0dXJuIGFuIHVwZGF0ZWQgYXJyYXkgb2YgbWFya3MsIG9yIG51bGwgdG8gaW5kaWNhdGUgc29tZSBvZiB0aGVcbiAgICAvLyBzdHlsZXMgaGFkIGEgcnVsZSB3aXRoIGBpZ25vcmVgIHNldC5cbiAgICByZWFkU3R5bGVzKGRvbSwgbWFya3MpIHtcbiAgICAgICAgbGV0IHN0eWxlcyA9IGRvbS5zdHlsZTtcbiAgICAgICAgLy8gQmVjYXVzZSBtYW55IHByb3BlcnRpZXMgd2lsbCBvbmx5IHNob3cgdXAgaW4gJ25vcm1hbGl6ZWQnIGZvcm1cbiAgICAgICAgLy8gaW4gYHN0eWxlLml0ZW1gIChpLmUuIHRleHQtZGVjb3JhdGlvbiBiZWNvbWVzXG4gICAgICAgIC8vIHRleHQtZGVjb3JhdGlvbi1saW5lLCB0ZXh0LWRlY29yYXRpb24tY29sb3IsIGV0YyksIHdlIGRpcmVjdGx5XG4gICAgICAgIC8vIHF1ZXJ5IHRoZSBzdHlsZXMgbWVudGlvbmVkIGluIG91ciBydWxlcyBpbnN0ZWFkIG9mIGl0ZXJhdGluZ1xuICAgICAgICAvLyBvdmVyIHRoZSBpdGVtcy5cbiAgICAgICAgaWYgKHN0eWxlcyAmJiBzdHlsZXMubGVuZ3RoKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBhcnNlci5tYXRjaGVkU3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5hbWUgPSB0aGlzLnBhcnNlci5tYXRjaGVkU3R5bGVzW2ldLCB2YWx1ZSA9IHN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgYWZ0ZXIgPSB1bmRlZmluZWQ7Oykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJ1bGUgPSB0aGlzLnBhcnNlci5tYXRjaFN0eWxlKG5hbWUsIHZhbHVlLCB0aGlzLCBhZnRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJ1bGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocnVsZS5pZ25vcmUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocnVsZS5jbGVhck1hcmspXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFya3MgPSBtYXJrcy5maWx0ZXIobSA9PiAhcnVsZS5jbGVhck1hcmsobSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtzID0gbWFya3MuY29uY2F0KHRoaXMucGFyc2VyLnNjaGVtYS5tYXJrc1tydWxlLm1hcmtdLmNyZWF0ZShydWxlLmF0dHJzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocnVsZS5jb25zdW1pbmcgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyID0gcnVsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFya3M7XG4gICAgfVxuICAgIC8vIExvb2sgdXAgYSBoYW5kbGVyIGZvciB0aGUgZ2l2ZW4gbm9kZS4gSWYgbm9uZSBhcmUgZm91bmQsIHJldHVyblxuICAgIC8vIGZhbHNlLiBPdGhlcndpc2UsIGFwcGx5IGl0LCB1c2UgaXRzIHJldHVybiB2YWx1ZSB0byBkcml2ZSB0aGUgd2F5XG4gICAgLy8gdGhlIG5vZGUncyBjb250ZW50IGlzIHdyYXBwZWQsIGFuZCByZXR1cm4gdHJ1ZS5cbiAgICBhZGRFbGVtZW50QnlSdWxlKGRvbSwgcnVsZSwgbWFya3MsIGNvbnRpbnVlQWZ0ZXIpIHtcbiAgICAgICAgbGV0IHN5bmMsIG5vZGVUeXBlO1xuICAgICAgICBpZiAocnVsZS5ub2RlKSB7XG4gICAgICAgICAgICBub2RlVHlwZSA9IHRoaXMucGFyc2VyLnNjaGVtYS5ub2Rlc1tydWxlLm5vZGVdO1xuICAgICAgICAgICAgaWYgKCFub2RlVHlwZS5pc0xlYWYpIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5uZXIgPSB0aGlzLmVudGVyKG5vZGVUeXBlLCBydWxlLmF0dHJzIHx8IG51bGwsIG1hcmtzLCBydWxlLnByZXNlcnZlV2hpdGVzcGFjZSk7XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHN5bmMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBtYXJrcyA9IGlubmVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLmluc2VydE5vZGUobm9kZVR5cGUuY3JlYXRlKHJ1bGUuYXR0cnMpLCBtYXJrcywgZG9tLm5vZGVOYW1lID09IFwiQlJcIikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxlYWZGYWxsYmFjayhkb20sIG1hcmtzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBtYXJrVHlwZSA9IHRoaXMucGFyc2VyLnNjaGVtYS5tYXJrc1tydWxlLm1hcmtdO1xuICAgICAgICAgICAgbWFya3MgPSBtYXJrcy5jb25jYXQobWFya1R5cGUuY3JlYXRlKHJ1bGUuYXR0cnMpKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnRJbiA9IHRoaXMudG9wO1xuICAgICAgICBpZiAobm9kZVR5cGUgJiYgbm9kZVR5cGUuaXNMZWFmKSB7XG4gICAgICAgICAgICB0aGlzLmZpbmRJbnNpZGUoZG9tKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb250aW51ZUFmdGVyKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEVsZW1lbnQoZG9tLCBtYXJrcywgY29udGludWVBZnRlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocnVsZS5nZXRDb250ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmZpbmRJbnNpZGUoZG9tKTtcbiAgICAgICAgICAgIHJ1bGUuZ2V0Q29udGVudChkb20sIHRoaXMucGFyc2VyLnNjaGVtYSkuZm9yRWFjaChub2RlID0+IHRoaXMuaW5zZXJ0Tm9kZShub2RlLCBtYXJrcywgZmFsc2UpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBjb250ZW50RE9NID0gZG9tO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBydWxlLmNvbnRlbnRFbGVtZW50ID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgY29udGVudERPTSA9IGRvbS5xdWVyeVNlbGVjdG9yKHJ1bGUuY29udGVudEVsZW1lbnQpO1xuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHJ1bGUuY29udGVudEVsZW1lbnQgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgICAgIGNvbnRlbnRET00gPSBydWxlLmNvbnRlbnRFbGVtZW50KGRvbSk7XG4gICAgICAgICAgICBlbHNlIGlmIChydWxlLmNvbnRlbnRFbGVtZW50KVxuICAgICAgICAgICAgICAgIGNvbnRlbnRET00gPSBydWxlLmNvbnRlbnRFbGVtZW50O1xuICAgICAgICAgICAgdGhpcy5maW5kQXJvdW5kKGRvbSwgY29udGVudERPTSwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLmFkZEFsbChjb250ZW50RE9NLCBtYXJrcyk7XG4gICAgICAgICAgICB0aGlzLmZpbmRBcm91bmQoZG9tLCBjb250ZW50RE9NLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN5bmMgJiYgdGhpcy5zeW5jKHN0YXJ0SW4pKVxuICAgICAgICAgICAgdGhpcy5vcGVuLS07XG4gICAgfVxuICAgIC8vIEFkZCBhbGwgY2hpbGQgbm9kZXMgYmV0d2VlbiBgc3RhcnRJbmRleGAgYW5kIGBlbmRJbmRleGAgKG9yIHRoZVxuICAgIC8vIHdob2xlIG5vZGUsIGlmIG5vdCBnaXZlbikuIElmIGBzeW5jYCBpcyBwYXNzZWQsIHVzZSBpdCB0b1xuICAgIC8vIHN5bmNocm9uaXplIGFmdGVyIGV2ZXJ5IGJsb2NrIGVsZW1lbnQuXG4gICAgYWRkQWxsKHBhcmVudCwgbWFya3MsIHN0YXJ0SW5kZXgsIGVuZEluZGV4KSB7XG4gICAgICAgIGxldCBpbmRleCA9IHN0YXJ0SW5kZXggfHwgMDtcbiAgICAgICAgZm9yIChsZXQgZG9tID0gc3RhcnRJbmRleCA/IHBhcmVudC5jaGlsZE5vZGVzW3N0YXJ0SW5kZXhdIDogcGFyZW50LmZpcnN0Q2hpbGQsIGVuZCA9IGVuZEluZGV4ID09IG51bGwgPyBudWxsIDogcGFyZW50LmNoaWxkTm9kZXNbZW5kSW5kZXhdOyBkb20gIT0gZW5kOyBkb20gPSBkb20ubmV4dFNpYmxpbmcsICsraW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMuZmluZEF0UG9pbnQocGFyZW50LCBpbmRleCk7XG4gICAgICAgICAgICB0aGlzLmFkZERPTShkb20sIG1hcmtzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpbmRBdFBvaW50KHBhcmVudCwgaW5kZXgpO1xuICAgIH1cbiAgICAvLyBUcnkgdG8gZmluZCBhIHdheSB0byBmaXQgdGhlIGdpdmVuIG5vZGUgdHlwZSBpbnRvIHRoZSBjdXJyZW50XG4gICAgLy8gY29udGV4dC4gTWF5IGFkZCBpbnRlcm1lZGlhdGUgd3JhcHBlcnMgYW5kL29yIGxlYXZlIG5vbi1zb2xpZFxuICAgIC8vIG5vZGVzIHRoYXQgd2UncmUgaW4uXG4gICAgZmluZFBsYWNlKG5vZGUsIG1hcmtzLCBjYXV0aW91cykge1xuICAgICAgICBsZXQgcm91dGUsIHN5bmM7XG4gICAgICAgIGZvciAobGV0IGRlcHRoID0gdGhpcy5vcGVuLCBwZW5hbHR5ID0gMDsgZGVwdGggPj0gMDsgZGVwdGgtLSkge1xuICAgICAgICAgICAgbGV0IGN4ID0gdGhpcy5ub2Rlc1tkZXB0aF07XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBjeC5maW5kV3JhcHBpbmcobm9kZSk7XG4gICAgICAgICAgICBpZiAoZm91bmQgJiYgKCFyb3V0ZSB8fCByb3V0ZS5sZW5ndGggPiBmb3VuZC5sZW5ndGggKyBwZW5hbHR5KSkge1xuICAgICAgICAgICAgICAgIHJvdXRlID0gZm91bmQ7XG4gICAgICAgICAgICAgICAgc3luYyA9IGN4O1xuICAgICAgICAgICAgICAgIGlmICghZm91bmQubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjeC5zb2xpZCkge1xuICAgICAgICAgICAgICAgIGlmIChjYXV0aW91cylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgcGVuYWx0eSArPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghcm91dGUpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgdGhpcy5zeW5jKHN5bmMpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvdXRlLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgbWFya3MgPSB0aGlzLmVudGVySW5uZXIocm91dGVbaV0sIG51bGwsIG1hcmtzLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiBtYXJrcztcbiAgICB9XG4gICAgLy8gVHJ5IHRvIGluc2VydCB0aGUgZ2l2ZW4gbm9kZSwgYWRqdXN0aW5nIHRoZSBjb250ZXh0IHdoZW4gbmVlZGVkLlxuICAgIGluc2VydE5vZGUobm9kZSwgbWFya3MsIGNhdXRpb3VzKSB7XG4gICAgICAgIGlmIChub2RlLmlzSW5saW5lICYmIHRoaXMubmVlZHNCbG9jayAmJiAhdGhpcy50b3AudHlwZSkge1xuICAgICAgICAgICAgbGV0IGJsb2NrID0gdGhpcy50ZXh0YmxvY2tGcm9tQ29udGV4dCgpO1xuICAgICAgICAgICAgaWYgKGJsb2NrKVxuICAgICAgICAgICAgICAgIG1hcmtzID0gdGhpcy5lbnRlcklubmVyKGJsb2NrLCBudWxsLCBtYXJrcyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGlubmVyTWFya3MgPSB0aGlzLmZpbmRQbGFjZShub2RlLCBtYXJrcywgY2F1dGlvdXMpO1xuICAgICAgICBpZiAoaW5uZXJNYXJrcykge1xuICAgICAgICAgICAgdGhpcy5jbG9zZUV4dHJhKCk7XG4gICAgICAgICAgICBsZXQgdG9wID0gdGhpcy50b3A7XG4gICAgICAgICAgICBpZiAodG9wLm1hdGNoKVxuICAgICAgICAgICAgICAgIHRvcC5tYXRjaCA9IHRvcC5tYXRjaC5tYXRjaFR5cGUobm9kZS50eXBlKTtcbiAgICAgICAgICAgIGxldCBub2RlTWFya3MgPSBNYXJrLm5vbmU7XG4gICAgICAgICAgICBmb3IgKGxldCBtIG9mIGlubmVyTWFya3MuY29uY2F0KG5vZGUubWFya3MpKVxuICAgICAgICAgICAgICAgIGlmICh0b3AudHlwZSA/IHRvcC50eXBlLmFsbG93c01hcmtUeXBlKG0udHlwZSkgOiBtYXJrTWF5QXBwbHkobS50eXBlLCBub2RlLnR5cGUpKVxuICAgICAgICAgICAgICAgICAgICBub2RlTWFya3MgPSBtLmFkZFRvU2V0KG5vZGVNYXJrcyk7XG4gICAgICAgICAgICB0b3AuY29udGVudC5wdXNoKG5vZGUubWFyayhub2RlTWFya3MpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gVHJ5IHRvIHN0YXJ0IGEgbm9kZSBvZiB0aGUgZ2l2ZW4gdHlwZSwgYWRqdXN0aW5nIHRoZSBjb250ZXh0IHdoZW5cbiAgICAvLyBuZWNlc3NhcnkuXG4gICAgZW50ZXIodHlwZSwgYXR0cnMsIG1hcmtzLCBwcmVzZXJ2ZVdTKSB7XG4gICAgICAgIGxldCBpbm5lck1hcmtzID0gdGhpcy5maW5kUGxhY2UodHlwZS5jcmVhdGUoYXR0cnMpLCBtYXJrcywgZmFsc2UpO1xuICAgICAgICBpZiAoaW5uZXJNYXJrcylcbiAgICAgICAgICAgIGlubmVyTWFya3MgPSB0aGlzLmVudGVySW5uZXIodHlwZSwgYXR0cnMsIG1hcmtzLCB0cnVlLCBwcmVzZXJ2ZVdTKTtcbiAgICAgICAgcmV0dXJuIGlubmVyTWFya3M7XG4gICAgfVxuICAgIC8vIE9wZW4gYSBub2RlIG9mIHRoZSBnaXZlbiB0eXBlXG4gICAgZW50ZXJJbm5lcih0eXBlLCBhdHRycywgbWFya3MsIHNvbGlkID0gZmFsc2UsIHByZXNlcnZlV1MpIHtcbiAgICAgICAgdGhpcy5jbG9zZUV4dHJhKCk7XG4gICAgICAgIGxldCB0b3AgPSB0aGlzLnRvcDtcbiAgICAgICAgdG9wLm1hdGNoID0gdG9wLm1hdGNoICYmIHRvcC5tYXRjaC5tYXRjaFR5cGUodHlwZSk7XG4gICAgICAgIGxldCBvcHRpb25zID0gd3NPcHRpb25zRm9yKHR5cGUsIHByZXNlcnZlV1MsIHRvcC5vcHRpb25zKTtcbiAgICAgICAgaWYgKCh0b3Aub3B0aW9ucyAmIE9QVF9PUEVOX0xFRlQpICYmIHRvcC5jb250ZW50Lmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgb3B0aW9ucyB8PSBPUFRfT1BFTl9MRUZUO1xuICAgICAgICBsZXQgYXBwbHlNYXJrcyA9IE1hcmsubm9uZTtcbiAgICAgICAgbWFya3MgPSBtYXJrcy5maWx0ZXIobSA9PiB7XG4gICAgICAgICAgICBpZiAodG9wLnR5cGUgPyB0b3AudHlwZS5hbGxvd3NNYXJrVHlwZShtLnR5cGUpIDogbWFya01heUFwcGx5KG0udHlwZSwgdHlwZSkpIHtcbiAgICAgICAgICAgICAgICBhcHBseU1hcmtzID0gbS5hZGRUb1NldChhcHBseU1hcmtzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubm9kZXMucHVzaChuZXcgTm9kZUNvbnRleHQodHlwZSwgYXR0cnMsIGFwcGx5TWFya3MsIHNvbGlkLCBudWxsLCBvcHRpb25zKSk7XG4gICAgICAgIHRoaXMub3BlbisrO1xuICAgICAgICByZXR1cm4gbWFya3M7XG4gICAgfVxuICAgIC8vIE1ha2Ugc3VyZSBhbGwgbm9kZXMgYWJvdmUgdGhpcy5vcGVuIGFyZSBmaW5pc2hlZCBhbmQgYWRkZWQgdG9cbiAgICAvLyB0aGVpciBwYXJlbnRzXG4gICAgY2xvc2VFeHRyYShvcGVuRW5kID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IGkgPSB0aGlzLm5vZGVzLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChpID4gdGhpcy5vcGVuKSB7XG4gICAgICAgICAgICBmb3IgKDsgaSA+IHRoaXMub3BlbjsgaS0tKVxuICAgICAgICAgICAgICAgIHRoaXMubm9kZXNbaSAtIDFdLmNvbnRlbnQucHVzaCh0aGlzLm5vZGVzW2ldLmZpbmlzaChvcGVuRW5kKSk7XG4gICAgICAgICAgICB0aGlzLm5vZGVzLmxlbmd0aCA9IHRoaXMub3BlbiArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmluaXNoKCkge1xuICAgICAgICB0aGlzLm9wZW4gPSAwO1xuICAgICAgICB0aGlzLmNsb3NlRXh0cmEodGhpcy5pc09wZW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5ub2Rlc1swXS5maW5pc2goISEodGhpcy5pc09wZW4gfHwgdGhpcy5vcHRpb25zLnRvcE9wZW4pKTtcbiAgICB9XG4gICAgc3luYyh0bykge1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5vcGVuOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubm9kZXNbaV0gPT0gdG8pIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW4gPSBpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5sb2NhbFByZXNlcnZlV1MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzW2ldLm9wdGlvbnMgfD0gT1BUX1BSRVNFUlZFX1dTO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnRQb3MoKSB7XG4gICAgICAgIHRoaXMuY2xvc2VFeHRyYSgpO1xuICAgICAgICBsZXQgcG9zID0gMDtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMub3BlbjsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCBjb250ZW50ID0gdGhpcy5ub2Rlc1tpXS5jb250ZW50O1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IGNvbnRlbnQubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pXG4gICAgICAgICAgICAgICAgcG9zICs9IGNvbnRlbnRbal0ubm9kZVNpemU7XG4gICAgICAgICAgICBpZiAoaSlcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgICBmaW5kQXRQb2ludChwYXJlbnQsIG9mZnNldCkge1xuICAgICAgICBpZiAodGhpcy5maW5kKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmZpbmQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5maW5kW2ldLm5vZGUgPT0gcGFyZW50ICYmIHRoaXMuZmluZFtpXS5vZmZzZXQgPT0gb2Zmc2V0KVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmRbaV0ucG9zID0gdGhpcy5jdXJyZW50UG9zO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICBmaW5kSW5zaWRlKHBhcmVudCkge1xuICAgICAgICBpZiAodGhpcy5maW5kKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmZpbmQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5maW5kW2ldLnBvcyA9PSBudWxsICYmIHBhcmVudC5ub2RlVHlwZSA9PSAxICYmIHBhcmVudC5jb250YWlucyh0aGlzLmZpbmRbaV0ubm9kZSkpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmluZFtpXS5wb3MgPSB0aGlzLmN1cnJlbnRQb3M7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIGZpbmRBcm91bmQocGFyZW50LCBjb250ZW50LCBiZWZvcmUpIHtcbiAgICAgICAgaWYgKHBhcmVudCAhPSBjb250ZW50ICYmIHRoaXMuZmluZClcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5maW5kLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmluZFtpXS5wb3MgPT0gbnVsbCAmJiBwYXJlbnQubm9kZVR5cGUgPT0gMSAmJiBwYXJlbnQuY29udGFpbnModGhpcy5maW5kW2ldLm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwb3MgPSBjb250ZW50LmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHRoaXMuZmluZFtpXS5ub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyAmIChiZWZvcmUgPyAyIDogNCkpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmRbaV0ucG9zID0gdGhpcy5jdXJyZW50UG9zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgZmluZEluVGV4dCh0ZXh0Tm9kZSkge1xuICAgICAgICBpZiAodGhpcy5maW5kKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmZpbmQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5maW5kW2ldLm5vZGUgPT0gdGV4dE5vZGUpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmluZFtpXS5wb3MgPSB0aGlzLmN1cnJlbnRQb3MgLSAodGV4dE5vZGUubm9kZVZhbHVlLmxlbmd0aCAtIHRoaXMuZmluZFtpXS5vZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICAvLyBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGdpdmVuIGNvbnRleHQgc3RyaW5nIG1hdGNoZXMgdGhpcyBjb250ZXh0LlxuICAgIG1hdGNoZXNDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQuaW5kZXhPZihcInxcIikgPiAtMSlcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LnNwbGl0KC9cXHMqXFx8XFxzKi8pLnNvbWUodGhpcy5tYXRjaGVzQ29udGV4dCwgdGhpcyk7XG4gICAgICAgIGxldCBwYXJ0cyA9IGNvbnRleHQuc3BsaXQoXCIvXCIpO1xuICAgICAgICBsZXQgb3B0aW9uID0gdGhpcy5vcHRpb25zLmNvbnRleHQ7XG4gICAgICAgIGxldCB1c2VSb290ID0gIXRoaXMuaXNPcGVuICYmICghb3B0aW9uIHx8IG9wdGlvbi5wYXJlbnQudHlwZSA9PSB0aGlzLm5vZGVzWzBdLnR5cGUpO1xuICAgICAgICBsZXQgbWluRGVwdGggPSAtKG9wdGlvbiA/IG9wdGlvbi5kZXB0aCArIDEgOiAwKSArICh1c2VSb290ID8gMCA6IDEpO1xuICAgICAgICBsZXQgbWF0Y2ggPSAoaSwgZGVwdGgpID0+IHtcbiAgICAgICAgICAgIGZvciAoOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGxldCBwYXJ0ID0gcGFydHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHBhcnQgPT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PSBwYXJ0cy5sZW5ndGggLSAxIHx8IGkgPT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgZGVwdGggPj0gbWluRGVwdGg7IGRlcHRoLS0pXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2goaSAtIDEsIGRlcHRoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHQgPSBkZXB0aCA+IDAgfHwgKGRlcHRoID09IDAgJiYgdXNlUm9vdCkgPyB0aGlzLm5vZGVzW2RlcHRoXS50eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG9wdGlvbiAmJiBkZXB0aCA+PSBtaW5EZXB0aCA/IG9wdGlvbi5ub2RlKGRlcHRoIC0gbWluRGVwdGgpLnR5cGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmV4dCB8fCAobmV4dC5uYW1lICE9IHBhcnQgJiYgIW5leHQuaXNJbkdyb3VwKHBhcnQpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG1hdGNoKHBhcnRzLmxlbmd0aCAtIDEsIHRoaXMub3Blbik7XG4gICAgfVxuICAgIHRleHRibG9ja0Zyb21Db250ZXh0KCkge1xuICAgICAgICBsZXQgJGNvbnRleHQgPSB0aGlzLm9wdGlvbnMuY29udGV4dDtcbiAgICAgICAgaWYgKCRjb250ZXh0KVxuICAgICAgICAgICAgZm9yIChsZXQgZCA9ICRjb250ZXh0LmRlcHRoOyBkID49IDA7IGQtLSkge1xuICAgICAgICAgICAgICAgIGxldCBkZWZsdCA9ICRjb250ZXh0Lm5vZGUoZCkuY29udGVudE1hdGNoQXQoJGNvbnRleHQuaW5kZXhBZnRlcihkKSkuZGVmYXVsdFR5cGU7XG4gICAgICAgICAgICAgICAgaWYgKGRlZmx0ICYmIGRlZmx0LmlzVGV4dGJsb2NrICYmIGRlZmx0LmRlZmF1bHRBdHRycylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlZmx0O1xuICAgICAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBuYW1lIGluIHRoaXMucGFyc2VyLnNjaGVtYS5ub2Rlcykge1xuICAgICAgICAgICAgbGV0IHR5cGUgPSB0aGlzLnBhcnNlci5zY2hlbWEubm9kZXNbbmFtZV07XG4gICAgICAgICAgICBpZiAodHlwZS5pc1RleHRibG9jayAmJiB0eXBlLmRlZmF1bHRBdHRycylcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIEtsdWRnZSB0byB3b3JrIGFyb3VuZCBkaXJlY3RseSBuZXN0ZWQgbGlzdCBub2RlcyBwcm9kdWNlZCBieSBzb21lXG4vLyB0b29scyBhbmQgYWxsb3dlZCBieSBicm93c2VycyB0byBtZWFuIHRoYXQgdGhlIG5lc3RlZCBsaXN0IGlzXG4vLyBhY3R1YWxseSBwYXJ0IG9mIHRoZSBsaXN0IGl0ZW0gYWJvdmUgaXQuXG5mdW5jdGlvbiBub3JtYWxpemVMaXN0KGRvbSkge1xuICAgIGZvciAobGV0IGNoaWxkID0gZG9tLmZpcnN0Q2hpbGQsIHByZXZJdGVtID0gbnVsbDsgY2hpbGQ7IGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgbGV0IG5hbWUgPSBjaGlsZC5ub2RlVHlwZSA9PSAxID8gY2hpbGQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA6IG51bGw7XG4gICAgICAgIGlmIChuYW1lICYmIGxpc3RUYWdzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHByZXZJdGVtKSB7XG4gICAgICAgICAgICBwcmV2SXRlbS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICAgICAgICBjaGlsZCA9IHByZXZJdGVtO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5hbWUgPT0gXCJsaVwiKSB7XG4gICAgICAgICAgICBwcmV2SXRlbSA9IGNoaWxkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIHByZXZJdGVtID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIEFwcGx5IGEgQ1NTIHNlbGVjdG9yLlxuZnVuY3Rpb24gbWF0Y2hlcyhkb20sIHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIChkb20ubWF0Y2hlcyB8fCBkb20ubXNNYXRjaGVzU2VsZWN0b3IgfHwgZG9tLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBkb20ubW96TWF0Y2hlc1NlbGVjdG9yKS5jYWxsKGRvbSwgc2VsZWN0b3IpO1xufVxuZnVuY3Rpb24gY29weShvYmopIHtcbiAgICBsZXQgY29weSA9IHt9O1xuICAgIGZvciAobGV0IHByb3AgaW4gb2JqKVxuICAgICAgICBjb3B5W3Byb3BdID0gb2JqW3Byb3BdO1xuICAgIHJldHVybiBjb3B5O1xufVxuLy8gVXNlZCB3aGVuIGZpbmRpbmcgYSBtYXJrIGF0IHRoZSB0b3AgbGV2ZWwgb2YgYSBmcmFnbWVudCBwYXJzZS5cbi8vIENoZWNrcyB3aGV0aGVyIGl0IHdvdWxkIGJlIHJlYXNvbmFibGUgdG8gYXBwbHkgYSBnaXZlbiBtYXJrIHR5cGUgdG9cbi8vIGEgZ2l2ZW4gbm9kZSwgYnkgbG9va2luZyBhdCB0aGUgd2F5IHRoZSBtYXJrIG9jY3VycyBpbiB0aGUgc2NoZW1hLlxuZnVuY3Rpb24gbWFya01heUFwcGx5KG1hcmtUeXBlLCBub2RlVHlwZSkge1xuICAgIGxldCBub2RlcyA9IG5vZGVUeXBlLnNjaGVtYS5ub2RlcztcbiAgICBmb3IgKGxldCBuYW1lIGluIG5vZGVzKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSBub2Rlc1tuYW1lXTtcbiAgICAgICAgaWYgKCFwYXJlbnQuYWxsb3dzTWFya1R5cGUobWFya1R5cGUpKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGxldCBzZWVuID0gW10sIHNjYW4gPSAobWF0Y2gpID0+IHtcbiAgICAgICAgICAgIHNlZW4ucHVzaChtYXRjaCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdGNoLmVkZ2VDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgdHlwZSwgbmV4dCB9ID0gbWF0Y2guZWRnZShpKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PSBub2RlVHlwZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHNlZW4uaW5kZXhPZihuZXh0KSA8IDAgJiYgc2NhbihuZXh0KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChzY2FuKHBhcmVudC5jb250ZW50TWF0Y2gpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuXG4vKipcbkEgRE9NIHNlcmlhbGl6ZXIga25vd3MgaG93IHRvIGNvbnZlcnQgUHJvc2VNaXJyb3Igbm9kZXMgYW5kXG5tYXJrcyBvZiB2YXJpb3VzIHR5cGVzIHRvIERPTSBub2Rlcy5cbiovXG5jbGFzcyBET01TZXJpYWxpemVyIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBzZXJpYWxpemVyLiBgbm9kZXNgIHNob3VsZCBtYXAgbm9kZSBuYW1lcyB0byBmdW5jdGlvbnNcbiAgICB0aGF0IHRha2UgYSBub2RlIGFuZCByZXR1cm4gYSBkZXNjcmlwdGlvbiBvZiB0aGUgY29ycmVzcG9uZGluZ1xuICAgIERPTS4gYG1hcmtzYCBkb2VzIHRoZSBzYW1lIGZvciBtYXJrIG5hbWVzLCBidXQgYWxzbyBnZXRzIGFuXG4gICAgYXJndW1lbnQgdGhhdCB0ZWxscyBpdCB3aGV0aGVyIHRoZSBtYXJrJ3MgY29udGVudCBpcyBibG9jayBvclxuICAgIGlubGluZSBjb250ZW50IChmb3IgdHlwaWNhbCB1c2UsIGl0J2xsIGFsd2F5cyBiZSBpbmxpbmUpLiBBIG1hcmtcbiAgICBzZXJpYWxpemVyIG1heSBiZSBgbnVsbGAgdG8gaW5kaWNhdGUgdGhhdCBtYXJrcyBvZiB0aGF0IHR5cGVcbiAgICBzaG91bGQgbm90IGJlIHNlcmlhbGl6ZWQuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbm9kZSBzZXJpYWxpemF0aW9uIGZ1bmN0aW9ucy5cbiAgICAqL1xuICAgIG5vZGVzLCBcbiAgICAvKipcbiAgICBUaGUgbWFyayBzZXJpYWxpemF0aW9uIGZ1bmN0aW9ucy5cbiAgICAqL1xuICAgIG1hcmtzKSB7XG4gICAgICAgIHRoaXMubm9kZXMgPSBub2RlcztcbiAgICAgICAgdGhpcy5tYXJrcyA9IG1hcmtzO1xuICAgIH1cbiAgICAvKipcbiAgICBTZXJpYWxpemUgdGhlIGNvbnRlbnQgb2YgdGhpcyBmcmFnbWVudCB0byBhIERPTSBmcmFnbWVudC4gV2hlblxuICAgIG5vdCBpbiB0aGUgYnJvd3NlciwgdGhlIGBkb2N1bWVudGAgb3B0aW9uLCBjb250YWluaW5nIGEgRE9NXG4gICAgZG9jdW1lbnQsIHNob3VsZCBiZSBwYXNzZWQgc28gdGhhdCB0aGUgc2VyaWFsaXplciBjYW4gY3JlYXRlXG4gICAgbm9kZXMuXG4gICAgKi9cbiAgICBzZXJpYWxpemVGcmFnbWVudChmcmFnbWVudCwgb3B0aW9ucyA9IHt9LCB0YXJnZXQpIHtcbiAgICAgICAgaWYgKCF0YXJnZXQpXG4gICAgICAgICAgICB0YXJnZXQgPSBkb2Mob3B0aW9ucykuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICBsZXQgdG9wID0gdGFyZ2V0LCBhY3RpdmUgPSBbXTtcbiAgICAgICAgZnJhZ21lbnQuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgICAgIGlmIChhY3RpdmUubGVuZ3RoIHx8IG5vZGUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGtlZXAgPSAwLCByZW5kZXJlZCA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGtlZXAgPCBhY3RpdmUubGVuZ3RoICYmIHJlbmRlcmVkIDwgbm9kZS5tYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHQgPSBub2RlLm1hcmtzW3JlbmRlcmVkXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLm1hcmtzW25leHQudHlwZS5uYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmV4dC5lcShhY3RpdmVba2VlcF1bMF0pIHx8IG5leHQudHlwZS5zcGVjLnNwYW5uaW5nID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBrZWVwKys7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVkKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlIChrZWVwIDwgYWN0aXZlLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdG9wID0gYWN0aXZlLnBvcCgpWzFdO1xuICAgICAgICAgICAgICAgIHdoaWxlIChyZW5kZXJlZCA8IG5vZGUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBhZGQgPSBub2RlLm1hcmtzW3JlbmRlcmVkKytdO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWFya0RPTSA9IHRoaXMuc2VyaWFsaXplTWFyayhhZGQsIG5vZGUuaXNJbmxpbmUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFya0RPTSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlLnB1c2goW2FkZCwgdG9wXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3AuYXBwZW5kQ2hpbGQobWFya0RPTS5kb20pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9wID0gbWFya0RPTS5jb250ZW50RE9NIHx8IG1hcmtET00uZG9tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9wLmFwcGVuZENoaWxkKHRoaXMuc2VyaWFsaXplTm9kZUlubmVyKG5vZGUsIG9wdGlvbnMpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2VyaWFsaXplTm9kZUlubmVyKG5vZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IHsgZG9tLCBjb250ZW50RE9NIH0gPSByZW5kZXJTcGVjKGRvYyhvcHRpb25zKSwgdGhpcy5ub2Rlc1tub2RlLnR5cGUubmFtZV0obm9kZSksIG51bGwsIG5vZGUuYXR0cnMpO1xuICAgICAgICBpZiAoY29udGVudERPTSkge1xuICAgICAgICAgICAgaWYgKG5vZGUuaXNMZWFmKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQ29udGVudCBob2xlIG5vdCBhbGxvd2VkIGluIGEgbGVhZiBub2RlIHNwZWNcIik7XG4gICAgICAgICAgICB0aGlzLnNlcmlhbGl6ZUZyYWdtZW50KG5vZGUuY29udGVudCwgb3B0aW9ucywgY29udGVudERPTSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRvbTtcbiAgICB9XG4gICAgLyoqXG4gICAgU2VyaWFsaXplIHRoaXMgbm9kZSB0byBhIERPTSBub2RlLiBUaGlzIGNhbiBiZSB1c2VmdWwgd2hlbiB5b3VcbiAgICBuZWVkIHRvIHNlcmlhbGl6ZSBhIHBhcnQgb2YgYSBkb2N1bWVudCwgYXMgb3Bwb3NlZCB0byB0aGUgd2hvbGVcbiAgICBkb2N1bWVudC4gVG8gc2VyaWFsaXplIGEgd2hvbGUgZG9jdW1lbnQsIHVzZVxuICAgIFtgc2VyaWFsaXplRnJhZ21lbnRgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuRE9NU2VyaWFsaXplci5zZXJpYWxpemVGcmFnbWVudCkgb25cbiAgICBpdHMgW2NvbnRlbnRdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlLmNvbnRlbnQpLlxuICAgICovXG4gICAgc2VyaWFsaXplTm9kZShub2RlLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgbGV0IGRvbSA9IHRoaXMuc2VyaWFsaXplTm9kZUlubmVyKG5vZGUsIG9wdGlvbnMpO1xuICAgICAgICBmb3IgKGxldCBpID0gbm9kZS5tYXJrcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IHdyYXAgPSB0aGlzLnNlcmlhbGl6ZU1hcmsobm9kZS5tYXJrc1tpXSwgbm9kZS5pc0lubGluZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAod3JhcCkge1xuICAgICAgICAgICAgICAgICh3cmFwLmNvbnRlbnRET00gfHwgd3JhcC5kb20pLmFwcGVuZENoaWxkKGRvbSk7XG4gICAgICAgICAgICAgICAgZG9tID0gd3JhcC5kb207XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRvbTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzZXJpYWxpemVNYXJrKG1hcmssIGlubGluZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCB0b0RPTSA9IHRoaXMubWFya3NbbWFyay50eXBlLm5hbWVdO1xuICAgICAgICByZXR1cm4gdG9ET00gJiYgcmVuZGVyU3BlYyhkb2Mob3B0aW9ucyksIHRvRE9NKG1hcmssIGlubGluZSksIG51bGwsIG1hcmsuYXR0cnMpO1xuICAgIH1cbiAgICBzdGF0aWMgcmVuZGVyU3BlYyhkb2MsIHN0cnVjdHVyZSwgeG1sTlMgPSBudWxsLCBibG9ja0FycmF5c0luKSB7XG4gICAgICAgIHJldHVybiByZW5kZXJTcGVjKGRvYywgc3RydWN0dXJlLCB4bWxOUywgYmxvY2tBcnJheXNJbik7XG4gICAgfVxuICAgIC8qKlxuICAgIEJ1aWxkIGEgc2VyaWFsaXplciB1c2luZyB0aGUgW2B0b0RPTWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy50b0RPTSlcbiAgICBwcm9wZXJ0aWVzIGluIGEgc2NoZW1hJ3Mgbm9kZSBhbmQgbWFyayBzcGVjcy5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tU2NoZW1hKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gc2NoZW1hLmNhY2hlZC5kb21TZXJpYWxpemVyIHx8XG4gICAgICAgICAgICAoc2NoZW1hLmNhY2hlZC5kb21TZXJpYWxpemVyID0gbmV3IERPTVNlcmlhbGl6ZXIodGhpcy5ub2Rlc0Zyb21TY2hlbWEoc2NoZW1hKSwgdGhpcy5tYXJrc0Zyb21TY2hlbWEoc2NoZW1hKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBHYXRoZXIgdGhlIHNlcmlhbGl6ZXJzIGluIGEgc2NoZW1hJ3Mgbm9kZSBzcGVjcyBpbnRvIGFuIG9iamVjdC5cbiAgICBUaGlzIGNhbiBiZSB1c2VmdWwgYXMgYSBiYXNlIHRvIGJ1aWxkIGEgY3VzdG9tIHNlcmlhbGl6ZXIgZnJvbS5cbiAgICAqL1xuICAgIHN0YXRpYyBub2Rlc0Zyb21TY2hlbWEoc2NoZW1hKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBnYXRoZXJUb0RPTShzY2hlbWEubm9kZXMpO1xuICAgICAgICBpZiAoIXJlc3VsdC50ZXh0KVxuICAgICAgICAgICAgcmVzdWx0LnRleHQgPSBub2RlID0+IG5vZGUudGV4dDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgR2F0aGVyIHRoZSBzZXJpYWxpemVycyBpbiBhIHNjaGVtYSdzIG1hcmsgc3BlY3MgaW50byBhbiBvYmplY3QuXG4gICAgKi9cbiAgICBzdGF0aWMgbWFya3NGcm9tU2NoZW1hKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gZ2F0aGVyVG9ET00oc2NoZW1hLm1hcmtzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnYXRoZXJUb0RPTShvYmopIHtcbiAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgZm9yIChsZXQgbmFtZSBpbiBvYmopIHtcbiAgICAgICAgbGV0IHRvRE9NID0gb2JqW25hbWVdLnNwZWMudG9ET007XG4gICAgICAgIGlmICh0b0RPTSlcbiAgICAgICAgICAgIHJlc3VsdFtuYW1lXSA9IHRvRE9NO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZG9jKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5kb2N1bWVudCB8fCB3aW5kb3cuZG9jdW1lbnQ7XG59XG5jb25zdCBzdXNwaWNpb3VzQXR0cmlidXRlQ2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gc3VzcGljaW91c0F0dHJpYnV0ZXMoYXR0cnMpIHtcbiAgICBsZXQgdmFsdWUgPSBzdXNwaWNpb3VzQXR0cmlidXRlQ2FjaGUuZ2V0KGF0dHJzKTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgc3VzcGljaW91c0F0dHJpYnV0ZUNhY2hlLnNldChhdHRycywgdmFsdWUgPSBzdXNwaWNpb3VzQXR0cmlidXRlc0lubmVyKGF0dHJzKSk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gc3VzcGljaW91c0F0dHJpYnV0ZXNJbm5lcihhdHRycykge1xuICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgIGZ1bmN0aW9uIHNjYW4odmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlWzBdID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjYW4odmFsdWVbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHByb3AgaW4gdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIHNjYW4odmFsdWVbcHJvcF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNjYW4oYXR0cnMpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiByZW5kZXJTcGVjKGRvYywgc3RydWN0dXJlLCB4bWxOUywgYmxvY2tBcnJheXNJbikge1xuICAgIGlmICh0eXBlb2Ygc3RydWN0dXJlID09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiB7IGRvbTogZG9jLmNyZWF0ZVRleHROb2RlKHN0cnVjdHVyZSkgfTtcbiAgICBpZiAoc3RydWN0dXJlLm5vZGVUeXBlICE9IG51bGwpXG4gICAgICAgIHJldHVybiB7IGRvbTogc3RydWN0dXJlIH07XG4gICAgaWYgKHN0cnVjdHVyZS5kb20gJiYgc3RydWN0dXJlLmRvbS5ub2RlVHlwZSAhPSBudWxsKVxuICAgICAgICByZXR1cm4gc3RydWN0dXJlO1xuICAgIGxldCB0YWdOYW1lID0gc3RydWN0dXJlWzBdLCBzdXNwaWNpb3VzO1xuICAgIGlmICh0eXBlb2YgdGFnTmFtZSAhPSBcInN0cmluZ1wiKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgYXJyYXkgcGFzc2VkIHRvIHJlbmRlclNwZWNcIik7XG4gICAgaWYgKGJsb2NrQXJyYXlzSW4gJiYgKHN1c3BpY2lvdXMgPSBzdXNwaWNpb3VzQXR0cmlidXRlcyhibG9ja0FycmF5c0luKSkgJiZcbiAgICAgICAgc3VzcGljaW91cy5pbmRleE9mKHN0cnVjdHVyZSkgPiAtMSlcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJVc2luZyBhbiBhcnJheSBmcm9tIGFuIGF0dHJpYnV0ZSBvYmplY3QgYXMgYSBET00gc3BlYy4gVGhpcyBtYXkgYmUgYW4gYXR0ZW1wdGVkIGNyb3NzIHNpdGUgc2NyaXB0aW5nIGF0dGFjay5cIik7XG4gICAgbGV0IHNwYWNlID0gdGFnTmFtZS5pbmRleE9mKFwiIFwiKTtcbiAgICBpZiAoc3BhY2UgPiAwKSB7XG4gICAgICAgIHhtbE5TID0gdGFnTmFtZS5zbGljZSgwLCBzcGFjZSk7XG4gICAgICAgIHRhZ05hbWUgPSB0YWdOYW1lLnNsaWNlKHNwYWNlICsgMSk7XG4gICAgfVxuICAgIGxldCBjb250ZW50RE9NO1xuICAgIGxldCBkb20gPSAoeG1sTlMgPyBkb2MuY3JlYXRlRWxlbWVudE5TKHhtbE5TLCB0YWdOYW1lKSA6IGRvYy5jcmVhdGVFbGVtZW50KHRhZ05hbWUpKTtcbiAgICBsZXQgYXR0cnMgPSBzdHJ1Y3R1cmVbMV0sIHN0YXJ0ID0gMTtcbiAgICBpZiAoYXR0cnMgJiYgdHlwZW9mIGF0dHJzID09IFwib2JqZWN0XCIgJiYgYXR0cnMubm9kZVR5cGUgPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheShhdHRycykpIHtcbiAgICAgICAgc3RhcnQgPSAyO1xuICAgICAgICBmb3IgKGxldCBuYW1lIGluIGF0dHJzKVxuICAgICAgICAgICAgaWYgKGF0dHJzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3BhY2UgPSBuYW1lLmluZGV4T2YoXCIgXCIpO1xuICAgICAgICAgICAgICAgIGlmIChzcGFjZSA+IDApXG4gICAgICAgICAgICAgICAgICAgIGRvbS5zZXRBdHRyaWJ1dGVOUyhuYW1lLnNsaWNlKDAsIHNwYWNlKSwgbmFtZS5zbGljZShzcGFjZSArIDEpLCBhdHRyc1tuYW1lXSk7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobmFtZSA9PSBcInN0eWxlXCIgJiYgZG9tLnN0eWxlKVxuICAgICAgICAgICAgICAgICAgICBkb20uc3R5bGUuY3NzVGV4dCA9IGF0dHJzW25hbWVdO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgZG9tLnNldEF0dHJpYnV0ZShuYW1lLCBhdHRyc1tuYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IHN0cnVjdHVyZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgY2hpbGQgPSBzdHJ1Y3R1cmVbaV07XG4gICAgICAgIGlmIChjaGlsZCA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKGkgPCBzdHJ1Y3R1cmUubGVuZ3RoIC0gMSB8fCBpID4gc3RhcnQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDb250ZW50IGhvbGUgbXVzdCBiZSB0aGUgb25seSBjaGlsZCBvZiBpdHMgcGFyZW50IG5vZGVcIik7XG4gICAgICAgICAgICByZXR1cm4geyBkb20sIGNvbnRlbnRET006IGRvbSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHsgZG9tOiBpbm5lciwgY29udGVudERPTTogaW5uZXJDb250ZW50IH0gPSByZW5kZXJTcGVjKGRvYywgY2hpbGQsIHhtbE5TLCBibG9ja0FycmF5c0luKTtcbiAgICAgICAgICAgIGRvbS5hcHBlbmRDaGlsZChpbm5lcik7XG4gICAgICAgICAgICBpZiAoaW5uZXJDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRET00pXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTXVsdGlwbGUgY29udGVudCBob2xlc1wiKTtcbiAgICAgICAgICAgICAgICBjb250ZW50RE9NID0gaW5uZXJDb250ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGRvbSwgY29udGVudERPTSB9O1xufVxuXG5leHBvcnQgeyBDb250ZW50TWF0Y2gsIERPTVBhcnNlciwgRE9NU2VyaWFsaXplciwgRnJhZ21lbnQsIE1hcmssIE1hcmtUeXBlLCBOb2RlLCBOb2RlUmFuZ2UsIE5vZGVUeXBlLCBSZXBsYWNlRXJyb3IsIFJlc29sdmVkUG9zLCBTY2hlbWEsIFNsaWNlIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prosemirror-model/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prosemirror-schema-list/dist/index.js":
/*!************************************************************!*\
  !*** ./node_modules/prosemirror-schema-list/dist/index.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addListNodes: function() { return /* binding */ addListNodes; },\n/* harmony export */   bulletList: function() { return /* binding */ bulletList; },\n/* harmony export */   liftListItem: function() { return /* binding */ liftListItem; },\n/* harmony export */   listItem: function() { return /* binding */ listItem; },\n/* harmony export */   orderedList: function() { return /* binding */ orderedList; },\n/* harmony export */   sinkListItem: function() { return /* binding */ sinkListItem; },\n/* harmony export */   splitListItem: function() { return /* binding */ splitListItem; },\n/* harmony export */   splitListItemKeepMarks: function() { return /* binding */ splitListItemKeepMarks; },\n/* harmony export */   wrapInList: function() { return /* binding */ wrapInList; },\n/* harmony export */   wrapRangeInList: function() { return /* binding */ wrapRangeInList; }\n/* harmony export */ });\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-transform */ \"(app-pages-browser)/./node_modules/prosemirror-transform/dist/index.js\");\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-model */ \"(app-pages-browser)/./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-state */ \"(app-pages-browser)/./node_modules/prosemirror-state/dist/index.js\");\n\n\n\n\nconst olDOM = [\"ol\", 0], ulDOM = [\"ul\", 0], liDOM = [\"li\", 0];\n/**\nAn ordered list [node spec](https://prosemirror.net/docs/ref/#model.NodeSpec). Has a single\nattribute, `order`, which determines the number at which the list\nstarts counting, and defaults to 1. Represented as an `<ol>`\nelement.\n*/\nconst orderedList = {\n    attrs: { order: { default: 1, validate: \"number\" } },\n    parseDOM: [{ tag: \"ol\", getAttrs(dom) {\n                return { order: dom.hasAttribute(\"start\") ? +dom.getAttribute(\"start\") : 1 };\n            } }],\n    toDOM(node) {\n        return node.attrs.order == 1 ? olDOM : [\"ol\", { start: node.attrs.order }, 0];\n    }\n};\n/**\nA bullet list node spec, represented in the DOM as `<ul>`.\n*/\nconst bulletList = {\n    parseDOM: [{ tag: \"ul\" }],\n    toDOM() { return ulDOM; }\n};\n/**\nA list item (`<li>`) spec.\n*/\nconst listItem = {\n    parseDOM: [{ tag: \"li\" }],\n    toDOM() { return liDOM; },\n    defining: true\n};\nfunction add(obj, props) {\n    let copy = {};\n    for (let prop in obj)\n        copy[prop] = obj[prop];\n    for (let prop in props)\n        copy[prop] = props[prop];\n    return copy;\n}\n/**\nConvenience function for adding list-related node types to a map\nspecifying the nodes for a schema. Adds\n[`orderedList`](https://prosemirror.net/docs/ref/#schema-list.orderedList) as `\"ordered_list\"`,\n[`bulletList`](https://prosemirror.net/docs/ref/#schema-list.bulletList) as `\"bullet_list\"`, and\n[`listItem`](https://prosemirror.net/docs/ref/#schema-list.listItem) as `\"list_item\"`.\n\n`itemContent` determines the content expression for the list items.\nIf you want the commands defined in this module to apply to your\nlist structure, it should have a shape like `\"paragraph block*\"` or\n`\"paragraph (ordered_list | bullet_list)*\"`. `listGroup` can be\ngiven to assign a group name to the list node types, for example\n`\"block\"`.\n*/\nfunction addListNodes(nodes, itemContent, listGroup) {\n    return nodes.append({\n        ordered_list: add(orderedList, { content: \"list_item+\", group: listGroup }),\n        bullet_list: add(bulletList, { content: \"list_item+\", group: listGroup }),\n        list_item: add(listItem, { content: itemContent })\n    });\n}\n/**\nReturns a command function that wraps the selection in a list with\nthe given type an attributes. If `dispatch` is null, only return a\nvalue to indicate whether this is possible, but don't actually\nperform the change.\n*/\nfunction wrapInList(listType, attrs = null) {\n    return function (state, dispatch) {\n        let { $from, $to } = state.selection;\n        let range = $from.blockRange($to);\n        if (!range)\n            return false;\n        let tr = dispatch ? state.tr : null;\n        if (!wrapRangeInList(tr, range, listType, attrs))\n            return false;\n        if (dispatch)\n            dispatch(tr.scrollIntoView());\n        return true;\n    };\n}\n/**\nTry to wrap the given node range in a list of the given type.\nReturn `true` when this is possible, `false` otherwise. When `tr`\nis non-null, the wrapping is added to that transaction. When it is\n`null`, the function only queries whether the wrapping is\npossible.\n*/\nfunction wrapRangeInList(tr, range, listType, attrs = null) {\n    let doJoin = false, outerRange = range, doc = range.$from.doc;\n    // This is at the top of an existing list item\n    if (range.depth >= 2 && range.$from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {\n        // Don't do anything if this is the top of the list\n        if (range.$from.index(range.depth - 1) == 0)\n            return false;\n        let $insert = doc.resolve(range.start - 2);\n        outerRange = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.NodeRange($insert, $insert, range.depth);\n        if (range.endIndex < range.parent.childCount)\n            range = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.NodeRange(range.$from, doc.resolve(range.$to.end(range.depth)), range.depth);\n        doJoin = true;\n    }\n    let wrap = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.findWrapping)(outerRange, listType, attrs, range);\n    if (!wrap)\n        return false;\n    if (tr)\n        doWrapInList(tr, range, wrap, doJoin, listType);\n    return true;\n}\nfunction doWrapInList(tr, range, wrappers, joinBefore, listType) {\n    let content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;\n    for (let i = wrappers.length - 1; i >= 0; i--)\n        content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));\n    tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(content, 0, 0), wrappers.length, true));\n    let found = 0;\n    for (let i = 0; i < wrappers.length; i++)\n        if (wrappers[i].type == listType)\n            found = i + 1;\n    let splitDepth = wrappers.length - found;\n    let splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent;\n    for (let i = range.startIndex, e = range.endIndex, first = true; i < e; i++, first = false) {\n        if (!first && (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.canSplit)(tr.doc, splitPos, splitDepth)) {\n            tr.split(splitPos, splitDepth);\n            splitPos += 2 * splitDepth;\n        }\n        splitPos += parent.child(i).nodeSize;\n    }\n    return tr;\n}\n/**\nBuild a command that splits a non-empty textblock at the top level\nof a list item by also splitting that list item.\n*/\nfunction splitListItem(itemType, itemAttrs) {\n    return function (state, dispatch) {\n        let { $from, $to, node } = state.selection;\n        if ((node && node.isBlock) || $from.depth < 2 || !$from.sameParent($to))\n            return false;\n        let grandParent = $from.node(-1);\n        if (grandParent.type != itemType)\n            return false;\n        if ($from.parent.content.size == 0 && $from.node(-1).childCount == $from.indexAfter(-1)) {\n            // In an empty block. If this is a nested list, the wrapping\n            // list item should be split. Otherwise, bail out and let next\n            // command handle lifting.\n            if ($from.depth == 3 || $from.node(-3).type != itemType ||\n                $from.index(-2) != $from.node(-2).childCount - 1)\n                return false;\n            if (dispatch) {\n                let wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;\n                let depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;\n                // Build a fragment containing empty versions of the structure\n                // from the outer list item to the parent node of the cursor\n                for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d--)\n                    wrap = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($from.node(d).copy(wrap));\n                let depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1\n                    : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;\n                // Add a second list item with an empty default start node\n                wrap = wrap.append(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(itemType.createAndFill()));\n                let start = $from.before($from.depth - (depthBefore - 1));\n                let tr = state.tr.replace(start, $from.after(-depthAfter), new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(wrap, 4 - depthBefore, 0));\n                let sel = -1;\n                tr.doc.nodesBetween(start, tr.doc.content.size, (node, pos) => {\n                    if (sel > -1)\n                        return false;\n                    if (node.isTextblock && node.content.size == 0)\n                        sel = pos + 1;\n                });\n                if (sel > -1)\n                    tr.setSelection(prosemirror_state__WEBPACK_IMPORTED_MODULE_2__.Selection.near(tr.doc.resolve(sel)));\n                dispatch(tr.scrollIntoView());\n            }\n            return true;\n        }\n        let nextType = $to.pos == $from.end() ? grandParent.contentMatchAt(0).defaultType : null;\n        let tr = state.tr.delete($from.pos, $to.pos);\n        let types = nextType ? [itemAttrs ? { type: itemType, attrs: itemAttrs } : null, { type: nextType }] : undefined;\n        if (!(0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.canSplit)(tr.doc, $from.pos, 2, types))\n            return false;\n        if (dispatch)\n            dispatch(tr.split($from.pos, 2, types).scrollIntoView());\n        return true;\n    };\n}\n/**\nActs like [`splitListItem`](https://prosemirror.net/docs/ref/#schema-list.splitListItem), but\nwithout resetting the set of active marks at the cursor.\n*/\nfunction splitListItemKeepMarks(itemType, itemAttrs) {\n    let split = splitListItem(itemType, itemAttrs);\n    return (state, dispatch) => {\n        return split(state, dispatch && (tr => {\n            let marks = state.storedMarks || (state.selection.$to.parentOffset && state.selection.$from.marks());\n            if (marks)\n                tr.ensureMarks(marks);\n            dispatch(tr);\n        }));\n    };\n}\n/**\nCreate a command to lift the list item around the selection up into\na wrapping list.\n*/\nfunction liftListItem(itemType) {\n    return function (state, dispatch) {\n        let { $from, $to } = state.selection;\n        let range = $from.blockRange($to, node => node.childCount > 0 && node.firstChild.type == itemType);\n        if (!range)\n            return false;\n        if (!dispatch)\n            return true;\n        if ($from.node(range.depth - 1).type == itemType) // Inside a parent list\n            return liftToOuterList(state, dispatch, itemType, range);\n        else // Outer list node\n            return liftOutOfList(state, dispatch, range);\n    };\n}\nfunction liftToOuterList(state, dispatch, itemType, range) {\n    let tr = state.tr, end = range.end, endOfList = range.$to.end(range.depth);\n    if (end < endOfList) {\n        // There are siblings after the lifted items, which must become\n        // children of the last item\n        tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.ReplaceAroundStep(end - 1, endOfList, end, endOfList, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));\n        range = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.NodeRange(tr.doc.resolve(range.$from.pos), tr.doc.resolve(endOfList), range.depth);\n    }\n    const target = (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.liftTarget)(range);\n    if (target == null)\n        return false;\n    tr.lift(range, target);\n    let $after = tr.doc.resolve(tr.mapping.map(end, -1) - 1);\n    if ((0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.canJoin)(tr.doc, $after.pos) && $after.nodeBefore.type == $after.nodeAfter.type)\n        tr.join($after.pos);\n    dispatch(tr.scrollIntoView());\n    return true;\n}\nfunction liftOutOfList(state, dispatch, range) {\n    let tr = state.tr, list = range.parent;\n    // Merge the list items into a single big item\n    for (let pos = range.end, i = range.endIndex - 1, e = range.startIndex; i > e; i--) {\n        pos -= list.child(i).nodeSize;\n        tr.delete(pos - 1, pos + 1);\n    }\n    let $start = tr.doc.resolve(range.start), item = $start.nodeAfter;\n    if (tr.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize)\n        return false;\n    let atStart = range.startIndex == 0, atEnd = range.endIndex == list.childCount;\n    let parent = $start.node(-1), indexBefore = $start.index(-1);\n    if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty : prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(list))))\n        return false;\n    let start = $start.pos, end = start + item.nodeSize;\n    // Strip off the surrounding list. At the sides where we're not at\n    // the end of the list, the existing list is closed. At sides where\n    // this is the end, it is overwritten to its end.\n    tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice((atStart ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty : prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(list.copy(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty)))\n        .append(atEnd ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty : prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(list.copy(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));\n    dispatch(tr.scrollIntoView());\n    return true;\n}\n/**\nCreate a command to sink the list item around the selection down\ninto an inner list.\n*/\nfunction sinkListItem(itemType) {\n    return function (state, dispatch) {\n        let { $from, $to } = state.selection;\n        let range = $from.blockRange($to, node => node.childCount > 0 && node.firstChild.type == itemType);\n        if (!range)\n            return false;\n        let startIndex = range.startIndex;\n        if (startIndex == 0)\n            return false;\n        let parent = range.parent, nodeBefore = parent.child(startIndex - 1);\n        if (nodeBefore.type != itemType)\n            return false;\n        if (dispatch) {\n            let nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;\n            let inner = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(nestedBefore ? itemType.create() : null);\n            let slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(itemType.create(null, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);\n            let before = range.start, after = range.end;\n            dispatch(state.tr.step(new prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice, 1, true))\n                .scrollIntoView());\n        }\n        return true;\n    };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1zY2hlbWEtbGlzdC9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBdUc7QUFDeEM7QUFDakI7O0FBRTlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVMsa0NBQWtDO0FBQ3hELGlCQUFpQjtBQUNqQix5QkFBeUI7QUFDekIsZUFBZTtBQUNmO0FBQ0Esd0RBQXdELHlCQUF5QjtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsV0FBVztBQUM1QixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixXQUFXO0FBQzVCLGNBQWMsZUFBZTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMseUNBQXlDO0FBQ2xGLHVDQUF1Qyx5Q0FBeUM7QUFDaEYsbUNBQW1DLHNCQUFzQjtBQUN6RCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsd0RBQVM7QUFDbEM7QUFDQSx3QkFBd0Isd0RBQVM7QUFDakM7QUFDQTtBQUNBLGVBQWUsbUVBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsdURBQVE7QUFDMUIsc0NBQXNDLFFBQVE7QUFDOUMsa0JBQWtCLHVEQUFRO0FBQzFCLGdCQUFnQixvRUFBaUIsNEVBQTRFLG9EQUFLO0FBQ2xIO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxPQUFPO0FBQzVFLHNCQUFzQiwrREFBUTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsbUJBQW1CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHVEQUFRO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxzQkFBc0I7QUFDOUUsMkJBQTJCLHVEQUFRO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx1REFBUTtBQUMzQztBQUNBLCtFQUErRSxvREFBSztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxvQ0FBb0Msd0RBQVM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLG1DQUFtQyxVQUFVLGdCQUFnQjtBQUMzRyxhQUFhLCtEQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9FQUFpQix5Q0FBeUMsb0RBQUssQ0FBQyx1REFBUTtBQUM1RixvQkFBb0Isd0RBQVM7QUFDN0I7QUFDQSxtQkFBbUIsaUVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDhEQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsT0FBTztBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUdBQXlHLHVEQUFRLFNBQVMsdURBQVE7QUFDbEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvRUFBaUIsMkVBQTJFLG9EQUFLLFlBQVksdURBQVEsU0FBUyx1REFBUSxnQkFBZ0IsdURBQVE7QUFDOUssd0JBQXdCLHVEQUFRLFNBQVMsdURBQVEsZ0JBQWdCLHVEQUFRO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsYUFBYTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHVEQUFRO0FBQ2hDLDRCQUE0QixvREFBSyxDQUFDLHVEQUFRLDRCQUE0Qix1REFBUTtBQUM5RTtBQUNBLHVDQUF1QyxvRUFBaUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMkoiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLXNjaGVtYS1saXN0L2Rpc3QvaW5kZXguanM/NGQ0ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBmaW5kV3JhcHBpbmcsIFJlcGxhY2VBcm91bmRTdGVwLCBjYW5TcGxpdCwgbGlmdFRhcmdldCwgY2FuSm9pbiB9IGZyb20gJ3Byb3NlbWlycm9yLXRyYW5zZm9ybSc7XG5pbXBvcnQgeyBOb2RlUmFuZ2UsIEZyYWdtZW50LCBTbGljZSB9IGZyb20gJ3Byb3NlbWlycm9yLW1vZGVsJztcbmltcG9ydCB7IFNlbGVjdGlvbiB9IGZyb20gJ3Byb3NlbWlycm9yLXN0YXRlJztcblxuY29uc3Qgb2xET00gPSBbXCJvbFwiLCAwXSwgdWxET00gPSBbXCJ1bFwiLCAwXSwgbGlET00gPSBbXCJsaVwiLCAwXTtcbi8qKlxuQW4gb3JkZXJlZCBsaXN0IFtub2RlIHNwZWNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYykuIEhhcyBhIHNpbmdsZVxuYXR0cmlidXRlLCBgb3JkZXJgLCB3aGljaCBkZXRlcm1pbmVzIHRoZSBudW1iZXIgYXQgd2hpY2ggdGhlIGxpc3RcbnN0YXJ0cyBjb3VudGluZywgYW5kIGRlZmF1bHRzIHRvIDEuIFJlcHJlc2VudGVkIGFzIGFuIGA8b2w+YFxuZWxlbWVudC5cbiovXG5jb25zdCBvcmRlcmVkTGlzdCA9IHtcbiAgICBhdHRyczogeyBvcmRlcjogeyBkZWZhdWx0OiAxLCB2YWxpZGF0ZTogXCJudW1iZXJcIiB9IH0sXG4gICAgcGFyc2VET006IFt7IHRhZzogXCJvbFwiLCBnZXRBdHRycyhkb20pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBvcmRlcjogZG9tLmhhc0F0dHJpYnV0ZShcInN0YXJ0XCIpID8gK2RvbS5nZXRBdHRyaWJ1dGUoXCJzdGFydFwiKSA6IDEgfTtcbiAgICAgICAgICAgIH0gfV0sXG4gICAgdG9ET00obm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZS5hdHRycy5vcmRlciA9PSAxID8gb2xET00gOiBbXCJvbFwiLCB7IHN0YXJ0OiBub2RlLmF0dHJzLm9yZGVyIH0sIDBdO1xuICAgIH1cbn07XG4vKipcbkEgYnVsbGV0IGxpc3Qgbm9kZSBzcGVjLCByZXByZXNlbnRlZCBpbiB0aGUgRE9NIGFzIGA8dWw+YC5cbiovXG5jb25zdCBidWxsZXRMaXN0ID0ge1xuICAgIHBhcnNlRE9NOiBbeyB0YWc6IFwidWxcIiB9XSxcbiAgICB0b0RPTSgpIHsgcmV0dXJuIHVsRE9NOyB9XG59O1xuLyoqXG5BIGxpc3QgaXRlbSAoYDxsaT5gKSBzcGVjLlxuKi9cbmNvbnN0IGxpc3RJdGVtID0ge1xuICAgIHBhcnNlRE9NOiBbeyB0YWc6IFwibGlcIiB9XSxcbiAgICB0b0RPTSgpIHsgcmV0dXJuIGxpRE9NOyB9LFxuICAgIGRlZmluaW5nOiB0cnVlXG59O1xuZnVuY3Rpb24gYWRkKG9iaiwgcHJvcHMpIHtcbiAgICBsZXQgY29weSA9IHt9O1xuICAgIGZvciAobGV0IHByb3AgaW4gb2JqKVxuICAgICAgICBjb3B5W3Byb3BdID0gb2JqW3Byb3BdO1xuICAgIGZvciAobGV0IHByb3AgaW4gcHJvcHMpXG4gICAgICAgIGNvcHlbcHJvcF0gPSBwcm9wc1twcm9wXTtcbiAgICByZXR1cm4gY29weTtcbn1cbi8qKlxuQ29udmVuaWVuY2UgZnVuY3Rpb24gZm9yIGFkZGluZyBsaXN0LXJlbGF0ZWQgbm9kZSB0eXBlcyB0byBhIG1hcFxuc3BlY2lmeWluZyB0aGUgbm9kZXMgZm9yIGEgc2NoZW1hLiBBZGRzXG5bYG9yZGVyZWRMaXN0YF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3NjaGVtYS1saXN0Lm9yZGVyZWRMaXN0KSBhcyBgXCJvcmRlcmVkX2xpc3RcImAsXG5bYGJ1bGxldExpc3RgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc2NoZW1hLWxpc3QuYnVsbGV0TGlzdCkgYXMgYFwiYnVsbGV0X2xpc3RcImAsIGFuZFxuW2BsaXN0SXRlbWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzY2hlbWEtbGlzdC5saXN0SXRlbSkgYXMgYFwibGlzdF9pdGVtXCJgLlxuXG5gaXRlbUNvbnRlbnRgIGRldGVybWluZXMgdGhlIGNvbnRlbnQgZXhwcmVzc2lvbiBmb3IgdGhlIGxpc3QgaXRlbXMuXG5JZiB5b3Ugd2FudCB0aGUgY29tbWFuZHMgZGVmaW5lZCBpbiB0aGlzIG1vZHVsZSB0byBhcHBseSB0byB5b3VyXG5saXN0IHN0cnVjdHVyZSwgaXQgc2hvdWxkIGhhdmUgYSBzaGFwZSBsaWtlIGBcInBhcmFncmFwaCBibG9jaypcImAgb3JcbmBcInBhcmFncmFwaCAob3JkZXJlZF9saXN0IHwgYnVsbGV0X2xpc3QpKlwiYC4gYGxpc3RHcm91cGAgY2FuIGJlXG5naXZlbiB0byBhc3NpZ24gYSBncm91cCBuYW1lIHRvIHRoZSBsaXN0IG5vZGUgdHlwZXMsIGZvciBleGFtcGxlXG5gXCJibG9ja1wiYC5cbiovXG5mdW5jdGlvbiBhZGRMaXN0Tm9kZXMobm9kZXMsIGl0ZW1Db250ZW50LCBsaXN0R3JvdXApIHtcbiAgICByZXR1cm4gbm9kZXMuYXBwZW5kKHtcbiAgICAgICAgb3JkZXJlZF9saXN0OiBhZGQob3JkZXJlZExpc3QsIHsgY29udGVudDogXCJsaXN0X2l0ZW0rXCIsIGdyb3VwOiBsaXN0R3JvdXAgfSksXG4gICAgICAgIGJ1bGxldF9saXN0OiBhZGQoYnVsbGV0TGlzdCwgeyBjb250ZW50OiBcImxpc3RfaXRlbStcIiwgZ3JvdXA6IGxpc3RHcm91cCB9KSxcbiAgICAgICAgbGlzdF9pdGVtOiBhZGQobGlzdEl0ZW0sIHsgY29udGVudDogaXRlbUNvbnRlbnQgfSlcbiAgICB9KTtcbn1cbi8qKlxuUmV0dXJucyBhIGNvbW1hbmQgZnVuY3Rpb24gdGhhdCB3cmFwcyB0aGUgc2VsZWN0aW9uIGluIGEgbGlzdCB3aXRoXG50aGUgZ2l2ZW4gdHlwZSBhbiBhdHRyaWJ1dGVzLiBJZiBgZGlzcGF0Y2hgIGlzIG51bGwsIG9ubHkgcmV0dXJuIGFcbnZhbHVlIHRvIGluZGljYXRlIHdoZXRoZXIgdGhpcyBpcyBwb3NzaWJsZSwgYnV0IGRvbid0IGFjdHVhbGx5XG5wZXJmb3JtIHRoZSBjaGFuZ2UuXG4qL1xuZnVuY3Rpb24gd3JhcEluTGlzdChsaXN0VHlwZSwgYXR0cnMgPSBudWxsKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzdGF0ZSwgZGlzcGF0Y2gpIHtcbiAgICAgICAgbGV0IHsgJGZyb20sICR0byB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBsZXQgcmFuZ2UgPSAkZnJvbS5ibG9ja1JhbmdlKCR0byk7XG4gICAgICAgIGlmICghcmFuZ2UpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCB0ciA9IGRpc3BhdGNoID8gc3RhdGUudHIgOiBudWxsO1xuICAgICAgICBpZiAoIXdyYXBSYW5nZUluTGlzdCh0ciwgcmFuZ2UsIGxpc3RUeXBlLCBhdHRycykpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChkaXNwYXRjaClcbiAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuLyoqXG5UcnkgdG8gd3JhcCB0aGUgZ2l2ZW4gbm9kZSByYW5nZSBpbiBhIGxpc3Qgb2YgdGhlIGdpdmVuIHR5cGUuXG5SZXR1cm4gYHRydWVgIHdoZW4gdGhpcyBpcyBwb3NzaWJsZSwgYGZhbHNlYCBvdGhlcndpc2UuIFdoZW4gYHRyYFxuaXMgbm9uLW51bGwsIHRoZSB3cmFwcGluZyBpcyBhZGRlZCB0byB0aGF0IHRyYW5zYWN0aW9uLiBXaGVuIGl0IGlzXG5gbnVsbGAsIHRoZSBmdW5jdGlvbiBvbmx5IHF1ZXJpZXMgd2hldGhlciB0aGUgd3JhcHBpbmcgaXNcbnBvc3NpYmxlLlxuKi9cbmZ1bmN0aW9uIHdyYXBSYW5nZUluTGlzdCh0ciwgcmFuZ2UsIGxpc3RUeXBlLCBhdHRycyA9IG51bGwpIHtcbiAgICBsZXQgZG9Kb2luID0gZmFsc2UsIG91dGVyUmFuZ2UgPSByYW5nZSwgZG9jID0gcmFuZ2UuJGZyb20uZG9jO1xuICAgIC8vIFRoaXMgaXMgYXQgdGhlIHRvcCBvZiBhbiBleGlzdGluZyBsaXN0IGl0ZW1cbiAgICBpZiAocmFuZ2UuZGVwdGggPj0gMiAmJiByYW5nZS4kZnJvbS5ub2RlKHJhbmdlLmRlcHRoIC0gMSkudHlwZS5jb21wYXRpYmxlQ29udGVudChsaXN0VHlwZSkgJiYgcmFuZ2Uuc3RhcnRJbmRleCA9PSAwKSB7XG4gICAgICAgIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIHRoaXMgaXMgdGhlIHRvcCBvZiB0aGUgbGlzdFxuICAgICAgICBpZiAocmFuZ2UuJGZyb20uaW5kZXgocmFuZ2UuZGVwdGggLSAxKSA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgJGluc2VydCA9IGRvYy5yZXNvbHZlKHJhbmdlLnN0YXJ0IC0gMik7XG4gICAgICAgIG91dGVyUmFuZ2UgPSBuZXcgTm9kZVJhbmdlKCRpbnNlcnQsICRpbnNlcnQsIHJhbmdlLmRlcHRoKTtcbiAgICAgICAgaWYgKHJhbmdlLmVuZEluZGV4IDwgcmFuZ2UucGFyZW50LmNoaWxkQ291bnQpXG4gICAgICAgICAgICByYW5nZSA9IG5ldyBOb2RlUmFuZ2UocmFuZ2UuJGZyb20sIGRvYy5yZXNvbHZlKHJhbmdlLiR0by5lbmQocmFuZ2UuZGVwdGgpKSwgcmFuZ2UuZGVwdGgpO1xuICAgICAgICBkb0pvaW4gPSB0cnVlO1xuICAgIH1cbiAgICBsZXQgd3JhcCA9IGZpbmRXcmFwcGluZyhvdXRlclJhbmdlLCBsaXN0VHlwZSwgYXR0cnMsIHJhbmdlKTtcbiAgICBpZiAoIXdyYXApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAodHIpXG4gICAgICAgIGRvV3JhcEluTGlzdCh0ciwgcmFuZ2UsIHdyYXAsIGRvSm9pbiwgbGlzdFR5cGUpO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZG9XcmFwSW5MaXN0KHRyLCByYW5nZSwgd3JhcHBlcnMsIGpvaW5CZWZvcmUsIGxpc3RUeXBlKSB7XG4gICAgbGV0IGNvbnRlbnQgPSBGcmFnbWVudC5lbXB0eTtcbiAgICBmb3IgKGxldCBpID0gd3JhcHBlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIGNvbnRlbnQgPSBGcmFnbWVudC5mcm9tKHdyYXBwZXJzW2ldLnR5cGUuY3JlYXRlKHdyYXBwZXJzW2ldLmF0dHJzLCBjb250ZW50KSk7XG4gICAgdHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAocmFuZ2Uuc3RhcnQgLSAoam9pbkJlZm9yZSA/IDIgOiAwKSwgcmFuZ2UuZW5kLCByYW5nZS5zdGFydCwgcmFuZ2UuZW5kLCBuZXcgU2xpY2UoY29udGVudCwgMCwgMCksIHdyYXBwZXJzLmxlbmd0aCwgdHJ1ZSkpO1xuICAgIGxldCBmb3VuZCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3cmFwcGVycy5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKHdyYXBwZXJzW2ldLnR5cGUgPT0gbGlzdFR5cGUpXG4gICAgICAgICAgICBmb3VuZCA9IGkgKyAxO1xuICAgIGxldCBzcGxpdERlcHRoID0gd3JhcHBlcnMubGVuZ3RoIC0gZm91bmQ7XG4gICAgbGV0IHNwbGl0UG9zID0gcmFuZ2Uuc3RhcnQgKyB3cmFwcGVycy5sZW5ndGggLSAoam9pbkJlZm9yZSA/IDIgOiAwKSwgcGFyZW50ID0gcmFuZ2UucGFyZW50O1xuICAgIGZvciAobGV0IGkgPSByYW5nZS5zdGFydEluZGV4LCBlID0gcmFuZ2UuZW5kSW5kZXgsIGZpcnN0ID0gdHJ1ZTsgaSA8IGU7IGkrKywgZmlyc3QgPSBmYWxzZSkge1xuICAgICAgICBpZiAoIWZpcnN0ICYmIGNhblNwbGl0KHRyLmRvYywgc3BsaXRQb3MsIHNwbGl0RGVwdGgpKSB7XG4gICAgICAgICAgICB0ci5zcGxpdChzcGxpdFBvcywgc3BsaXREZXB0aCk7XG4gICAgICAgICAgICBzcGxpdFBvcyArPSAyICogc3BsaXREZXB0aDtcbiAgICAgICAgfVxuICAgICAgICBzcGxpdFBvcyArPSBwYXJlbnQuY2hpbGQoaSkubm9kZVNpemU7XG4gICAgfVxuICAgIHJldHVybiB0cjtcbn1cbi8qKlxuQnVpbGQgYSBjb21tYW5kIHRoYXQgc3BsaXRzIGEgbm9uLWVtcHR5IHRleHRibG9jayBhdCB0aGUgdG9wIGxldmVsXG5vZiBhIGxpc3QgaXRlbSBieSBhbHNvIHNwbGl0dGluZyB0aGF0IGxpc3QgaXRlbS5cbiovXG5mdW5jdGlvbiBzcGxpdExpc3RJdGVtKGl0ZW1UeXBlLCBpdGVtQXR0cnMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICBsZXQgeyAkZnJvbSwgJHRvLCBub2RlIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGlmICgobm9kZSAmJiBub2RlLmlzQmxvY2spIHx8ICRmcm9tLmRlcHRoIDwgMiB8fCAhJGZyb20uc2FtZVBhcmVudCgkdG8pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgZ3JhbmRQYXJlbnQgPSAkZnJvbS5ub2RlKC0xKTtcbiAgICAgICAgaWYgKGdyYW5kUGFyZW50LnR5cGUgIT0gaXRlbVR5cGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICgkZnJvbS5wYXJlbnQuY29udGVudC5zaXplID09IDAgJiYgJGZyb20ubm9kZSgtMSkuY2hpbGRDb3VudCA9PSAkZnJvbS5pbmRleEFmdGVyKC0xKSkge1xuICAgICAgICAgICAgLy8gSW4gYW4gZW1wdHkgYmxvY2suIElmIHRoaXMgaXMgYSBuZXN0ZWQgbGlzdCwgdGhlIHdyYXBwaW5nXG4gICAgICAgICAgICAvLyBsaXN0IGl0ZW0gc2hvdWxkIGJlIHNwbGl0LiBPdGhlcndpc2UsIGJhaWwgb3V0IGFuZCBsZXQgbmV4dFxuICAgICAgICAgICAgLy8gY29tbWFuZCBoYW5kbGUgbGlmdGluZy5cbiAgICAgICAgICAgIGlmICgkZnJvbS5kZXB0aCA9PSAzIHx8ICRmcm9tLm5vZGUoLTMpLnR5cGUgIT0gaXRlbVR5cGUgfHxcbiAgICAgICAgICAgICAgICAkZnJvbS5pbmRleCgtMikgIT0gJGZyb20ubm9kZSgtMikuY2hpbGRDb3VudCAtIDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKGRpc3BhdGNoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHdyYXAgPSBGcmFnbWVudC5lbXB0eTtcbiAgICAgICAgICAgICAgICBsZXQgZGVwdGhCZWZvcmUgPSAkZnJvbS5pbmRleCgtMSkgPyAxIDogJGZyb20uaW5kZXgoLTIpID8gMiA6IDM7XG4gICAgICAgICAgICAgICAgLy8gQnVpbGQgYSBmcmFnbWVudCBjb250YWluaW5nIGVtcHR5IHZlcnNpb25zIG9mIHRoZSBzdHJ1Y3R1cmVcbiAgICAgICAgICAgICAgICAvLyBmcm9tIHRoZSBvdXRlciBsaXN0IGl0ZW0gdG8gdGhlIHBhcmVudCBub2RlIG9mIHRoZSBjdXJzb3JcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBkID0gJGZyb20uZGVwdGggLSBkZXB0aEJlZm9yZTsgZCA+PSAkZnJvbS5kZXB0aCAtIDM7IGQtLSlcbiAgICAgICAgICAgICAgICAgICAgd3JhcCA9IEZyYWdtZW50LmZyb20oJGZyb20ubm9kZShkKS5jb3B5KHdyYXApKTtcbiAgICAgICAgICAgICAgICBsZXQgZGVwdGhBZnRlciA9ICRmcm9tLmluZGV4QWZ0ZXIoLTEpIDwgJGZyb20ubm9kZSgtMikuY2hpbGRDb3VudCA/IDFcbiAgICAgICAgICAgICAgICAgICAgOiAkZnJvbS5pbmRleEFmdGVyKC0yKSA8ICRmcm9tLm5vZGUoLTMpLmNoaWxkQ291bnQgPyAyIDogMztcbiAgICAgICAgICAgICAgICAvLyBBZGQgYSBzZWNvbmQgbGlzdCBpdGVtIHdpdGggYW4gZW1wdHkgZGVmYXVsdCBzdGFydCBub2RlXG4gICAgICAgICAgICAgICAgd3JhcCA9IHdyYXAuYXBwZW5kKEZyYWdtZW50LmZyb20oaXRlbVR5cGUuY3JlYXRlQW5kRmlsbCgpKSk7XG4gICAgICAgICAgICAgICAgbGV0IHN0YXJ0ID0gJGZyb20uYmVmb3JlKCRmcm9tLmRlcHRoIC0gKGRlcHRoQmVmb3JlIC0gMSkpO1xuICAgICAgICAgICAgICAgIGxldCB0ciA9IHN0YXRlLnRyLnJlcGxhY2Uoc3RhcnQsICRmcm9tLmFmdGVyKC1kZXB0aEFmdGVyKSwgbmV3IFNsaWNlKHdyYXAsIDQgLSBkZXB0aEJlZm9yZSwgMCkpO1xuICAgICAgICAgICAgICAgIGxldCBzZWwgPSAtMTtcbiAgICAgICAgICAgICAgICB0ci5kb2Mubm9kZXNCZXR3ZWVuKHN0YXJ0LCB0ci5kb2MuY29udGVudC5zaXplLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWwgPiAtMSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuaXNUZXh0YmxvY2sgJiYgbm9kZS5jb250ZW50LnNpemUgPT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbCA9IHBvcyArIDE7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbCA+IC0xKVxuICAgICAgICAgICAgICAgICAgICB0ci5zZXRTZWxlY3Rpb24oU2VsZWN0aW9uLm5lYXIodHIuZG9jLnJlc29sdmUoc2VsKSkpO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5leHRUeXBlID0gJHRvLnBvcyA9PSAkZnJvbS5lbmQoKSA/IGdyYW5kUGFyZW50LmNvbnRlbnRNYXRjaEF0KDApLmRlZmF1bHRUeXBlIDogbnVsbDtcbiAgICAgICAgbGV0IHRyID0gc3RhdGUudHIuZGVsZXRlKCRmcm9tLnBvcywgJHRvLnBvcyk7XG4gICAgICAgIGxldCB0eXBlcyA9IG5leHRUeXBlID8gW2l0ZW1BdHRycyA/IHsgdHlwZTogaXRlbVR5cGUsIGF0dHJzOiBpdGVtQXR0cnMgfSA6IG51bGwsIHsgdHlwZTogbmV4dFR5cGUgfV0gOiB1bmRlZmluZWQ7XG4gICAgICAgIGlmICghY2FuU3BsaXQodHIuZG9jLCAkZnJvbS5wb3MsIDIsIHR5cGVzKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGRpc3BhdGNoKVxuICAgICAgICAgICAgZGlzcGF0Y2godHIuc3BsaXQoJGZyb20ucG9zLCAyLCB0eXBlcykuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG4vKipcbkFjdHMgbGlrZSBbYHNwbGl0TGlzdEl0ZW1gXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc2NoZW1hLWxpc3Quc3BsaXRMaXN0SXRlbSksIGJ1dFxud2l0aG91dCByZXNldHRpbmcgdGhlIHNldCBvZiBhY3RpdmUgbWFya3MgYXQgdGhlIGN1cnNvci5cbiovXG5mdW5jdGlvbiBzcGxpdExpc3RJdGVtS2VlcE1hcmtzKGl0ZW1UeXBlLCBpdGVtQXR0cnMpIHtcbiAgICBsZXQgc3BsaXQgPSBzcGxpdExpc3RJdGVtKGl0ZW1UeXBlLCBpdGVtQXR0cnMpO1xuICAgIHJldHVybiAoc3RhdGUsIGRpc3BhdGNoKSA9PiB7XG4gICAgICAgIHJldHVybiBzcGxpdChzdGF0ZSwgZGlzcGF0Y2ggJiYgKHRyID0+IHtcbiAgICAgICAgICAgIGxldCBtYXJrcyA9IHN0YXRlLnN0b3JlZE1hcmtzIHx8IChzdGF0ZS5zZWxlY3Rpb24uJHRvLnBhcmVudE9mZnNldCAmJiBzdGF0ZS5zZWxlY3Rpb24uJGZyb20ubWFya3MoKSk7XG4gICAgICAgICAgICBpZiAobWFya3MpXG4gICAgICAgICAgICAgICAgdHIuZW5zdXJlTWFya3MobWFya3MpO1xuICAgICAgICAgICAgZGlzcGF0Y2godHIpO1xuICAgICAgICB9KSk7XG4gICAgfTtcbn1cbi8qKlxuQ3JlYXRlIGEgY29tbWFuZCB0byBsaWZ0IHRoZSBsaXN0IGl0ZW0gYXJvdW5kIHRoZSBzZWxlY3Rpb24gdXAgaW50b1xuYSB3cmFwcGluZyBsaXN0LlxuKi9cbmZ1bmN0aW9uIGxpZnRMaXN0SXRlbShpdGVtVHlwZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoc3RhdGUsIGRpc3BhdGNoKSB7XG4gICAgICAgIGxldCB7ICRmcm9tLCAkdG8gfSA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgbGV0IHJhbmdlID0gJGZyb20uYmxvY2tSYW5nZSgkdG8sIG5vZGUgPT4gbm9kZS5jaGlsZENvdW50ID4gMCAmJiBub2RlLmZpcnN0Q2hpbGQudHlwZSA9PSBpdGVtVHlwZSk7XG4gICAgICAgIGlmICghcmFuZ2UpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghZGlzcGF0Y2gpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKCRmcm9tLm5vZGUocmFuZ2UuZGVwdGggLSAxKS50eXBlID09IGl0ZW1UeXBlKSAvLyBJbnNpZGUgYSBwYXJlbnQgbGlzdFxuICAgICAgICAgICAgcmV0dXJuIGxpZnRUb091dGVyTGlzdChzdGF0ZSwgZGlzcGF0Y2gsIGl0ZW1UeXBlLCByYW5nZSk7XG4gICAgICAgIGVsc2UgLy8gT3V0ZXIgbGlzdCBub2RlXG4gICAgICAgICAgICByZXR1cm4gbGlmdE91dE9mTGlzdChzdGF0ZSwgZGlzcGF0Y2gsIHJhbmdlKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gbGlmdFRvT3V0ZXJMaXN0KHN0YXRlLCBkaXNwYXRjaCwgaXRlbVR5cGUsIHJhbmdlKSB7XG4gICAgbGV0IHRyID0gc3RhdGUudHIsIGVuZCA9IHJhbmdlLmVuZCwgZW5kT2ZMaXN0ID0gcmFuZ2UuJHRvLmVuZChyYW5nZS5kZXB0aCk7XG4gICAgaWYgKGVuZCA8IGVuZE9mTGlzdCkge1xuICAgICAgICAvLyBUaGVyZSBhcmUgc2libGluZ3MgYWZ0ZXIgdGhlIGxpZnRlZCBpdGVtcywgd2hpY2ggbXVzdCBiZWNvbWVcbiAgICAgICAgLy8gY2hpbGRyZW4gb2YgdGhlIGxhc3QgaXRlbVxuICAgICAgICB0ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcChlbmQgLSAxLCBlbmRPZkxpc3QsIGVuZCwgZW5kT2ZMaXN0LCBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbShpdGVtVHlwZS5jcmVhdGUobnVsbCwgcmFuZ2UucGFyZW50LmNvcHkoKSkpLCAxLCAwKSwgMSwgdHJ1ZSkpO1xuICAgICAgICByYW5nZSA9IG5ldyBOb2RlUmFuZ2UodHIuZG9jLnJlc29sdmUocmFuZ2UuJGZyb20ucG9zKSwgdHIuZG9jLnJlc29sdmUoZW5kT2ZMaXN0KSwgcmFuZ2UuZGVwdGgpO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXQgPSBsaWZ0VGFyZ2V0KHJhbmdlKTtcbiAgICBpZiAodGFyZ2V0ID09IG51bGwpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB0ci5saWZ0KHJhbmdlLCB0YXJnZXQpO1xuICAgIGxldCAkYWZ0ZXIgPSB0ci5kb2MucmVzb2x2ZSh0ci5tYXBwaW5nLm1hcChlbmQsIC0xKSAtIDEpO1xuICAgIGlmIChjYW5Kb2luKHRyLmRvYywgJGFmdGVyLnBvcykgJiYgJGFmdGVyLm5vZGVCZWZvcmUudHlwZSA9PSAkYWZ0ZXIubm9kZUFmdGVyLnR5cGUpXG4gICAgICAgIHRyLmpvaW4oJGFmdGVyLnBvcyk7XG4gICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBsaWZ0T3V0T2ZMaXN0KHN0YXRlLCBkaXNwYXRjaCwgcmFuZ2UpIHtcbiAgICBsZXQgdHIgPSBzdGF0ZS50ciwgbGlzdCA9IHJhbmdlLnBhcmVudDtcbiAgICAvLyBNZXJnZSB0aGUgbGlzdCBpdGVtcyBpbnRvIGEgc2luZ2xlIGJpZyBpdGVtXG4gICAgZm9yIChsZXQgcG9zID0gcmFuZ2UuZW5kLCBpID0gcmFuZ2UuZW5kSW5kZXggLSAxLCBlID0gcmFuZ2Uuc3RhcnRJbmRleDsgaSA+IGU7IGktLSkge1xuICAgICAgICBwb3MgLT0gbGlzdC5jaGlsZChpKS5ub2RlU2l6ZTtcbiAgICAgICAgdHIuZGVsZXRlKHBvcyAtIDEsIHBvcyArIDEpO1xuICAgIH1cbiAgICBsZXQgJHN0YXJ0ID0gdHIuZG9jLnJlc29sdmUocmFuZ2Uuc3RhcnQpLCBpdGVtID0gJHN0YXJ0Lm5vZGVBZnRlcjtcbiAgICBpZiAodHIubWFwcGluZy5tYXAocmFuZ2UuZW5kKSAhPSByYW5nZS5zdGFydCArICRzdGFydC5ub2RlQWZ0ZXIubm9kZVNpemUpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgYXRTdGFydCA9IHJhbmdlLnN0YXJ0SW5kZXggPT0gMCwgYXRFbmQgPSByYW5nZS5lbmRJbmRleCA9PSBsaXN0LmNoaWxkQ291bnQ7XG4gICAgbGV0IHBhcmVudCA9ICRzdGFydC5ub2RlKC0xKSwgaW5kZXhCZWZvcmUgPSAkc3RhcnQuaW5kZXgoLTEpO1xuICAgIGlmICghcGFyZW50LmNhblJlcGxhY2UoaW5kZXhCZWZvcmUgKyAoYXRTdGFydCA/IDAgOiAxKSwgaW5kZXhCZWZvcmUgKyAxLCBpdGVtLmNvbnRlbnQuYXBwZW5kKGF0RW5kID8gRnJhZ21lbnQuZW1wdHkgOiBGcmFnbWVudC5mcm9tKGxpc3QpKSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgc3RhcnQgPSAkc3RhcnQucG9zLCBlbmQgPSBzdGFydCArIGl0ZW0ubm9kZVNpemU7XG4gICAgLy8gU3RyaXAgb2ZmIHRoZSBzdXJyb3VuZGluZyBsaXN0LiBBdCB0aGUgc2lkZXMgd2hlcmUgd2UncmUgbm90IGF0XG4gICAgLy8gdGhlIGVuZCBvZiB0aGUgbGlzdCwgdGhlIGV4aXN0aW5nIGxpc3QgaXMgY2xvc2VkLiBBdCBzaWRlcyB3aGVyZVxuICAgIC8vIHRoaXMgaXMgdGhlIGVuZCwgaXQgaXMgb3ZlcndyaXR0ZW4gdG8gaXRzIGVuZC5cbiAgICB0ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcChzdGFydCAtIChhdFN0YXJ0ID8gMSA6IDApLCBlbmQgKyAoYXRFbmQgPyAxIDogMCksIHN0YXJ0ICsgMSwgZW5kIC0gMSwgbmV3IFNsaWNlKChhdFN0YXJ0ID8gRnJhZ21lbnQuZW1wdHkgOiBGcmFnbWVudC5mcm9tKGxpc3QuY29weShGcmFnbWVudC5lbXB0eSkpKVxuICAgICAgICAuYXBwZW5kKGF0RW5kID8gRnJhZ21lbnQuZW1wdHkgOiBGcmFnbWVudC5mcm9tKGxpc3QuY29weShGcmFnbWVudC5lbXB0eSkpKSwgYXRTdGFydCA/IDAgOiAxLCBhdEVuZCA/IDAgOiAxKSwgYXRTdGFydCA/IDAgOiAxKSk7XG4gICAgZGlzcGF0Y2godHIuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbkNyZWF0ZSBhIGNvbW1hbmQgdG8gc2luayB0aGUgbGlzdCBpdGVtIGFyb3VuZCB0aGUgc2VsZWN0aW9uIGRvd25cbmludG8gYW4gaW5uZXIgbGlzdC5cbiovXG5mdW5jdGlvbiBzaW5rTGlzdEl0ZW0oaXRlbVR5cGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlLCBkaXNwYXRjaCkge1xuICAgICAgICBsZXQgeyAkZnJvbSwgJHRvIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGxldCByYW5nZSA9ICRmcm9tLmJsb2NrUmFuZ2UoJHRvLCBub2RlID0+IG5vZGUuY2hpbGRDb3VudCA+IDAgJiYgbm9kZS5maXJzdENoaWxkLnR5cGUgPT0gaXRlbVR5cGUpO1xuICAgICAgICBpZiAoIXJhbmdlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgc3RhcnRJbmRleCA9IHJhbmdlLnN0YXJ0SW5kZXg7XG4gICAgICAgIGlmIChzdGFydEluZGV4ID09IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCBwYXJlbnQgPSByYW5nZS5wYXJlbnQsIG5vZGVCZWZvcmUgPSBwYXJlbnQuY2hpbGQoc3RhcnRJbmRleCAtIDEpO1xuICAgICAgICBpZiAobm9kZUJlZm9yZS50eXBlICE9IGl0ZW1UeXBlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZGlzcGF0Y2gpIHtcbiAgICAgICAgICAgIGxldCBuZXN0ZWRCZWZvcmUgPSBub2RlQmVmb3JlLmxhc3RDaGlsZCAmJiBub2RlQmVmb3JlLmxhc3RDaGlsZC50eXBlID09IHBhcmVudC50eXBlO1xuICAgICAgICAgICAgbGV0IGlubmVyID0gRnJhZ21lbnQuZnJvbShuZXN0ZWRCZWZvcmUgPyBpdGVtVHlwZS5jcmVhdGUoKSA6IG51bGwpO1xuICAgICAgICAgICAgbGV0IHNsaWNlID0gbmV3IFNsaWNlKEZyYWdtZW50LmZyb20oaXRlbVR5cGUuY3JlYXRlKG51bGwsIEZyYWdtZW50LmZyb20ocGFyZW50LnR5cGUuY3JlYXRlKG51bGwsIGlubmVyKSkpKSwgbmVzdGVkQmVmb3JlID8gMyA6IDEsIDApO1xuICAgICAgICAgICAgbGV0IGJlZm9yZSA9IHJhbmdlLnN0YXJ0LCBhZnRlciA9IHJhbmdlLmVuZDtcbiAgICAgICAgICAgIGRpc3BhdGNoKHN0YXRlLnRyLnN0ZXAobmV3IFJlcGxhY2VBcm91bmRTdGVwKGJlZm9yZSAtIChuZXN0ZWRCZWZvcmUgPyAzIDogMSksIGFmdGVyLCBiZWZvcmUsIGFmdGVyLCBzbGljZSwgMSwgdHJ1ZSkpXG4gICAgICAgICAgICAgICAgLnNjcm9sbEludG9WaWV3KCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG59XG5cbmV4cG9ydCB7IGFkZExpc3ROb2RlcywgYnVsbGV0TGlzdCwgbGlmdExpc3RJdGVtLCBsaXN0SXRlbSwgb3JkZXJlZExpc3QsIHNpbmtMaXN0SXRlbSwgc3BsaXRMaXN0SXRlbSwgc3BsaXRMaXN0SXRlbUtlZXBNYXJrcywgd3JhcEluTGlzdCwgd3JhcFJhbmdlSW5MaXN0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prosemirror-schema-list/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prosemirror-state/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/prosemirror-state/dist/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AllSelection: function() { return /* binding */ AllSelection; },\n/* harmony export */   EditorState: function() { return /* binding */ EditorState; },\n/* harmony export */   NodeSelection: function() { return /* binding */ NodeSelection; },\n/* harmony export */   Plugin: function() { return /* binding */ Plugin; },\n/* harmony export */   PluginKey: function() { return /* binding */ PluginKey; },\n/* harmony export */   Selection: function() { return /* binding */ Selection; },\n/* harmony export */   SelectionRange: function() { return /* binding */ SelectionRange; },\n/* harmony export */   TextSelection: function() { return /* binding */ TextSelection; },\n/* harmony export */   Transaction: function() { return /* binding */ Transaction; }\n/* harmony export */ });\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-model */ \"(app-pages-browser)/./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-transform */ \"(app-pages-browser)/./node_modules/prosemirror-transform/dist/index.js\");\n\n\n\nconst classesById = Object.create(null);\n/**\nSuperclass for editor selections. Every selection type should\nextend this. Should not be instantiated directly.\n*/\nclass Selection {\n    /**\n    Initialize a selection with the head and anchor and ranges. If no\n    ranges are given, constructs a single range across `$anchor` and\n    `$head`.\n    */\n    constructor(\n    /**\n    The resolved anchor of the selection (the side that stays in\n    place when the selection is modified).\n    */\n    $anchor, \n    /**\n    The resolved head of the selection (the side that moves when\n    the selection is modified).\n    */\n    $head, ranges) {\n        this.$anchor = $anchor;\n        this.$head = $head;\n        this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];\n    }\n    /**\n    The selection's anchor, as an unresolved position.\n    */\n    get anchor() { return this.$anchor.pos; }\n    /**\n    The selection's head.\n    */\n    get head() { return this.$head.pos; }\n    /**\n    The lower bound of the selection's main range.\n    */\n    get from() { return this.$from.pos; }\n    /**\n    The upper bound of the selection's main range.\n    */\n    get to() { return this.$to.pos; }\n    /**\n    The resolved lower  bound of the selection's main range.\n    */\n    get $from() {\n        return this.ranges[0].$from;\n    }\n    /**\n    The resolved upper bound of the selection's main range.\n    */\n    get $to() {\n        return this.ranges[0].$to;\n    }\n    /**\n    Indicates whether the selection contains any content.\n    */\n    get empty() {\n        let ranges = this.ranges;\n        for (let i = 0; i < ranges.length; i++)\n            if (ranges[i].$from.pos != ranges[i].$to.pos)\n                return false;\n        return true;\n    }\n    /**\n    Get the content of this selection as a slice.\n    */\n    content() {\n        return this.$from.doc.slice(this.from, this.to, true);\n    }\n    /**\n    Replace the selection with a slice or, if no slice is given,\n    delete the selection. Will append to the given transaction.\n    */\n    replace(tr, content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty) {\n        // Put the new selection at the position after the inserted\n        // content. When that ended in an inline node, search backwards,\n        // to get the position after that node. If not, search forward.\n        let lastNode = content.content.lastChild, lastParent = null;\n        for (let i = 0; i < content.openEnd; i++) {\n            lastParent = lastNode;\n            lastNode = lastNode.lastChild;\n        }\n        let mapFrom = tr.steps.length, ranges = this.ranges;\n        for (let i = 0; i < ranges.length; i++) {\n            let { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);\n            tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty : content);\n            if (i == 0)\n                selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);\n        }\n    }\n    /**\n    Replace the selection with the given node, appending the changes\n    to the given transaction.\n    */\n    replaceWith(tr, node) {\n        let mapFrom = tr.steps.length, ranges = this.ranges;\n        for (let i = 0; i < ranges.length; i++) {\n            let { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);\n            let from = mapping.map($from.pos), to = mapping.map($to.pos);\n            if (i) {\n                tr.deleteRange(from, to);\n            }\n            else {\n                tr.replaceRangeWith(from, to, node);\n                selectionToInsertionEnd(tr, mapFrom, node.isInline ? -1 : 1);\n            }\n        }\n    }\n    /**\n    Find a valid cursor or leaf node selection starting at the given\n    position and searching back if `dir` is negative, and forward if\n    positive. When `textOnly` is true, only consider cursor\n    selections. Will return null when no valid selection position is\n    found.\n    */\n    static findFrom($pos, dir, textOnly = false) {\n        let inner = $pos.parent.inlineContent ? new TextSelection($pos)\n            : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);\n        if (inner)\n            return inner;\n        for (let depth = $pos.depth - 1; depth >= 0; depth--) {\n            let found = dir < 0\n                ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly)\n                : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);\n            if (found)\n                return found;\n        }\n        return null;\n    }\n    /**\n    Find a valid cursor or leaf node selection near the given\n    position. Searches forward first by default, but if `bias` is\n    negative, it will search backwards first.\n    */\n    static near($pos, bias = 1) {\n        return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));\n    }\n    /**\n    Find the cursor or leaf node selection closest to the start of\n    the given document. Will return an\n    [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position\n    exists.\n    */\n    static atStart(doc) {\n        return findSelectionIn(doc, doc, 0, 0, 1) || new AllSelection(doc);\n    }\n    /**\n    Find the cursor or leaf node selection closest to the end of the\n    given document.\n    */\n    static atEnd(doc) {\n        return findSelectionIn(doc, doc, doc.content.size, doc.childCount, -1) || new AllSelection(doc);\n    }\n    /**\n    Deserialize the JSON representation of a selection. Must be\n    implemented for custom classes (as a static class method).\n    */\n    static fromJSON(doc, json) {\n        if (!json || !json.type)\n            throw new RangeError(\"Invalid input for Selection.fromJSON\");\n        let cls = classesById[json.type];\n        if (!cls)\n            throw new RangeError(`No selection type ${json.type} defined`);\n        return cls.fromJSON(doc, json);\n    }\n    /**\n    To be able to deserialize selections from JSON, custom selection\n    classes must register themselves with an ID string, so that they\n    can be disambiguated. Try to pick something that's unlikely to\n    clash with classes from other modules.\n    */\n    static jsonID(id, selectionClass) {\n        if (id in classesById)\n            throw new RangeError(\"Duplicate use of selection JSON ID \" + id);\n        classesById[id] = selectionClass;\n        selectionClass.prototype.jsonID = id;\n        return selectionClass;\n    }\n    /**\n    Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,\n    which is a value that can be mapped without having access to a\n    current document, and later resolved to a real selection for a\n    given document again. (This is used mostly by the history to\n    track and restore old selections.) The default implementation of\n    this method just converts the selection to a text selection and\n    returns the bookmark for that.\n    */\n    getBookmark() {\n        return TextSelection.between(this.$anchor, this.$head).getBookmark();\n    }\n}\nSelection.prototype.visible = true;\n/**\nRepresents a selected range in a document.\n*/\nclass SelectionRange {\n    /**\n    Create a range.\n    */\n    constructor(\n    /**\n    The lower bound of the range.\n    */\n    $from, \n    /**\n    The upper bound of the range.\n    */\n    $to) {\n        this.$from = $from;\n        this.$to = $to;\n    }\n}\nlet warnedAboutTextSelection = false;\nfunction checkTextSelection($pos) {\n    if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {\n        warnedAboutTextSelection = true;\n        console[\"warn\"](\"TextSelection endpoint not pointing into a node with inline content (\" + $pos.parent.type.name + \")\");\n    }\n}\n/**\nA text selection represents a classical editor selection, with a\nhead (the moving side) and anchor (immobile side), both of which\npoint into textblock nodes. It can be empty (a regular cursor\nposition).\n*/\nclass TextSelection extends Selection {\n    /**\n    Construct a text selection between the given points.\n    */\n    constructor($anchor, $head = $anchor) {\n        checkTextSelection($anchor);\n        checkTextSelection($head);\n        super($anchor, $head);\n    }\n    /**\n    Returns a resolved position if this is a cursor selection (an\n    empty text selection), and null otherwise.\n    */\n    get $cursor() { return this.$anchor.pos == this.$head.pos ? this.$head : null; }\n    map(doc, mapping) {\n        let $head = doc.resolve(mapping.map(this.head));\n        if (!$head.parent.inlineContent)\n            return Selection.near($head);\n        let $anchor = doc.resolve(mapping.map(this.anchor));\n        return new TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head);\n    }\n    replace(tr, content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty) {\n        super.replace(tr, content);\n        if (content == prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty) {\n            let marks = this.$from.marksAcross(this.$to);\n            if (marks)\n                tr.ensureMarks(marks);\n        }\n    }\n    eq(other) {\n        return other instanceof TextSelection && other.anchor == this.anchor && other.head == this.head;\n    }\n    getBookmark() {\n        return new TextBookmark(this.anchor, this.head);\n    }\n    toJSON() {\n        return { type: \"text\", anchor: this.anchor, head: this.head };\n    }\n    /**\n    @internal\n    */\n    static fromJSON(doc, json) {\n        if (typeof json.anchor != \"number\" || typeof json.head != \"number\")\n            throw new RangeError(\"Invalid input for TextSelection.fromJSON\");\n        return new TextSelection(doc.resolve(json.anchor), doc.resolve(json.head));\n    }\n    /**\n    Create a text selection from non-resolved positions.\n    */\n    static create(doc, anchor, head = anchor) {\n        let $anchor = doc.resolve(anchor);\n        return new this($anchor, head == anchor ? $anchor : doc.resolve(head));\n    }\n    /**\n    Return a text selection that spans the given positions or, if\n    they aren't text positions, find a text selection near them.\n    `bias` determines whether the method searches forward (default)\n    or backwards (negative number) first. Will fall back to calling\n    [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document\n    doesn't contain a valid text position.\n    */\n    static between($anchor, $head, bias) {\n        let dPos = $anchor.pos - $head.pos;\n        if (!bias || dPos)\n            bias = dPos >= 0 ? 1 : -1;\n        if (!$head.parent.inlineContent) {\n            let found = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);\n            if (found)\n                $head = found.$head;\n            else\n                return Selection.near($head, bias);\n        }\n        if (!$anchor.parent.inlineContent) {\n            if (dPos == 0) {\n                $anchor = $head;\n            }\n            else {\n                $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;\n                if (($anchor.pos < $head.pos) != (dPos < 0))\n                    $anchor = $head;\n            }\n        }\n        return new TextSelection($anchor, $head);\n    }\n}\nSelection.jsonID(\"text\", TextSelection);\nclass TextBookmark {\n    constructor(anchor, head) {\n        this.anchor = anchor;\n        this.head = head;\n    }\n    map(mapping) {\n        return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head));\n    }\n    resolve(doc) {\n        return TextSelection.between(doc.resolve(this.anchor), doc.resolve(this.head));\n    }\n}\n/**\nA node selection is a selection that points at a single node. All\nnodes marked [selectable](https://prosemirror.net/docs/ref/#model.NodeSpec.selectable) can be the\ntarget of a node selection. In such a selection, `from` and `to`\npoint directly before and after the selected node, `anchor` equals\n`from`, and `head` equals `to`..\n*/\nclass NodeSelection extends Selection {\n    /**\n    Create a node selection. Does not verify the validity of its\n    argument.\n    */\n    constructor($pos) {\n        let node = $pos.nodeAfter;\n        let $end = $pos.node(0).resolve($pos.pos + node.nodeSize);\n        super($pos, $end);\n        this.node = node;\n    }\n    map(doc, mapping) {\n        let { deleted, pos } = mapping.mapResult(this.anchor);\n        let $pos = doc.resolve(pos);\n        if (deleted)\n            return Selection.near($pos);\n        return new NodeSelection($pos);\n    }\n    content() {\n        return new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(this.node), 0, 0);\n    }\n    eq(other) {\n        return other instanceof NodeSelection && other.anchor == this.anchor;\n    }\n    toJSON() {\n        return { type: \"node\", anchor: this.anchor };\n    }\n    getBookmark() { return new NodeBookmark(this.anchor); }\n    /**\n    @internal\n    */\n    static fromJSON(doc, json) {\n        if (typeof json.anchor != \"number\")\n            throw new RangeError(\"Invalid input for NodeSelection.fromJSON\");\n        return new NodeSelection(doc.resolve(json.anchor));\n    }\n    /**\n    Create a node selection from non-resolved positions.\n    */\n    static create(doc, from) {\n        return new NodeSelection(doc.resolve(from));\n    }\n    /**\n    Determines whether the given node may be selected as a node\n    selection.\n    */\n    static isSelectable(node) {\n        return !node.isText && node.type.spec.selectable !== false;\n    }\n}\nNodeSelection.prototype.visible = false;\nSelection.jsonID(\"node\", NodeSelection);\nclass NodeBookmark {\n    constructor(anchor) {\n        this.anchor = anchor;\n    }\n    map(mapping) {\n        let { deleted, pos } = mapping.mapResult(this.anchor);\n        return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos);\n    }\n    resolve(doc) {\n        let $pos = doc.resolve(this.anchor), node = $pos.nodeAfter;\n        if (node && NodeSelection.isSelectable(node))\n            return new NodeSelection($pos);\n        return Selection.near($pos);\n    }\n}\n/**\nA selection type that represents selecting the whole document\n(which can not necessarily be expressed with a text selection, when\nthere are for example leaf block nodes at the start or end of the\ndocument).\n*/\nclass AllSelection extends Selection {\n    /**\n    Create an all-selection over the given document.\n    */\n    constructor(doc) {\n        super(doc.resolve(0), doc.resolve(doc.content.size));\n    }\n    replace(tr, content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty) {\n        if (content == prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty) {\n            tr.delete(0, tr.doc.content.size);\n            let sel = Selection.atStart(tr.doc);\n            if (!sel.eq(tr.selection))\n                tr.setSelection(sel);\n        }\n        else {\n            super.replace(tr, content);\n        }\n    }\n    toJSON() { return { type: \"all\" }; }\n    /**\n    @internal\n    */\n    static fromJSON(doc) { return new AllSelection(doc); }\n    map(doc) { return new AllSelection(doc); }\n    eq(other) { return other instanceof AllSelection; }\n    getBookmark() { return AllBookmark; }\n}\nSelection.jsonID(\"all\", AllSelection);\nconst AllBookmark = {\n    map() { return this; },\n    resolve(doc) { return new AllSelection(doc); }\n};\n// FIXME we'll need some awareness of text direction when scanning for selections\n// Try to find a selection inside the given node. `pos` points at the\n// position where the search starts. When `text` is true, only return\n// text selections.\nfunction findSelectionIn(doc, node, pos, index, dir, text = false) {\n    if (node.inlineContent)\n        return TextSelection.create(doc, pos);\n    for (let i = index - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {\n        let child = node.child(i);\n        if (!child.isAtom) {\n            let inner = findSelectionIn(doc, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);\n            if (inner)\n                return inner;\n        }\n        else if (!text && NodeSelection.isSelectable(child)) {\n            return NodeSelection.create(doc, pos - (dir < 0 ? child.nodeSize : 0));\n        }\n        pos += child.nodeSize * dir;\n    }\n    return null;\n}\nfunction selectionToInsertionEnd(tr, startLen, bias) {\n    let last = tr.steps.length - 1;\n    if (last < startLen)\n        return;\n    let step = tr.steps[last];\n    if (!(step instanceof prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.ReplaceStep || step instanceof prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.ReplaceAroundStep))\n        return;\n    let map = tr.mapping.maps[last], end;\n    map.forEach((_from, _to, _newFrom, newTo) => { if (end == null)\n        end = newTo; });\n    tr.setSelection(Selection.near(tr.doc.resolve(end), bias));\n}\n\nconst UPDATED_SEL = 1, UPDATED_MARKS = 2, UPDATED_SCROLL = 4;\n/**\nAn editor state transaction, which can be applied to a state to\ncreate an updated state. Use\n[`EditorState.tr`](https://prosemirror.net/docs/ref/#state.EditorState.tr) to create an instance.\n\nTransactions track changes to the document (they are a subclass of\n[`Transform`](https://prosemirror.net/docs/ref/#transform.Transform)), but also other state changes,\nlike selection updates and adjustments of the set of [stored\nmarks](https://prosemirror.net/docs/ref/#state.EditorState.storedMarks). In addition, you can store\nmetadata properties in a transaction, which are extra pieces of\ninformation that client code or plugins can use to describe what a\ntransaction represents, so that they can update their [own\nstate](https://prosemirror.net/docs/ref/#state.StateField) accordingly.\n\nThe [editor view](https://prosemirror.net/docs/ref/#view.EditorView) uses a few metadata\nproperties: it will attach a property `\"pointer\"` with the value\n`true` to selection transactions directly caused by mouse or touch\ninput, a `\"composition\"` property holding an ID identifying the\ncomposition that caused it to transactions caused by composed DOM\ninput, and a `\"uiEvent\"` property of that may be `\"paste\"`,\n`\"cut\"`, or `\"drop\"`.\n*/\nclass Transaction extends prosemirror_transform__WEBPACK_IMPORTED_MODULE_1__.Transform {\n    /**\n    @internal\n    */\n    constructor(state) {\n        super(state.doc);\n        // The step count for which the current selection is valid.\n        this.curSelectionFor = 0;\n        // Bitfield to track which aspects of the state were updated by\n        // this transaction.\n        this.updated = 0;\n        // Object used to store metadata properties for the transaction.\n        this.meta = Object.create(null);\n        this.time = Date.now();\n        this.curSelection = state.selection;\n        this.storedMarks = state.storedMarks;\n    }\n    /**\n    The transaction's current selection. This defaults to the editor\n    selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the\n    transaction, but can be overwritten with\n    [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).\n    */\n    get selection() {\n        if (this.curSelectionFor < this.steps.length) {\n            this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));\n            this.curSelectionFor = this.steps.length;\n        }\n        return this.curSelection;\n    }\n    /**\n    Update the transaction's current selection. Will determine the\n    selection that the editor gets when the transaction is applied.\n    */\n    setSelection(selection) {\n        if (selection.$from.doc != this.doc)\n            throw new RangeError(\"Selection passed to setSelection must point at the current document\");\n        this.curSelection = selection;\n        this.curSelectionFor = this.steps.length;\n        this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;\n        this.storedMarks = null;\n        return this;\n    }\n    /**\n    Whether the selection was explicitly updated by this transaction.\n    */\n    get selectionSet() {\n        return (this.updated & UPDATED_SEL) > 0;\n    }\n    /**\n    Set the current stored marks.\n    */\n    setStoredMarks(marks) {\n        this.storedMarks = marks;\n        this.updated |= UPDATED_MARKS;\n        return this;\n    }\n    /**\n    Make sure the current stored marks or, if that is null, the marks\n    at the selection, match the given set of marks. Does nothing if\n    this is already the case.\n    */\n    ensureMarks(marks) {\n        if (!prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks))\n            this.setStoredMarks(marks);\n        return this;\n    }\n    /**\n    Add a mark to the set of stored marks.\n    */\n    addStoredMark(mark) {\n        return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()));\n    }\n    /**\n    Remove a mark or mark type from the set of stored marks.\n    */\n    removeStoredMark(mark) {\n        return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()));\n    }\n    /**\n    Whether the stored marks were explicitly set for this transaction.\n    */\n    get storedMarksSet() {\n        return (this.updated & UPDATED_MARKS) > 0;\n    }\n    /**\n    @internal\n    */\n    addStep(step, doc) {\n        super.addStep(step, doc);\n        this.updated = this.updated & ~UPDATED_MARKS;\n        this.storedMarks = null;\n    }\n    /**\n    Update the timestamp for the transaction.\n    */\n    setTime(time) {\n        this.time = time;\n        return this;\n    }\n    /**\n    Replace the current selection with the given slice.\n    */\n    replaceSelection(slice) {\n        this.selection.replace(this, slice);\n        return this;\n    }\n    /**\n    Replace the selection with the given node. When `inheritMarks` is\n    true and the content is inline, it inherits the marks from the\n    place where it is inserted.\n    */\n    replaceSelectionWith(node, inheritMarks = true) {\n        let selection = this.selection;\n        if (inheritMarks)\n            node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : (selection.$from.marksAcross(selection.$to) || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Mark.none)));\n        selection.replaceWith(this, node);\n        return this;\n    }\n    /**\n    Delete the selection.\n    */\n    deleteSelection() {\n        this.selection.replace(this);\n        return this;\n    }\n    /**\n    Replace the given range, or the selection if no range is given,\n    with a text node containing the given string.\n    */\n    insertText(text, from, to) {\n        let schema = this.doc.type.schema;\n        if (from == null) {\n            if (!text)\n                return this.deleteSelection();\n            return this.replaceSelectionWith(schema.text(text), true);\n        }\n        else {\n            if (to == null)\n                to = from;\n            to = to == null ? from : to;\n            if (!text)\n                return this.deleteRange(from, to);\n            let marks = this.storedMarks;\n            if (!marks) {\n                let $from = this.doc.resolve(from);\n                marks = to == from ? $from.marks() : $from.marksAcross(this.doc.resolve(to));\n            }\n            this.replaceRangeWith(from, to, schema.text(text, marks));\n            if (!this.selection.empty)\n                this.setSelection(Selection.near(this.selection.$to));\n            return this;\n        }\n    }\n    /**\n    Store a metadata property in this transaction, keyed either by\n    name or by plugin.\n    */\n    setMeta(key, value) {\n        this.meta[typeof key == \"string\" ? key : key.key] = value;\n        return this;\n    }\n    /**\n    Retrieve a metadata property for a given name or plugin.\n    */\n    getMeta(key) {\n        return this.meta[typeof key == \"string\" ? key : key.key];\n    }\n    /**\n    Returns true if this transaction doesn't contain any metadata,\n    and can thus safely be extended.\n    */\n    get isGeneric() {\n        for (let _ in this.meta)\n            return false;\n        return true;\n    }\n    /**\n    Indicate that the editor should scroll the selection into view\n    when updated to the state produced by this transaction.\n    */\n    scrollIntoView() {\n        this.updated |= UPDATED_SCROLL;\n        return this;\n    }\n    /**\n    True when this transaction has had `scrollIntoView` called on it.\n    */\n    get scrolledIntoView() {\n        return (this.updated & UPDATED_SCROLL) > 0;\n    }\n}\n\nfunction bind(f, self) {\n    return !self || !f ? f : f.bind(self);\n}\nclass FieldDesc {\n    constructor(name, desc, self) {\n        this.name = name;\n        this.init = bind(desc.init, self);\n        this.apply = bind(desc.apply, self);\n    }\n}\nconst baseFields = [\n    new FieldDesc(\"doc\", {\n        init(config) { return config.doc || config.schema.topNodeType.createAndFill(); },\n        apply(tr) { return tr.doc; }\n    }),\n    new FieldDesc(\"selection\", {\n        init(config, instance) { return config.selection || Selection.atStart(instance.doc); },\n        apply(tr) { return tr.selection; }\n    }),\n    new FieldDesc(\"storedMarks\", {\n        init(config) { return config.storedMarks || null; },\n        apply(tr, _marks, _old, state) { return state.selection.$cursor ? tr.storedMarks : null; }\n    }),\n    new FieldDesc(\"scrollToSelection\", {\n        init() { return 0; },\n        apply(tr, prev) { return tr.scrolledIntoView ? prev + 1 : prev; }\n    })\n];\n// Object wrapping the part of a state object that stays the same\n// across transactions. Stored in the state's `config` property.\nclass Configuration {\n    constructor(schema, plugins) {\n        this.schema = schema;\n        this.plugins = [];\n        this.pluginsByKey = Object.create(null);\n        this.fields = baseFields.slice();\n        if (plugins)\n            plugins.forEach(plugin => {\n                if (this.pluginsByKey[plugin.key])\n                    throw new RangeError(\"Adding different instances of a keyed plugin (\" + plugin.key + \")\");\n                this.plugins.push(plugin);\n                this.pluginsByKey[plugin.key] = plugin;\n                if (plugin.spec.state)\n                    this.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));\n            });\n    }\n}\n/**\nThe state of a ProseMirror editor is represented by an object of\nthis type. A state is a persistent data structure—it isn't\nupdated, but rather a new state value is computed from an old one\nusing the [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) method.\n\nA state holds a number of built-in fields, and plugins can\n[define](https://prosemirror.net/docs/ref/#state.PluginSpec.state) additional fields.\n*/\nclass EditorState {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    @internal\n    */\n    config) {\n        this.config = config;\n    }\n    /**\n    The schema of the state's document.\n    */\n    get schema() {\n        return this.config.schema;\n    }\n    /**\n    The plugins that are active in this state.\n    */\n    get plugins() {\n        return this.config.plugins;\n    }\n    /**\n    Apply the given transaction to produce a new state.\n    */\n    apply(tr) {\n        return this.applyTransaction(tr).state;\n    }\n    /**\n    @internal\n    */\n    filterTransaction(tr, ignore = -1) {\n        for (let i = 0; i < this.config.plugins.length; i++)\n            if (i != ignore) {\n                let plugin = this.config.plugins[i];\n                if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this))\n                    return false;\n            }\n        return true;\n    }\n    /**\n    Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that\n    returns the precise transactions that were applied (which might\n    be influenced by the [transaction\n    hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of\n    plugins) along with the new state.\n    */\n    applyTransaction(rootTr) {\n        if (!this.filterTransaction(rootTr))\n            return { state: this, transactions: [] };\n        let trs = [rootTr], newState = this.applyInner(rootTr), seen = null;\n        // This loop repeatedly gives plugins a chance to respond to\n        // transactions as new transactions are added, making sure to only\n        // pass the transactions the plugin did not see before.\n        for (;;) {\n            let haveNew = false;\n            for (let i = 0; i < this.config.plugins.length; i++) {\n                let plugin = this.config.plugins[i];\n                if (plugin.spec.appendTransaction) {\n                    let n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this;\n                    let tr = n < trs.length &&\n                        plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);\n                    if (tr && newState.filterTransaction(tr, i)) {\n                        tr.setMeta(\"appendedTransaction\", rootTr);\n                        if (!seen) {\n                            seen = [];\n                            for (let j = 0; j < this.config.plugins.length; j++)\n                                seen.push(j < i ? { state: newState, n: trs.length } : { state: this, n: 0 });\n                        }\n                        trs.push(tr);\n                        newState = newState.applyInner(tr);\n                        haveNew = true;\n                    }\n                    if (seen)\n                        seen[i] = { state: newState, n: trs.length };\n                }\n            }\n            if (!haveNew)\n                return { state: newState, transactions: trs };\n        }\n    }\n    /**\n    @internal\n    */\n    applyInner(tr) {\n        if (!tr.before.eq(this.doc))\n            throw new RangeError(\"Applying a mismatched transaction\");\n        let newInstance = new EditorState(this.config), fields = this.config.fields;\n        for (let i = 0; i < fields.length; i++) {\n            let field = fields[i];\n            newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);\n        }\n        return newInstance;\n    }\n    /**\n    Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.\n    */\n    get tr() { return new Transaction(this); }\n    /**\n    Create a new state.\n    */\n    static create(config) {\n        let $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);\n        let instance = new EditorState($config);\n        for (let i = 0; i < $config.fields.length; i++)\n            instance[$config.fields[i].name] = $config.fields[i].init(config, instance);\n        return instance;\n    }\n    /**\n    Create a new state based on this one, but with an adjusted set\n    of active plugins. State fields that exist in both sets of\n    plugins are kept unchanged. Those that no longer exist are\n    dropped, and those that are new are initialized using their\n    [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new\n    configuration object..\n    */\n    reconfigure(config) {\n        let $config = new Configuration(this.schema, config.plugins);\n        let fields = $config.fields, instance = new EditorState($config);\n        for (let i = 0; i < fields.length; i++) {\n            let name = fields[i].name;\n            instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance);\n        }\n        return instance;\n    }\n    /**\n    Serialize this state to JSON. If you want to serialize the state\n    of plugins, pass an object mapping property names to use in the\n    resulting JSON object to plugin objects. The argument may also be\n    a string or number, in which case it is ignored, to support the\n    way `JSON.stringify` calls `toString` methods.\n    */\n    toJSON(pluginFields) {\n        let result = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };\n        if (this.storedMarks)\n            result.storedMarks = this.storedMarks.map(m => m.toJSON());\n        if (pluginFields && typeof pluginFields == 'object')\n            for (let prop in pluginFields) {\n                if (prop == \"doc\" || prop == \"selection\")\n                    throw new RangeError(\"The JSON fields `doc` and `selection` are reserved\");\n                let plugin = pluginFields[prop], state = plugin.spec.state;\n                if (state && state.toJSON)\n                    result[prop] = state.toJSON.call(plugin, this[plugin.key]);\n            }\n        return result;\n    }\n    /**\n    Deserialize a JSON representation of a state. `config` should\n    have at least a `schema` field, and should contain array of\n    plugins to initialize the state with. `pluginFields` can be used\n    to deserialize the state of plugins, by associating plugin\n    instances with the property names they use in the JSON object.\n    */\n    static fromJSON(config, json, pluginFields) {\n        if (!json)\n            throw new RangeError(\"Invalid input for EditorState.fromJSON\");\n        if (!config.schema)\n            throw new RangeError(\"Required config field 'schema' missing\");\n        let $config = new Configuration(config.schema, config.plugins);\n        let instance = new EditorState($config);\n        $config.fields.forEach(field => {\n            if (field.name == \"doc\") {\n                instance.doc = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Node.fromJSON(config.schema, json.doc);\n            }\n            else if (field.name == \"selection\") {\n                instance.selection = Selection.fromJSON(instance.doc, json.selection);\n            }\n            else if (field.name == \"storedMarks\") {\n                if (json.storedMarks)\n                    instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON);\n            }\n            else {\n                if (pluginFields)\n                    for (let prop in pluginFields) {\n                        let plugin = pluginFields[prop], state = plugin.spec.state;\n                        if (plugin.key == field.name && state && state.fromJSON &&\n                            Object.prototype.hasOwnProperty.call(json, prop)) {\n                            instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance);\n                            return;\n                        }\n                    }\n                instance[field.name] = field.init(config, instance);\n            }\n        });\n        return instance;\n    }\n}\n\nfunction bindProps(obj, self, target) {\n    for (let prop in obj) {\n        let val = obj[prop];\n        if (val instanceof Function)\n            val = val.bind(self);\n        else if (prop == \"handleDOMEvents\")\n            val = bindProps(val, self, {});\n        target[prop] = val;\n    }\n    return target;\n}\n/**\nPlugins bundle functionality that can be added to an editor.\nThey are part of the [editor state](https://prosemirror.net/docs/ref/#state.EditorState) and\nmay influence that state and the view that contains it.\n*/\nclass Plugin {\n    /**\n    Create a plugin.\n    */\n    constructor(\n    /**\n    The plugin's [spec object](https://prosemirror.net/docs/ref/#state.PluginSpec).\n    */\n    spec) {\n        this.spec = spec;\n        /**\n        The [props](https://prosemirror.net/docs/ref/#view.EditorProps) exported by this plugin.\n        */\n        this.props = {};\n        if (spec.props)\n            bindProps(spec.props, this, this.props);\n        this.key = spec.key ? spec.key.key : createKey(\"plugin\");\n    }\n    /**\n    Extract the plugin's state field from an editor state.\n    */\n    getState(state) { return state[this.key]; }\n}\nconst keys = Object.create(null);\nfunction createKey(name) {\n    if (name in keys)\n        return name + \"$\" + ++keys[name];\n    keys[name] = 0;\n    return name + \"$\";\n}\n/**\nA key is used to [tag](https://prosemirror.net/docs/ref/#state.PluginSpec.key) plugins in a way\nthat makes it possible to find them, given an editor state.\nAssigning a key does mean only one plugin of that type can be\nactive in a state.\n*/\nclass PluginKey {\n    /**\n    Create a plugin key.\n    */\n    constructor(name = \"key\") { this.key = createKey(name); }\n    /**\n    Get the active plugin with this key, if any, from an editor\n    state.\n    */\n    get(state) { return state.config.pluginsByKey[this.key]; }\n    /**\n    Get the plugin's state from an editor state.\n    */\n    getState(state) { return state[this.key]; }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci1zdGF0ZS9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQWdFO0FBQ2tCOztBQUVsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsb0RBQUs7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQyxrQkFBa0IsYUFBYTtBQUMvQiw4RUFBOEUsb0RBQUs7QUFDbkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDLGtCQUFrQixhQUFhO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFlBQVk7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxXQUFXO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixvREFBSztBQUMvQjtBQUNBLHVCQUF1QixvREFBSztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsZUFBZTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0RBQUssQ0FBQyx1REFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGVBQWU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsb0RBQUs7QUFDL0IsdUJBQXVCLG9EQUFLO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IsZUFBZTtBQUNmLGdCQUFnQjtBQUNoQixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHdDQUF3QztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsOERBQVcsb0JBQW9CLG9FQUFpQjtBQUMxRTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25ELHNCQUFzQjtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDREQUFTO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1EQUFJO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCOztBQUU4SCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcHJvc2VtaXJyb3Itc3RhdGUvZGlzdC9pbmRleC5qcz81NmI2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNsaWNlLCBGcmFnbWVudCwgTWFyaywgTm9kZSB9IGZyb20gJ3Byb3NlbWlycm9yLW1vZGVsJztcbmltcG9ydCB7IFJlcGxhY2VTdGVwLCBSZXBsYWNlQXJvdW5kU3RlcCwgVHJhbnNmb3JtIH0gZnJvbSAncHJvc2VtaXJyb3ItdHJhbnNmb3JtJztcblxuY29uc3QgY2xhc3Nlc0J5SWQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqXG5TdXBlcmNsYXNzIGZvciBlZGl0b3Igc2VsZWN0aW9ucy4gRXZlcnkgc2VsZWN0aW9uIHR5cGUgc2hvdWxkXG5leHRlbmQgdGhpcy4gU2hvdWxkIG5vdCBiZSBpbnN0YW50aWF0ZWQgZGlyZWN0bHkuXG4qL1xuY2xhc3MgU2VsZWN0aW9uIHtcbiAgICAvKipcbiAgICBJbml0aWFsaXplIGEgc2VsZWN0aW9uIHdpdGggdGhlIGhlYWQgYW5kIGFuY2hvciBhbmQgcmFuZ2VzLiBJZiBub1xuICAgIHJhbmdlcyBhcmUgZ2l2ZW4sIGNvbnN0cnVjdHMgYSBzaW5nbGUgcmFuZ2UgYWNyb3NzIGAkYW5jaG9yYCBhbmRcbiAgICBgJGhlYWRgLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHJlc29sdmVkIGFuY2hvciBvZiB0aGUgc2VsZWN0aW9uICh0aGUgc2lkZSB0aGF0IHN0YXlzIGluXG4gICAgcGxhY2Ugd2hlbiB0aGUgc2VsZWN0aW9uIGlzIG1vZGlmaWVkKS5cbiAgICAqL1xuICAgICRhbmNob3IsIFxuICAgIC8qKlxuICAgIFRoZSByZXNvbHZlZCBoZWFkIG9mIHRoZSBzZWxlY3Rpb24gKHRoZSBzaWRlIHRoYXQgbW92ZXMgd2hlblxuICAgIHRoZSBzZWxlY3Rpb24gaXMgbW9kaWZpZWQpLlxuICAgICovXG4gICAgJGhlYWQsIHJhbmdlcykge1xuICAgICAgICB0aGlzLiRhbmNob3IgPSAkYW5jaG9yO1xuICAgICAgICB0aGlzLiRoZWFkID0gJGhlYWQ7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzIHx8IFtuZXcgU2VsZWN0aW9uUmFuZ2UoJGFuY2hvci5taW4oJGhlYWQpLCAkYW5jaG9yLm1heCgkaGVhZCkpXTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHNlbGVjdGlvbidzIGFuY2hvciwgYXMgYW4gdW5yZXNvbHZlZCBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGdldCBhbmNob3IoKSB7IHJldHVybiB0aGlzLiRhbmNob3IucG9zOyB9XG4gICAgLyoqXG4gICAgVGhlIHNlbGVjdGlvbidzIGhlYWQuXG4gICAgKi9cbiAgICBnZXQgaGVhZCgpIHsgcmV0dXJuIHRoaXMuJGhlYWQucG9zOyB9XG4gICAgLyoqXG4gICAgVGhlIGxvd2VyIGJvdW5kIG9mIHRoZSBzZWxlY3Rpb24ncyBtYWluIHJhbmdlLlxuICAgICovXG4gICAgZ2V0IGZyb20oKSB7IHJldHVybiB0aGlzLiRmcm9tLnBvczsgfVxuICAgIC8qKlxuICAgIFRoZSB1cHBlciBib3VuZCBvZiB0aGUgc2VsZWN0aW9uJ3MgbWFpbiByYW5nZS5cbiAgICAqL1xuICAgIGdldCB0bygpIHsgcmV0dXJuIHRoaXMuJHRvLnBvczsgfVxuICAgIC8qKlxuICAgIFRoZSByZXNvbHZlZCBsb3dlciAgYm91bmQgb2YgdGhlIHNlbGVjdGlvbidzIG1haW4gcmFuZ2UuXG4gICAgKi9cbiAgICBnZXQgJGZyb20oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJhbmdlc1swXS4kZnJvbTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHJlc29sdmVkIHVwcGVyIGJvdW5kIG9mIHRoZSBzZWxlY3Rpb24ncyBtYWluIHJhbmdlLlxuICAgICovXG4gICAgZ2V0ICR0bygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmFuZ2VzWzBdLiR0bztcbiAgICB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHNlbGVjdGlvbiBjb250YWlucyBhbnkgY29udGVudC5cbiAgICAqL1xuICAgIGdldCBlbXB0eSgpIHtcbiAgICAgICAgbGV0IHJhbmdlcyA9IHRoaXMucmFuZ2VzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChyYW5nZXNbaV0uJGZyb20ucG9zICE9IHJhbmdlc1tpXS4kdG8ucG9zKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgY29udGVudCBvZiB0aGlzIHNlbGVjdGlvbiBhcyBhIHNsaWNlLlxuICAgICovXG4gICAgY29udGVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJGZyb20uZG9jLnNsaWNlKHRoaXMuZnJvbSwgdGhpcy50bywgdHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlcGxhY2UgdGhlIHNlbGVjdGlvbiB3aXRoIGEgc2xpY2Ugb3IsIGlmIG5vIHNsaWNlIGlzIGdpdmVuLFxuICAgIGRlbGV0ZSB0aGUgc2VsZWN0aW9uLiBXaWxsIGFwcGVuZCB0byB0aGUgZ2l2ZW4gdHJhbnNhY3Rpb24uXG4gICAgKi9cbiAgICByZXBsYWNlKHRyLCBjb250ZW50ID0gU2xpY2UuZW1wdHkpIHtcbiAgICAgICAgLy8gUHV0IHRoZSBuZXcgc2VsZWN0aW9uIGF0IHRoZSBwb3NpdGlvbiBhZnRlciB0aGUgaW5zZXJ0ZWRcbiAgICAgICAgLy8gY29udGVudC4gV2hlbiB0aGF0IGVuZGVkIGluIGFuIGlubGluZSBub2RlLCBzZWFyY2ggYmFja3dhcmRzLFxuICAgICAgICAvLyB0byBnZXQgdGhlIHBvc2l0aW9uIGFmdGVyIHRoYXQgbm9kZS4gSWYgbm90LCBzZWFyY2ggZm9yd2FyZC5cbiAgICAgICAgbGV0IGxhc3ROb2RlID0gY29udGVudC5jb250ZW50Lmxhc3RDaGlsZCwgbGFzdFBhcmVudCA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29udGVudC5vcGVuRW5kOyBpKyspIHtcbiAgICAgICAgICAgIGxhc3RQYXJlbnQgPSBsYXN0Tm9kZTtcbiAgICAgICAgICAgIGxhc3ROb2RlID0gbGFzdE5vZGUubGFzdENoaWxkO1xuICAgICAgICB9XG4gICAgICAgIGxldCBtYXBGcm9tID0gdHIuc3RlcHMubGVuZ3RoLCByYW5nZXMgPSB0aGlzLnJhbmdlcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB7ICRmcm9tLCAkdG8gfSA9IHJhbmdlc1tpXSwgbWFwcGluZyA9IHRyLm1hcHBpbmcuc2xpY2UobWFwRnJvbSk7XG4gICAgICAgICAgICB0ci5yZXBsYWNlUmFuZ2UobWFwcGluZy5tYXAoJGZyb20ucG9zKSwgbWFwcGluZy5tYXAoJHRvLnBvcyksIGkgPyBTbGljZS5lbXB0eSA6IGNvbnRlbnQpO1xuICAgICAgICAgICAgaWYgKGkgPT0gMClcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25Ub0luc2VydGlvbkVuZCh0ciwgbWFwRnJvbSwgKGxhc3ROb2RlID8gbGFzdE5vZGUuaXNJbmxpbmUgOiBsYXN0UGFyZW50ICYmIGxhc3RQYXJlbnQuaXNUZXh0YmxvY2spID8gLTEgOiAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIHRoZSBzZWxlY3Rpb24gd2l0aCB0aGUgZ2l2ZW4gbm9kZSwgYXBwZW5kaW5nIHRoZSBjaGFuZ2VzXG4gICAgdG8gdGhlIGdpdmVuIHRyYW5zYWN0aW9uLlxuICAgICovXG4gICAgcmVwbGFjZVdpdGgodHIsIG5vZGUpIHtcbiAgICAgICAgbGV0IG1hcEZyb20gPSB0ci5zdGVwcy5sZW5ndGgsIHJhbmdlcyA9IHRoaXMucmFuZ2VzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHsgJGZyb20sICR0byB9ID0gcmFuZ2VzW2ldLCBtYXBwaW5nID0gdHIubWFwcGluZy5zbGljZShtYXBGcm9tKTtcbiAgICAgICAgICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXAoJGZyb20ucG9zKSwgdG8gPSBtYXBwaW5nLm1hcCgkdG8ucG9zKTtcbiAgICAgICAgICAgIGlmIChpKSB7XG4gICAgICAgICAgICAgICAgdHIuZGVsZXRlUmFuZ2UoZnJvbSwgdG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHIucmVwbGFjZVJhbmdlV2l0aChmcm9tLCB0bywgbm9kZSk7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uVG9JbnNlcnRpb25FbmQodHIsIG1hcEZyb20sIG5vZGUuaXNJbmxpbmUgPyAtMSA6IDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgYSB2YWxpZCBjdXJzb3Igb3IgbGVhZiBub2RlIHNlbGVjdGlvbiBzdGFydGluZyBhdCB0aGUgZ2l2ZW5cbiAgICBwb3NpdGlvbiBhbmQgc2VhcmNoaW5nIGJhY2sgaWYgYGRpcmAgaXMgbmVnYXRpdmUsIGFuZCBmb3J3YXJkIGlmXG4gICAgcG9zaXRpdmUuIFdoZW4gYHRleHRPbmx5YCBpcyB0cnVlLCBvbmx5IGNvbnNpZGVyIGN1cnNvclxuICAgIHNlbGVjdGlvbnMuIFdpbGwgcmV0dXJuIG51bGwgd2hlbiBubyB2YWxpZCBzZWxlY3Rpb24gcG9zaXRpb24gaXNcbiAgICBmb3VuZC5cbiAgICAqL1xuICAgIHN0YXRpYyBmaW5kRnJvbSgkcG9zLCBkaXIsIHRleHRPbmx5ID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IGlubmVyID0gJHBvcy5wYXJlbnQuaW5saW5lQ29udGVudCA/IG5ldyBUZXh0U2VsZWN0aW9uKCRwb3MpXG4gICAgICAgICAgICA6IGZpbmRTZWxlY3Rpb25JbigkcG9zLm5vZGUoMCksICRwb3MucGFyZW50LCAkcG9zLnBvcywgJHBvcy5pbmRleCgpLCBkaXIsIHRleHRPbmx5KTtcbiAgICAgICAgaWYgKGlubmVyKVxuICAgICAgICAgICAgcmV0dXJuIGlubmVyO1xuICAgICAgICBmb3IgKGxldCBkZXB0aCA9ICRwb3MuZGVwdGggLSAxOyBkZXB0aCA+PSAwOyBkZXB0aC0tKSB7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBkaXIgPCAwXG4gICAgICAgICAgICAgICAgPyBmaW5kU2VsZWN0aW9uSW4oJHBvcy5ub2RlKDApLCAkcG9zLm5vZGUoZGVwdGgpLCAkcG9zLmJlZm9yZShkZXB0aCArIDEpLCAkcG9zLmluZGV4KGRlcHRoKSwgZGlyLCB0ZXh0T25seSlcbiAgICAgICAgICAgICAgICA6IGZpbmRTZWxlY3Rpb25JbigkcG9zLm5vZGUoMCksICRwb3Mubm9kZShkZXB0aCksICRwb3MuYWZ0ZXIoZGVwdGggKyAxKSwgJHBvcy5pbmRleChkZXB0aCkgKyAxLCBkaXIsIHRleHRPbmx5KTtcbiAgICAgICAgICAgIGlmIChmb3VuZClcbiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgYSB2YWxpZCBjdXJzb3Igb3IgbGVhZiBub2RlIHNlbGVjdGlvbiBuZWFyIHRoZSBnaXZlblxuICAgIHBvc2l0aW9uLiBTZWFyY2hlcyBmb3J3YXJkIGZpcnN0IGJ5IGRlZmF1bHQsIGJ1dCBpZiBgYmlhc2AgaXNcbiAgICBuZWdhdGl2ZSwgaXQgd2lsbCBzZWFyY2ggYmFja3dhcmRzIGZpcnN0LlxuICAgICovXG4gICAgc3RhdGljIG5lYXIoJHBvcywgYmlhcyA9IDEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZEZyb20oJHBvcywgYmlhcykgfHwgdGhpcy5maW5kRnJvbSgkcG9zLCAtYmlhcykgfHwgbmV3IEFsbFNlbGVjdGlvbigkcG9zLm5vZGUoMCkpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBjdXJzb3Igb3IgbGVhZiBub2RlIHNlbGVjdGlvbiBjbG9zZXN0IHRvIHRoZSBzdGFydCBvZlxuICAgIHRoZSBnaXZlbiBkb2N1bWVudC4gV2lsbCByZXR1cm4gYW5cbiAgICBbYEFsbFNlbGVjdGlvbmBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5BbGxTZWxlY3Rpb24pIGlmIG5vIHZhbGlkIHBvc2l0aW9uXG4gICAgZXhpc3RzLlxuICAgICovXG4gICAgc3RhdGljIGF0U3RhcnQoZG9jKSB7XG4gICAgICAgIHJldHVybiBmaW5kU2VsZWN0aW9uSW4oZG9jLCBkb2MsIDAsIDAsIDEpIHx8IG5ldyBBbGxTZWxlY3Rpb24oZG9jKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgY3Vyc29yIG9yIGxlYWYgbm9kZSBzZWxlY3Rpb24gY2xvc2VzdCB0byB0aGUgZW5kIG9mIHRoZVxuICAgIGdpdmVuIGRvY3VtZW50LlxuICAgICovXG4gICAgc3RhdGljIGF0RW5kKGRvYykge1xuICAgICAgICByZXR1cm4gZmluZFNlbGVjdGlvbkluKGRvYywgZG9jLCBkb2MuY29udGVudC5zaXplLCBkb2MuY2hpbGRDb3VudCwgLTEpIHx8IG5ldyBBbGxTZWxlY3Rpb24oZG9jKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRGVzZXJpYWxpemUgdGhlIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYSBzZWxlY3Rpb24uIE11c3QgYmVcbiAgICBpbXBsZW1lbnRlZCBmb3IgY3VzdG9tIGNsYXNzZXMgKGFzIGEgc3RhdGljIGNsYXNzIG1ldGhvZCkuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oZG9jLCBqc29uKSB7XG4gICAgICAgIGlmICghanNvbiB8fCAhanNvbi50eXBlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBTZWxlY3Rpb24uZnJvbUpTT05cIik7XG4gICAgICAgIGxldCBjbHMgPSBjbGFzc2VzQnlJZFtqc29uLnR5cGVdO1xuICAgICAgICBpZiAoIWNscylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBObyBzZWxlY3Rpb24gdHlwZSAke2pzb24udHlwZX0gZGVmaW5lZGApO1xuICAgICAgICByZXR1cm4gY2xzLmZyb21KU09OKGRvYywganNvbik7XG4gICAgfVxuICAgIC8qKlxuICAgIFRvIGJlIGFibGUgdG8gZGVzZXJpYWxpemUgc2VsZWN0aW9ucyBmcm9tIEpTT04sIGN1c3RvbSBzZWxlY3Rpb25cbiAgICBjbGFzc2VzIG11c3QgcmVnaXN0ZXIgdGhlbXNlbHZlcyB3aXRoIGFuIElEIHN0cmluZywgc28gdGhhdCB0aGV5XG4gICAgY2FuIGJlIGRpc2FtYmlndWF0ZWQuIFRyeSB0byBwaWNrIHNvbWV0aGluZyB0aGF0J3MgdW5saWtlbHkgdG9cbiAgICBjbGFzaCB3aXRoIGNsYXNzZXMgZnJvbSBvdGhlciBtb2R1bGVzLlxuICAgICovXG4gICAgc3RhdGljIGpzb25JRChpZCwgc2VsZWN0aW9uQ2xhc3MpIHtcbiAgICAgICAgaWYgKGlkIGluIGNsYXNzZXNCeUlkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJEdXBsaWNhdGUgdXNlIG9mIHNlbGVjdGlvbiBKU09OIElEIFwiICsgaWQpO1xuICAgICAgICBjbGFzc2VzQnlJZFtpZF0gPSBzZWxlY3Rpb25DbGFzcztcbiAgICAgICAgc2VsZWN0aW9uQ2xhc3MucHJvdG90eXBlLmpzb25JRCA9IGlkO1xuICAgICAgICByZXR1cm4gc2VsZWN0aW9uQ2xhc3M7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCBhIFtib29rbWFya10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLlNlbGVjdGlvbkJvb2ttYXJrKSBmb3IgdGhpcyBzZWxlY3Rpb24sXG4gICAgd2hpY2ggaXMgYSB2YWx1ZSB0aGF0IGNhbiBiZSBtYXBwZWQgd2l0aG91dCBoYXZpbmcgYWNjZXNzIHRvIGFcbiAgICBjdXJyZW50IGRvY3VtZW50LCBhbmQgbGF0ZXIgcmVzb2x2ZWQgdG8gYSByZWFsIHNlbGVjdGlvbiBmb3IgYVxuICAgIGdpdmVuIGRvY3VtZW50IGFnYWluLiAoVGhpcyBpcyB1c2VkIG1vc3RseSBieSB0aGUgaGlzdG9yeSB0b1xuICAgIHRyYWNrIGFuZCByZXN0b3JlIG9sZCBzZWxlY3Rpb25zLikgVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2ZcbiAgICB0aGlzIG1ldGhvZCBqdXN0IGNvbnZlcnRzIHRoZSBzZWxlY3Rpb24gdG8gYSB0ZXh0IHNlbGVjdGlvbiBhbmRcbiAgICByZXR1cm5zIHRoZSBib29rbWFyayBmb3IgdGhhdC5cbiAgICAqL1xuICAgIGdldEJvb2ttYXJrKCkge1xuICAgICAgICByZXR1cm4gVGV4dFNlbGVjdGlvbi5iZXR3ZWVuKHRoaXMuJGFuY2hvciwgdGhpcy4kaGVhZCkuZ2V0Qm9va21hcmsoKTtcbiAgICB9XG59XG5TZWxlY3Rpb24ucHJvdG90eXBlLnZpc2libGUgPSB0cnVlO1xuLyoqXG5SZXByZXNlbnRzIGEgc2VsZWN0ZWQgcmFuZ2UgaW4gYSBkb2N1bWVudC5cbiovXG5jbGFzcyBTZWxlY3Rpb25SYW5nZSB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgcmFuZ2UuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbG93ZXIgYm91bmQgb2YgdGhlIHJhbmdlLlxuICAgICovXG4gICAgJGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSB1cHBlciBib3VuZCBvZiB0aGUgcmFuZ2UuXG4gICAgKi9cbiAgICAkdG8pIHtcbiAgICAgICAgdGhpcy4kZnJvbSA9ICRmcm9tO1xuICAgICAgICB0aGlzLiR0byA9ICR0bztcbiAgICB9XG59XG5sZXQgd2FybmVkQWJvdXRUZXh0U2VsZWN0aW9uID0gZmFsc2U7XG5mdW5jdGlvbiBjaGVja1RleHRTZWxlY3Rpb24oJHBvcykge1xuICAgIGlmICghd2FybmVkQWJvdXRUZXh0U2VsZWN0aW9uICYmICEkcG9zLnBhcmVudC5pbmxpbmVDb250ZW50KSB7XG4gICAgICAgIHdhcm5lZEFib3V0VGV4dFNlbGVjdGlvbiA9IHRydWU7XG4gICAgICAgIGNvbnNvbGVbXCJ3YXJuXCJdKFwiVGV4dFNlbGVjdGlvbiBlbmRwb2ludCBub3QgcG9pbnRpbmcgaW50byBhIG5vZGUgd2l0aCBpbmxpbmUgY29udGVudCAoXCIgKyAkcG9zLnBhcmVudC50eXBlLm5hbWUgKyBcIilcIik7XG4gICAgfVxufVxuLyoqXG5BIHRleHQgc2VsZWN0aW9uIHJlcHJlc2VudHMgYSBjbGFzc2ljYWwgZWRpdG9yIHNlbGVjdGlvbiwgd2l0aCBhXG5oZWFkICh0aGUgbW92aW5nIHNpZGUpIGFuZCBhbmNob3IgKGltbW9iaWxlIHNpZGUpLCBib3RoIG9mIHdoaWNoXG5wb2ludCBpbnRvIHRleHRibG9jayBub2Rlcy4gSXQgY2FuIGJlIGVtcHR5IChhIHJlZ3VsYXIgY3Vyc29yXG5wb3NpdGlvbikuXG4qL1xuY2xhc3MgVGV4dFNlbGVjdGlvbiBleHRlbmRzIFNlbGVjdGlvbiB7XG4gICAgLyoqXG4gICAgQ29uc3RydWN0IGEgdGV4dCBzZWxlY3Rpb24gYmV0d2VlbiB0aGUgZ2l2ZW4gcG9pbnRzLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoJGFuY2hvciwgJGhlYWQgPSAkYW5jaG9yKSB7XG4gICAgICAgIGNoZWNrVGV4dFNlbGVjdGlvbigkYW5jaG9yKTtcbiAgICAgICAgY2hlY2tUZXh0U2VsZWN0aW9uKCRoZWFkKTtcbiAgICAgICAgc3VwZXIoJGFuY2hvciwgJGhlYWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIGEgcmVzb2x2ZWQgcG9zaXRpb24gaWYgdGhpcyBpcyBhIGN1cnNvciBzZWxlY3Rpb24gKGFuXG4gICAgZW1wdHkgdGV4dCBzZWxlY3Rpb24pLCBhbmQgbnVsbCBvdGhlcndpc2UuXG4gICAgKi9cbiAgICBnZXQgJGN1cnNvcigpIHsgcmV0dXJuIHRoaXMuJGFuY2hvci5wb3MgPT0gdGhpcy4kaGVhZC5wb3MgPyB0aGlzLiRoZWFkIDogbnVsbDsgfVxuICAgIG1hcChkb2MsIG1hcHBpbmcpIHtcbiAgICAgICAgbGV0ICRoZWFkID0gZG9jLnJlc29sdmUobWFwcGluZy5tYXAodGhpcy5oZWFkKSk7XG4gICAgICAgIGlmICghJGhlYWQucGFyZW50LmlubGluZUNvbnRlbnQpXG4gICAgICAgICAgICByZXR1cm4gU2VsZWN0aW9uLm5lYXIoJGhlYWQpO1xuICAgICAgICBsZXQgJGFuY2hvciA9IGRvYy5yZXNvbHZlKG1hcHBpbmcubWFwKHRoaXMuYW5jaG9yKSk7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dFNlbGVjdGlvbigkYW5jaG9yLnBhcmVudC5pbmxpbmVDb250ZW50ID8gJGFuY2hvciA6ICRoZWFkLCAkaGVhZCk7XG4gICAgfVxuICAgIHJlcGxhY2UodHIsIGNvbnRlbnQgPSBTbGljZS5lbXB0eSkge1xuICAgICAgICBzdXBlci5yZXBsYWNlKHRyLCBjb250ZW50KTtcbiAgICAgICAgaWYgKGNvbnRlbnQgPT0gU2xpY2UuZW1wdHkpIHtcbiAgICAgICAgICAgIGxldCBtYXJrcyA9IHRoaXMuJGZyb20ubWFya3NBY3Jvc3ModGhpcy4kdG8pO1xuICAgICAgICAgICAgaWYgKG1hcmtzKVxuICAgICAgICAgICAgICAgIHRyLmVuc3VyZU1hcmtzKG1hcmtzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlcShvdGhlcikge1xuICAgICAgICByZXR1cm4gb3RoZXIgaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uICYmIG90aGVyLmFuY2hvciA9PSB0aGlzLmFuY2hvciAmJiBvdGhlci5oZWFkID09IHRoaXMuaGVhZDtcbiAgICB9XG4gICAgZ2V0Qm9va21hcmsoKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dEJvb2ttYXJrKHRoaXMuYW5jaG9yLCB0aGlzLmhlYWQpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwidGV4dFwiLCBhbmNob3I6IHRoaXMuYW5jaG9yLCBoZWFkOiB0aGlzLmhlYWQgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oZG9jLCBqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5hbmNob3IgIT0gXCJudW1iZXJcIiB8fCB0eXBlb2YganNvbi5oZWFkICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIFRleHRTZWxlY3Rpb24uZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dFNlbGVjdGlvbihkb2MucmVzb2x2ZShqc29uLmFuY2hvciksIGRvYy5yZXNvbHZlKGpzb24uaGVhZCkpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSB0ZXh0IHNlbGVjdGlvbiBmcm9tIG5vbi1yZXNvbHZlZCBwb3NpdGlvbnMuXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGRvYywgYW5jaG9yLCBoZWFkID0gYW5jaG9yKSB7XG4gICAgICAgIGxldCAkYW5jaG9yID0gZG9jLnJlc29sdmUoYW5jaG9yKTtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzKCRhbmNob3IsIGhlYWQgPT0gYW5jaG9yID8gJGFuY2hvciA6IGRvYy5yZXNvbHZlKGhlYWQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJuIGEgdGV4dCBzZWxlY3Rpb24gdGhhdCBzcGFucyB0aGUgZ2l2ZW4gcG9zaXRpb25zIG9yLCBpZlxuICAgIHRoZXkgYXJlbid0IHRleHQgcG9zaXRpb25zLCBmaW5kIGEgdGV4dCBzZWxlY3Rpb24gbmVhciB0aGVtLlxuICAgIGBiaWFzYCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG1ldGhvZCBzZWFyY2hlcyBmb3J3YXJkIChkZWZhdWx0KVxuICAgIG9yIGJhY2t3YXJkcyAobmVnYXRpdmUgbnVtYmVyKSBmaXJzdC4gV2lsbCBmYWxsIGJhY2sgdG8gY2FsbGluZ1xuICAgIFtgU2VsZWN0aW9uLm5lYXJgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuU2VsZWN0aW9uXm5lYXIpIHdoZW4gdGhlIGRvY3VtZW50XG4gICAgZG9lc24ndCBjb250YWluIGEgdmFsaWQgdGV4dCBwb3NpdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBiZXR3ZWVuKCRhbmNob3IsICRoZWFkLCBiaWFzKSB7XG4gICAgICAgIGxldCBkUG9zID0gJGFuY2hvci5wb3MgLSAkaGVhZC5wb3M7XG4gICAgICAgIGlmICghYmlhcyB8fCBkUG9zKVxuICAgICAgICAgICAgYmlhcyA9IGRQb3MgPj0gMCA/IDEgOiAtMTtcbiAgICAgICAgaWYgKCEkaGVhZC5wYXJlbnQuaW5saW5lQ29udGVudCkge1xuICAgICAgICAgICAgbGV0IGZvdW5kID0gU2VsZWN0aW9uLmZpbmRGcm9tKCRoZWFkLCBiaWFzLCB0cnVlKSB8fCBTZWxlY3Rpb24uZmluZEZyb20oJGhlYWQsIC1iaWFzLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChmb3VuZClcbiAgICAgICAgICAgICAgICAkaGVhZCA9IGZvdW5kLiRoZWFkO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiBTZWxlY3Rpb24ubmVhcigkaGVhZCwgYmlhcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEkYW5jaG9yLnBhcmVudC5pbmxpbmVDb250ZW50KSB7XG4gICAgICAgICAgICBpZiAoZFBvcyA9PSAwKSB7XG4gICAgICAgICAgICAgICAgJGFuY2hvciA9ICRoZWFkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgJGFuY2hvciA9IChTZWxlY3Rpb24uZmluZEZyb20oJGFuY2hvciwgLWJpYXMsIHRydWUpIHx8IFNlbGVjdGlvbi5maW5kRnJvbSgkYW5jaG9yLCBiaWFzLCB0cnVlKSkuJGFuY2hvcjtcbiAgICAgICAgICAgICAgICBpZiAoKCRhbmNob3IucG9zIDwgJGhlYWQucG9zKSAhPSAoZFBvcyA8IDApKVxuICAgICAgICAgICAgICAgICAgICAkYW5jaG9yID0gJGhlYWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0U2VsZWN0aW9uKCRhbmNob3IsICRoZWFkKTtcbiAgICB9XG59XG5TZWxlY3Rpb24uanNvbklEKFwidGV4dFwiLCBUZXh0U2VsZWN0aW9uKTtcbmNsYXNzIFRleHRCb29rbWFyayB7XG4gICAgY29uc3RydWN0b3IoYW5jaG9yLCBoZWFkKSB7XG4gICAgICAgIHRoaXMuYW5jaG9yID0gYW5jaG9yO1xuICAgICAgICB0aGlzLmhlYWQgPSBoZWFkO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICByZXR1cm4gbmV3IFRleHRCb29rbWFyayhtYXBwaW5nLm1hcCh0aGlzLmFuY2hvciksIG1hcHBpbmcubWFwKHRoaXMuaGVhZCkpO1xuICAgIH1cbiAgICByZXNvbHZlKGRvYykge1xuICAgICAgICByZXR1cm4gVGV4dFNlbGVjdGlvbi5iZXR3ZWVuKGRvYy5yZXNvbHZlKHRoaXMuYW5jaG9yKSwgZG9jLnJlc29sdmUodGhpcy5oZWFkKSk7XG4gICAgfVxufVxuLyoqXG5BIG5vZGUgc2VsZWN0aW9uIGlzIGEgc2VsZWN0aW9uIHRoYXQgcG9pbnRzIGF0IGEgc2luZ2xlIG5vZGUuIEFsbFxubm9kZXMgbWFya2VkIFtzZWxlY3RhYmxlXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMuc2VsZWN0YWJsZSkgY2FuIGJlIHRoZVxudGFyZ2V0IG9mIGEgbm9kZSBzZWxlY3Rpb24uIEluIHN1Y2ggYSBzZWxlY3Rpb24sIGBmcm9tYCBhbmQgYHRvYFxucG9pbnQgZGlyZWN0bHkgYmVmb3JlIGFuZCBhZnRlciB0aGUgc2VsZWN0ZWQgbm9kZSwgYGFuY2hvcmAgZXF1YWxzXG5gZnJvbWAsIGFuZCBgaGVhZGAgZXF1YWxzIGB0b2AuLlxuKi9cbmNsYXNzIE5vZGVTZWxlY3Rpb24gZXh0ZW5kcyBTZWxlY3Rpb24ge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5vZGUgc2VsZWN0aW9uLiBEb2VzIG5vdCB2ZXJpZnkgdGhlIHZhbGlkaXR5IG9mIGl0c1xuICAgIGFyZ3VtZW50LlxuICAgICovXG4gICAgY29uc3RydWN0b3IoJHBvcykge1xuICAgICAgICBsZXQgbm9kZSA9ICRwb3Mubm9kZUFmdGVyO1xuICAgICAgICBsZXQgJGVuZCA9ICRwb3Mubm9kZSgwKS5yZXNvbHZlKCRwb3MucG9zICsgbm9kZS5ub2RlU2l6ZSk7XG4gICAgICAgIHN1cGVyKCRwb3MsICRlbmQpO1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgIH1cbiAgICBtYXAoZG9jLCBtYXBwaW5nKSB7XG4gICAgICAgIGxldCB7IGRlbGV0ZWQsIHBvcyB9ID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy5hbmNob3IpO1xuICAgICAgICBsZXQgJHBvcyA9IGRvYy5yZXNvbHZlKHBvcyk7XG4gICAgICAgIGlmIChkZWxldGVkKVxuICAgICAgICAgICAgcmV0dXJuIFNlbGVjdGlvbi5uZWFyKCRwb3MpO1xuICAgICAgICByZXR1cm4gbmV3IE5vZGVTZWxlY3Rpb24oJHBvcyk7XG4gICAgfVxuICAgIGNvbnRlbnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbSh0aGlzLm5vZGUpLCAwLCAwKTtcbiAgICB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG90aGVyIGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbiAmJiBvdGhlci5hbmNob3IgPT0gdGhpcy5hbmNob3I7XG4gICAgfVxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJub2RlXCIsIGFuY2hvcjogdGhpcy5hbmNob3IgfTtcbiAgICB9XG4gICAgZ2V0Qm9va21hcmsoKSB7IHJldHVybiBuZXcgTm9kZUJvb2ttYXJrKHRoaXMuYW5jaG9yKTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGljIGZyb21KU09OKGRvYywganNvbikge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24uYW5jaG9yICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIE5vZGVTZWxlY3Rpb24uZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgTm9kZVNlbGVjdGlvbihkb2MucmVzb2x2ZShqc29uLmFuY2hvcikpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBub2RlIHNlbGVjdGlvbiBmcm9tIG5vbi1yZXNvbHZlZCBwb3NpdGlvbnMuXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGRvYywgZnJvbSkge1xuICAgICAgICByZXR1cm4gbmV3IE5vZGVTZWxlY3Rpb24oZG9jLnJlc29sdmUoZnJvbSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGdpdmVuIG5vZGUgbWF5IGJlIHNlbGVjdGVkIGFzIGEgbm9kZVxuICAgIHNlbGVjdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBpc1NlbGVjdGFibGUobm9kZSkge1xuICAgICAgICByZXR1cm4gIW5vZGUuaXNUZXh0ICYmIG5vZGUudHlwZS5zcGVjLnNlbGVjdGFibGUgIT09IGZhbHNlO1xuICAgIH1cbn1cbk5vZGVTZWxlY3Rpb24ucHJvdG90eXBlLnZpc2libGUgPSBmYWxzZTtcblNlbGVjdGlvbi5qc29uSUQoXCJub2RlXCIsIE5vZGVTZWxlY3Rpb24pO1xuY2xhc3MgTm9kZUJvb2ttYXJrIHtcbiAgICBjb25zdHJ1Y3RvcihhbmNob3IpIHtcbiAgICAgICAgdGhpcy5hbmNob3IgPSBhbmNob3I7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIGxldCB7IGRlbGV0ZWQsIHBvcyB9ID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy5hbmNob3IpO1xuICAgICAgICByZXR1cm4gZGVsZXRlZCA/IG5ldyBUZXh0Qm9va21hcmsocG9zLCBwb3MpIDogbmV3IE5vZGVCb29rbWFyayhwb3MpO1xuICAgIH1cbiAgICByZXNvbHZlKGRvYykge1xuICAgICAgICBsZXQgJHBvcyA9IGRvYy5yZXNvbHZlKHRoaXMuYW5jaG9yKSwgbm9kZSA9ICRwb3Mubm9kZUFmdGVyO1xuICAgICAgICBpZiAobm9kZSAmJiBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShub2RlKSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgTm9kZVNlbGVjdGlvbigkcG9zKTtcbiAgICAgICAgcmV0dXJuIFNlbGVjdGlvbi5uZWFyKCRwb3MpO1xuICAgIH1cbn1cbi8qKlxuQSBzZWxlY3Rpb24gdHlwZSB0aGF0IHJlcHJlc2VudHMgc2VsZWN0aW5nIHRoZSB3aG9sZSBkb2N1bWVudFxuKHdoaWNoIGNhbiBub3QgbmVjZXNzYXJpbHkgYmUgZXhwcmVzc2VkIHdpdGggYSB0ZXh0IHNlbGVjdGlvbiwgd2hlblxudGhlcmUgYXJlIGZvciBleGFtcGxlIGxlYWYgYmxvY2sgbm9kZXMgYXQgdGhlIHN0YXJ0IG9yIGVuZCBvZiB0aGVcbmRvY3VtZW50KS5cbiovXG5jbGFzcyBBbGxTZWxlY3Rpb24gZXh0ZW5kcyBTZWxlY3Rpb24ge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBhbGwtc2VsZWN0aW9uIG92ZXIgdGhlIGdpdmVuIGRvY3VtZW50LlxuICAgICovXG4gICAgY29uc3RydWN0b3IoZG9jKSB7XG4gICAgICAgIHN1cGVyKGRvYy5yZXNvbHZlKDApLCBkb2MucmVzb2x2ZShkb2MuY29udGVudC5zaXplKSk7XG4gICAgfVxuICAgIHJlcGxhY2UodHIsIGNvbnRlbnQgPSBTbGljZS5lbXB0eSkge1xuICAgICAgICBpZiAoY29udGVudCA9PSBTbGljZS5lbXB0eSkge1xuICAgICAgICAgICAgdHIuZGVsZXRlKDAsIHRyLmRvYy5jb250ZW50LnNpemUpO1xuICAgICAgICAgICAgbGV0IHNlbCA9IFNlbGVjdGlvbi5hdFN0YXJ0KHRyLmRvYyk7XG4gICAgICAgICAgICBpZiAoIXNlbC5lcSh0ci5zZWxlY3Rpb24pKVxuICAgICAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbihzZWwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3VwZXIucmVwbGFjZSh0ciwgY29udGVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9KU09OKCkgeyByZXR1cm4geyB0eXBlOiBcImFsbFwiIH07IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihkb2MpIHsgcmV0dXJuIG5ldyBBbGxTZWxlY3Rpb24oZG9jKTsgfVxuICAgIG1hcChkb2MpIHsgcmV0dXJuIG5ldyBBbGxTZWxlY3Rpb24oZG9jKTsgfVxuICAgIGVxKG90aGVyKSB7IHJldHVybiBvdGhlciBpbnN0YW5jZW9mIEFsbFNlbGVjdGlvbjsgfVxuICAgIGdldEJvb2ttYXJrKCkgeyByZXR1cm4gQWxsQm9va21hcms7IH1cbn1cblNlbGVjdGlvbi5qc29uSUQoXCJhbGxcIiwgQWxsU2VsZWN0aW9uKTtcbmNvbnN0IEFsbEJvb2ttYXJrID0ge1xuICAgIG1hcCgpIHsgcmV0dXJuIHRoaXM7IH0sXG4gICAgcmVzb2x2ZShkb2MpIHsgcmV0dXJuIG5ldyBBbGxTZWxlY3Rpb24oZG9jKTsgfVxufTtcbi8vIEZJWE1FIHdlJ2xsIG5lZWQgc29tZSBhd2FyZW5lc3Mgb2YgdGV4dCBkaXJlY3Rpb24gd2hlbiBzY2FubmluZyBmb3Igc2VsZWN0aW9uc1xuLy8gVHJ5IHRvIGZpbmQgYSBzZWxlY3Rpb24gaW5zaWRlIHRoZSBnaXZlbiBub2RlLiBgcG9zYCBwb2ludHMgYXQgdGhlXG4vLyBwb3NpdGlvbiB3aGVyZSB0aGUgc2VhcmNoIHN0YXJ0cy4gV2hlbiBgdGV4dGAgaXMgdHJ1ZSwgb25seSByZXR1cm5cbi8vIHRleHQgc2VsZWN0aW9ucy5cbmZ1bmN0aW9uIGZpbmRTZWxlY3Rpb25Jbihkb2MsIG5vZGUsIHBvcywgaW5kZXgsIGRpciwgdGV4dCA9IGZhbHNlKSB7XG4gICAgaWYgKG5vZGUuaW5saW5lQ29udGVudClcbiAgICAgICAgcmV0dXJuIFRleHRTZWxlY3Rpb24uY3JlYXRlKGRvYywgcG9zKTtcbiAgICBmb3IgKGxldCBpID0gaW5kZXggLSAoZGlyID4gMCA/IDAgOiAxKTsgZGlyID4gMCA/IGkgPCBub2RlLmNoaWxkQ291bnQgOiBpID49IDA7IGkgKz0gZGlyKSB7XG4gICAgICAgIGxldCBjaGlsZCA9IG5vZGUuY2hpbGQoaSk7XG4gICAgICAgIGlmICghY2hpbGQuaXNBdG9tKSB7XG4gICAgICAgICAgICBsZXQgaW5uZXIgPSBmaW5kU2VsZWN0aW9uSW4oZG9jLCBjaGlsZCwgcG9zICsgZGlyLCBkaXIgPCAwID8gY2hpbGQuY2hpbGRDb3VudCA6IDAsIGRpciwgdGV4dCk7XG4gICAgICAgICAgICBpZiAoaW5uZXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlubmVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0ZXh0ICYmIE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKGNoaWxkKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5vZGVTZWxlY3Rpb24uY3JlYXRlKGRvYywgcG9zIC0gKGRpciA8IDAgPyBjaGlsZC5ub2RlU2l6ZSA6IDApKTtcbiAgICAgICAgfVxuICAgICAgICBwb3MgKz0gY2hpbGQubm9kZVNpemUgKiBkaXI7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gc2VsZWN0aW9uVG9JbnNlcnRpb25FbmQodHIsIHN0YXJ0TGVuLCBiaWFzKSB7XG4gICAgbGV0IGxhc3QgPSB0ci5zdGVwcy5sZW5ndGggLSAxO1xuICAgIGlmIChsYXN0IDwgc3RhcnRMZW4pXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgc3RlcCA9IHRyLnN0ZXBzW2xhc3RdO1xuICAgIGlmICghKHN0ZXAgaW5zdGFuY2VvZiBSZXBsYWNlU3RlcCB8fCBzdGVwIGluc3RhbmNlb2YgUmVwbGFjZUFyb3VuZFN0ZXApKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IG1hcCA9IHRyLm1hcHBpbmcubWFwc1tsYXN0XSwgZW5kO1xuICAgIG1hcC5mb3JFYWNoKChfZnJvbSwgX3RvLCBfbmV3RnJvbSwgbmV3VG8pID0+IHsgaWYgKGVuZCA9PSBudWxsKVxuICAgICAgICBlbmQgPSBuZXdUbzsgfSk7XG4gICAgdHIuc2V0U2VsZWN0aW9uKFNlbGVjdGlvbi5uZWFyKHRyLmRvYy5yZXNvbHZlKGVuZCksIGJpYXMpKTtcbn1cblxuY29uc3QgVVBEQVRFRF9TRUwgPSAxLCBVUERBVEVEX01BUktTID0gMiwgVVBEQVRFRF9TQ1JPTEwgPSA0O1xuLyoqXG5BbiBlZGl0b3Igc3RhdGUgdHJhbnNhY3Rpb24sIHdoaWNoIGNhbiBiZSBhcHBsaWVkIHRvIGEgc3RhdGUgdG9cbmNyZWF0ZSBhbiB1cGRhdGVkIHN0YXRlLiBVc2VcbltgRWRpdG9yU3RhdGUudHJgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUudHIpIHRvIGNyZWF0ZSBhbiBpbnN0YW5jZS5cblxuVHJhbnNhY3Rpb25zIHRyYWNrIGNoYW5nZXMgdG8gdGhlIGRvY3VtZW50ICh0aGV5IGFyZSBhIHN1YmNsYXNzIG9mXG5bYFRyYW5zZm9ybWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN0cmFuc2Zvcm0uVHJhbnNmb3JtKSksIGJ1dCBhbHNvIG90aGVyIHN0YXRlIGNoYW5nZXMsXG5saWtlIHNlbGVjdGlvbiB1cGRhdGVzIGFuZCBhZGp1c3RtZW50cyBvZiB0aGUgc2V0IG9mIFtzdG9yZWRcbm1hcmtzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUuc3RvcmVkTWFya3MpLiBJbiBhZGRpdGlvbiwgeW91IGNhbiBzdG9yZVxubWV0YWRhdGEgcHJvcGVydGllcyBpbiBhIHRyYW5zYWN0aW9uLCB3aGljaCBhcmUgZXh0cmEgcGllY2VzIG9mXG5pbmZvcm1hdGlvbiB0aGF0IGNsaWVudCBjb2RlIG9yIHBsdWdpbnMgY2FuIHVzZSB0byBkZXNjcmliZSB3aGF0IGFcbnRyYW5zYWN0aW9uIHJlcHJlc2VudHMsIHNvIHRoYXQgdGhleSBjYW4gdXBkYXRlIHRoZWlyIFtvd25cbnN0YXRlXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuU3RhdGVGaWVsZCkgYWNjb3JkaW5nbHkuXG5cblRoZSBbZWRpdG9yIHZpZXddKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3LkVkaXRvclZpZXcpIHVzZXMgYSBmZXcgbWV0YWRhdGFcbnByb3BlcnRpZXM6IGl0IHdpbGwgYXR0YWNoIGEgcHJvcGVydHkgYFwicG9pbnRlclwiYCB3aXRoIHRoZSB2YWx1ZVxuYHRydWVgIHRvIHNlbGVjdGlvbiB0cmFuc2FjdGlvbnMgZGlyZWN0bHkgY2F1c2VkIGJ5IG1vdXNlIG9yIHRvdWNoXG5pbnB1dCwgYSBgXCJjb21wb3NpdGlvblwiYCBwcm9wZXJ0eSBob2xkaW5nIGFuIElEIGlkZW50aWZ5aW5nIHRoZVxuY29tcG9zaXRpb24gdGhhdCBjYXVzZWQgaXQgdG8gdHJhbnNhY3Rpb25zIGNhdXNlZCBieSBjb21wb3NlZCBET01cbmlucHV0LCBhbmQgYSBgXCJ1aUV2ZW50XCJgIHByb3BlcnR5IG9mIHRoYXQgbWF5IGJlIGBcInBhc3RlXCJgLFxuYFwiY3V0XCJgLCBvciBgXCJkcm9wXCJgLlxuKi9cbmNsYXNzIFRyYW5zYWN0aW9uIGV4dGVuZHMgVHJhbnNmb3JtIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHN0YXRlKSB7XG4gICAgICAgIHN1cGVyKHN0YXRlLmRvYyk7XG4gICAgICAgIC8vIFRoZSBzdGVwIGNvdW50IGZvciB3aGljaCB0aGUgY3VycmVudCBzZWxlY3Rpb24gaXMgdmFsaWQuXG4gICAgICAgIHRoaXMuY3VyU2VsZWN0aW9uRm9yID0gMDtcbiAgICAgICAgLy8gQml0ZmllbGQgdG8gdHJhY2sgd2hpY2ggYXNwZWN0cyBvZiB0aGUgc3RhdGUgd2VyZSB1cGRhdGVkIGJ5XG4gICAgICAgIC8vIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgICAgIHRoaXMudXBkYXRlZCA9IDA7XG4gICAgICAgIC8vIE9iamVjdCB1c2VkIHRvIHN0b3JlIG1ldGFkYXRhIHByb3BlcnRpZXMgZm9yIHRoZSB0cmFuc2FjdGlvbi5cbiAgICAgICAgdGhpcy5tZXRhID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy50aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy5jdXJTZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIHRoaXMuc3RvcmVkTWFya3MgPSBzdGF0ZS5zdG9yZWRNYXJrcztcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHRyYW5zYWN0aW9uJ3MgY3VycmVudCBzZWxlY3Rpb24uIFRoaXMgZGVmYXVsdHMgdG8gdGhlIGVkaXRvclxuICAgIHNlbGVjdGlvbiBbbWFwcGVkXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuU2VsZWN0aW9uLm1hcCkgdGhyb3VnaCB0aGUgc3RlcHMgaW4gdGhlXG4gICAgdHJhbnNhY3Rpb24sIGJ1dCBjYW4gYmUgb3ZlcndyaXR0ZW4gd2l0aFxuICAgIFtgc2V0U2VsZWN0aW9uYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uLnNldFNlbGVjdGlvbikuXG4gICAgKi9cbiAgICBnZXQgc2VsZWN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJTZWxlY3Rpb25Gb3IgPCB0aGlzLnN0ZXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5jdXJTZWxlY3Rpb24gPSB0aGlzLmN1clNlbGVjdGlvbi5tYXAodGhpcy5kb2MsIHRoaXMubWFwcGluZy5zbGljZSh0aGlzLmN1clNlbGVjdGlvbkZvcikpO1xuICAgICAgICAgICAgdGhpcy5jdXJTZWxlY3Rpb25Gb3IgPSB0aGlzLnN0ZXBzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jdXJTZWxlY3Rpb247XG4gICAgfVxuICAgIC8qKlxuICAgIFVwZGF0ZSB0aGUgdHJhbnNhY3Rpb24ncyBjdXJyZW50IHNlbGVjdGlvbi4gV2lsbCBkZXRlcm1pbmUgdGhlXG4gICAgc2VsZWN0aW9uIHRoYXQgdGhlIGVkaXRvciBnZXRzIHdoZW4gdGhlIHRyYW5zYWN0aW9uIGlzIGFwcGxpZWQuXG4gICAgKi9cbiAgICBzZXRTZWxlY3Rpb24oc2VsZWN0aW9uKSB7XG4gICAgICAgIGlmIChzZWxlY3Rpb24uJGZyb20uZG9jICE9IHRoaXMuZG9jKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJTZWxlY3Rpb24gcGFzc2VkIHRvIHNldFNlbGVjdGlvbiBtdXN0IHBvaW50IGF0IHRoZSBjdXJyZW50IGRvY3VtZW50XCIpO1xuICAgICAgICB0aGlzLmN1clNlbGVjdGlvbiA9IHNlbGVjdGlvbjtcbiAgICAgICAgdGhpcy5jdXJTZWxlY3Rpb25Gb3IgPSB0aGlzLnN0ZXBzLmxlbmd0aDtcbiAgICAgICAgdGhpcy51cGRhdGVkID0gKHRoaXMudXBkYXRlZCB8IFVQREFURURfU0VMKSAmIH5VUERBVEVEX01BUktTO1xuICAgICAgICB0aGlzLnN0b3JlZE1hcmtzID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFdoZXRoZXIgdGhlIHNlbGVjdGlvbiB3YXMgZXhwbGljaXRseSB1cGRhdGVkIGJ5IHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgKi9cbiAgICBnZXQgc2VsZWN0aW9uU2V0KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudXBkYXRlZCAmIFVQREFURURfU0VMKSA+IDA7XG4gICAgfVxuICAgIC8qKlxuICAgIFNldCB0aGUgY3VycmVudCBzdG9yZWQgbWFya3MuXG4gICAgKi9cbiAgICBzZXRTdG9yZWRNYXJrcyhtYXJrcykge1xuICAgICAgICB0aGlzLnN0b3JlZE1hcmtzID0gbWFya3M7XG4gICAgICAgIHRoaXMudXBkYXRlZCB8PSBVUERBVEVEX01BUktTO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgTWFrZSBzdXJlIHRoZSBjdXJyZW50IHN0b3JlZCBtYXJrcyBvciwgaWYgdGhhdCBpcyBudWxsLCB0aGUgbWFya3NcbiAgICBhdCB0aGUgc2VsZWN0aW9uLCBtYXRjaCB0aGUgZ2l2ZW4gc2V0IG9mIG1hcmtzLiBEb2VzIG5vdGhpbmcgaWZcbiAgICB0aGlzIGlzIGFscmVhZHkgdGhlIGNhc2UuXG4gICAgKi9cbiAgICBlbnN1cmVNYXJrcyhtYXJrcykge1xuICAgICAgICBpZiAoIU1hcmsuc2FtZVNldCh0aGlzLnN0b3JlZE1hcmtzIHx8IHRoaXMuc2VsZWN0aW9uLiRmcm9tLm1hcmtzKCksIG1hcmtzKSlcbiAgICAgICAgICAgIHRoaXMuc2V0U3RvcmVkTWFya3MobWFya3MpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgQWRkIGEgbWFyayB0byB0aGUgc2V0IG9mIHN0b3JlZCBtYXJrcy5cbiAgICAqL1xuICAgIGFkZFN0b3JlZE1hcmsobWFyaykge1xuICAgICAgICByZXR1cm4gdGhpcy5lbnN1cmVNYXJrcyhtYXJrLmFkZFRvU2V0KHRoaXMuc3RvcmVkTWFya3MgfHwgdGhpcy5zZWxlY3Rpb24uJGhlYWQubWFya3MoKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZW1vdmUgYSBtYXJrIG9yIG1hcmsgdHlwZSBmcm9tIHRoZSBzZXQgb2Ygc3RvcmVkIG1hcmtzLlxuICAgICovXG4gICAgcmVtb3ZlU3RvcmVkTWFyayhtYXJrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuc3VyZU1hcmtzKG1hcmsucmVtb3ZlRnJvbVNldCh0aGlzLnN0b3JlZE1hcmtzIHx8IHRoaXMuc2VsZWN0aW9uLiRoZWFkLm1hcmtzKCkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgV2hldGhlciB0aGUgc3RvcmVkIG1hcmtzIHdlcmUgZXhwbGljaXRseSBzZXQgZm9yIHRoaXMgdHJhbnNhY3Rpb24uXG4gICAgKi9cbiAgICBnZXQgc3RvcmVkTWFya3NTZXQoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy51cGRhdGVkICYgVVBEQVRFRF9NQVJLUykgPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGFkZFN0ZXAoc3RlcCwgZG9jKSB7XG4gICAgICAgIHN1cGVyLmFkZFN0ZXAoc3RlcCwgZG9jKTtcbiAgICAgICAgdGhpcy51cGRhdGVkID0gdGhpcy51cGRhdGVkICYgflVQREFURURfTUFSS1M7XG4gICAgICAgIHRoaXMuc3RvcmVkTWFya3MgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBVcGRhdGUgdGhlIHRpbWVzdGFtcCBmb3IgdGhlIHRyYW5zYWN0aW9uLlxuICAgICovXG4gICAgc2V0VGltZSh0aW1lKSB7XG4gICAgICAgIHRoaXMudGltZSA9IHRpbWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIHRoZSBjdXJyZW50IHNlbGVjdGlvbiB3aXRoIHRoZSBnaXZlbiBzbGljZS5cbiAgICAqL1xuICAgIHJlcGxhY2VTZWxlY3Rpb24oc2xpY2UpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24ucmVwbGFjZSh0aGlzLCBzbGljZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIHRoZSBzZWxlY3Rpb24gd2l0aCB0aGUgZ2l2ZW4gbm9kZS4gV2hlbiBgaW5oZXJpdE1hcmtzYCBpc1xuICAgIHRydWUgYW5kIHRoZSBjb250ZW50IGlzIGlubGluZSwgaXQgaW5oZXJpdHMgdGhlIG1hcmtzIGZyb20gdGhlXG4gICAgcGxhY2Ugd2hlcmUgaXQgaXMgaW5zZXJ0ZWQuXG4gICAgKi9cbiAgICByZXBsYWNlU2VsZWN0aW9uV2l0aChub2RlLCBpbmhlcml0TWFya3MgPSB0cnVlKSB7XG4gICAgICAgIGxldCBzZWxlY3Rpb24gPSB0aGlzLnNlbGVjdGlvbjtcbiAgICAgICAgaWYgKGluaGVyaXRNYXJrcylcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLm1hcmsodGhpcy5zdG9yZWRNYXJrcyB8fCAoc2VsZWN0aW9uLmVtcHR5ID8gc2VsZWN0aW9uLiRmcm9tLm1hcmtzKCkgOiAoc2VsZWN0aW9uLiRmcm9tLm1hcmtzQWNyb3NzKHNlbGVjdGlvbi4kdG8pIHx8IE1hcmsubm9uZSkpKTtcbiAgICAgICAgc2VsZWN0aW9uLnJlcGxhY2VXaXRoKHRoaXMsIG5vZGUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgRGVsZXRlIHRoZSBzZWxlY3Rpb24uXG4gICAgKi9cbiAgICBkZWxldGVTZWxlY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLnJlcGxhY2UodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIHRoZSBnaXZlbiByYW5nZSwgb3IgdGhlIHNlbGVjdGlvbiBpZiBubyByYW5nZSBpcyBnaXZlbixcbiAgICB3aXRoIGEgdGV4dCBub2RlIGNvbnRhaW5pbmcgdGhlIGdpdmVuIHN0cmluZy5cbiAgICAqL1xuICAgIGluc2VydFRleHQodGV4dCwgZnJvbSwgdG8pIHtcbiAgICAgICAgbGV0IHNjaGVtYSA9IHRoaXMuZG9jLnR5cGUuc2NoZW1hO1xuICAgICAgICBpZiAoZnJvbSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoIXRleHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVsZXRlU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlU2VsZWN0aW9uV2l0aChzY2hlbWEudGV4dCh0ZXh0KSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodG8gPT0gbnVsbClcbiAgICAgICAgICAgICAgICB0byA9IGZyb207XG4gICAgICAgICAgICB0byA9IHRvID09IG51bGwgPyBmcm9tIDogdG87XG4gICAgICAgICAgICBpZiAoIXRleHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVsZXRlUmFuZ2UoZnJvbSwgdG8pO1xuICAgICAgICAgICAgbGV0IG1hcmtzID0gdGhpcy5zdG9yZWRNYXJrcztcbiAgICAgICAgICAgIGlmICghbWFya3MpIHtcbiAgICAgICAgICAgICAgICBsZXQgJGZyb20gPSB0aGlzLmRvYy5yZXNvbHZlKGZyb20pO1xuICAgICAgICAgICAgICAgIG1hcmtzID0gdG8gPT0gZnJvbSA/ICRmcm9tLm1hcmtzKCkgOiAkZnJvbS5tYXJrc0Fjcm9zcyh0aGlzLmRvYy5yZXNvbHZlKHRvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJlcGxhY2VSYW5nZVdpdGgoZnJvbSwgdG8sIHNjaGVtYS50ZXh0KHRleHQsIG1hcmtzKSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2VsZWN0aW9uLmVtcHR5KVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U2VsZWN0aW9uKFNlbGVjdGlvbi5uZWFyKHRoaXMuc2VsZWN0aW9uLiR0bykpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgU3RvcmUgYSBtZXRhZGF0YSBwcm9wZXJ0eSBpbiB0aGlzIHRyYW5zYWN0aW9uLCBrZXllZCBlaXRoZXIgYnlcbiAgICBuYW1lIG9yIGJ5IHBsdWdpbi5cbiAgICAqL1xuICAgIHNldE1ldGEoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLm1ldGFbdHlwZW9mIGtleSA9PSBcInN0cmluZ1wiID8ga2V5IDoga2V5LmtleV0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHJpZXZlIGEgbWV0YWRhdGEgcHJvcGVydHkgZm9yIGEgZ2l2ZW4gbmFtZSBvciBwbHVnaW4uXG4gICAgKi9cbiAgICBnZXRNZXRhKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXRhW3R5cGVvZiBrZXkgPT0gXCJzdHJpbmdcIiA/IGtleSA6IGtleS5rZXldO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRydWUgaWYgdGhpcyB0cmFuc2FjdGlvbiBkb2Vzbid0IGNvbnRhaW4gYW55IG1ldGFkYXRhLFxuICAgIGFuZCBjYW4gdGh1cyBzYWZlbHkgYmUgZXh0ZW5kZWQuXG4gICAgKi9cbiAgICBnZXQgaXNHZW5lcmljKCkge1xuICAgICAgICBmb3IgKGxldCBfIGluIHRoaXMubWV0YSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEluZGljYXRlIHRoYXQgdGhlIGVkaXRvciBzaG91bGQgc2Nyb2xsIHRoZSBzZWxlY3Rpb24gaW50byB2aWV3XG4gICAgd2hlbiB1cGRhdGVkIHRvIHRoZSBzdGF0ZSBwcm9kdWNlZCBieSB0aGlzIHRyYW5zYWN0aW9uLlxuICAgICovXG4gICAgc2Nyb2xsSW50b1ZpZXcoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlZCB8PSBVUERBVEVEX1NDUk9MTDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFRydWUgd2hlbiB0aGlzIHRyYW5zYWN0aW9uIGhhcyBoYWQgYHNjcm9sbEludG9WaWV3YCBjYWxsZWQgb24gaXQuXG4gICAgKi9cbiAgICBnZXQgc2Nyb2xsZWRJbnRvVmlldygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnVwZGF0ZWQgJiBVUERBVEVEX1NDUk9MTCkgPiAwO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYmluZChmLCBzZWxmKSB7XG4gICAgcmV0dXJuICFzZWxmIHx8ICFmID8gZiA6IGYuYmluZChzZWxmKTtcbn1cbmNsYXNzIEZpZWxkRGVzYyB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgZGVzYywgc2VsZikge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmluaXQgPSBiaW5kKGRlc2MuaW5pdCwgc2VsZik7XG4gICAgICAgIHRoaXMuYXBwbHkgPSBiaW5kKGRlc2MuYXBwbHksIHNlbGYpO1xuICAgIH1cbn1cbmNvbnN0IGJhc2VGaWVsZHMgPSBbXG4gICAgbmV3IEZpZWxkRGVzYyhcImRvY1wiLCB7XG4gICAgICAgIGluaXQoY29uZmlnKSB7IHJldHVybiBjb25maWcuZG9jIHx8IGNvbmZpZy5zY2hlbWEudG9wTm9kZVR5cGUuY3JlYXRlQW5kRmlsbCgpOyB9LFxuICAgICAgICBhcHBseSh0cikgeyByZXR1cm4gdHIuZG9jOyB9XG4gICAgfSksXG4gICAgbmV3IEZpZWxkRGVzYyhcInNlbGVjdGlvblwiLCB7XG4gICAgICAgIGluaXQoY29uZmlnLCBpbnN0YW5jZSkgeyByZXR1cm4gY29uZmlnLnNlbGVjdGlvbiB8fCBTZWxlY3Rpb24uYXRTdGFydChpbnN0YW5jZS5kb2MpOyB9LFxuICAgICAgICBhcHBseSh0cikgeyByZXR1cm4gdHIuc2VsZWN0aW9uOyB9XG4gICAgfSksXG4gICAgbmV3IEZpZWxkRGVzYyhcInN0b3JlZE1hcmtzXCIsIHtcbiAgICAgICAgaW5pdChjb25maWcpIHsgcmV0dXJuIGNvbmZpZy5zdG9yZWRNYXJrcyB8fCBudWxsOyB9LFxuICAgICAgICBhcHBseSh0ciwgX21hcmtzLCBfb2xkLCBzdGF0ZSkgeyByZXR1cm4gc3RhdGUuc2VsZWN0aW9uLiRjdXJzb3IgPyB0ci5zdG9yZWRNYXJrcyA6IG51bGw7IH1cbiAgICB9KSxcbiAgICBuZXcgRmllbGREZXNjKFwic2Nyb2xsVG9TZWxlY3Rpb25cIiwge1xuICAgICAgICBpbml0KCkgeyByZXR1cm4gMDsgfSxcbiAgICAgICAgYXBwbHkodHIsIHByZXYpIHsgcmV0dXJuIHRyLnNjcm9sbGVkSW50b1ZpZXcgPyBwcmV2ICsgMSA6IHByZXY7IH1cbiAgICB9KVxuXTtcbi8vIE9iamVjdCB3cmFwcGluZyB0aGUgcGFydCBvZiBhIHN0YXRlIG9iamVjdCB0aGF0IHN0YXlzIHRoZSBzYW1lXG4vLyBhY3Jvc3MgdHJhbnNhY3Rpb25zLiBTdG9yZWQgaW4gdGhlIHN0YXRlJ3MgYGNvbmZpZ2AgcHJvcGVydHkuXG5jbGFzcyBDb25maWd1cmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihzY2hlbWEsIHBsdWdpbnMpIHtcbiAgICAgICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgICAgIHRoaXMucGx1Z2lucyA9IFtdO1xuICAgICAgICB0aGlzLnBsdWdpbnNCeUtleSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuZmllbGRzID0gYmFzZUZpZWxkcy5zbGljZSgpO1xuICAgICAgICBpZiAocGx1Z2lucylcbiAgICAgICAgICAgIHBsdWdpbnMuZm9yRWFjaChwbHVnaW4gPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBsdWdpbnNCeUtleVtwbHVnaW4ua2V5XSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBZGRpbmcgZGlmZmVyZW50IGluc3RhbmNlcyBvZiBhIGtleWVkIHBsdWdpbiAoXCIgKyBwbHVnaW4ua2V5ICsgXCIpXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMucGx1Z2lucy5wdXNoKHBsdWdpbik7XG4gICAgICAgICAgICAgICAgdGhpcy5wbHVnaW5zQnlLZXlbcGx1Z2luLmtleV0gPSBwbHVnaW47XG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpbi5zcGVjLnN0YXRlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpZWxkcy5wdXNoKG5ldyBGaWVsZERlc2MocGx1Z2luLmtleSwgcGx1Z2luLnNwZWMuc3RhdGUsIHBsdWdpbikpO1xuICAgICAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG5UaGUgc3RhdGUgb2YgYSBQcm9zZU1pcnJvciBlZGl0b3IgaXMgcmVwcmVzZW50ZWQgYnkgYW4gb2JqZWN0IG9mXG50aGlzIHR5cGUuIEEgc3RhdGUgaXMgYSBwZXJzaXN0ZW50IGRhdGEgc3RydWN0dXJl4oCUaXQgaXNuJ3RcbnVwZGF0ZWQsIGJ1dCByYXRoZXIgYSBuZXcgc3RhdGUgdmFsdWUgaXMgY29tcHV0ZWQgZnJvbSBhbiBvbGQgb25lXG51c2luZyB0aGUgW2BhcHBseWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5hcHBseSkgbWV0aG9kLlxuXG5BIHN0YXRlIGhvbGRzIGEgbnVtYmVyIG9mIGJ1aWx0LWluIGZpZWxkcywgYW5kIHBsdWdpbnMgY2FuXG5bZGVmaW5lXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuUGx1Z2luU3BlYy5zdGF0ZSkgYWRkaXRpb25hbCBmaWVsZHMuXG4qL1xuY2xhc3MgRWRpdG9yU3RhdGUge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25maWcpIHtcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBzY2hlbWEgb2YgdGhlIHN0YXRlJ3MgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBnZXQgc2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWcuc2NoZW1hO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgcGx1Z2lucyB0aGF0IGFyZSBhY3RpdmUgaW4gdGhpcyBzdGF0ZS5cbiAgICAqL1xuICAgIGdldCBwbHVnaW5zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWcucGx1Z2lucztcbiAgICB9XG4gICAgLyoqXG4gICAgQXBwbHkgdGhlIGdpdmVuIHRyYW5zYWN0aW9uIHRvIHByb2R1Y2UgYSBuZXcgc3RhdGUuXG4gICAgKi9cbiAgICBhcHBseSh0cikge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBseVRyYW5zYWN0aW9uKHRyKS5zdGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBmaWx0ZXJUcmFuc2FjdGlvbih0ciwgaWdub3JlID0gLTEpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvbmZpZy5wbHVnaW5zLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKGkgIT0gaWdub3JlKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBsdWdpbiA9IHRoaXMuY29uZmlnLnBsdWdpbnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpbi5zcGVjLmZpbHRlclRyYW5zYWN0aW9uICYmICFwbHVnaW4uc3BlYy5maWx0ZXJUcmFuc2FjdGlvbi5jYWxsKHBsdWdpbiwgdHIsIHRoaXMpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBWZXJib3NlIHZhcmlhbnQgb2YgW2BhcHBseWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5hcHBseSkgdGhhdFxuICAgIHJldHVybnMgdGhlIHByZWNpc2UgdHJhbnNhY3Rpb25zIHRoYXQgd2VyZSBhcHBsaWVkICh3aGljaCBtaWdodFxuICAgIGJlIGluZmx1ZW5jZWQgYnkgdGhlIFt0cmFuc2FjdGlvblxuICAgIGhvb2tzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuUGx1Z2luU3BlYy5maWx0ZXJUcmFuc2FjdGlvbikgb2ZcbiAgICBwbHVnaW5zKSBhbG9uZyB3aXRoIHRoZSBuZXcgc3RhdGUuXG4gICAgKi9cbiAgICBhcHBseVRyYW5zYWN0aW9uKHJvb3RUcikge1xuICAgICAgICBpZiAoIXRoaXMuZmlsdGVyVHJhbnNhY3Rpb24ocm9vdFRyKSlcbiAgICAgICAgICAgIHJldHVybiB7IHN0YXRlOiB0aGlzLCB0cmFuc2FjdGlvbnM6IFtdIH07XG4gICAgICAgIGxldCB0cnMgPSBbcm9vdFRyXSwgbmV3U3RhdGUgPSB0aGlzLmFwcGx5SW5uZXIocm9vdFRyKSwgc2VlbiA9IG51bGw7XG4gICAgICAgIC8vIFRoaXMgbG9vcCByZXBlYXRlZGx5IGdpdmVzIHBsdWdpbnMgYSBjaGFuY2UgdG8gcmVzcG9uZCB0b1xuICAgICAgICAvLyB0cmFuc2FjdGlvbnMgYXMgbmV3IHRyYW5zYWN0aW9ucyBhcmUgYWRkZWQsIG1ha2luZyBzdXJlIHRvIG9ubHlcbiAgICAgICAgLy8gcGFzcyB0aGUgdHJhbnNhY3Rpb25zIHRoZSBwbHVnaW4gZGlkIG5vdCBzZWUgYmVmb3JlLlxuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgaGF2ZU5ldyA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvbmZpZy5wbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBsdWdpbiA9IHRoaXMuY29uZmlnLnBsdWdpbnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpbi5zcGVjLmFwcGVuZFRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuID0gc2VlbiA/IHNlZW5baV0ubiA6IDAsIG9sZFN0YXRlID0gc2VlbiA/IHNlZW5baV0uc3RhdGUgOiB0aGlzO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdHIgPSBuIDwgdHJzLmxlbmd0aCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgcGx1Z2luLnNwZWMuYXBwZW5kVHJhbnNhY3Rpb24uY2FsbChwbHVnaW4sIG4gPyB0cnMuc2xpY2UobikgOiB0cnMsIG9sZFN0YXRlLCBuZXdTdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ciAmJiBuZXdTdGF0ZS5maWx0ZXJUcmFuc2FjdGlvbih0ciwgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyLnNldE1ldGEoXCJhcHBlbmRlZFRyYW5zYWN0aW9uXCIsIHJvb3RUcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNlZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWVuID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbmZpZy5wbHVnaW5zLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWVuLnB1c2goaiA8IGkgPyB7IHN0YXRlOiBuZXdTdGF0ZSwgbjogdHJzLmxlbmd0aCB9IDogeyBzdGF0ZTogdGhpcywgbjogMCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRycy5wdXNoKHRyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YXRlID0gbmV3U3RhdGUuYXBwbHlJbm5lcih0cik7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXZlTmV3ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2VlbilcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZW5baV0gPSB7IHN0YXRlOiBuZXdTdGF0ZSwgbjogdHJzLmxlbmd0aCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaGF2ZU5ldylcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdGF0ZTogbmV3U3RhdGUsIHRyYW5zYWN0aW9uczogdHJzIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBhcHBseUlubmVyKHRyKSB7XG4gICAgICAgIGlmICghdHIuYmVmb3JlLmVxKHRoaXMuZG9jKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiQXBwbHlpbmcgYSBtaXNtYXRjaGVkIHRyYW5zYWN0aW9uXCIpO1xuICAgICAgICBsZXQgbmV3SW5zdGFuY2UgPSBuZXcgRWRpdG9yU3RhdGUodGhpcy5jb25maWcpLCBmaWVsZHMgPSB0aGlzLmNvbmZpZy5maWVsZHM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmllbGRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgZmllbGQgPSBmaWVsZHNbaV07XG4gICAgICAgICAgICBuZXdJbnN0YW5jZVtmaWVsZC5uYW1lXSA9IGZpZWxkLmFwcGx5KHRyLCB0aGlzW2ZpZWxkLm5hbWVdLCB0aGlzLCBuZXdJbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0luc3RhbmNlO1xuICAgIH1cbiAgICAvKipcbiAgICBTdGFydCBhIFt0cmFuc2FjdGlvbl0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLlRyYW5zYWN0aW9uKSBmcm9tIHRoaXMgc3RhdGUuXG4gICAgKi9cbiAgICBnZXQgdHIoKSB7IHJldHVybiBuZXcgVHJhbnNhY3Rpb24odGhpcyk7IH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgc3RhdGUuXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGNvbmZpZykge1xuICAgICAgICBsZXQgJGNvbmZpZyA9IG5ldyBDb25maWd1cmF0aW9uKGNvbmZpZy5kb2MgPyBjb25maWcuZG9jLnR5cGUuc2NoZW1hIDogY29uZmlnLnNjaGVtYSwgY29uZmlnLnBsdWdpbnMpO1xuICAgICAgICBsZXQgaW5zdGFuY2UgPSBuZXcgRWRpdG9yU3RhdGUoJGNvbmZpZyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgJGNvbmZpZy5maWVsZHMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpbnN0YW5jZVskY29uZmlnLmZpZWxkc1tpXS5uYW1lXSA9ICRjb25maWcuZmllbGRzW2ldLmluaXQoY29uZmlnLCBpbnN0YW5jZSk7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IHN0YXRlIGJhc2VkIG9uIHRoaXMgb25lLCBidXQgd2l0aCBhbiBhZGp1c3RlZCBzZXRcbiAgICBvZiBhY3RpdmUgcGx1Z2lucy4gU3RhdGUgZmllbGRzIHRoYXQgZXhpc3QgaW4gYm90aCBzZXRzIG9mXG4gICAgcGx1Z2lucyBhcmUga2VwdCB1bmNoYW5nZWQuIFRob3NlIHRoYXQgbm8gbG9uZ2VyIGV4aXN0IGFyZVxuICAgIGRyb3BwZWQsIGFuZCB0aG9zZSB0aGF0IGFyZSBuZXcgYXJlIGluaXRpYWxpemVkIHVzaW5nIHRoZWlyXG4gICAgW2Bpbml0YF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLlN0YXRlRmllbGQuaW5pdCkgbWV0aG9kLCBwYXNzaW5nIGluIHRoZSBuZXdcbiAgICBjb25maWd1cmF0aW9uIG9iamVjdC4uXG4gICAgKi9cbiAgICByZWNvbmZpZ3VyZShjb25maWcpIHtcbiAgICAgICAgbGV0ICRjb25maWcgPSBuZXcgQ29uZmlndXJhdGlvbih0aGlzLnNjaGVtYSwgY29uZmlnLnBsdWdpbnMpO1xuICAgICAgICBsZXQgZmllbGRzID0gJGNvbmZpZy5maWVsZHMsIGluc3RhbmNlID0gbmV3IEVkaXRvclN0YXRlKCRjb25maWcpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG5hbWUgPSBmaWVsZHNbaV0ubmFtZTtcbiAgICAgICAgICAgIGluc3RhbmNlW25hbWVdID0gdGhpcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IHRoaXNbbmFtZV0gOiBmaWVsZHNbaV0uaW5pdChjb25maWcsIGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuICAgIC8qKlxuICAgIFNlcmlhbGl6ZSB0aGlzIHN0YXRlIHRvIEpTT04uIElmIHlvdSB3YW50IHRvIHNlcmlhbGl6ZSB0aGUgc3RhdGVcbiAgICBvZiBwbHVnaW5zLCBwYXNzIGFuIG9iamVjdCBtYXBwaW5nIHByb3BlcnR5IG5hbWVzIHRvIHVzZSBpbiB0aGVcbiAgICByZXN1bHRpbmcgSlNPTiBvYmplY3QgdG8gcGx1Z2luIG9iamVjdHMuIFRoZSBhcmd1bWVudCBtYXkgYWxzbyBiZVxuICAgIGEgc3RyaW5nIG9yIG51bWJlciwgaW4gd2hpY2ggY2FzZSBpdCBpcyBpZ25vcmVkLCB0byBzdXBwb3J0IHRoZVxuICAgIHdheSBgSlNPTi5zdHJpbmdpZnlgIGNhbGxzIGB0b1N0cmluZ2AgbWV0aG9kcy5cbiAgICAqL1xuICAgIHRvSlNPTihwbHVnaW5GaWVsZHMpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgZG9jOiB0aGlzLmRvYy50b0pTT04oKSwgc2VsZWN0aW9uOiB0aGlzLnNlbGVjdGlvbi50b0pTT04oKSB9O1xuICAgICAgICBpZiAodGhpcy5zdG9yZWRNYXJrcylcbiAgICAgICAgICAgIHJlc3VsdC5zdG9yZWRNYXJrcyA9IHRoaXMuc3RvcmVkTWFya3MubWFwKG0gPT4gbS50b0pTT04oKSk7XG4gICAgICAgIGlmIChwbHVnaW5GaWVsZHMgJiYgdHlwZW9mIHBsdWdpbkZpZWxkcyA9PSAnb2JqZWN0JylcbiAgICAgICAgICAgIGZvciAobGV0IHByb3AgaW4gcGx1Z2luRmllbGRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByb3AgPT0gXCJkb2NcIiB8fCBwcm9wID09IFwic2VsZWN0aW9uXCIpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlIEpTT04gZmllbGRzIGBkb2NgIGFuZCBgc2VsZWN0aW9uYCBhcmUgcmVzZXJ2ZWRcIik7XG4gICAgICAgICAgICAgICAgbGV0IHBsdWdpbiA9IHBsdWdpbkZpZWxkc1twcm9wXSwgc3RhdGUgPSBwbHVnaW4uc3BlYy5zdGF0ZTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUgJiYgc3RhdGUudG9KU09OKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHRbcHJvcF0gPSBzdGF0ZS50b0pTT04uY2FsbChwbHVnaW4sIHRoaXNbcGx1Z2luLmtleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBEZXNlcmlhbGl6ZSBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgYSBzdGF0ZS4gYGNvbmZpZ2Agc2hvdWxkXG4gICAgaGF2ZSBhdCBsZWFzdCBhIGBzY2hlbWFgIGZpZWxkLCBhbmQgc2hvdWxkIGNvbnRhaW4gYXJyYXkgb2ZcbiAgICBwbHVnaW5zIHRvIGluaXRpYWxpemUgdGhlIHN0YXRlIHdpdGguIGBwbHVnaW5GaWVsZHNgIGNhbiBiZSB1c2VkXG4gICAgdG8gZGVzZXJpYWxpemUgdGhlIHN0YXRlIG9mIHBsdWdpbnMsIGJ5IGFzc29jaWF0aW5nIHBsdWdpblxuICAgIGluc3RhbmNlcyB3aXRoIHRoZSBwcm9wZXJ0eSBuYW1lcyB0aGV5IHVzZSBpbiB0aGUgSlNPTiBvYmplY3QuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oY29uZmlnLCBqc29uLCBwbHVnaW5GaWVsZHMpIHtcbiAgICAgICAgaWYgKCFqc29uKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBFZGl0b3JTdGF0ZS5mcm9tSlNPTlwiKTtcbiAgICAgICAgaWYgKCFjb25maWcuc2NoZW1hKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJSZXF1aXJlZCBjb25maWcgZmllbGQgJ3NjaGVtYScgbWlzc2luZ1wiKTtcbiAgICAgICAgbGV0ICRjb25maWcgPSBuZXcgQ29uZmlndXJhdGlvbihjb25maWcuc2NoZW1hLCBjb25maWcucGx1Z2lucyk7XG4gICAgICAgIGxldCBpbnN0YW5jZSA9IG5ldyBFZGl0b3JTdGF0ZSgkY29uZmlnKTtcbiAgICAgICAgJGNvbmZpZy5maWVsZHMuZm9yRWFjaChmaWVsZCA9PiB7XG4gICAgICAgICAgICBpZiAoZmllbGQubmFtZSA9PSBcImRvY1wiKSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UuZG9jID0gTm9kZS5mcm9tSlNPTihjb25maWcuc2NoZW1hLCBqc29uLmRvYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmaWVsZC5uYW1lID09IFwic2VsZWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5zZWxlY3Rpb24gPSBTZWxlY3Rpb24uZnJvbUpTT04oaW5zdGFuY2UuZG9jLCBqc29uLnNlbGVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmaWVsZC5uYW1lID09IFwic3RvcmVkTWFya3NcIikge1xuICAgICAgICAgICAgICAgIGlmIChqc29uLnN0b3JlZE1hcmtzKVxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZS5zdG9yZWRNYXJrcyA9IGpzb24uc3RvcmVkTWFya3MubWFwKGNvbmZpZy5zY2hlbWEubWFya0Zyb21KU09OKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChwbHVnaW5GaWVsZHMpXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHByb3AgaW4gcGx1Z2luRmllbGRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcGx1Z2luID0gcGx1Z2luRmllbGRzW3Byb3BdLCBzdGF0ZSA9IHBsdWdpbi5zcGVjLnN0YXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBsdWdpbi5rZXkgPT0gZmllbGQubmFtZSAmJiBzdGF0ZSAmJiBzdGF0ZS5mcm9tSlNPTiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChqc29uLCBwcm9wKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3RhbmNlW2ZpZWxkLm5hbWVdID0gc3RhdGUuZnJvbUpTT04uY2FsbChwbHVnaW4sIGNvbmZpZywganNvbltwcm9wXSwgaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluc3RhbmNlW2ZpZWxkLm5hbWVdID0gZmllbGQuaW5pdChjb25maWcsIGluc3RhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGJpbmRQcm9wcyhvYmosIHNlbGYsIHRhcmdldCkge1xuICAgIGZvciAobGV0IHByb3AgaW4gb2JqKSB7XG4gICAgICAgIGxldCB2YWwgPSBvYmpbcHJvcF07XG4gICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBGdW5jdGlvbilcbiAgICAgICAgICAgIHZhbCA9IHZhbC5iaW5kKHNlbGYpO1xuICAgICAgICBlbHNlIGlmIChwcm9wID09IFwiaGFuZGxlRE9NRXZlbnRzXCIpXG4gICAgICAgICAgICB2YWwgPSBiaW5kUHJvcHModmFsLCBzZWxmLCB7fSk7XG4gICAgICAgIHRhcmdldFtwcm9wXSA9IHZhbDtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbi8qKlxuUGx1Z2lucyBidW5kbGUgZnVuY3Rpb25hbGl0eSB0aGF0IGNhbiBiZSBhZGRlZCB0byBhbiBlZGl0b3IuXG5UaGV5IGFyZSBwYXJ0IG9mIHRoZSBbZWRpdG9yIHN0YXRlXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGUpIGFuZFxubWF5IGluZmx1ZW5jZSB0aGF0IHN0YXRlIGFuZCB0aGUgdmlldyB0aGF0IGNvbnRhaW5zIGl0LlxuKi9cbmNsYXNzIFBsdWdpbiB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgcGx1Z2luLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHBsdWdpbidzIFtzcGVjIG9iamVjdF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLlBsdWdpblNwZWMpLlxuICAgICovXG4gICAgc3BlYykge1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICAgICAgICAvKipcbiAgICAgICAgVGhlIFtwcm9wc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuRWRpdG9yUHJvcHMpIGV4cG9ydGVkIGJ5IHRoaXMgcGx1Z2luLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnByb3BzID0ge307XG4gICAgICAgIGlmIChzcGVjLnByb3BzKVxuICAgICAgICAgICAgYmluZFByb3BzKHNwZWMucHJvcHMsIHRoaXMsIHRoaXMucHJvcHMpO1xuICAgICAgICB0aGlzLmtleSA9IHNwZWMua2V5ID8gc3BlYy5rZXkua2V5IDogY3JlYXRlS2V5KFwicGx1Z2luXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICBFeHRyYWN0IHRoZSBwbHVnaW4ncyBzdGF0ZSBmaWVsZCBmcm9tIGFuIGVkaXRvciBzdGF0ZS5cbiAgICAqL1xuICAgIGdldFN0YXRlKHN0YXRlKSB7IHJldHVybiBzdGF0ZVt0aGlzLmtleV07IH1cbn1cbmNvbnN0IGtleXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZnVuY3Rpb24gY3JlYXRlS2V5KG5hbWUpIHtcbiAgICBpZiAobmFtZSBpbiBrZXlzKVxuICAgICAgICByZXR1cm4gbmFtZSArIFwiJFwiICsgKytrZXlzW25hbWVdO1xuICAgIGtleXNbbmFtZV0gPSAwO1xuICAgIHJldHVybiBuYW1lICsgXCIkXCI7XG59XG4vKipcbkEga2V5IGlzIHVzZWQgdG8gW3RhZ10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3N0YXRlLlBsdWdpblNwZWMua2V5KSBwbHVnaW5zIGluIGEgd2F5XG50aGF0IG1ha2VzIGl0IHBvc3NpYmxlIHRvIGZpbmQgdGhlbSwgZ2l2ZW4gYW4gZWRpdG9yIHN0YXRlLlxuQXNzaWduaW5nIGEga2V5IGRvZXMgbWVhbiBvbmx5IG9uZSBwbHVnaW4gb2YgdGhhdCB0eXBlIGNhbiBiZVxuYWN0aXZlIGluIGEgc3RhdGUuXG4qL1xuY2xhc3MgUGx1Z2luS2V5IHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBwbHVnaW4ga2V5LlxuICAgICovXG4gICAgY29uc3RydWN0b3IobmFtZSA9IFwia2V5XCIpIHsgdGhpcy5rZXkgPSBjcmVhdGVLZXkobmFtZSk7IH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGFjdGl2ZSBwbHVnaW4gd2l0aCB0aGlzIGtleSwgaWYgYW55LCBmcm9tIGFuIGVkaXRvclxuICAgIHN0YXRlLlxuICAgICovXG4gICAgZ2V0KHN0YXRlKSB7IHJldHVybiBzdGF0ZS5jb25maWcucGx1Z2luc0J5S2V5W3RoaXMua2V5XTsgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgcGx1Z2luJ3Mgc3RhdGUgZnJvbSBhbiBlZGl0b3Igc3RhdGUuXG4gICAgKi9cbiAgICBnZXRTdGF0ZShzdGF0ZSkgeyByZXR1cm4gc3RhdGVbdGhpcy5rZXldOyB9XG59XG5cbmV4cG9ydCB7IEFsbFNlbGVjdGlvbiwgRWRpdG9yU3RhdGUsIE5vZGVTZWxlY3Rpb24sIFBsdWdpbiwgUGx1Z2luS2V5LCBTZWxlY3Rpb24sIFNlbGVjdGlvblJhbmdlLCBUZXh0U2VsZWN0aW9uLCBUcmFuc2FjdGlvbiB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prosemirror-state/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prosemirror-transform/dist/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/prosemirror-transform/dist/index.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddMarkStep: function() { return /* binding */ AddMarkStep; },\n/* harmony export */   AddNodeMarkStep: function() { return /* binding */ AddNodeMarkStep; },\n/* harmony export */   AttrStep: function() { return /* binding */ AttrStep; },\n/* harmony export */   DocAttrStep: function() { return /* binding */ DocAttrStep; },\n/* harmony export */   MapResult: function() { return /* binding */ MapResult; },\n/* harmony export */   Mapping: function() { return /* binding */ Mapping; },\n/* harmony export */   RemoveMarkStep: function() { return /* binding */ RemoveMarkStep; },\n/* harmony export */   RemoveNodeMarkStep: function() { return /* binding */ RemoveNodeMarkStep; },\n/* harmony export */   ReplaceAroundStep: function() { return /* binding */ ReplaceAroundStep; },\n/* harmony export */   ReplaceStep: function() { return /* binding */ ReplaceStep; },\n/* harmony export */   Step: function() { return /* binding */ Step; },\n/* harmony export */   StepMap: function() { return /* binding */ StepMap; },\n/* harmony export */   StepResult: function() { return /* binding */ StepResult; },\n/* harmony export */   Transform: function() { return /* binding */ Transform; },\n/* harmony export */   TransformError: function() { return /* binding */ TransformError; },\n/* harmony export */   canJoin: function() { return /* binding */ canJoin; },\n/* harmony export */   canSplit: function() { return /* binding */ canSplit; },\n/* harmony export */   dropPoint: function() { return /* binding */ dropPoint; },\n/* harmony export */   findWrapping: function() { return /* binding */ findWrapping; },\n/* harmony export */   insertPoint: function() { return /* binding */ insertPoint; },\n/* harmony export */   joinPoint: function() { return /* binding */ joinPoint; },\n/* harmony export */   liftTarget: function() { return /* binding */ liftTarget; },\n/* harmony export */   replaceStep: function() { return /* binding */ replaceStep; }\n/* harmony export */ });\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-model */ \"(app-pages-browser)/./node_modules/prosemirror-model/dist/index.js\");\n\n\n// Recovery values encode a range index and an offset. They are\n// represented as numbers, because tons of them will be created when\n// mapping, for example, a large number of decorations. The number's\n// lower 16 bits provide the index, the remaining bits the offset.\n//\n// Note: We intentionally don't use bit shift operators to en- and\n// decode these, since those clip to 32 bits, which we might in rare\n// cases want to overflow. A 64-bit float can represent 48-bit\n// integers precisely.\nconst lower16 = 0xffff;\nconst factor16 = Math.pow(2, 16);\nfunction makeRecover(index, offset) { return index + offset * factor16; }\nfunction recoverIndex(value) { return value & lower16; }\nfunction recoverOffset(value) { return (value - (value & lower16)) / factor16; }\nconst DEL_BEFORE = 1, DEL_AFTER = 2, DEL_ACROSS = 4, DEL_SIDE = 8;\n/**\nAn object representing a mapped position with extra\ninformation.\n*/\nclass MapResult {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The mapped version of the position.\n    */\n    pos, \n    /**\n    @internal\n    */\n    delInfo, \n    /**\n    @internal\n    */\n    recover) {\n        this.pos = pos;\n        this.delInfo = delInfo;\n        this.recover = recover;\n    }\n    /**\n    Tells you whether the position was deleted, that is, whether the\n    step removed the token on the side queried (via the `assoc`)\n    argument from the document.\n    */\n    get deleted() { return (this.delInfo & DEL_SIDE) > 0; }\n    /**\n    Tells you whether the token before the mapped position was deleted.\n    */\n    get deletedBefore() { return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0; }\n    /**\n    True when the token after the mapped position was deleted.\n    */\n    get deletedAfter() { return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0; }\n    /**\n    Tells whether any of the steps mapped through deletes across the\n    position (including both the token before and after the\n    position).\n    */\n    get deletedAcross() { return (this.delInfo & DEL_ACROSS) > 0; }\n}\n/**\nA map describing the deletions and insertions made by a step, which\ncan be used to find the correspondence between positions in the\npre-step version of a document and the same position in the\npost-step version.\n*/\nclass StepMap {\n    /**\n    Create a position map. The modifications to the document are\n    represented as an array of numbers, in which each group of three\n    represents a modified chunk as `[start, oldSize, newSize]`.\n    */\n    constructor(\n    /**\n    @internal\n    */\n    ranges, \n    /**\n    @internal\n    */\n    inverted = false) {\n        this.ranges = ranges;\n        this.inverted = inverted;\n        if (!ranges.length && StepMap.empty)\n            return StepMap.empty;\n    }\n    /**\n    @internal\n    */\n    recover(value) {\n        let diff = 0, index = recoverIndex(value);\n        if (!this.inverted)\n            for (let i = 0; i < index; i++)\n                diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];\n        return this.ranges[index * 3] + diff + recoverOffset(value);\n    }\n    mapResult(pos, assoc = 1) { return this._map(pos, assoc, false); }\n    map(pos, assoc = 1) { return this._map(pos, assoc, true); }\n    /**\n    @internal\n    */\n    _map(pos, assoc, simple) {\n        let diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;\n        for (let i = 0; i < this.ranges.length; i += 3) {\n            let start = this.ranges[i] - (this.inverted ? diff : 0);\n            if (start > pos)\n                break;\n            let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end = start + oldSize;\n            if (pos <= end) {\n                let side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;\n                let result = start + diff + (side < 0 ? 0 : newSize);\n                if (simple)\n                    return result;\n                let recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start);\n                let del = pos == start ? DEL_AFTER : pos == end ? DEL_BEFORE : DEL_ACROSS;\n                if (assoc < 0 ? pos != start : pos != end)\n                    del |= DEL_SIDE;\n                return new MapResult(result, del, recover);\n            }\n            diff += newSize - oldSize;\n        }\n        return simple ? pos + diff : new MapResult(pos + diff, 0, null);\n    }\n    /**\n    @internal\n    */\n    touches(pos, recover) {\n        let diff = 0, index = recoverIndex(recover);\n        let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;\n        for (let i = 0; i < this.ranges.length; i += 3) {\n            let start = this.ranges[i] - (this.inverted ? diff : 0);\n            if (start > pos)\n                break;\n            let oldSize = this.ranges[i + oldIndex], end = start + oldSize;\n            if (pos <= end && i == index * 3)\n                return true;\n            diff += this.ranges[i + newIndex] - oldSize;\n        }\n        return false;\n    }\n    /**\n    Calls the given function on each of the changed ranges included in\n    this map.\n    */\n    forEach(f) {\n        let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;\n        for (let i = 0, diff = 0; i < this.ranges.length; i += 3) {\n            let start = this.ranges[i], oldStart = start - (this.inverted ? diff : 0), newStart = start + (this.inverted ? 0 : diff);\n            let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex];\n            f(oldStart, oldStart + oldSize, newStart, newStart + newSize);\n            diff += newSize - oldSize;\n        }\n    }\n    /**\n    Create an inverted version of this map. The result can be used to\n    map positions in the post-step document to the pre-step document.\n    */\n    invert() {\n        return new StepMap(this.ranges, !this.inverted);\n    }\n    /**\n    @internal\n    */\n    toString() {\n        return (this.inverted ? \"-\" : \"\") + JSON.stringify(this.ranges);\n    }\n    /**\n    Create a map that moves all positions by offset `n` (which may be\n    negative). This can be useful when applying steps meant for a\n    sub-document to a larger document, or vice-versa.\n    */\n    static offset(n) {\n        return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n]);\n    }\n}\n/**\nA StepMap that contains no changed ranges.\n*/\nStepMap.empty = new StepMap([]);\n/**\nA mapping represents a pipeline of zero or more [step\nmaps](https://prosemirror.net/docs/ref/#transform.StepMap). It has special provisions for losslessly\nhandling mapping positions through a series of steps in which some\nsteps are inverted versions of earlier steps. (This comes up when\n‘[rebasing](https://prosemirror.net/docs/guide/#transform.rebasing)’ steps for\ncollaboration or history management.)\n*/\nclass Mapping {\n    /**\n    Create a new mapping with the given position maps.\n    */\n    constructor(maps, \n    /**\n    @internal\n    */\n    mirror, \n    /**\n    The starting position in the `maps` array, used when `map` or\n    `mapResult` is called.\n    */\n    from = 0, \n    /**\n    The end position in the `maps` array.\n    */\n    to = maps ? maps.length : 0) {\n        this.mirror = mirror;\n        this.from = from;\n        this.to = to;\n        this._maps = maps || [];\n        this.ownData = !(maps || mirror);\n    }\n    /**\n    The step maps in this mapping.\n    */\n    get maps() { return this._maps; }\n    /**\n    Create a mapping that maps only through a part of this one.\n    */\n    slice(from = 0, to = this.maps.length) {\n        return new Mapping(this._maps, this.mirror, from, to);\n    }\n    /**\n    Add a step map to the end of this mapping. If `mirrors` is\n    given, it should be the index of the step map that is the mirror\n    image of this one.\n    */\n    appendMap(map, mirrors) {\n        if (!this.ownData) {\n            this._maps = this._maps.slice();\n            this.mirror = this.mirror && this.mirror.slice();\n            this.ownData = true;\n        }\n        this.to = this._maps.push(map);\n        if (mirrors != null)\n            this.setMirror(this._maps.length - 1, mirrors);\n    }\n    /**\n    Add all the step maps in a given mapping to this one (preserving\n    mirroring information).\n    */\n    appendMapping(mapping) {\n        for (let i = 0, startSize = this._maps.length; i < mapping._maps.length; i++) {\n            let mirr = mapping.getMirror(i);\n            this.appendMap(mapping._maps[i], mirr != null && mirr < i ? startSize + mirr : undefined);\n        }\n    }\n    /**\n    Finds the offset of the step map that mirrors the map at the\n    given offset, in this mapping (as per the second argument to\n    `appendMap`).\n    */\n    getMirror(n) {\n        if (this.mirror)\n            for (let i = 0; i < this.mirror.length; i++)\n                if (this.mirror[i] == n)\n                    return this.mirror[i + (i % 2 ? -1 : 1)];\n    }\n    /**\n    @internal\n    */\n    setMirror(n, m) {\n        if (!this.mirror)\n            this.mirror = [];\n        this.mirror.push(n, m);\n    }\n    /**\n    Append the inverse of the given mapping to this one.\n    */\n    appendMappingInverted(mapping) {\n        for (let i = mapping.maps.length - 1, totalSize = this._maps.length + mapping._maps.length; i >= 0; i--) {\n            let mirr = mapping.getMirror(i);\n            this.appendMap(mapping._maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : undefined);\n        }\n    }\n    /**\n    Create an inverted version of this mapping.\n    */\n    invert() {\n        let inverse = new Mapping;\n        inverse.appendMappingInverted(this);\n        return inverse;\n    }\n    /**\n    Map a position through this mapping.\n    */\n    map(pos, assoc = 1) {\n        if (this.mirror)\n            return this._map(pos, assoc, true);\n        for (let i = this.from; i < this.to; i++)\n            pos = this._maps[i].map(pos, assoc);\n        return pos;\n    }\n    /**\n    Map a position through this mapping, returning a mapping\n    result.\n    */\n    mapResult(pos, assoc = 1) { return this._map(pos, assoc, false); }\n    /**\n    @internal\n    */\n    _map(pos, assoc, simple) {\n        let delInfo = 0;\n        for (let i = this.from; i < this.to; i++) {\n            let map = this._maps[i], result = map.mapResult(pos, assoc);\n            if (result.recover != null) {\n                let corr = this.getMirror(i);\n                if (corr != null && corr > i && corr < this.to) {\n                    i = corr;\n                    pos = this._maps[corr].recover(result.recover);\n                    continue;\n                }\n            }\n            delInfo |= result.delInfo;\n            pos = result.pos;\n        }\n        return simple ? pos : new MapResult(pos, delInfo, null);\n    }\n}\n\nconst stepsByID = Object.create(null);\n/**\nA step object represents an atomic change. It generally applies\nonly to the document it was created for, since the positions\nstored in it will only make sense for that document.\n\nNew steps are defined by creating classes that extend `Step`,\noverriding the `apply`, `invert`, `map`, `getMap` and `fromJSON`\nmethods, and registering your class with a unique\nJSON-serialization identifier using\n[`Step.jsonID`](https://prosemirror.net/docs/ref/#transform.Step^jsonID).\n*/\nclass Step {\n    /**\n    Get the step map that represents the changes made by this step,\n    and which can be used to transform between positions in the old\n    and the new document.\n    */\n    getMap() { return StepMap.empty; }\n    /**\n    Try to merge this step with another one, to be applied directly\n    after it. Returns the merged step when possible, null if the\n    steps can't be merged.\n    */\n    merge(other) { return null; }\n    /**\n    Deserialize a step from its JSON representation. Will call\n    through to the step class' own implementation of this method.\n    */\n    static fromJSON(schema, json) {\n        if (!json || !json.stepType)\n            throw new RangeError(\"Invalid input for Step.fromJSON\");\n        let type = stepsByID[json.stepType];\n        if (!type)\n            throw new RangeError(`No step type ${json.stepType} defined`);\n        return type.fromJSON(schema, json);\n    }\n    /**\n    To be able to serialize steps to JSON, each step needs a string\n    ID to attach to its JSON representation. Use this method to\n    register an ID for your step classes. Try to pick something\n    that's unlikely to clash with steps from other modules.\n    */\n    static jsonID(id, stepClass) {\n        if (id in stepsByID)\n            throw new RangeError(\"Duplicate use of step JSON ID \" + id);\n        stepsByID[id] = stepClass;\n        stepClass.prototype.jsonID = id;\n        return stepClass;\n    }\n}\n/**\nThe result of [applying](https://prosemirror.net/docs/ref/#transform.Step.apply) a step. Contains either a\nnew document or a failure value.\n*/\nclass StepResult {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The transformed document, if successful.\n    */\n    doc, \n    /**\n    The failure message, if unsuccessful.\n    */\n    failed) {\n        this.doc = doc;\n        this.failed = failed;\n    }\n    /**\n    Create a successful step result.\n    */\n    static ok(doc) { return new StepResult(doc, null); }\n    /**\n    Create a failed step result.\n    */\n    static fail(message) { return new StepResult(null, message); }\n    /**\n    Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given\n    arguments. Create a successful result if it succeeds, and a\n    failed one if it throws a `ReplaceError`.\n    */\n    static fromReplace(doc, from, to, slice) {\n        try {\n            return StepResult.ok(doc.replace(from, to, slice));\n        }\n        catch (e) {\n            if (e instanceof prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.ReplaceError)\n                return StepResult.fail(e.message);\n            throw e;\n        }\n    }\n}\n\nfunction mapFragment(fragment, f, parent) {\n    let mapped = [];\n    for (let i = 0; i < fragment.childCount; i++) {\n        let child = fragment.child(i);\n        if (child.content.size)\n            child = child.copy(mapFragment(child.content, f, child));\n        if (child.isInline)\n            child = f(child, parent, i);\n        mapped.push(child);\n    }\n    return prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.fromArray(mapped);\n}\n/**\nAdd a mark to all inline content between two positions.\n*/\nclass AddMarkStep extends Step {\n    /**\n    Create a mark step.\n    */\n    constructor(\n    /**\n    The start of the marked range.\n    */\n    from, \n    /**\n    The end of the marked range.\n    */\n    to, \n    /**\n    The mark to add.\n    */\n    mark) {\n        super();\n        this.from = from;\n        this.to = to;\n        this.mark = mark;\n    }\n    apply(doc) {\n        let oldSlice = doc.slice(this.from, this.to), $from = doc.resolve(this.from);\n        let parent = $from.node($from.sharedDepth(this.to));\n        let slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(mapFragment(oldSlice.content, (node, parent) => {\n            if (!node.isAtom || !parent.type.allowsMarkType(this.mark.type))\n                return node;\n            return node.mark(this.mark.addToSet(node.marks));\n        }, parent), oldSlice.openStart, oldSlice.openEnd);\n        return StepResult.fromReplace(doc, this.from, this.to, slice);\n    }\n    invert() {\n        return new RemoveMarkStep(this.from, this.to, this.mark);\n    }\n    map(mapping) {\n        let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n        if (from.deleted && to.deleted || from.pos >= to.pos)\n            return null;\n        return new AddMarkStep(from.pos, to.pos, this.mark);\n    }\n    merge(other) {\n        if (other instanceof AddMarkStep &&\n            other.mark.eq(this.mark) &&\n            this.from <= other.to && this.to >= other.from)\n            return new AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);\n        return null;\n    }\n    toJSON() {\n        return { stepType: \"addMark\", mark: this.mark.toJSON(),\n            from: this.from, to: this.to };\n    }\n    /**\n    @internal\n    */\n    static fromJSON(schema, json) {\n        if (typeof json.from != \"number\" || typeof json.to != \"number\")\n            throw new RangeError(\"Invalid input for AddMarkStep.fromJSON\");\n        return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark));\n    }\n}\nStep.jsonID(\"addMark\", AddMarkStep);\n/**\nRemove a mark from all inline content between two positions.\n*/\nclass RemoveMarkStep extends Step {\n    /**\n    Create a mark-removing step.\n    */\n    constructor(\n    /**\n    The start of the unmarked range.\n    */\n    from, \n    /**\n    The end of the unmarked range.\n    */\n    to, \n    /**\n    The mark to remove.\n    */\n    mark) {\n        super();\n        this.from = from;\n        this.to = to;\n        this.mark = mark;\n    }\n    apply(doc) {\n        let oldSlice = doc.slice(this.from, this.to);\n        let slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(mapFragment(oldSlice.content, node => {\n            return node.mark(this.mark.removeFromSet(node.marks));\n        }, doc), oldSlice.openStart, oldSlice.openEnd);\n        return StepResult.fromReplace(doc, this.from, this.to, slice);\n    }\n    invert() {\n        return new AddMarkStep(this.from, this.to, this.mark);\n    }\n    map(mapping) {\n        let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n        if (from.deleted && to.deleted || from.pos >= to.pos)\n            return null;\n        return new RemoveMarkStep(from.pos, to.pos, this.mark);\n    }\n    merge(other) {\n        if (other instanceof RemoveMarkStep &&\n            other.mark.eq(this.mark) &&\n            this.from <= other.to && this.to >= other.from)\n            return new RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);\n        return null;\n    }\n    toJSON() {\n        return { stepType: \"removeMark\", mark: this.mark.toJSON(),\n            from: this.from, to: this.to };\n    }\n    /**\n    @internal\n    */\n    static fromJSON(schema, json) {\n        if (typeof json.from != \"number\" || typeof json.to != \"number\")\n            throw new RangeError(\"Invalid input for RemoveMarkStep.fromJSON\");\n        return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark));\n    }\n}\nStep.jsonID(\"removeMark\", RemoveMarkStep);\n/**\nAdd a mark to a specific node.\n*/\nclass AddNodeMarkStep extends Step {\n    /**\n    Create a node mark step.\n    */\n    constructor(\n    /**\n    The position of the target node.\n    */\n    pos, \n    /**\n    The mark to add.\n    */\n    mark) {\n        super();\n        this.pos = pos;\n        this.mark = mark;\n    }\n    apply(doc) {\n        let node = doc.nodeAt(this.pos);\n        if (!node)\n            return StepResult.fail(\"No node at mark step's position\");\n        let updated = node.type.create(node.attrs, null, this.mark.addToSet(node.marks));\n        return StepResult.fromReplace(doc, this.pos, this.pos + 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(updated), 0, node.isLeaf ? 0 : 1));\n    }\n    invert(doc) {\n        let node = doc.nodeAt(this.pos);\n        if (node) {\n            let newSet = this.mark.addToSet(node.marks);\n            if (newSet.length == node.marks.length) {\n                for (let i = 0; i < node.marks.length; i++)\n                    if (!node.marks[i].isInSet(newSet))\n                        return new AddNodeMarkStep(this.pos, node.marks[i]);\n                return new AddNodeMarkStep(this.pos, this.mark);\n            }\n        }\n        return new RemoveNodeMarkStep(this.pos, this.mark);\n    }\n    map(mapping) {\n        let pos = mapping.mapResult(this.pos, 1);\n        return pos.deletedAfter ? null : new AddNodeMarkStep(pos.pos, this.mark);\n    }\n    toJSON() {\n        return { stepType: \"addNodeMark\", pos: this.pos, mark: this.mark.toJSON() };\n    }\n    /**\n    @internal\n    */\n    static fromJSON(schema, json) {\n        if (typeof json.pos != \"number\")\n            throw new RangeError(\"Invalid input for AddNodeMarkStep.fromJSON\");\n        return new AddNodeMarkStep(json.pos, schema.markFromJSON(json.mark));\n    }\n}\nStep.jsonID(\"addNodeMark\", AddNodeMarkStep);\n/**\nRemove a mark from a specific node.\n*/\nclass RemoveNodeMarkStep extends Step {\n    /**\n    Create a mark-removing step.\n    */\n    constructor(\n    /**\n    The position of the target node.\n    */\n    pos, \n    /**\n    The mark to remove.\n    */\n    mark) {\n        super();\n        this.pos = pos;\n        this.mark = mark;\n    }\n    apply(doc) {\n        let node = doc.nodeAt(this.pos);\n        if (!node)\n            return StepResult.fail(\"No node at mark step's position\");\n        let updated = node.type.create(node.attrs, null, this.mark.removeFromSet(node.marks));\n        return StepResult.fromReplace(doc, this.pos, this.pos + 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(updated), 0, node.isLeaf ? 0 : 1));\n    }\n    invert(doc) {\n        let node = doc.nodeAt(this.pos);\n        if (!node || !this.mark.isInSet(node.marks))\n            return this;\n        return new AddNodeMarkStep(this.pos, this.mark);\n    }\n    map(mapping) {\n        let pos = mapping.mapResult(this.pos, 1);\n        return pos.deletedAfter ? null : new RemoveNodeMarkStep(pos.pos, this.mark);\n    }\n    toJSON() {\n        return { stepType: \"removeNodeMark\", pos: this.pos, mark: this.mark.toJSON() };\n    }\n    /**\n    @internal\n    */\n    static fromJSON(schema, json) {\n        if (typeof json.pos != \"number\")\n            throw new RangeError(\"Invalid input for RemoveNodeMarkStep.fromJSON\");\n        return new RemoveNodeMarkStep(json.pos, schema.markFromJSON(json.mark));\n    }\n}\nStep.jsonID(\"removeNodeMark\", RemoveNodeMarkStep);\n\n/**\nReplace a part of the document with a slice of new content.\n*/\nclass ReplaceStep extends Step {\n    /**\n    The given `slice` should fit the 'gap' between `from` and\n    `to`—the depths must line up, and the surrounding nodes must be\n    able to be joined with the open sides of the slice. When\n    `structure` is true, the step will fail if the content between\n    from and to is not just a sequence of closing and then opening\n    tokens (this is to guard against rebased replace steps\n    overwriting something they weren't supposed to).\n    */\n    constructor(\n    /**\n    The start position of the replaced range.\n    */\n    from, \n    /**\n    The end position of the replaced range.\n    */\n    to, \n    /**\n    The slice to insert.\n    */\n    slice, \n    /**\n    @internal\n    */\n    structure = false) {\n        super();\n        this.from = from;\n        this.to = to;\n        this.slice = slice;\n        this.structure = structure;\n    }\n    apply(doc) {\n        if (this.structure && contentBetween(doc, this.from, this.to))\n            return StepResult.fail(\"Structure replace would overwrite content\");\n        return StepResult.fromReplace(doc, this.from, this.to, this.slice);\n    }\n    getMap() {\n        return new StepMap([this.from, this.to - this.from, this.slice.size]);\n    }\n    invert(doc) {\n        return new ReplaceStep(this.from, this.from + this.slice.size, doc.slice(this.from, this.to));\n    }\n    map(mapping) {\n        let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n        if (from.deletedAcross && to.deletedAcross)\n            return null;\n        return new ReplaceStep(from.pos, Math.max(from.pos, to.pos), this.slice, this.structure);\n    }\n    merge(other) {\n        if (!(other instanceof ReplaceStep) || other.structure || this.structure)\n            return null;\n        if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {\n            let slice = this.slice.size + other.slice.size == 0 ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty\n                : new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);\n            return new ReplaceStep(this.from, this.to + (other.to - other.from), slice, this.structure);\n        }\n        else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {\n            let slice = this.slice.size + other.slice.size == 0 ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty\n                : new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);\n            return new ReplaceStep(other.from, this.to, slice, this.structure);\n        }\n        else {\n            return null;\n        }\n    }\n    toJSON() {\n        let json = { stepType: \"replace\", from: this.from, to: this.to };\n        if (this.slice.size)\n            json.slice = this.slice.toJSON();\n        if (this.structure)\n            json.structure = true;\n        return json;\n    }\n    /**\n    @internal\n    */\n    static fromJSON(schema, json) {\n        if (typeof json.from != \"number\" || typeof json.to != \"number\")\n            throw new RangeError(\"Invalid input for ReplaceStep.fromJSON\");\n        return new ReplaceStep(json.from, json.to, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.fromJSON(schema, json.slice), !!json.structure);\n    }\n}\nStep.jsonID(\"replace\", ReplaceStep);\n/**\nReplace a part of the document with a slice of content, but\npreserve a range of the replaced content by moving it into the\nslice.\n*/\nclass ReplaceAroundStep extends Step {\n    /**\n    Create a replace-around step with the given range and gap.\n    `insert` should be the point in the slice into which the content\n    of the gap should be moved. `structure` has the same meaning as\n    it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.\n    */\n    constructor(\n    /**\n    The start position of the replaced range.\n    */\n    from, \n    /**\n    The end position of the replaced range.\n    */\n    to, \n    /**\n    The start of preserved range.\n    */\n    gapFrom, \n    /**\n    The end of preserved range.\n    */\n    gapTo, \n    /**\n    The slice to insert.\n    */\n    slice, \n    /**\n    The position in the slice where the preserved range should be\n    inserted.\n    */\n    insert, \n    /**\n    @internal\n    */\n    structure = false) {\n        super();\n        this.from = from;\n        this.to = to;\n        this.gapFrom = gapFrom;\n        this.gapTo = gapTo;\n        this.slice = slice;\n        this.insert = insert;\n        this.structure = structure;\n    }\n    apply(doc) {\n        if (this.structure && (contentBetween(doc, this.from, this.gapFrom) ||\n            contentBetween(doc, this.gapTo, this.to)))\n            return StepResult.fail(\"Structure gap-replace would overwrite content\");\n        let gap = doc.slice(this.gapFrom, this.gapTo);\n        if (gap.openStart || gap.openEnd)\n            return StepResult.fail(\"Gap is not a flat range\");\n        let inserted = this.slice.insertAt(this.insert, gap.content);\n        if (!inserted)\n            return StepResult.fail(\"Content does not fit in gap\");\n        return StepResult.fromReplace(doc, this.from, this.to, inserted);\n    }\n    getMap() {\n        return new StepMap([this.from, this.gapFrom - this.from, this.insert,\n            this.gapTo, this.to - this.gapTo, this.slice.size - this.insert]);\n    }\n    invert(doc) {\n        let gap = this.gapTo - this.gapFrom;\n        return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);\n    }\n    map(mapping) {\n        let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n        let gapFrom = this.from == this.gapFrom ? from.pos : mapping.map(this.gapFrom, -1);\n        let gapTo = this.to == this.gapTo ? to.pos : mapping.map(this.gapTo, 1);\n        if ((from.deletedAcross && to.deletedAcross) || gapFrom < from.pos || gapTo > to.pos)\n            return null;\n        return new ReplaceAroundStep(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);\n    }\n    toJSON() {\n        let json = { stepType: \"replaceAround\", from: this.from, to: this.to,\n            gapFrom: this.gapFrom, gapTo: this.gapTo, insert: this.insert };\n        if (this.slice.size)\n            json.slice = this.slice.toJSON();\n        if (this.structure)\n            json.structure = true;\n        return json;\n    }\n    /**\n    @internal\n    */\n    static fromJSON(schema, json) {\n        if (typeof json.from != \"number\" || typeof json.to != \"number\" ||\n            typeof json.gapFrom != \"number\" || typeof json.gapTo != \"number\" || typeof json.insert != \"number\")\n            throw new RangeError(\"Invalid input for ReplaceAroundStep.fromJSON\");\n        return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.fromJSON(schema, json.slice), json.insert, !!json.structure);\n    }\n}\nStep.jsonID(\"replaceAround\", ReplaceAroundStep);\nfunction contentBetween(doc, from, to) {\n    let $from = doc.resolve(from), dist = to - from, depth = $from.depth;\n    while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {\n        depth--;\n        dist--;\n    }\n    if (dist > 0) {\n        let next = $from.node(depth).maybeChild($from.indexAfter(depth));\n        while (dist > 0) {\n            if (!next || next.isLeaf)\n                return true;\n            next = next.firstChild;\n            dist--;\n        }\n    }\n    return false;\n}\n\nfunction addMark(tr, from, to, mark) {\n    let removed = [], added = [];\n    let removing, adding;\n    tr.doc.nodesBetween(from, to, (node, pos, parent) => {\n        if (!node.isInline)\n            return;\n        let marks = node.marks;\n        if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {\n            let start = Math.max(pos, from), end = Math.min(pos + node.nodeSize, to);\n            let newSet = mark.addToSet(marks);\n            for (let i = 0; i < marks.length; i++) {\n                if (!marks[i].isInSet(newSet)) {\n                    if (removing && removing.to == start && removing.mark.eq(marks[i]))\n                        removing.to = end;\n                    else\n                        removed.push(removing = new RemoveMarkStep(start, end, marks[i]));\n                }\n            }\n            if (adding && adding.to == start)\n                adding.to = end;\n            else\n                added.push(adding = new AddMarkStep(start, end, mark));\n        }\n    });\n    removed.forEach(s => tr.step(s));\n    added.forEach(s => tr.step(s));\n}\nfunction removeMark(tr, from, to, mark) {\n    let matched = [], step = 0;\n    tr.doc.nodesBetween(from, to, (node, pos) => {\n        if (!node.isInline)\n            return;\n        step++;\n        let toRemove = null;\n        if (mark instanceof prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.MarkType) {\n            let set = node.marks, found;\n            while (found = mark.isInSet(set)) {\n                (toRemove || (toRemove = [])).push(found);\n                set = found.removeFromSet(set);\n            }\n        }\n        else if (mark) {\n            if (mark.isInSet(node.marks))\n                toRemove = [mark];\n        }\n        else {\n            toRemove = node.marks;\n        }\n        if (toRemove && toRemove.length) {\n            let end = Math.min(pos + node.nodeSize, to);\n            for (let i = 0; i < toRemove.length; i++) {\n                let style = toRemove[i], found;\n                for (let j = 0; j < matched.length; j++) {\n                    let m = matched[j];\n                    if (m.step == step - 1 && style.eq(matched[j].style))\n                        found = m;\n                }\n                if (found) {\n                    found.to = end;\n                    found.step = step;\n                }\n                else {\n                    matched.push({ style, from: Math.max(pos, from), to: end, step });\n                }\n            }\n        }\n    });\n    matched.forEach(m => tr.step(new RemoveMarkStep(m.from, m.to, m.style)));\n}\nfunction clearIncompatible(tr, pos, parentType, match = parentType.contentMatch, clearNewlines = true) {\n    let node = tr.doc.nodeAt(pos);\n    let replSteps = [], cur = pos + 1;\n    for (let i = 0; i < node.childCount; i++) {\n        let child = node.child(i), end = cur + child.nodeSize;\n        let allowed = match.matchType(child.type);\n        if (!allowed) {\n            replSteps.push(new ReplaceStep(cur, end, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty));\n        }\n        else {\n            match = allowed;\n            for (let j = 0; j < child.marks.length; j++)\n                if (!parentType.allowsMarkType(child.marks[j].type))\n                    tr.step(new RemoveMarkStep(cur, end, child.marks[j]));\n            if (clearNewlines && child.isText && parentType.whitespace != \"pre\") {\n                let m, newline = /\\r?\\n|\\r/g, slice;\n                while (m = newline.exec(child.text)) {\n                    if (!slice)\n                        slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(parentType.schema.text(\" \", parentType.allowedMarks(child.marks))), 0, 0);\n                    replSteps.push(new ReplaceStep(cur + m.index, cur + m.index + m[0].length, slice));\n                }\n            }\n        }\n        cur = end;\n    }\n    if (!match.validEnd) {\n        let fill = match.fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true);\n        tr.replace(cur, cur, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(fill, 0, 0));\n    }\n    for (let i = replSteps.length - 1; i >= 0; i--)\n        tr.step(replSteps[i]);\n}\n\nfunction canCut(node, start, end) {\n    return (start == 0 || node.canReplace(start, node.childCount)) &&\n        (end == node.childCount || node.canReplace(0, end));\n}\n/**\nTry to find a target depth to which the content in the given range\ncan be lifted. Will not go across\n[isolating](https://prosemirror.net/docs/ref/#model.NodeSpec.isolating) parent nodes.\n*/\nfunction liftTarget(range) {\n    let parent = range.parent;\n    let content = parent.content.cutByIndex(range.startIndex, range.endIndex);\n    for (let depth = range.depth;; --depth) {\n        let node = range.$from.node(depth);\n        let index = range.$from.index(depth), endIndex = range.$to.indexAfter(depth);\n        if (depth < range.depth && node.canReplace(index, endIndex, content))\n            return depth;\n        if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex))\n            break;\n    }\n    return null;\n}\nfunction lift(tr, range, target) {\n    let { $from, $to, depth } = range;\n    let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);\n    let start = gapStart, end = gapEnd;\n    let before = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, openStart = 0;\n    for (let d = depth, splitting = false; d > target; d--)\n        if (splitting || $from.index(d) > 0) {\n            splitting = true;\n            before = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($from.node(d).copy(before));\n            openStart++;\n        }\n        else {\n            start--;\n        }\n    let after = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, openEnd = 0;\n    for (let d = depth, splitting = false; d > target; d--)\n        if (splitting || $to.after(d + 1) < $to.end(d)) {\n            splitting = true;\n            after = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($to.node(d).copy(after));\n            openEnd++;\n        }\n        else {\n            end++;\n        }\n    tr.step(new ReplaceAroundStep(start, end, gapStart, gapEnd, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(before.append(after), openStart, openEnd), before.size - openStart, true));\n}\n/**\nTry to find a valid way to wrap the content in the given range in a\nnode of the given type. May introduce extra nodes around and inside\nthe wrapper node, if necessary. Returns null if no valid wrapping\ncould be found. When `innerRange` is given, that range's content is\nused as the content to fit into the wrapping, instead of the\ncontent of `range`.\n*/\nfunction findWrapping(range, nodeType, attrs = null, innerRange = range) {\n    let around = findWrappingOutside(range, nodeType);\n    let inner = around && findWrappingInside(innerRange, nodeType);\n    if (!inner)\n        return null;\n    return around.map(withAttrs)\n        .concat({ type: nodeType, attrs }).concat(inner.map(withAttrs));\n}\nfunction withAttrs(type) { return { type, attrs: null }; }\nfunction findWrappingOutside(range, type) {\n    let { parent, startIndex, endIndex } = range;\n    let around = parent.contentMatchAt(startIndex).findWrapping(type);\n    if (!around)\n        return null;\n    let outer = around.length ? around[0] : type;\n    return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;\n}\nfunction findWrappingInside(range, type) {\n    let { parent, startIndex, endIndex } = range;\n    let inner = parent.child(startIndex);\n    let inside = type.contentMatch.findWrapping(inner.type);\n    if (!inside)\n        return null;\n    let lastType = inside.length ? inside[inside.length - 1] : type;\n    let innerMatch = lastType.contentMatch;\n    for (let i = startIndex; innerMatch && i < endIndex; i++)\n        innerMatch = innerMatch.matchType(parent.child(i).type);\n    if (!innerMatch || !innerMatch.validEnd)\n        return null;\n    return inside;\n}\nfunction wrap(tr, range, wrappers) {\n    let content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;\n    for (let i = wrappers.length - 1; i >= 0; i--) {\n        if (content.size) {\n            let match = wrappers[i].type.contentMatch.matchFragment(content);\n            if (!match || !match.validEnd)\n                throw new RangeError(\"Wrapper type given to Transform.wrap does not form valid content of its parent wrapper\");\n        }\n        content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));\n    }\n    let start = range.start, end = range.end;\n    tr.step(new ReplaceAroundStep(start, end, start, end, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(content, 0, 0), wrappers.length, true));\n}\nfunction setBlockType(tr, from, to, type, attrs) {\n    if (!type.isTextblock)\n        throw new RangeError(\"Type given to setBlockType should be a textblock\");\n    let mapFrom = tr.steps.length;\n    tr.doc.nodesBetween(from, to, (node, pos) => {\n        let attrsHere = typeof attrs == \"function\" ? attrs(node) : attrs;\n        if (node.isTextblock && !node.hasMarkup(type, attrsHere) &&\n            canChangeType(tr.doc, tr.mapping.slice(mapFrom).map(pos), type)) {\n            let convertNewlines = null;\n            if (type.schema.linebreakReplacement) {\n                let pre = type.whitespace == \"pre\", supportLinebreak = !!type.contentMatch.matchType(type.schema.linebreakReplacement);\n                if (pre && !supportLinebreak)\n                    convertNewlines = false;\n                else if (!pre && supportLinebreak)\n                    convertNewlines = true;\n            }\n            // Ensure all markup that isn't allowed in the new node type is cleared\n            if (convertNewlines === false)\n                replaceLinebreaks(tr, node, pos, mapFrom);\n            clearIncompatible(tr, tr.mapping.slice(mapFrom).map(pos, 1), type, undefined, convertNewlines === null);\n            let mapping = tr.mapping.slice(mapFrom);\n            let startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1);\n            tr.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(type.create(attrsHere, null, node.marks)), 0, 0), 1, true));\n            if (convertNewlines === true)\n                replaceNewlines(tr, node, pos, mapFrom);\n            return false;\n        }\n    });\n}\nfunction replaceNewlines(tr, node, pos, mapFrom) {\n    node.forEach((child, offset) => {\n        if (child.isText) {\n            let m, newline = /\\r?\\n|\\r/g;\n            while (m = newline.exec(child.text)) {\n                let start = tr.mapping.slice(mapFrom).map(pos + 1 + offset + m.index);\n                tr.replaceWith(start, start + 1, node.type.schema.linebreakReplacement.create());\n            }\n        }\n    });\n}\nfunction replaceLinebreaks(tr, node, pos, mapFrom) {\n    node.forEach((child, offset) => {\n        if (child.type == child.type.schema.linebreakReplacement) {\n            let start = tr.mapping.slice(mapFrom).map(pos + 1 + offset);\n            tr.replaceWith(start, start + 1, node.type.schema.text(\"\\n\"));\n        }\n    });\n}\nfunction canChangeType(doc, pos, type) {\n    let $pos = doc.resolve(pos), index = $pos.index();\n    return $pos.parent.canReplaceWith(index, index + 1, type);\n}\n/**\nChange the type, attributes, and/or marks of the node at `pos`.\nWhen `type` isn't given, the existing node type is preserved,\n*/\nfunction setNodeMarkup(tr, pos, type, attrs, marks) {\n    let node = tr.doc.nodeAt(pos);\n    if (!node)\n        throw new RangeError(\"No node at given position\");\n    if (!type)\n        type = node.type;\n    let newNode = type.create(attrs, null, marks || node.marks);\n    if (node.isLeaf)\n        return tr.replaceWith(pos, pos + node.nodeSize, newNode);\n    if (!type.validContent(node.content))\n        throw new RangeError(\"Invalid content for node type \" + type.name);\n    tr.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(newNode), 0, 0), 1, true));\n}\n/**\nCheck whether splitting at the given position is allowed.\n*/\nfunction canSplit(doc, pos, depth = 1, typesAfter) {\n    let $pos = doc.resolve(pos), base = $pos.depth - depth;\n    let innerType = (typesAfter && typesAfter[typesAfter.length - 1]) || $pos.parent;\n    if (base < 0 || $pos.parent.type.spec.isolating ||\n        !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) ||\n        !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))\n        return false;\n    for (let d = $pos.depth - 1, i = depth - 2; d > base; d--, i--) {\n        let node = $pos.node(d), index = $pos.index(d);\n        if (node.type.spec.isolating)\n            return false;\n        let rest = node.content.cutByIndex(index, node.childCount);\n        let overrideChild = typesAfter && typesAfter[i + 1];\n        if (overrideChild)\n            rest = rest.replaceChild(0, overrideChild.type.create(overrideChild.attrs));\n        let after = (typesAfter && typesAfter[i]) || node;\n        if (!node.canReplace(index + 1, node.childCount) || !after.type.validContent(rest))\n            return false;\n    }\n    let index = $pos.indexAfter(base);\n    let baseType = typesAfter && typesAfter[0];\n    return $pos.node(base).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base + 1).type);\n}\nfunction split(tr, pos, depth = 1, typesAfter) {\n    let $pos = tr.doc.resolve(pos), before = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, after = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;\n    for (let d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {\n        before = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($pos.node(d).copy(before));\n        let typeAfter = typesAfter && typesAfter[i];\n        after = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));\n    }\n    tr.step(new ReplaceStep(pos, pos, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(before.append(after), depth, depth), true));\n}\n/**\nTest whether the blocks before and after a given position can be\njoined.\n*/\nfunction canJoin(doc, pos) {\n    let $pos = doc.resolve(pos), index = $pos.index();\n    return joinable($pos.nodeBefore, $pos.nodeAfter) &&\n        $pos.parent.canReplace(index, index + 1);\n}\nfunction canAppendWithSubstitutedLinebreaks(a, b) {\n    if (!b.content.size)\n        a.type.compatibleContent(b.type);\n    let match = a.contentMatchAt(a.childCount);\n    let { linebreakReplacement } = a.type.schema;\n    for (let i = 0; i < b.childCount; i++) {\n        let child = b.child(i);\n        let type = child.type == linebreakReplacement ? a.type.schema.nodes.text : child.type;\n        match = match.matchType(type);\n        if (!match)\n            return false;\n        if (!a.type.allowsMarks(child.marks))\n            return false;\n    }\n    return match.validEnd;\n}\nfunction joinable(a, b) {\n    return !!(a && b && !a.isLeaf && canAppendWithSubstitutedLinebreaks(a, b));\n}\n/**\nFind an ancestor of the given position that can be joined to the\nblock before (or after if `dir` is positive). Returns the joinable\npoint, if any.\n*/\nfunction joinPoint(doc, pos, dir = -1) {\n    let $pos = doc.resolve(pos);\n    for (let d = $pos.depth;; d--) {\n        let before, after, index = $pos.index(d);\n        if (d == $pos.depth) {\n            before = $pos.nodeBefore;\n            after = $pos.nodeAfter;\n        }\n        else if (dir > 0) {\n            before = $pos.node(d + 1);\n            index++;\n            after = $pos.node(d).maybeChild(index);\n        }\n        else {\n            before = $pos.node(d).maybeChild(index - 1);\n            after = $pos.node(d + 1);\n        }\n        if (before && !before.isTextblock && joinable(before, after) &&\n            $pos.node(d).canReplace(index, index + 1))\n            return pos;\n        if (d == 0)\n            break;\n        pos = dir < 0 ? $pos.before(d) : $pos.after(d);\n    }\n}\nfunction join(tr, pos, depth) {\n    let convertNewlines = null;\n    let { linebreakReplacement } = tr.doc.type.schema;\n    let $before = tr.doc.resolve(pos - depth), beforeType = $before.node().type;\n    if (linebreakReplacement && beforeType.inlineContent) {\n        let pre = beforeType.whitespace == \"pre\";\n        let supportLinebreak = !!beforeType.contentMatch.matchType(linebreakReplacement);\n        if (pre && !supportLinebreak)\n            convertNewlines = false;\n        else if (!pre && supportLinebreak)\n            convertNewlines = true;\n    }\n    let mapFrom = tr.steps.length;\n    if (convertNewlines === false) {\n        let $after = tr.doc.resolve(pos + depth);\n        replaceLinebreaks(tr, $after.node(), $after.before(), mapFrom);\n    }\n    if (beforeType.inlineContent)\n        clearIncompatible(tr, pos + depth - 1, beforeType, $before.node().contentMatchAt($before.index()), convertNewlines == null);\n    let mapping = tr.mapping.slice(mapFrom), start = mapping.map(pos - depth);\n    tr.step(new ReplaceStep(start, mapping.map(pos + depth, -1), prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty, true));\n    if (convertNewlines === true) {\n        let $full = tr.doc.resolve(start);\n        replaceNewlines(tr, $full.node(), $full.before(), tr.steps.length);\n    }\n    return tr;\n}\n/**\nTry to find a point where a node of the given type can be inserted\nnear `pos`, by searching up the node hierarchy when `pos` itself\nisn't a valid place but is at the start or end of a node. Return\nnull if no position was found.\n*/\nfunction insertPoint(doc, pos, nodeType) {\n    let $pos = doc.resolve(pos);\n    if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType))\n        return pos;\n    if ($pos.parentOffset == 0)\n        for (let d = $pos.depth - 1; d >= 0; d--) {\n            let index = $pos.index(d);\n            if ($pos.node(d).canReplaceWith(index, index, nodeType))\n                return $pos.before(d + 1);\n            if (index > 0)\n                return null;\n        }\n    if ($pos.parentOffset == $pos.parent.content.size)\n        for (let d = $pos.depth - 1; d >= 0; d--) {\n            let index = $pos.indexAfter(d);\n            if ($pos.node(d).canReplaceWith(index, index, nodeType))\n                return $pos.after(d + 1);\n            if (index < $pos.node(d).childCount)\n                return null;\n        }\n    return null;\n}\n/**\nFinds a position at or around the given position where the given\nslice can be inserted. Will look at parent nodes' nearest boundary\nand try there, even if the original position wasn't directly at the\nstart or end of that node. Returns null when no position was found.\n*/\nfunction dropPoint(doc, pos, slice) {\n    let $pos = doc.resolve(pos);\n    if (!slice.content.size)\n        return pos;\n    let content = slice.content;\n    for (let i = 0; i < slice.openStart; i++)\n        content = content.firstChild.content;\n    for (let pass = 1; pass <= (slice.openStart == 0 && slice.size ? 2 : 1); pass++) {\n        for (let d = $pos.depth; d >= 0; d--) {\n            let bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;\n            let insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);\n            let parent = $pos.node(d), fits = false;\n            if (pass == 1) {\n                fits = parent.canReplace(insertPos, insertPos, content);\n            }\n            else {\n                let wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);\n                fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);\n            }\n            if (fits)\n                return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);\n        }\n    }\n    return null;\n}\n\n/**\n‘Fit’ a slice into a given position in the document, producing a\n[step](https://prosemirror.net/docs/ref/#transform.Step) that inserts it. Will return null if\nthere's no meaningful way to insert the slice here, or inserting it\nwould be a no-op (an empty slice over an empty range).\n*/\nfunction replaceStep(doc, from, to = from, slice = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty) {\n    if (from == to && !slice.size)\n        return null;\n    let $from = doc.resolve(from), $to = doc.resolve(to);\n    // Optimization -- avoid work if it's obvious that it's not needed.\n    if (fitsTrivially($from, $to, slice))\n        return new ReplaceStep(from, to, slice);\n    return new Fitter($from, $to, slice).fit();\n}\nfunction fitsTrivially($from, $to, slice) {\n    return !slice.openStart && !slice.openEnd && $from.start() == $to.start() &&\n        $from.parent.canReplace($from.index(), $to.index(), slice.content);\n}\n// Algorithm for 'placing' the elements of a slice into a gap:\n//\n// We consider the content of each node that is open to the left to be\n// independently placeable. I.e. in <p(\"foo\"), p(\"bar\")>, when the\n// paragraph on the left is open, \"foo\" can be placed (somewhere on\n// the left side of the replacement gap) independently from p(\"bar\").\n//\n// This class tracks the state of the placement progress in the\n// following properties:\n//\n//  - `frontier` holds a stack of `{type, match}` objects that\n//    represent the open side of the replacement. It starts at\n//    `$from`, then moves forward as content is placed, and is finally\n//    reconciled with `$to`.\n//\n//  - `unplaced` is a slice that represents the content that hasn't\n//    been placed yet.\n//\n//  - `placed` is a fragment of placed content. Its open-start value\n//    is implicit in `$from`, and its open-end value in `frontier`.\nclass Fitter {\n    constructor($from, $to, unplaced) {\n        this.$from = $from;\n        this.$to = $to;\n        this.unplaced = unplaced;\n        this.frontier = [];\n        this.placed = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;\n        for (let i = 0; i <= $from.depth; i++) {\n            let node = $from.node(i);\n            this.frontier.push({\n                type: node.type,\n                match: node.contentMatchAt($from.indexAfter(i))\n            });\n        }\n        for (let i = $from.depth; i > 0; i--)\n            this.placed = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from($from.node(i).copy(this.placed));\n    }\n    get depth() { return this.frontier.length - 1; }\n    fit() {\n        // As long as there's unplaced content, try to place some of it.\n        // If that fails, either increase the open score of the unplaced\n        // slice, or drop nodes from it, and then try again.\n        while (this.unplaced.size) {\n            let fit = this.findFittable();\n            if (fit)\n                this.placeNodes(fit);\n            else\n                this.openMore() || this.dropNode();\n        }\n        // When there's inline content directly after the frontier _and_\n        // directly after `this.$to`, we must generate a `ReplaceAround`\n        // step that pulls that content into the node after the frontier.\n        // That means the fitting must be done to the end of the textblock\n        // node after `this.$to`, not `this.$to` itself.\n        let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;\n        let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));\n        if (!$to)\n            return null;\n        // If closing to `$to` succeeded, create a step\n        let content = this.placed, openStart = $from.depth, openEnd = $to.depth;\n        while (openStart && openEnd && content.childCount == 1) { // Normalize by dropping open parent nodes\n            content = content.firstChild.content;\n            openStart--;\n            openEnd--;\n        }\n        let slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(content, openStart, openEnd);\n        if (moveInline > -1)\n            return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice, placedSize);\n        if (slice.size || $from.pos != this.$to.pos) // Don't generate no-op steps\n            return new ReplaceStep($from.pos, $to.pos, slice);\n        return null;\n    }\n    // Find a position on the start spine of `this.unplaced` that has\n    // content that can be moved somewhere on the frontier. Returns two\n    // depths, one for the slice and one for the frontier.\n    findFittable() {\n        let startDepth = this.unplaced.openStart;\n        for (let cur = this.unplaced.content, d = 0, openEnd = this.unplaced.openEnd; d < startDepth; d++) {\n            let node = cur.firstChild;\n            if (cur.childCount > 1)\n                openEnd = 0;\n            if (node.type.spec.isolating && openEnd <= d) {\n                startDepth = d;\n                break;\n            }\n            cur = node.content;\n        }\n        // Only try wrapping nodes (pass 2) after finding a place without\n        // wrapping failed.\n        for (let pass = 1; pass <= 2; pass++) {\n            for (let sliceDepth = pass == 1 ? startDepth : this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {\n                let fragment, parent = null;\n                if (sliceDepth) {\n                    parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;\n                    fragment = parent.content;\n                }\n                else {\n                    fragment = this.unplaced.content;\n                }\n                let first = fragment.firstChild;\n                for (let frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {\n                    let { type, match } = this.frontier[frontierDepth], wrap, inject = null;\n                    // In pass 1, if the next node matches, or there is no next\n                    // node but the parents look compatible, we've found a\n                    // place.\n                    if (pass == 1 && (first ? match.matchType(first.type) || (inject = match.fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(first), false))\n                        : parent && type.compatibleContent(parent.type)))\n                        return { sliceDepth, frontierDepth, parent, inject };\n                    // In pass 2, look for a set of wrapping nodes that make\n                    // `first` fit here.\n                    else if (pass == 2 && first && (wrap = match.findWrapping(first.type)))\n                        return { sliceDepth, frontierDepth, parent, wrap };\n                    // Don't continue looking further up if the parent node\n                    // would fit here.\n                    if (parent && match.matchType(parent.type))\n                        break;\n                }\n            }\n        }\n    }\n    openMore() {\n        let { content, openStart, openEnd } = this.unplaced;\n        let inner = contentAt(content, openStart);\n        if (!inner.childCount || inner.firstChild.isLeaf)\n            return false;\n        this.unplaced = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(content, openStart + 1, Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));\n        return true;\n    }\n    dropNode() {\n        let { content, openStart, openEnd } = this.unplaced;\n        let inner = contentAt(content, openStart);\n        if (inner.childCount <= 1 && openStart > 0) {\n            let openAtEnd = content.size - openStart <= openStart + inner.size;\n            this.unplaced = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);\n        }\n        else {\n            this.unplaced = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);\n        }\n    }\n    // Move content from the unplaced slice at `sliceDepth` to the\n    // frontier node at `frontierDepth`. Close that frontier node when\n    // applicable.\n    placeNodes({ sliceDepth, frontierDepth, parent, inject, wrap }) {\n        while (this.depth > frontierDepth)\n            this.closeFrontierNode();\n        if (wrap)\n            for (let i = 0; i < wrap.length; i++)\n                this.openFrontierNode(wrap[i]);\n        let slice = this.unplaced, fragment = parent ? parent.content : slice.content;\n        let openStart = slice.openStart - sliceDepth;\n        let taken = 0, add = [];\n        let { match, type } = this.frontier[frontierDepth];\n        if (inject) {\n            for (let i = 0; i < inject.childCount; i++)\n                add.push(inject.child(i));\n            match = match.matchFragment(inject);\n        }\n        // Computes the amount of (end) open nodes at the end of the\n        // fragment. When 0, the parent is open, but no more. When\n        // negative, nothing is open.\n        let openEndCount = (fragment.size + sliceDepth) - (slice.content.size - slice.openEnd);\n        // Scan over the fragment, fitting as many child nodes as\n        // possible.\n        while (taken < fragment.childCount) {\n            let next = fragment.child(taken), matches = match.matchType(next.type);\n            if (!matches)\n                break;\n            taken++;\n            if (taken > 1 || openStart == 0 || next.content.size) { // Drop empty open nodes\n                match = matches;\n                add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));\n            }\n        }\n        let toEnd = taken == fragment.childCount;\n        if (!toEnd)\n            openEndCount = -1;\n        this.placed = addToFragment(this.placed, frontierDepth, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(add));\n        this.frontier[frontierDepth].match = match;\n        // If the parent types match, and the entire node was moved, and\n        // it's not open, close this frontier node right away.\n        if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)\n            this.closeFrontierNode();\n        // Add new frontier nodes for any open nodes at the end.\n        for (let i = 0, cur = fragment; i < openEndCount; i++) {\n            let node = cur.lastChild;\n            this.frontier.push({ type: node.type, match: node.contentMatchAt(node.childCount) });\n            cur = node.content;\n        }\n        // Update `this.unplaced`. Drop the entire node from which we\n        // placed it we got to its end, otherwise just drop the placed\n        // nodes.\n        this.unplaced = !toEnd ? new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(dropFromFragment(slice.content, sliceDepth, taken), slice.openStart, slice.openEnd)\n            : sliceDepth == 0 ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty\n                : new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(dropFromFragment(slice.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice.openEnd : sliceDepth - 1);\n    }\n    mustMoveInline() {\n        if (!this.$to.parent.isTextblock)\n            return -1;\n        let top = this.frontier[this.depth], level;\n        if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) ||\n            (this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth))\n            return -1;\n        let { depth } = this.$to, after = this.$to.after(depth);\n        while (depth > 1 && after == this.$to.end(--depth))\n            ++after;\n        return after;\n    }\n    findCloseLevel($to) {\n        scan: for (let i = Math.min(this.depth, $to.depth); i >= 0; i--) {\n            let { match, type } = this.frontier[i];\n            let dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));\n            let fit = contentAfterFits($to, i, type, match, dropInner);\n            if (!fit)\n                continue;\n            for (let d = i - 1; d >= 0; d--) {\n                let { match, type } = this.frontier[d];\n                let matches = contentAfterFits($to, d, type, match, true);\n                if (!matches || matches.childCount)\n                    continue scan;\n            }\n            return { depth: i, fit, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to };\n        }\n    }\n    close($to) {\n        let close = this.findCloseLevel($to);\n        if (!close)\n            return null;\n        while (this.depth > close.depth)\n            this.closeFrontierNode();\n        if (close.fit.childCount)\n            this.placed = addToFragment(this.placed, close.depth, close.fit);\n        $to = close.move;\n        for (let d = close.depth + 1; d <= $to.depth; d++) {\n            let node = $to.node(d), add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));\n            this.openFrontierNode(node.type, node.attrs, add);\n        }\n        return $to;\n    }\n    openFrontierNode(type, attrs = null, content) {\n        let top = this.frontier[this.depth];\n        top.match = top.match.matchType(type);\n        this.placed = addToFragment(this.placed, this.depth, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(type.create(attrs, content)));\n        this.frontier.push({ type, match: type.contentMatch });\n    }\n    closeFrontierNode() {\n        let open = this.frontier.pop();\n        let add = open.match.fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true);\n        if (add.childCount)\n            this.placed = addToFragment(this.placed, this.frontier.length, add);\n    }\n}\nfunction dropFromFragment(fragment, depth, count) {\n    if (depth == 0)\n        return fragment.cutByIndex(count, fragment.childCount);\n    return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));\n}\nfunction addToFragment(fragment, depth, content) {\n    if (depth == 0)\n        return fragment.append(content);\n    return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)));\n}\nfunction contentAt(fragment, depth) {\n    for (let i = 0; i < depth; i++)\n        fragment = fragment.firstChild.content;\n    return fragment;\n}\nfunction closeNodeStart(node, openStart, openEnd) {\n    if (openStart <= 0)\n        return node;\n    let frag = node.content;\n    if (openStart > 1)\n        frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));\n    if (openStart > 0) {\n        frag = node.type.contentMatch.fillBefore(frag).append(frag);\n        if (openEnd <= 0)\n            frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true));\n    }\n    return node.copy(frag);\n}\nfunction contentAfterFits($to, depth, type, match, open) {\n    let node = $to.node(depth), index = open ? $to.indexAfter(depth) : $to.index(depth);\n    if (index == node.childCount && !type.compatibleContent(node.type))\n        return null;\n    let fit = match.fillBefore(node.content, true, index);\n    return fit && !invalidMarks(type, node.content, index) ? fit : null;\n}\nfunction invalidMarks(type, fragment, start) {\n    for (let i = start; i < fragment.childCount; i++)\n        if (!type.allowsMarks(fragment.child(i).marks))\n            return true;\n    return false;\n}\nfunction definesContent(type) {\n    return type.spec.defining || type.spec.definingForContent;\n}\nfunction replaceRange(tr, from, to, slice) {\n    if (!slice.size)\n        return tr.deleteRange(from, to);\n    let $from = tr.doc.resolve(from), $to = tr.doc.resolve(to);\n    if (fitsTrivially($from, $to, slice))\n        return tr.step(new ReplaceStep(from, to, slice));\n    let targetDepths = coveredDepths($from, tr.doc.resolve(to));\n    // Can't replace the whole document, so remove 0 if it's present\n    if (targetDepths[targetDepths.length - 1] == 0)\n        targetDepths.pop();\n    // Negative numbers represent not expansion over the whole node at\n    // that depth, but replacing from $from.before(-D) to $to.pos.\n    let preferredTarget = -($from.depth + 1);\n    targetDepths.unshift(preferredTarget);\n    // This loop picks a preferred target depth, if one of the covering\n    // depths is not outside of a defining node, and adds negative\n    // depths for any depth that has $from at its start and does not\n    // cross a defining node.\n    for (let d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {\n        let spec = $from.node(d).type.spec;\n        if (spec.defining || spec.definingAsContext || spec.isolating)\n            break;\n        if (targetDepths.indexOf(d) > -1)\n            preferredTarget = d;\n        else if ($from.before(d) == pos)\n            targetDepths.splice(1, 0, -d);\n    }\n    // Try to fit each possible depth of the slice into each possible\n    // target depth, starting with the preferred depths.\n    let preferredTargetIndex = targetDepths.indexOf(preferredTarget);\n    let leftNodes = [], preferredDepth = slice.openStart;\n    for (let content = slice.content, i = 0;; i++) {\n        let node = content.firstChild;\n        leftNodes.push(node);\n        if (i == slice.openStart)\n            break;\n        content = node.content;\n    }\n    // Back up preferredDepth to cover defining textblocks directly\n    // above it, possibly skipping a non-defining textblock.\n    for (let d = preferredDepth - 1; d >= 0; d--) {\n        let leftNode = leftNodes[d], def = definesContent(leftNode.type);\n        if (def && !leftNode.sameMarkup($from.node(Math.abs(preferredTarget) - 1)))\n            preferredDepth = d;\n        else if (def || !leftNode.type.isTextblock)\n            break;\n    }\n    for (let j = slice.openStart; j >= 0; j--) {\n        let openDepth = (j + preferredDepth + 1) % (slice.openStart + 1);\n        let insert = leftNodes[openDepth];\n        if (!insert)\n            continue;\n        for (let i = 0; i < targetDepths.length; i++) {\n            // Loop over possible expansion levels, starting with the\n            // preferred one\n            let targetDepth = targetDepths[(i + preferredTargetIndex) % targetDepths.length], expand = true;\n            if (targetDepth < 0) {\n                expand = false;\n                targetDepth = -targetDepth;\n            }\n            let parent = $from.node(targetDepth - 1), index = $from.index(targetDepth - 1);\n            if (parent.canReplaceWith(index, index, insert.type, insert.marks))\n                return tr.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(closeFragment(slice.content, 0, slice.openStart, openDepth), openDepth, slice.openEnd));\n        }\n    }\n    let startSteps = tr.steps.length;\n    for (let i = targetDepths.length - 1; i >= 0; i--) {\n        tr.replace(from, to, slice);\n        if (tr.steps.length > startSteps)\n            break;\n        let depth = targetDepths[i];\n        if (depth < 0)\n            continue;\n        from = $from.before(depth);\n        to = $to.after(depth);\n    }\n}\nfunction closeFragment(fragment, depth, oldOpen, newOpen, parent) {\n    if (depth < oldOpen) {\n        let first = fragment.firstChild;\n        fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)));\n    }\n    if (depth > newOpen) {\n        let match = parent.contentMatchAt(0);\n        let start = match.fillBefore(fragment).append(fragment);\n        fragment = start.append(match.matchFragment(start).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true));\n    }\n    return fragment;\n}\nfunction replaceRangeWith(tr, from, to, node) {\n    if (!node.isInline && from == to && tr.doc.resolve(from).parent.content.size) {\n        let point = insertPoint(tr.doc, from, node.type);\n        if (point != null)\n            from = to = point;\n    }\n    tr.replaceRange(from, to, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(node), 0, 0));\n}\nfunction deleteRange(tr, from, to) {\n    let $from = tr.doc.resolve(from), $to = tr.doc.resolve(to);\n    let covered = coveredDepths($from, $to);\n    for (let i = 0; i < covered.length; i++) {\n        let depth = covered[i], last = i == covered.length - 1;\n        if ((last && depth == 0) || $from.node(depth).type.contentMatch.validEnd)\n            return tr.delete($from.start(depth), $to.end(depth));\n        if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))\n            return tr.delete($from.before(depth), $to.after(depth));\n    }\n    for (let d = 1; d <= $from.depth && d <= $to.depth; d++) {\n        if (from - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d &&\n            $from.start(d - 1) == $to.start(d - 1) && $from.node(d - 1).canReplace($from.index(d - 1), $to.index(d - 1)))\n            return tr.delete($from.before(d), to);\n    }\n    tr.delete(from, to);\n}\n// Returns an array of all depths for which $from - $to spans the\n// whole content of the nodes at that depth.\nfunction coveredDepths($from, $to) {\n    let result = [], minDepth = Math.min($from.depth, $to.depth);\n    for (let d = minDepth; d >= 0; d--) {\n        let start = $from.start(d);\n        if (start < $from.pos - ($from.depth - d) ||\n            $to.end(d) > $to.pos + ($to.depth - d) ||\n            $from.node(d).type.spec.isolating ||\n            $to.node(d).type.spec.isolating)\n            break;\n        if (start == $to.start(d) ||\n            (d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent &&\n                d && $to.start(d - 1) == start - 1))\n            result.push(d);\n    }\n    return result;\n}\n\n/**\nUpdate an attribute in a specific node.\n*/\nclass AttrStep extends Step {\n    /**\n    Construct an attribute step.\n    */\n    constructor(\n    /**\n    The position of the target node.\n    */\n    pos, \n    /**\n    The attribute to set.\n    */\n    attr, \n    // The attribute's new value.\n    value) {\n        super();\n        this.pos = pos;\n        this.attr = attr;\n        this.value = value;\n    }\n    apply(doc) {\n        let node = doc.nodeAt(this.pos);\n        if (!node)\n            return StepResult.fail(\"No node at attribute step's position\");\n        let attrs = Object.create(null);\n        for (let name in node.attrs)\n            attrs[name] = node.attrs[name];\n        attrs[this.attr] = this.value;\n        let updated = node.type.create(attrs, null, node.marks);\n        return StepResult.fromReplace(doc, this.pos, this.pos + 1, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(updated), 0, node.isLeaf ? 0 : 1));\n    }\n    getMap() {\n        return StepMap.empty;\n    }\n    invert(doc) {\n        return new AttrStep(this.pos, this.attr, doc.nodeAt(this.pos).attrs[this.attr]);\n    }\n    map(mapping) {\n        let pos = mapping.mapResult(this.pos, 1);\n        return pos.deletedAfter ? null : new AttrStep(pos.pos, this.attr, this.value);\n    }\n    toJSON() {\n        return { stepType: \"attr\", pos: this.pos, attr: this.attr, value: this.value };\n    }\n    static fromJSON(schema, json) {\n        if (typeof json.pos != \"number\" || typeof json.attr != \"string\")\n            throw new RangeError(\"Invalid input for AttrStep.fromJSON\");\n        return new AttrStep(json.pos, json.attr, json.value);\n    }\n}\nStep.jsonID(\"attr\", AttrStep);\n/**\nUpdate an attribute in the doc node.\n*/\nclass DocAttrStep extends Step {\n    /**\n    Construct an attribute step.\n    */\n    constructor(\n    /**\n    The attribute to set.\n    */\n    attr, \n    // The attribute's new value.\n    value) {\n        super();\n        this.attr = attr;\n        this.value = value;\n    }\n    apply(doc) {\n        let attrs = Object.create(null);\n        for (let name in doc.attrs)\n            attrs[name] = doc.attrs[name];\n        attrs[this.attr] = this.value;\n        let updated = doc.type.create(attrs, doc.content, doc.marks);\n        return StepResult.ok(updated);\n    }\n    getMap() {\n        return StepMap.empty;\n    }\n    invert(doc) {\n        return new DocAttrStep(this.attr, doc.attrs[this.attr]);\n    }\n    map(mapping) {\n        return this;\n    }\n    toJSON() {\n        return { stepType: \"docAttr\", attr: this.attr, value: this.value };\n    }\n    static fromJSON(schema, json) {\n        if (typeof json.attr != \"string\")\n            throw new RangeError(\"Invalid input for DocAttrStep.fromJSON\");\n        return new DocAttrStep(json.attr, json.value);\n    }\n}\nStep.jsonID(\"docAttr\", DocAttrStep);\n\n/**\n@internal\n*/\nlet TransformError = class extends Error {\n};\nTransformError = function TransformError(message) {\n    let err = Error.call(this, message);\n    err.__proto__ = TransformError.prototype;\n    return err;\n};\nTransformError.prototype = Object.create(Error.prototype);\nTransformError.prototype.constructor = TransformError;\nTransformError.prototype.name = \"TransformError\";\n/**\nAbstraction to build up and track an array of\n[steps](https://prosemirror.net/docs/ref/#transform.Step) representing a document transformation.\n\nMost transforming methods return the `Transform` object itself, so\nthat they can be chained.\n*/\nclass Transform {\n    /**\n    Create a transform that starts with the given document.\n    */\n    constructor(\n    /**\n    The current document (the result of applying the steps in the\n    transform).\n    */\n    doc) {\n        this.doc = doc;\n        /**\n        The steps in this transform.\n        */\n        this.steps = [];\n        /**\n        The documents before each of the steps.\n        */\n        this.docs = [];\n        /**\n        A mapping with the maps for each of the steps in this transform.\n        */\n        this.mapping = new Mapping;\n    }\n    /**\n    The starting document.\n    */\n    get before() { return this.docs.length ? this.docs[0] : this.doc; }\n    /**\n    Apply a new step in this transform, saving the result. Throws an\n    error when the step fails.\n    */\n    step(step) {\n        let result = this.maybeStep(step);\n        if (result.failed)\n            throw new TransformError(result.failed);\n        return this;\n    }\n    /**\n    Try to apply a step in this transformation, ignoring it if it\n    fails. Returns the step result.\n    */\n    maybeStep(step) {\n        let result = step.apply(this.doc);\n        if (!result.failed)\n            this.addStep(step, result.doc);\n        return result;\n    }\n    /**\n    True when the document has been changed (when there are any\n    steps).\n    */\n    get docChanged() {\n        return this.steps.length > 0;\n    }\n    /**\n    @internal\n    */\n    addStep(step, doc) {\n        this.docs.push(this.doc);\n        this.steps.push(step);\n        this.mapping.appendMap(step.getMap());\n        this.doc = doc;\n    }\n    /**\n    Replace the part of the document between `from` and `to` with the\n    given `slice`.\n    */\n    replace(from, to = from, slice = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty) {\n        let step = replaceStep(this.doc, from, to, slice);\n        if (step)\n            this.step(step);\n        return this;\n    }\n    /**\n    Replace the given range with the given content, which may be a\n    fragment, node, or array of nodes.\n    */\n    replaceWith(from, to, content) {\n        return this.replace(from, to, new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(content), 0, 0));\n    }\n    /**\n    Delete the content between the given positions.\n    */\n    delete(from, to) {\n        return this.replace(from, to, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty);\n    }\n    /**\n    Insert the given content at the given position.\n    */\n    insert(pos, content) {\n        return this.replaceWith(pos, pos, content);\n    }\n    /**\n    Replace a range of the document with a given slice, using\n    `from`, `to`, and the slice's\n    [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather\n    than fixed start and end points. This method may grow the\n    replaced area or close open nodes in the slice in order to get a\n    fit that is more in line with WYSIWYG expectations, by dropping\n    fully covered parent nodes of the replaced region when they are\n    marked [non-defining as\n    context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an\n    open parent node from the slice that _is_ marked as [defining\n    its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).\n    \n    This is the method, for example, to handle paste. The similar\n    [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more\n    primitive tool which will _not_ move the start and end of its given\n    range, and is useful in situations where you need more precise\n    control over what happens.\n    */\n    replaceRange(from, to, slice) {\n        replaceRange(this, from, to, slice);\n        return this;\n    }\n    /**\n    Replace the given range with a node, but use `from` and `to` as\n    hints, rather than precise positions. When from and to are the same\n    and are at the start or end of a parent node in which the given\n    node doesn't fit, this method may _move_ them out towards a parent\n    that does allow the given node to be placed. When the given range\n    completely covers a parent node, this method may completely replace\n    that parent node.\n    */\n    replaceRangeWith(from, to, node) {\n        replaceRangeWith(this, from, to, node);\n        return this;\n    }\n    /**\n    Delete the given range, expanding it to cover fully covered\n    parent nodes until a valid replace is found.\n    */\n    deleteRange(from, to) {\n        deleteRange(this, from, to);\n        return this;\n    }\n    /**\n    Split the content in the given range off from its parent, if there\n    is sibling content before or after it, and move it up the tree to\n    the depth specified by `target`. You'll probably want to use\n    [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make\n    sure the lift is valid.\n    */\n    lift(range, target) {\n        lift(this, range, target);\n        return this;\n    }\n    /**\n    Join the blocks around the given position. If depth is 2, their\n    last and first siblings are also joined, and so on.\n    */\n    join(pos, depth = 1) {\n        join(this, pos, depth);\n        return this;\n    }\n    /**\n    Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.\n    The wrappers are assumed to be valid in this position, and should\n    probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).\n    */\n    wrap(range, wrappers) {\n        wrap(this, range, wrappers);\n        return this;\n    }\n    /**\n    Set the type of all textblocks (partly) between `from` and `to` to\n    the given node type with the given attributes.\n    */\n    setBlockType(from, to = from, type, attrs = null) {\n        setBlockType(this, from, to, type, attrs);\n        return this;\n    }\n    /**\n    Change the type, attributes, and/or marks of the node at `pos`.\n    When `type` isn't given, the existing node type is preserved,\n    */\n    setNodeMarkup(pos, type, attrs = null, marks) {\n        setNodeMarkup(this, pos, type, attrs, marks);\n        return this;\n    }\n    /**\n    Set a single attribute on a given node to a new value.\n    The `pos` addresses the document content. Use `setDocAttribute`\n    to set attributes on the document itself.\n    */\n    setNodeAttribute(pos, attr, value) {\n        this.step(new AttrStep(pos, attr, value));\n        return this;\n    }\n    /**\n    Set a single attribute on the document to a new value.\n    */\n    setDocAttribute(attr, value) {\n        this.step(new DocAttrStep(attr, value));\n        return this;\n    }\n    /**\n    Add a mark to the node at position `pos`.\n    */\n    addNodeMark(pos, mark) {\n        this.step(new AddNodeMarkStep(pos, mark));\n        return this;\n    }\n    /**\n    Remove a mark (or all marks of the given type) from the node at\n    position `pos`.\n    */\n    removeNodeMark(pos, mark) {\n        let node = this.doc.nodeAt(pos);\n        if (!node)\n            throw new RangeError(\"No node at position \" + pos);\n        if (mark instanceof prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Mark) {\n            if (mark.isInSet(node.marks))\n                this.step(new RemoveNodeMarkStep(pos, mark));\n        }\n        else {\n            let set = node.marks, found, steps = [];\n            while (found = mark.isInSet(set)) {\n                steps.push(new RemoveNodeMarkStep(pos, found));\n                set = found.removeFromSet(set);\n            }\n            for (let i = steps.length - 1; i >= 0; i--)\n                this.step(steps[i]);\n        }\n        return this;\n    }\n    /**\n    Split the node at the given position, and optionally, if `depth` is\n    greater than one, any number of nodes above that. By default, the\n    parts split off will inherit the node type of the original node.\n    This can be changed by passing an array of types and attributes to\n    use after the split (with the outermost nodes coming first).\n    */\n    split(pos, depth = 1, typesAfter) {\n        split(this, pos, depth, typesAfter);\n        return this;\n    }\n    /**\n    Add the given mark to the inline content between `from` and `to`.\n    */\n    addMark(from, to, mark) {\n        addMark(this, from, to, mark);\n        return this;\n    }\n    /**\n    Remove marks from inline nodes between `from` and `to`. When\n    `mark` is a single mark, remove precisely that mark. When it is\n    a mark type, remove all marks of that type. When it is null,\n    remove all marks of any type.\n    */\n    removeMark(from, to, mark) {\n        removeMark(this, from, to, mark);\n        return this;\n    }\n    /**\n    Removes all marks and nodes from the content of the node at\n    `pos` that don't match the given new parent node type. Accepts\n    an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as\n    third argument.\n    */\n    clearIncompatible(pos, parentType, match) {\n        clearIncompatible(this, pos, parentType, match);\n        return this;\n    }\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci10cmFuc2Zvcm0vZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBa0Y7O0FBRWxGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsK0JBQStCO0FBQy9CLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFdBQVc7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsb0RBQUs7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsb0RBQUssQ0FBQyx1REFBUTtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLG9EQUFLO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtREFBSTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsUUFBUTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMFMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLXRyYW5zZm9ybS9kaXN0L2luZGV4LmpzP2I2ODIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUmVwbGFjZUVycm9yLCBTbGljZSwgRnJhZ21lbnQsIE1hcmtUeXBlLCBNYXJrIH0gZnJvbSAncHJvc2VtaXJyb3ItbW9kZWwnO1xuXG4vLyBSZWNvdmVyeSB2YWx1ZXMgZW5jb2RlIGEgcmFuZ2UgaW5kZXggYW5kIGFuIG9mZnNldC4gVGhleSBhcmVcbi8vIHJlcHJlc2VudGVkIGFzIG51bWJlcnMsIGJlY2F1c2UgdG9ucyBvZiB0aGVtIHdpbGwgYmUgY3JlYXRlZCB3aGVuXG4vLyBtYXBwaW5nLCBmb3IgZXhhbXBsZSwgYSBsYXJnZSBudW1iZXIgb2YgZGVjb3JhdGlvbnMuIFRoZSBudW1iZXInc1xuLy8gbG93ZXIgMTYgYml0cyBwcm92aWRlIHRoZSBpbmRleCwgdGhlIHJlbWFpbmluZyBiaXRzIHRoZSBvZmZzZXQuXG4vL1xuLy8gTm90ZTogV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYml0IHNoaWZ0IG9wZXJhdG9ycyB0byBlbi0gYW5kXG4vLyBkZWNvZGUgdGhlc2UsIHNpbmNlIHRob3NlIGNsaXAgdG8gMzIgYml0cywgd2hpY2ggd2UgbWlnaHQgaW4gcmFyZVxuLy8gY2FzZXMgd2FudCB0byBvdmVyZmxvdy4gQSA2NC1iaXQgZmxvYXQgY2FuIHJlcHJlc2VudCA0OC1iaXRcbi8vIGludGVnZXJzIHByZWNpc2VseS5cbmNvbnN0IGxvd2VyMTYgPSAweGZmZmY7XG5jb25zdCBmYWN0b3IxNiA9IE1hdGgucG93KDIsIDE2KTtcbmZ1bmN0aW9uIG1ha2VSZWNvdmVyKGluZGV4LCBvZmZzZXQpIHsgcmV0dXJuIGluZGV4ICsgb2Zmc2V0ICogZmFjdG9yMTY7IH1cbmZ1bmN0aW9uIHJlY292ZXJJbmRleCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgJiBsb3dlcjE2OyB9XG5mdW5jdGlvbiByZWNvdmVyT2Zmc2V0KHZhbHVlKSB7IHJldHVybiAodmFsdWUgLSAodmFsdWUgJiBsb3dlcjE2KSkgLyBmYWN0b3IxNjsgfVxuY29uc3QgREVMX0JFRk9SRSA9IDEsIERFTF9BRlRFUiA9IDIsIERFTF9BQ1JPU1MgPSA0LCBERUxfU0lERSA9IDg7XG4vKipcbkFuIG9iamVjdCByZXByZXNlbnRpbmcgYSBtYXBwZWQgcG9zaXRpb24gd2l0aCBleHRyYVxuaW5mb3JtYXRpb24uXG4qL1xuY2xhc3MgTWFwUmVzdWx0IHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBtYXBwZWQgdmVyc2lvbiBvZiB0aGUgcG9zaXRpb24uXG4gICAgKi9cbiAgICBwb3MsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZGVsSW5mbywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByZWNvdmVyKSB7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLmRlbEluZm8gPSBkZWxJbmZvO1xuICAgICAgICB0aGlzLnJlY292ZXIgPSByZWNvdmVyO1xuICAgIH1cbiAgICAvKipcbiAgICBUZWxscyB5b3Ugd2hldGhlciB0aGUgcG9zaXRpb24gd2FzIGRlbGV0ZWQsIHRoYXQgaXMsIHdoZXRoZXIgdGhlXG4gICAgc3RlcCByZW1vdmVkIHRoZSB0b2tlbiBvbiB0aGUgc2lkZSBxdWVyaWVkICh2aWEgdGhlIGBhc3NvY2ApXG4gICAgYXJndW1lbnQgZnJvbSB0aGUgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBnZXQgZGVsZXRlZCgpIHsgcmV0dXJuICh0aGlzLmRlbEluZm8gJiBERUxfU0lERSkgPiAwOyB9XG4gICAgLyoqXG4gICAgVGVsbHMgeW91IHdoZXRoZXIgdGhlIHRva2VuIGJlZm9yZSB0aGUgbWFwcGVkIHBvc2l0aW9uIHdhcyBkZWxldGVkLlxuICAgICovXG4gICAgZ2V0IGRlbGV0ZWRCZWZvcmUoKSB7IHJldHVybiAodGhpcy5kZWxJbmZvICYgKERFTF9CRUZPUkUgfCBERUxfQUNST1NTKSkgPiAwOyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoZSB0b2tlbiBhZnRlciB0aGUgbWFwcGVkIHBvc2l0aW9uIHdhcyBkZWxldGVkLlxuICAgICovXG4gICAgZ2V0IGRlbGV0ZWRBZnRlcigpIHsgcmV0dXJuICh0aGlzLmRlbEluZm8gJiAoREVMX0FGVEVSIHwgREVMX0FDUk9TUykpID4gMDsgfVxuICAgIC8qKlxuICAgIFRlbGxzIHdoZXRoZXIgYW55IG9mIHRoZSBzdGVwcyBtYXBwZWQgdGhyb3VnaCBkZWxldGVzIGFjcm9zcyB0aGVcbiAgICBwb3NpdGlvbiAoaW5jbHVkaW5nIGJvdGggdGhlIHRva2VuIGJlZm9yZSBhbmQgYWZ0ZXIgdGhlXG4gICAgcG9zaXRpb24pLlxuICAgICovXG4gICAgZ2V0IGRlbGV0ZWRBY3Jvc3MoKSB7IHJldHVybiAodGhpcy5kZWxJbmZvICYgREVMX0FDUk9TUykgPiAwOyB9XG59XG4vKipcbkEgbWFwIGRlc2NyaWJpbmcgdGhlIGRlbGV0aW9ucyBhbmQgaW5zZXJ0aW9ucyBtYWRlIGJ5IGEgc3RlcCwgd2hpY2hcbmNhbiBiZSB1c2VkIHRvIGZpbmQgdGhlIGNvcnJlc3BvbmRlbmNlIGJldHdlZW4gcG9zaXRpb25zIGluIHRoZVxucHJlLXN0ZXAgdmVyc2lvbiBvZiBhIGRvY3VtZW50IGFuZCB0aGUgc2FtZSBwb3NpdGlvbiBpbiB0aGVcbnBvc3Qtc3RlcCB2ZXJzaW9uLlxuKi9cbmNsYXNzIFN0ZXBNYXAge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHBvc2l0aW9uIG1hcC4gVGhlIG1vZGlmaWNhdGlvbnMgdG8gdGhlIGRvY3VtZW50IGFyZVxuICAgIHJlcHJlc2VudGVkIGFzIGFuIGFycmF5IG9mIG51bWJlcnMsIGluIHdoaWNoIGVhY2ggZ3JvdXAgb2YgdGhyZWVcbiAgICByZXByZXNlbnRzIGEgbW9kaWZpZWQgY2h1bmsgYXMgYFtzdGFydCwgb2xkU2l6ZSwgbmV3U2l6ZV1gLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByYW5nZXMsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgaW52ZXJ0ZWQgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcztcbiAgICAgICAgdGhpcy5pbnZlcnRlZCA9IGludmVydGVkO1xuICAgICAgICBpZiAoIXJhbmdlcy5sZW5ndGggJiYgU3RlcE1hcC5lbXB0eSlcbiAgICAgICAgICAgIHJldHVybiBTdGVwTWFwLmVtcHR5O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlY292ZXIodmFsdWUpIHtcbiAgICAgICAgbGV0IGRpZmYgPSAwLCBpbmRleCA9IHJlY292ZXJJbmRleCh2YWx1ZSk7XG4gICAgICAgIGlmICghdGhpcy5pbnZlcnRlZClcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXg7IGkrKylcbiAgICAgICAgICAgICAgICBkaWZmICs9IHRoaXMucmFuZ2VzW2kgKiAzICsgMl0gLSB0aGlzLnJhbmdlc1tpICogMyArIDFdO1xuICAgICAgICByZXR1cm4gdGhpcy5yYW5nZXNbaW5kZXggKiAzXSArIGRpZmYgKyByZWNvdmVyT2Zmc2V0KHZhbHVlKTtcbiAgICB9XG4gICAgbWFwUmVzdWx0KHBvcywgYXNzb2MgPSAxKSB7IHJldHVybiB0aGlzLl9tYXAocG9zLCBhc3NvYywgZmFsc2UpOyB9XG4gICAgbWFwKHBvcywgYXNzb2MgPSAxKSB7IHJldHVybiB0aGlzLl9tYXAocG9zLCBhc3NvYywgdHJ1ZSk7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIF9tYXAocG9zLCBhc3NvYywgc2ltcGxlKSB7XG4gICAgICAgIGxldCBkaWZmID0gMCwgb2xkSW5kZXggPSB0aGlzLmludmVydGVkID8gMiA6IDEsIG5ld0luZGV4ID0gdGhpcy5pbnZlcnRlZCA/IDEgOiAyO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucmFuZ2VzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSB0aGlzLnJhbmdlc1tpXSAtICh0aGlzLmludmVydGVkID8gZGlmZiA6IDApO1xuICAgICAgICAgICAgaWYgKHN0YXJ0ID4gcG9zKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbGV0IG9sZFNpemUgPSB0aGlzLnJhbmdlc1tpICsgb2xkSW5kZXhdLCBuZXdTaXplID0gdGhpcy5yYW5nZXNbaSArIG5ld0luZGV4XSwgZW5kID0gc3RhcnQgKyBvbGRTaXplO1xuICAgICAgICAgICAgaWYgKHBvcyA8PSBlbmQpIHtcbiAgICAgICAgICAgICAgICBsZXQgc2lkZSA9ICFvbGRTaXplID8gYXNzb2MgOiBwb3MgPT0gc3RhcnQgPyAtMSA6IHBvcyA9PSBlbmQgPyAxIDogYXNzb2M7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHN0YXJ0ICsgZGlmZiArIChzaWRlIDwgMCA/IDAgOiBuZXdTaXplKTtcbiAgICAgICAgICAgICAgICBpZiAoc2ltcGxlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGxldCByZWNvdmVyID0gcG9zID09IChhc3NvYyA8IDAgPyBzdGFydCA6IGVuZCkgPyBudWxsIDogbWFrZVJlY292ZXIoaSAvIDMsIHBvcyAtIHN0YXJ0KTtcbiAgICAgICAgICAgICAgICBsZXQgZGVsID0gcG9zID09IHN0YXJ0ID8gREVMX0FGVEVSIDogcG9zID09IGVuZCA/IERFTF9CRUZPUkUgOiBERUxfQUNST1NTO1xuICAgICAgICAgICAgICAgIGlmIChhc3NvYyA8IDAgPyBwb3MgIT0gc3RhcnQgOiBwb3MgIT0gZW5kKVxuICAgICAgICAgICAgICAgICAgICBkZWwgfD0gREVMX1NJREU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNYXBSZXN1bHQocmVzdWx0LCBkZWwsIHJlY292ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlmZiArPSBuZXdTaXplIC0gb2xkU2l6ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2ltcGxlID8gcG9zICsgZGlmZiA6IG5ldyBNYXBSZXN1bHQocG9zICsgZGlmZiwgMCwgbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG91Y2hlcyhwb3MsIHJlY292ZXIpIHtcbiAgICAgICAgbGV0IGRpZmYgPSAwLCBpbmRleCA9IHJlY292ZXJJbmRleChyZWNvdmVyKTtcbiAgICAgICAgbGV0IG9sZEluZGV4ID0gdGhpcy5pbnZlcnRlZCA/IDIgOiAxLCBuZXdJbmRleCA9IHRoaXMuaW52ZXJ0ZWQgPyAxIDogMjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJhbmdlcy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5yYW5nZXNbaV0gLSAodGhpcy5pbnZlcnRlZCA/IGRpZmYgOiAwKTtcbiAgICAgICAgICAgIGlmIChzdGFydCA+IHBvcylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCBvbGRTaXplID0gdGhpcy5yYW5nZXNbaSArIG9sZEluZGV4XSwgZW5kID0gc3RhcnQgKyBvbGRTaXplO1xuICAgICAgICAgICAgaWYgKHBvcyA8PSBlbmQgJiYgaSA9PSBpbmRleCAqIDMpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBkaWZmICs9IHRoaXMucmFuZ2VzW2kgKyBuZXdJbmRleF0gLSBvbGRTaXplO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ2FsbHMgdGhlIGdpdmVuIGZ1bmN0aW9uIG9uIGVhY2ggb2YgdGhlIGNoYW5nZWQgcmFuZ2VzIGluY2x1ZGVkIGluXG4gICAgdGhpcyBtYXAuXG4gICAgKi9cbiAgICBmb3JFYWNoKGYpIHtcbiAgICAgICAgbGV0IG9sZEluZGV4ID0gdGhpcy5pbnZlcnRlZCA/IDIgOiAxLCBuZXdJbmRleCA9IHRoaXMuaW52ZXJ0ZWQgPyAxIDogMjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGRpZmYgPSAwOyBpIDwgdGhpcy5yYW5nZXMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMucmFuZ2VzW2ldLCBvbGRTdGFydCA9IHN0YXJ0IC0gKHRoaXMuaW52ZXJ0ZWQgPyBkaWZmIDogMCksIG5ld1N0YXJ0ID0gc3RhcnQgKyAodGhpcy5pbnZlcnRlZCA/IDAgOiBkaWZmKTtcbiAgICAgICAgICAgIGxldCBvbGRTaXplID0gdGhpcy5yYW5nZXNbaSArIG9sZEluZGV4XSwgbmV3U2l6ZSA9IHRoaXMucmFuZ2VzW2kgKyBuZXdJbmRleF07XG4gICAgICAgICAgICBmKG9sZFN0YXJ0LCBvbGRTdGFydCArIG9sZFNpemUsIG5ld1N0YXJ0LCBuZXdTdGFydCArIG5ld1NpemUpO1xuICAgICAgICAgICAgZGlmZiArPSBuZXdTaXplIC0gb2xkU2l6ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYW4gaW52ZXJ0ZWQgdmVyc2lvbiBvZiB0aGlzIG1hcC4gVGhlIHJlc3VsdCBjYW4gYmUgdXNlZCB0b1xuICAgIG1hcCBwb3NpdGlvbnMgaW4gdGhlIHBvc3Qtc3RlcCBkb2N1bWVudCB0byB0aGUgcHJlLXN0ZXAgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBpbnZlcnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RlcE1hcCh0aGlzLnJhbmdlcywgIXRoaXMuaW52ZXJ0ZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuaW52ZXJ0ZWQgPyBcIi1cIiA6IFwiXCIpICsgSlNPTi5zdHJpbmdpZnkodGhpcy5yYW5nZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBtYXAgdGhhdCBtb3ZlcyBhbGwgcG9zaXRpb25zIGJ5IG9mZnNldCBgbmAgKHdoaWNoIG1heSBiZVxuICAgIG5lZ2F0aXZlKS4gVGhpcyBjYW4gYmUgdXNlZnVsIHdoZW4gYXBwbHlpbmcgc3RlcHMgbWVhbnQgZm9yIGFcbiAgICBzdWItZG9jdW1lbnQgdG8gYSBsYXJnZXIgZG9jdW1lbnQsIG9yIHZpY2UtdmVyc2EuXG4gICAgKi9cbiAgICBzdGF0aWMgb2Zmc2V0KG4pIHtcbiAgICAgICAgcmV0dXJuIG4gPT0gMCA/IFN0ZXBNYXAuZW1wdHkgOiBuZXcgU3RlcE1hcChuIDwgMCA/IFswLCAtbiwgMF0gOiBbMCwgMCwgbl0pO1xuICAgIH1cbn1cbi8qKlxuQSBTdGVwTWFwIHRoYXQgY29udGFpbnMgbm8gY2hhbmdlZCByYW5nZXMuXG4qL1xuU3RlcE1hcC5lbXB0eSA9IG5ldyBTdGVwTWFwKFtdKTtcbi8qKlxuQSBtYXBwaW5nIHJlcHJlc2VudHMgYSBwaXBlbGluZSBvZiB6ZXJvIG9yIG1vcmUgW3N0ZXBcbm1hcHNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN0cmFuc2Zvcm0uU3RlcE1hcCkuIEl0IGhhcyBzcGVjaWFsIHByb3Zpc2lvbnMgZm9yIGxvc3NsZXNzbHlcbmhhbmRsaW5nIG1hcHBpbmcgcG9zaXRpb25zIHRocm91Z2ggYSBzZXJpZXMgb2Ygc3RlcHMgaW4gd2hpY2ggc29tZVxuc3RlcHMgYXJlIGludmVydGVkIHZlcnNpb25zIG9mIGVhcmxpZXIgc3RlcHMuIChUaGlzIGNvbWVzIHVwIHdoZW5cbuKAmFtyZWJhc2luZ10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9ndWlkZS8jdHJhbnNmb3JtLnJlYmFzaW5nKeKAmSBzdGVwcyBmb3JcbmNvbGxhYm9yYXRpb24gb3IgaGlzdG9yeSBtYW5hZ2VtZW50LilcbiovXG5jbGFzcyBNYXBwaW5nIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSBuZXcgbWFwcGluZyB3aXRoIHRoZSBnaXZlbiBwb3NpdGlvbiBtYXBzLlxuICAgICovXG4gICAgY29uc3RydWN0b3IobWFwcywgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtaXJyb3IsIFxuICAgIC8qKlxuICAgIFRoZSBzdGFydGluZyBwb3NpdGlvbiBpbiB0aGUgYG1hcHNgIGFycmF5LCB1c2VkIHdoZW4gYG1hcGAgb3JcbiAgICBgbWFwUmVzdWx0YCBpcyBjYWxsZWQuXG4gICAgKi9cbiAgICBmcm9tID0gMCwgXG4gICAgLyoqXG4gICAgVGhlIGVuZCBwb3NpdGlvbiBpbiB0aGUgYG1hcHNgIGFycmF5LlxuICAgICovXG4gICAgdG8gPSBtYXBzID8gbWFwcy5sZW5ndGggOiAwKSB7XG4gICAgICAgIHRoaXMubWlycm9yID0gbWlycm9yO1xuICAgICAgICB0aGlzLmZyb20gPSBmcm9tO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgICAgIHRoaXMuX21hcHMgPSBtYXBzIHx8IFtdO1xuICAgICAgICB0aGlzLm93bkRhdGEgPSAhKG1hcHMgfHwgbWlycm9yKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIHN0ZXAgbWFwcyBpbiB0aGlzIG1hcHBpbmcuXG4gICAgKi9cbiAgICBnZXQgbWFwcygpIHsgcmV0dXJuIHRoaXMuX21hcHM7IH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBtYXBwaW5nIHRoYXQgbWFwcyBvbmx5IHRocm91Z2ggYSBwYXJ0IG9mIHRoaXMgb25lLlxuICAgICovXG4gICAgc2xpY2UoZnJvbSA9IDAsIHRvID0gdGhpcy5tYXBzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbmV3IE1hcHBpbmcodGhpcy5fbWFwcywgdGhpcy5taXJyb3IsIGZyb20sIHRvKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQWRkIGEgc3RlcCBtYXAgdG8gdGhlIGVuZCBvZiB0aGlzIG1hcHBpbmcuIElmIGBtaXJyb3JzYCBpc1xuICAgIGdpdmVuLCBpdCBzaG91bGQgYmUgdGhlIGluZGV4IG9mIHRoZSBzdGVwIG1hcCB0aGF0IGlzIHRoZSBtaXJyb3JcbiAgICBpbWFnZSBvZiB0aGlzIG9uZS5cbiAgICAqL1xuICAgIGFwcGVuZE1hcChtYXAsIG1pcnJvcnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLm93bkRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcHMgPSB0aGlzLl9tYXBzLnNsaWNlKCk7XG4gICAgICAgICAgICB0aGlzLm1pcnJvciA9IHRoaXMubWlycm9yICYmIHRoaXMubWlycm9yLnNsaWNlKCk7XG4gICAgICAgICAgICB0aGlzLm93bkRhdGEgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudG8gPSB0aGlzLl9tYXBzLnB1c2gobWFwKTtcbiAgICAgICAgaWYgKG1pcnJvcnMgIT0gbnVsbClcbiAgICAgICAgICAgIHRoaXMuc2V0TWlycm9yKHRoaXMuX21hcHMubGVuZ3RoIC0gMSwgbWlycm9ycyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEFkZCBhbGwgdGhlIHN0ZXAgbWFwcyBpbiBhIGdpdmVuIG1hcHBpbmcgdG8gdGhpcyBvbmUgKHByZXNlcnZpbmdcbiAgICBtaXJyb3JpbmcgaW5mb3JtYXRpb24pLlxuICAgICovXG4gICAgYXBwZW5kTWFwcGluZyhtYXBwaW5nKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBzdGFydFNpemUgPSB0aGlzLl9tYXBzLmxlbmd0aDsgaSA8IG1hcHBpbmcuX21hcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBtaXJyID0gbWFwcGluZy5nZXRNaXJyb3IoaSk7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZE1hcChtYXBwaW5nLl9tYXBzW2ldLCBtaXJyICE9IG51bGwgJiYgbWlyciA8IGkgPyBzdGFydFNpemUgKyBtaXJyIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBGaW5kcyB0aGUgb2Zmc2V0IG9mIHRoZSBzdGVwIG1hcCB0aGF0IG1pcnJvcnMgdGhlIG1hcCBhdCB0aGVcbiAgICBnaXZlbiBvZmZzZXQsIGluIHRoaXMgbWFwcGluZyAoYXMgcGVyIHRoZSBzZWNvbmQgYXJndW1lbnQgdG9cbiAgICBgYXBwZW5kTWFwYCkuXG4gICAgKi9cbiAgICBnZXRNaXJyb3Iobikge1xuICAgICAgICBpZiAodGhpcy5taXJyb3IpXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWlycm9yLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1pcnJvcltpXSA9PSBuKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5taXJyb3JbaSArIChpICUgMiA/IC0xIDogMSldO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNldE1pcnJvcihuLCBtKSB7XG4gICAgICAgIGlmICghdGhpcy5taXJyb3IpXG4gICAgICAgICAgICB0aGlzLm1pcnJvciA9IFtdO1xuICAgICAgICB0aGlzLm1pcnJvci5wdXNoKG4sIG0pO1xuICAgIH1cbiAgICAvKipcbiAgICBBcHBlbmQgdGhlIGludmVyc2Ugb2YgdGhlIGdpdmVuIG1hcHBpbmcgdG8gdGhpcyBvbmUuXG4gICAgKi9cbiAgICBhcHBlbmRNYXBwaW5nSW52ZXJ0ZWQobWFwcGluZykge1xuICAgICAgICBmb3IgKGxldCBpID0gbWFwcGluZy5tYXBzLmxlbmd0aCAtIDEsIHRvdGFsU2l6ZSA9IHRoaXMuX21hcHMubGVuZ3RoICsgbWFwcGluZy5fbWFwcy5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgbWlyciA9IG1hcHBpbmcuZ2V0TWlycm9yKGkpO1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRNYXAobWFwcGluZy5fbWFwc1tpXS5pbnZlcnQoKSwgbWlyciAhPSBudWxsICYmIG1pcnIgPiBpID8gdG90YWxTaXplIC0gbWlyciAtIDEgOiB1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhbiBpbnZlcnRlZCB2ZXJzaW9uIG9mIHRoaXMgbWFwcGluZy5cbiAgICAqL1xuICAgIGludmVydCgpIHtcbiAgICAgICAgbGV0IGludmVyc2UgPSBuZXcgTWFwcGluZztcbiAgICAgICAgaW52ZXJzZS5hcHBlbmRNYXBwaW5nSW52ZXJ0ZWQodGhpcyk7XG4gICAgICAgIHJldHVybiBpbnZlcnNlO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXAgYSBwb3NpdGlvbiB0aHJvdWdoIHRoaXMgbWFwcGluZy5cbiAgICAqL1xuICAgIG1hcChwb3MsIGFzc29jID0gMSkge1xuICAgICAgICBpZiAodGhpcy5taXJyb3IpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWFwKHBvcywgYXNzb2MsIHRydWUpO1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5mcm9tOyBpIDwgdGhpcy50bzsgaSsrKVxuICAgICAgICAgICAgcG9zID0gdGhpcy5fbWFwc1tpXS5tYXAocG9zLCBhc3NvYyk7XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIC8qKlxuICAgIE1hcCBhIHBvc2l0aW9uIHRocm91Z2ggdGhpcyBtYXBwaW5nLCByZXR1cm5pbmcgYSBtYXBwaW5nXG4gICAgcmVzdWx0LlxuICAgICovXG4gICAgbWFwUmVzdWx0KHBvcywgYXNzb2MgPSAxKSB7IHJldHVybiB0aGlzLl9tYXAocG9zLCBhc3NvYywgZmFsc2UpOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBfbWFwKHBvcywgYXNzb2MsIHNpbXBsZSkge1xuICAgICAgICBsZXQgZGVsSW5mbyA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmZyb207IGkgPCB0aGlzLnRvOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBtYXAgPSB0aGlzLl9tYXBzW2ldLCByZXN1bHQgPSBtYXAubWFwUmVzdWx0KHBvcywgYXNzb2MpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5yZWNvdmVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsZXQgY29yciA9IHRoaXMuZ2V0TWlycm9yKGkpO1xuICAgICAgICAgICAgICAgIGlmIChjb3JyICE9IG51bGwgJiYgY29yciA+IGkgJiYgY29yciA8IHRoaXMudG8pIHtcbiAgICAgICAgICAgICAgICAgICAgaSA9IGNvcnI7XG4gICAgICAgICAgICAgICAgICAgIHBvcyA9IHRoaXMuX21hcHNbY29ycl0ucmVjb3ZlcihyZXN1bHQucmVjb3Zlcik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlbEluZm8gfD0gcmVzdWx0LmRlbEluZm87XG4gICAgICAgICAgICBwb3MgPSByZXN1bHQucG9zO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaW1wbGUgPyBwb3MgOiBuZXcgTWFwUmVzdWx0KHBvcywgZGVsSW5mbywgbnVsbCk7XG4gICAgfVxufVxuXG5jb25zdCBzdGVwc0J5SUQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqXG5BIHN0ZXAgb2JqZWN0IHJlcHJlc2VudHMgYW4gYXRvbWljIGNoYW5nZS4gSXQgZ2VuZXJhbGx5IGFwcGxpZXNcbm9ubHkgdG8gdGhlIGRvY3VtZW50IGl0IHdhcyBjcmVhdGVkIGZvciwgc2luY2UgdGhlIHBvc2l0aW9uc1xuc3RvcmVkIGluIGl0IHdpbGwgb25seSBtYWtlIHNlbnNlIGZvciB0aGF0IGRvY3VtZW50LlxuXG5OZXcgc3RlcHMgYXJlIGRlZmluZWQgYnkgY3JlYXRpbmcgY2xhc3NlcyB0aGF0IGV4dGVuZCBgU3RlcGAsXG5vdmVycmlkaW5nIHRoZSBgYXBwbHlgLCBgaW52ZXJ0YCwgYG1hcGAsIGBnZXRNYXBgIGFuZCBgZnJvbUpTT05gXG5tZXRob2RzLCBhbmQgcmVnaXN0ZXJpbmcgeW91ciBjbGFzcyB3aXRoIGEgdW5pcXVlXG5KU09OLXNlcmlhbGl6YXRpb24gaWRlbnRpZmllciB1c2luZ1xuW2BTdGVwLmpzb25JRGBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN0cmFuc2Zvcm0uU3RlcF5qc29uSUQpLlxuKi9cbmNsYXNzIFN0ZXAge1xuICAgIC8qKlxuICAgIEdldCB0aGUgc3RlcCBtYXAgdGhhdCByZXByZXNlbnRzIHRoZSBjaGFuZ2VzIG1hZGUgYnkgdGhpcyBzdGVwLFxuICAgIGFuZCB3aGljaCBjYW4gYmUgdXNlZCB0byB0cmFuc2Zvcm0gYmV0d2VlbiBwb3NpdGlvbnMgaW4gdGhlIG9sZFxuICAgIGFuZCB0aGUgbmV3IGRvY3VtZW50LlxuICAgICovXG4gICAgZ2V0TWFwKCkgeyByZXR1cm4gU3RlcE1hcC5lbXB0eTsgfVxuICAgIC8qKlxuICAgIFRyeSB0byBtZXJnZSB0aGlzIHN0ZXAgd2l0aCBhbm90aGVyIG9uZSwgdG8gYmUgYXBwbGllZCBkaXJlY3RseVxuICAgIGFmdGVyIGl0LiBSZXR1cm5zIHRoZSBtZXJnZWQgc3RlcCB3aGVuIHBvc3NpYmxlLCBudWxsIGlmIHRoZVxuICAgIHN0ZXBzIGNhbid0IGJlIG1lcmdlZC5cbiAgICAqL1xuICAgIG1lcmdlKG90aGVyKSB7IHJldHVybiBudWxsOyB9XG4gICAgLyoqXG4gICAgRGVzZXJpYWxpemUgYSBzdGVwIGZyb20gaXRzIEpTT04gcmVwcmVzZW50YXRpb24uIFdpbGwgY2FsbFxuICAgIHRocm91Z2ggdG8gdGhlIHN0ZXAgY2xhc3MnIG93biBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIG1ldGhvZC5cbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKCFqc29uIHx8ICFqc29uLnN0ZXBUeXBlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBTdGVwLmZyb21KU09OXCIpO1xuICAgICAgICBsZXQgdHlwZSA9IHN0ZXBzQnlJRFtqc29uLnN0ZXBUeXBlXTtcbiAgICAgICAgaWYgKCF0eXBlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYE5vIHN0ZXAgdHlwZSAke2pzb24uc3RlcFR5cGV9IGRlZmluZWRgKTtcbiAgICAgICAgcmV0dXJuIHR5cGUuZnJvbUpTT04oc2NoZW1hLCBqc29uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVG8gYmUgYWJsZSB0byBzZXJpYWxpemUgc3RlcHMgdG8gSlNPTiwgZWFjaCBzdGVwIG5lZWRzIGEgc3RyaW5nXG4gICAgSUQgdG8gYXR0YWNoIHRvIGl0cyBKU09OIHJlcHJlc2VudGF0aW9uLiBVc2UgdGhpcyBtZXRob2QgdG9cbiAgICByZWdpc3RlciBhbiBJRCBmb3IgeW91ciBzdGVwIGNsYXNzZXMuIFRyeSB0byBwaWNrIHNvbWV0aGluZ1xuICAgIHRoYXQncyB1bmxpa2VseSB0byBjbGFzaCB3aXRoIHN0ZXBzIGZyb20gb3RoZXIgbW9kdWxlcy5cbiAgICAqL1xuICAgIHN0YXRpYyBqc29uSUQoaWQsIHN0ZXBDbGFzcykge1xuICAgICAgICBpZiAoaWQgaW4gc3RlcHNCeUlEKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJEdXBsaWNhdGUgdXNlIG9mIHN0ZXAgSlNPTiBJRCBcIiArIGlkKTtcbiAgICAgICAgc3RlcHNCeUlEW2lkXSA9IHN0ZXBDbGFzcztcbiAgICAgICAgc3RlcENsYXNzLnByb3RvdHlwZS5qc29uSUQgPSBpZDtcbiAgICAgICAgcmV0dXJuIHN0ZXBDbGFzcztcbiAgICB9XG59XG4vKipcblRoZSByZXN1bHQgb2YgW2FwcGx5aW5nXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdHJhbnNmb3JtLlN0ZXAuYXBwbHkpIGEgc3RlcC4gQ29udGFpbnMgZWl0aGVyIGFcbm5ldyBkb2N1bWVudCBvciBhIGZhaWx1cmUgdmFsdWUuXG4qL1xuY2xhc3MgU3RlcFJlc3VsdCB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgdHJhbnNmb3JtZWQgZG9jdW1lbnQsIGlmIHN1Y2Nlc3NmdWwuXG4gICAgKi9cbiAgICBkb2MsIFxuICAgIC8qKlxuICAgIFRoZSBmYWlsdXJlIG1lc3NhZ2UsIGlmIHVuc3VjY2Vzc2Z1bC5cbiAgICAqL1xuICAgIGZhaWxlZCkge1xuICAgICAgICB0aGlzLmRvYyA9IGRvYztcbiAgICAgICAgdGhpcy5mYWlsZWQgPSBmYWlsZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHN1Y2Nlc3NmdWwgc3RlcCByZXN1bHQuXG4gICAgKi9cbiAgICBzdGF0aWMgb2soZG9jKSB7IHJldHVybiBuZXcgU3RlcFJlc3VsdChkb2MsIG51bGwpOyB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgZmFpbGVkIHN0ZXAgcmVzdWx0LlxuICAgICovXG4gICAgc3RhdGljIGZhaWwobWVzc2FnZSkgeyByZXR1cm4gbmV3IFN0ZXBSZXN1bHQobnVsbCwgbWVzc2FnZSk7IH1cbiAgICAvKipcbiAgICBDYWxsIFtgTm9kZS5yZXBsYWNlYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGUucmVwbGFjZSkgd2l0aCB0aGUgZ2l2ZW5cbiAgICBhcmd1bWVudHMuIENyZWF0ZSBhIHN1Y2Nlc3NmdWwgcmVzdWx0IGlmIGl0IHN1Y2NlZWRzLCBhbmQgYVxuICAgIGZhaWxlZCBvbmUgaWYgaXQgdGhyb3dzIGEgYFJlcGxhY2VFcnJvcmAuXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbVJlcGxhY2UoZG9jLCBmcm9tLCB0bywgc2xpY2UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBTdGVwUmVzdWx0Lm9rKGRvYy5yZXBsYWNlKGZyb20sIHRvLCBzbGljZSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIFJlcGxhY2VFcnJvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mYWlsKGUubWVzc2FnZSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBtYXBGcmFnbWVudChmcmFnbWVudCwgZiwgcGFyZW50KSB7XG4gICAgbGV0IG1hcHBlZCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZnJhZ21lbnQuY2hpbGRDb3VudDsgaSsrKSB7XG4gICAgICAgIGxldCBjaGlsZCA9IGZyYWdtZW50LmNoaWxkKGkpO1xuICAgICAgICBpZiAoY2hpbGQuY29udGVudC5zaXplKVxuICAgICAgICAgICAgY2hpbGQgPSBjaGlsZC5jb3B5KG1hcEZyYWdtZW50KGNoaWxkLmNvbnRlbnQsIGYsIGNoaWxkKSk7XG4gICAgICAgIGlmIChjaGlsZC5pc0lubGluZSlcbiAgICAgICAgICAgIGNoaWxkID0gZihjaGlsZCwgcGFyZW50LCBpKTtcbiAgICAgICAgbWFwcGVkLnB1c2goY2hpbGQpO1xuICAgIH1cbiAgICByZXR1cm4gRnJhZ21lbnQuZnJvbUFycmF5KG1hcHBlZCk7XG59XG4vKipcbkFkZCBhIG1hcmsgdG8gYWxsIGlubGluZSBjb250ZW50IGJldHdlZW4gdHdvIHBvc2l0aW9ucy5cbiovXG5jbGFzcyBBZGRNYXJrU3RlcCBleHRlbmRzIFN0ZXAge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIG1hcmsgc3RlcC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzdGFydCBvZiB0aGUgbWFya2VkIHJhbmdlLlxuICAgICovXG4gICAgZnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIGVuZCBvZiB0aGUgbWFya2VkIHJhbmdlLlxuICAgICovXG4gICAgdG8sIFxuICAgIC8qKlxuICAgIFRoZSBtYXJrIHRvIGFkZC5cbiAgICAqL1xuICAgIG1hcmspIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLm1hcmsgPSBtYXJrO1xuICAgIH1cbiAgICBhcHBseShkb2MpIHtcbiAgICAgICAgbGV0IG9sZFNsaWNlID0gZG9jLnNsaWNlKHRoaXMuZnJvbSwgdGhpcy50byksICRmcm9tID0gZG9jLnJlc29sdmUodGhpcy5mcm9tKTtcbiAgICAgICAgbGV0IHBhcmVudCA9ICRmcm9tLm5vZGUoJGZyb20uc2hhcmVkRGVwdGgodGhpcy50bykpO1xuICAgICAgICBsZXQgc2xpY2UgPSBuZXcgU2xpY2UobWFwRnJhZ21lbnQob2xkU2xpY2UuY29udGVudCwgKG5vZGUsIHBhcmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFub2RlLmlzQXRvbSB8fCAhcGFyZW50LnR5cGUuYWxsb3dzTWFya1R5cGUodGhpcy5tYXJrLnR5cGUpKVxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUubWFyayh0aGlzLm1hcmsuYWRkVG9TZXQobm9kZS5tYXJrcykpO1xuICAgICAgICB9LCBwYXJlbnQpLCBvbGRTbGljZS5vcGVuU3RhcnQsIG9sZFNsaWNlLm9wZW5FbmQpO1xuICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mcm9tUmVwbGFjZShkb2MsIHRoaXMuZnJvbSwgdGhpcy50bywgc2xpY2UpO1xuICAgIH1cbiAgICBpbnZlcnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVtb3ZlTWFya1N0ZXAodGhpcy5mcm9tLCB0aGlzLnRvLCB0aGlzLm1hcmspO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICBsZXQgZnJvbSA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMuZnJvbSwgMSksIHRvID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy50bywgLTEpO1xuICAgICAgICBpZiAoZnJvbS5kZWxldGVkICYmIHRvLmRlbGV0ZWQgfHwgZnJvbS5wb3MgPj0gdG8ucG9zKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgQWRkTWFya1N0ZXAoZnJvbS5wb3MsIHRvLnBvcywgdGhpcy5tYXJrKTtcbiAgICB9XG4gICAgbWVyZ2Uob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgQWRkTWFya1N0ZXAgJiZcbiAgICAgICAgICAgIG90aGVyLm1hcmsuZXEodGhpcy5tYXJrKSAmJlxuICAgICAgICAgICAgdGhpcy5mcm9tIDw9IG90aGVyLnRvICYmIHRoaXMudG8gPj0gb3RoZXIuZnJvbSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgQWRkTWFya1N0ZXAoTWF0aC5taW4odGhpcy5mcm9tLCBvdGhlci5mcm9tKSwgTWF0aC5tYXgodGhpcy50bywgb3RoZXIudG8pLCB0aGlzLm1hcmspO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyBzdGVwVHlwZTogXCJhZGRNYXJrXCIsIG1hcms6IHRoaXMubWFyay50b0pTT04oKSxcbiAgICAgICAgICAgIGZyb206IHRoaXMuZnJvbSwgdG86IHRoaXMudG8gfTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5mcm9tICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24udG8gIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgQWRkTWFya1N0ZXAuZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgQWRkTWFya1N0ZXAoanNvbi5mcm9tLCBqc29uLnRvLCBzY2hlbWEubWFya0Zyb21KU09OKGpzb24ubWFyaykpO1xuICAgIH1cbn1cblN0ZXAuanNvbklEKFwiYWRkTWFya1wiLCBBZGRNYXJrU3RlcCk7XG4vKipcblJlbW92ZSBhIG1hcmsgZnJvbSBhbGwgaW5saW5lIGNvbnRlbnQgYmV0d2VlbiB0d28gcG9zaXRpb25zLlxuKi9cbmNsYXNzIFJlbW92ZU1hcmtTdGVwIGV4dGVuZHMgU3RlcCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbWFyay1yZW1vdmluZyBzdGVwLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHN0YXJ0IG9mIHRoZSB1bm1hcmtlZCByYW5nZS5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBlbmQgb2YgdGhlIHVubWFya2VkIHJhbmdlLlxuICAgICovXG4gICAgdG8sIFxuICAgIC8qKlxuICAgIFRoZSBtYXJrIHRvIHJlbW92ZS5cbiAgICAqL1xuICAgIG1hcmspIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLm1hcmsgPSBtYXJrO1xuICAgIH1cbiAgICBhcHBseShkb2MpIHtcbiAgICAgICAgbGV0IG9sZFNsaWNlID0gZG9jLnNsaWNlKHRoaXMuZnJvbSwgdGhpcy50byk7XG4gICAgICAgIGxldCBzbGljZSA9IG5ldyBTbGljZShtYXBGcmFnbWVudChvbGRTbGljZS5jb250ZW50LCBub2RlID0+IHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLm1hcmsodGhpcy5tYXJrLnJlbW92ZUZyb21TZXQobm9kZS5tYXJrcykpO1xuICAgICAgICB9LCBkb2MpLCBvbGRTbGljZS5vcGVuU3RhcnQsIG9sZFNsaWNlLm9wZW5FbmQpO1xuICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mcm9tUmVwbGFjZShkb2MsIHRoaXMuZnJvbSwgdGhpcy50bywgc2xpY2UpO1xuICAgIH1cbiAgICBpbnZlcnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgQWRkTWFya1N0ZXAodGhpcy5mcm9tLCB0aGlzLnRvLCB0aGlzLm1hcmspO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICBsZXQgZnJvbSA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMuZnJvbSwgMSksIHRvID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy50bywgLTEpO1xuICAgICAgICBpZiAoZnJvbS5kZWxldGVkICYmIHRvLmRlbGV0ZWQgfHwgZnJvbS5wb3MgPj0gdG8ucG9zKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHJldHVybiBuZXcgUmVtb3ZlTWFya1N0ZXAoZnJvbS5wb3MsIHRvLnBvcywgdGhpcy5tYXJrKTtcbiAgICB9XG4gICAgbWVyZ2Uob3RoZXIpIHtcbiAgICAgICAgaWYgKG90aGVyIGluc3RhbmNlb2YgUmVtb3ZlTWFya1N0ZXAgJiZcbiAgICAgICAgICAgIG90aGVyLm1hcmsuZXEodGhpcy5tYXJrKSAmJlxuICAgICAgICAgICAgdGhpcy5mcm9tIDw9IG90aGVyLnRvICYmIHRoaXMudG8gPj0gb3RoZXIuZnJvbSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVtb3ZlTWFya1N0ZXAoTWF0aC5taW4odGhpcy5mcm9tLCBvdGhlci5mcm9tKSwgTWF0aC5tYXgodGhpcy50bywgb3RoZXIudG8pLCB0aGlzLm1hcmspO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyBzdGVwVHlwZTogXCJyZW1vdmVNYXJrXCIsIG1hcms6IHRoaXMubWFyay50b0pTT04oKSxcbiAgICAgICAgICAgIGZyb206IHRoaXMuZnJvbSwgdG86IHRoaXMudG8gfTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5mcm9tICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24udG8gIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgUmVtb3ZlTWFya1N0ZXAuZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgUmVtb3ZlTWFya1N0ZXAoanNvbi5mcm9tLCBqc29uLnRvLCBzY2hlbWEubWFya0Zyb21KU09OKGpzb24ubWFyaykpO1xuICAgIH1cbn1cblN0ZXAuanNvbklEKFwicmVtb3ZlTWFya1wiLCBSZW1vdmVNYXJrU3RlcCk7XG4vKipcbkFkZCBhIG1hcmsgdG8gYSBzcGVjaWZpYyBub2RlLlxuKi9cbmNsYXNzIEFkZE5vZGVNYXJrU3RlcCBleHRlbmRzIFN0ZXAge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIG5vZGUgbWFyayBzdGVwLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIG9mIHRoZSB0YXJnZXQgbm9kZS5cbiAgICAqL1xuICAgIHBvcywgXG4gICAgLyoqXG4gICAgVGhlIG1hcmsgdG8gYWRkLlxuICAgICovXG4gICAgbWFyaykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5tYXJrID0gbWFyaztcbiAgICB9XG4gICAgYXBwbHkoZG9jKSB7XG4gICAgICAgIGxldCBub2RlID0gZG9jLm5vZGVBdCh0aGlzLnBvcyk7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZhaWwoXCJObyBub2RlIGF0IG1hcmsgc3RlcCdzIHBvc2l0aW9uXCIpO1xuICAgICAgICBsZXQgdXBkYXRlZCA9IG5vZGUudHlwZS5jcmVhdGUobm9kZS5hdHRycywgbnVsbCwgdGhpcy5tYXJrLmFkZFRvU2V0KG5vZGUubWFya3MpKTtcbiAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZnJvbVJlcGxhY2UoZG9jLCB0aGlzLnBvcywgdGhpcy5wb3MgKyAxLCBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbSh1cGRhdGVkKSwgMCwgbm9kZS5pc0xlYWYgPyAwIDogMSkpO1xuICAgIH1cbiAgICBpbnZlcnQoZG9jKSB7XG4gICAgICAgIGxldCBub2RlID0gZG9jLm5vZGVBdCh0aGlzLnBvcyk7XG4gICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICBsZXQgbmV3U2V0ID0gdGhpcy5tYXJrLmFkZFRvU2V0KG5vZGUubWFya3MpO1xuICAgICAgICAgICAgaWYgKG5ld1NldC5sZW5ndGggPT0gbm9kZS5tYXJrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUubWFya3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9kZS5tYXJrc1tpXS5pc0luU2V0KG5ld1NldCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFkZE5vZGVNYXJrU3RlcCh0aGlzLnBvcywgbm9kZS5tYXJrc1tpXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBZGROb2RlTWFya1N0ZXAodGhpcy5wb3MsIHRoaXMubWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBSZW1vdmVOb2RlTWFya1N0ZXAodGhpcy5wb3MsIHRoaXMubWFyayk7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIGxldCBwb3MgPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLnBvcywgMSk7XG4gICAgICAgIHJldHVybiBwb3MuZGVsZXRlZEFmdGVyID8gbnVsbCA6IG5ldyBBZGROb2RlTWFya1N0ZXAocG9zLnBvcywgdGhpcy5tYXJrKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyBzdGVwVHlwZTogXCJhZGROb2RlTWFya1wiLCBwb3M6IHRoaXMucG9zLCBtYXJrOiB0aGlzLm1hcmsudG9KU09OKCkgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5wb3MgIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgQWRkTm9kZU1hcmtTdGVwLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IEFkZE5vZGVNYXJrU3RlcChqc29uLnBvcywgc2NoZW1hLm1hcmtGcm9tSlNPTihqc29uLm1hcmspKTtcbiAgICB9XG59XG5TdGVwLmpzb25JRChcImFkZE5vZGVNYXJrXCIsIEFkZE5vZGVNYXJrU3RlcCk7XG4vKipcblJlbW92ZSBhIG1hcmsgZnJvbSBhIHNwZWNpZmljIG5vZGUuXG4qL1xuY2xhc3MgUmVtb3ZlTm9kZU1hcmtTdGVwIGV4dGVuZHMgU3RlcCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbWFyay1yZW1vdmluZyBzdGVwLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIG9mIHRoZSB0YXJnZXQgbm9kZS5cbiAgICAqL1xuICAgIHBvcywgXG4gICAgLyoqXG4gICAgVGhlIG1hcmsgdG8gcmVtb3ZlLlxuICAgICovXG4gICAgbWFyaykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5tYXJrID0gbWFyaztcbiAgICB9XG4gICAgYXBwbHkoZG9jKSB7XG4gICAgICAgIGxldCBub2RlID0gZG9jLm5vZGVBdCh0aGlzLnBvcyk7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZhaWwoXCJObyBub2RlIGF0IG1hcmsgc3RlcCdzIHBvc2l0aW9uXCIpO1xuICAgICAgICBsZXQgdXBkYXRlZCA9IG5vZGUudHlwZS5jcmVhdGUobm9kZS5hdHRycywgbnVsbCwgdGhpcy5tYXJrLnJlbW92ZUZyb21TZXQobm9kZS5tYXJrcykpO1xuICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mcm9tUmVwbGFjZShkb2MsIHRoaXMucG9zLCB0aGlzLnBvcyArIDEsIG5ldyBTbGljZShGcmFnbWVudC5mcm9tKHVwZGF0ZWQpLCAwLCBub2RlLmlzTGVhZiA/IDAgOiAxKSk7XG4gICAgfVxuICAgIGludmVydChkb2MpIHtcbiAgICAgICAgbGV0IG5vZGUgPSBkb2Mubm9kZUF0KHRoaXMucG9zKTtcbiAgICAgICAgaWYgKCFub2RlIHx8ICF0aGlzLm1hcmsuaXNJblNldChub2RlLm1hcmtzKSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IEFkZE5vZGVNYXJrU3RlcCh0aGlzLnBvcywgdGhpcy5tYXJrKTtcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcpIHtcbiAgICAgICAgbGV0IHBvcyA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMucG9zLCAxKTtcbiAgICAgICAgcmV0dXJuIHBvcy5kZWxldGVkQWZ0ZXIgPyBudWxsIDogbmV3IFJlbW92ZU5vZGVNYXJrU3RlcChwb3MucG9zLCB0aGlzLm1hcmspO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7IHN0ZXBUeXBlOiBcInJlbW92ZU5vZGVNYXJrXCIsIHBvczogdGhpcy5wb3MsIG1hcms6IHRoaXMubWFyay50b0pTT04oKSB9O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBmcm9tSlNPTihzY2hlbWEsIGpzb24pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBqc29uLnBvcyAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBSZW1vdmVOb2RlTWFya1N0ZXAuZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgUmVtb3ZlTm9kZU1hcmtTdGVwKGpzb24ucG9zLCBzY2hlbWEubWFya0Zyb21KU09OKGpzb24ubWFyaykpO1xuICAgIH1cbn1cblN0ZXAuanNvbklEKFwicmVtb3ZlTm9kZU1hcmtcIiwgUmVtb3ZlTm9kZU1hcmtTdGVwKTtcblxuLyoqXG5SZXBsYWNlIGEgcGFydCBvZiB0aGUgZG9jdW1lbnQgd2l0aCBhIHNsaWNlIG9mIG5ldyBjb250ZW50LlxuKi9cbmNsYXNzIFJlcGxhY2VTdGVwIGV4dGVuZHMgU3RlcCB7XG4gICAgLyoqXG4gICAgVGhlIGdpdmVuIGBzbGljZWAgc2hvdWxkIGZpdCB0aGUgJ2dhcCcgYmV0d2VlbiBgZnJvbWAgYW5kXG4gICAgYHRvYOKAlHRoZSBkZXB0aHMgbXVzdCBsaW5lIHVwLCBhbmQgdGhlIHN1cnJvdW5kaW5nIG5vZGVzIG11c3QgYmVcbiAgICBhYmxlIHRvIGJlIGpvaW5lZCB3aXRoIHRoZSBvcGVuIHNpZGVzIG9mIHRoZSBzbGljZS4gV2hlblxuICAgIGBzdHJ1Y3R1cmVgIGlzIHRydWUsIHRoZSBzdGVwIHdpbGwgZmFpbCBpZiB0aGUgY29udGVudCBiZXR3ZWVuXG4gICAgZnJvbSBhbmQgdG8gaXMgbm90IGp1c3QgYSBzZXF1ZW5jZSBvZiBjbG9zaW5nIGFuZCB0aGVuIG9wZW5pbmdcbiAgICB0b2tlbnMgKHRoaXMgaXMgdG8gZ3VhcmQgYWdhaW5zdCByZWJhc2VkIHJlcGxhY2Ugc3RlcHNcbiAgICBvdmVyd3JpdGluZyBzb21ldGhpbmcgdGhleSB3ZXJlbid0IHN1cHBvc2VkIHRvKS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVwbGFjZWQgcmFuZ2UuXG4gICAgKi9cbiAgICBmcm9tLCBcbiAgICAvKipcbiAgICBUaGUgZW5kIHBvc2l0aW9uIG9mIHRoZSByZXBsYWNlZCByYW5nZS5cbiAgICAqL1xuICAgIHRvLCBcbiAgICAvKipcbiAgICBUaGUgc2xpY2UgdG8gaW5zZXJ0LlxuICAgICovXG4gICAgc2xpY2UsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RydWN0dXJlID0gZmFsc2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLnNsaWNlID0gc2xpY2U7XG4gICAgICAgIHRoaXMuc3RydWN0dXJlID0gc3RydWN0dXJlO1xuICAgIH1cbiAgICBhcHBseShkb2MpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RydWN0dXJlICYmIGNvbnRlbnRCZXR3ZWVuKGRvYywgdGhpcy5mcm9tLCB0aGlzLnRvKSlcbiAgICAgICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZhaWwoXCJTdHJ1Y3R1cmUgcmVwbGFjZSB3b3VsZCBvdmVyd3JpdGUgY29udGVudFwiKTtcbiAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZnJvbVJlcGxhY2UoZG9jLCB0aGlzLmZyb20sIHRoaXMudG8sIHRoaXMuc2xpY2UpO1xuICAgIH1cbiAgICBnZXRNYXAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RlcE1hcChbdGhpcy5mcm9tLCB0aGlzLnRvIC0gdGhpcy5mcm9tLCB0aGlzLnNsaWNlLnNpemVdKTtcbiAgICB9XG4gICAgaW52ZXJ0KGRvYykge1xuICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VTdGVwKHRoaXMuZnJvbSwgdGhpcy5mcm9tICsgdGhpcy5zbGljZS5zaXplLCBkb2Muc2xpY2UodGhpcy5mcm9tLCB0aGlzLnRvKSk7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nKSB7XG4gICAgICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy5mcm9tLCAxKSwgdG8gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLnRvLCAtMSk7XG4gICAgICAgIGlmIChmcm9tLmRlbGV0ZWRBY3Jvc3MgJiYgdG8uZGVsZXRlZEFjcm9zcylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VTdGVwKGZyb20ucG9zLCBNYXRoLm1heChmcm9tLnBvcywgdG8ucG9zKSwgdGhpcy5zbGljZSwgdGhpcy5zdHJ1Y3R1cmUpO1xuICAgIH1cbiAgICBtZXJnZShvdGhlcikge1xuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFJlcGxhY2VTdGVwKSB8fCBvdGhlci5zdHJ1Y3R1cmUgfHwgdGhpcy5zdHJ1Y3R1cmUpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuZnJvbSArIHRoaXMuc2xpY2Uuc2l6ZSA9PSBvdGhlci5mcm9tICYmICF0aGlzLnNsaWNlLm9wZW5FbmQgJiYgIW90aGVyLnNsaWNlLm9wZW5TdGFydCkge1xuICAgICAgICAgICAgbGV0IHNsaWNlID0gdGhpcy5zbGljZS5zaXplICsgb3RoZXIuc2xpY2Uuc2l6ZSA9PSAwID8gU2xpY2UuZW1wdHlcbiAgICAgICAgICAgICAgICA6IG5ldyBTbGljZSh0aGlzLnNsaWNlLmNvbnRlbnQuYXBwZW5kKG90aGVyLnNsaWNlLmNvbnRlbnQpLCB0aGlzLnNsaWNlLm9wZW5TdGFydCwgb3RoZXIuc2xpY2Uub3BlbkVuZCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VTdGVwKHRoaXMuZnJvbSwgdGhpcy50byArIChvdGhlci50byAtIG90aGVyLmZyb20pLCBzbGljZSwgdGhpcy5zdHJ1Y3R1cmUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG90aGVyLnRvID09IHRoaXMuZnJvbSAmJiAhdGhpcy5zbGljZS5vcGVuU3RhcnQgJiYgIW90aGVyLnNsaWNlLm9wZW5FbmQpIHtcbiAgICAgICAgICAgIGxldCBzbGljZSA9IHRoaXMuc2xpY2Uuc2l6ZSArIG90aGVyLnNsaWNlLnNpemUgPT0gMCA/IFNsaWNlLmVtcHR5XG4gICAgICAgICAgICAgICAgOiBuZXcgU2xpY2Uob3RoZXIuc2xpY2UuY29udGVudC5hcHBlbmQodGhpcy5zbGljZS5jb250ZW50KSwgb3RoZXIuc2xpY2Uub3BlblN0YXJ0LCB0aGlzLnNsaWNlLm9wZW5FbmQpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlU3RlcChvdGhlci5mcm9tLCB0aGlzLnRvLCBzbGljZSwgdGhpcy5zdHJ1Y3R1cmUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICBsZXQganNvbiA9IHsgc3RlcFR5cGU6IFwicmVwbGFjZVwiLCBmcm9tOiB0aGlzLmZyb20sIHRvOiB0aGlzLnRvIH07XG4gICAgICAgIGlmICh0aGlzLnNsaWNlLnNpemUpXG4gICAgICAgICAgICBqc29uLnNsaWNlID0gdGhpcy5zbGljZS50b0pTT04oKTtcbiAgICAgICAgaWYgKHRoaXMuc3RydWN0dXJlKVxuICAgICAgICAgICAganNvbi5zdHJ1Y3R1cmUgPSB0cnVlO1xuICAgICAgICByZXR1cm4ganNvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5mcm9tICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24udG8gIT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBpbnB1dCBmb3IgUmVwbGFjZVN0ZXAuZnJvbUpTT05cIik7XG4gICAgICAgIHJldHVybiBuZXcgUmVwbGFjZVN0ZXAoanNvbi5mcm9tLCBqc29uLnRvLCBTbGljZS5mcm9tSlNPTihzY2hlbWEsIGpzb24uc2xpY2UpLCAhIWpzb24uc3RydWN0dXJlKTtcbiAgICB9XG59XG5TdGVwLmpzb25JRChcInJlcGxhY2VcIiwgUmVwbGFjZVN0ZXApO1xuLyoqXG5SZXBsYWNlIGEgcGFydCBvZiB0aGUgZG9jdW1lbnQgd2l0aCBhIHNsaWNlIG9mIGNvbnRlbnQsIGJ1dFxucHJlc2VydmUgYSByYW5nZSBvZiB0aGUgcmVwbGFjZWQgY29udGVudCBieSBtb3ZpbmcgaXQgaW50byB0aGVcbnNsaWNlLlxuKi9cbmNsYXNzIFJlcGxhY2VBcm91bmRTdGVwIGV4dGVuZHMgU3RlcCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgcmVwbGFjZS1hcm91bmQgc3RlcCB3aXRoIHRoZSBnaXZlbiByYW5nZSBhbmQgZ2FwLlxuICAgIGBpbnNlcnRgIHNob3VsZCBiZSB0aGUgcG9pbnQgaW4gdGhlIHNsaWNlIGludG8gd2hpY2ggdGhlIGNvbnRlbnRcbiAgICBvZiB0aGUgZ2FwIHNob3VsZCBiZSBtb3ZlZC4gYHN0cnVjdHVyZWAgaGFzIHRoZSBzYW1lIG1lYW5pbmcgYXNcbiAgICBpdCBoYXMgaW4gdGhlIFtgUmVwbGFjZVN0ZXBgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdHJhbnNmb3JtLlJlcGxhY2VTdGVwKSBjbGFzcy5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVwbGFjZWQgcmFuZ2UuXG4gICAgKi9cbiAgICBmcm9tLCBcbiAgICAvKipcbiAgICBUaGUgZW5kIHBvc2l0aW9uIG9mIHRoZSByZXBsYWNlZCByYW5nZS5cbiAgICAqL1xuICAgIHRvLCBcbiAgICAvKipcbiAgICBUaGUgc3RhcnQgb2YgcHJlc2VydmVkIHJhbmdlLlxuICAgICovXG4gICAgZ2FwRnJvbSwgXG4gICAgLyoqXG4gICAgVGhlIGVuZCBvZiBwcmVzZXJ2ZWQgcmFuZ2UuXG4gICAgKi9cbiAgICBnYXBUbywgXG4gICAgLyoqXG4gICAgVGhlIHNsaWNlIHRvIGluc2VydC5cbiAgICAqL1xuICAgIHNsaWNlLCBcbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gaW4gdGhlIHNsaWNlIHdoZXJlIHRoZSBwcmVzZXJ2ZWQgcmFuZ2Ugc2hvdWxkIGJlXG4gICAgaW5zZXJ0ZWQuXG4gICAgKi9cbiAgICBpbnNlcnQsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RydWN0dXJlID0gZmFsc2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLmdhcEZyb20gPSBnYXBGcm9tO1xuICAgICAgICB0aGlzLmdhcFRvID0gZ2FwVG87XG4gICAgICAgIHRoaXMuc2xpY2UgPSBzbGljZTtcbiAgICAgICAgdGhpcy5pbnNlcnQgPSBpbnNlcnQ7XG4gICAgICAgIHRoaXMuc3RydWN0dXJlID0gc3RydWN0dXJlO1xuICAgIH1cbiAgICBhcHBseShkb2MpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RydWN0dXJlICYmIChjb250ZW50QmV0d2Vlbihkb2MsIHRoaXMuZnJvbSwgdGhpcy5nYXBGcm9tKSB8fFxuICAgICAgICAgICAgY29udGVudEJldHdlZW4oZG9jLCB0aGlzLmdhcFRvLCB0aGlzLnRvKSkpXG4gICAgICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mYWlsKFwiU3RydWN0dXJlIGdhcC1yZXBsYWNlIHdvdWxkIG92ZXJ3cml0ZSBjb250ZW50XCIpO1xuICAgICAgICBsZXQgZ2FwID0gZG9jLnNsaWNlKHRoaXMuZ2FwRnJvbSwgdGhpcy5nYXBUbyk7XG4gICAgICAgIGlmIChnYXAub3BlblN0YXJ0IHx8IGdhcC5vcGVuRW5kKVxuICAgICAgICAgICAgcmV0dXJuIFN0ZXBSZXN1bHQuZmFpbChcIkdhcCBpcyBub3QgYSBmbGF0IHJhbmdlXCIpO1xuICAgICAgICBsZXQgaW5zZXJ0ZWQgPSB0aGlzLnNsaWNlLmluc2VydEF0KHRoaXMuaW5zZXJ0LCBnYXAuY29udGVudCk7XG4gICAgICAgIGlmICghaW5zZXJ0ZWQpXG4gICAgICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mYWlsKFwiQ29udGVudCBkb2VzIG5vdCBmaXQgaW4gZ2FwXCIpO1xuICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5mcm9tUmVwbGFjZShkb2MsIHRoaXMuZnJvbSwgdGhpcy50bywgaW5zZXJ0ZWQpO1xuICAgIH1cbiAgICBnZXRNYXAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RlcE1hcChbdGhpcy5mcm9tLCB0aGlzLmdhcEZyb20gLSB0aGlzLmZyb20sIHRoaXMuaW5zZXJ0LFxuICAgICAgICAgICAgdGhpcy5nYXBUbywgdGhpcy50byAtIHRoaXMuZ2FwVG8sIHRoaXMuc2xpY2Uuc2l6ZSAtIHRoaXMuaW5zZXJ0XSk7XG4gICAgfVxuICAgIGludmVydChkb2MpIHtcbiAgICAgICAgbGV0IGdhcCA9IHRoaXMuZ2FwVG8gLSB0aGlzLmdhcEZyb207XG4gICAgICAgIHJldHVybiBuZXcgUmVwbGFjZUFyb3VuZFN0ZXAodGhpcy5mcm9tLCB0aGlzLmZyb20gKyB0aGlzLnNsaWNlLnNpemUgKyBnYXAsIHRoaXMuZnJvbSArIHRoaXMuaW5zZXJ0LCB0aGlzLmZyb20gKyB0aGlzLmluc2VydCArIGdhcCwgZG9jLnNsaWNlKHRoaXMuZnJvbSwgdGhpcy50bykucmVtb3ZlQmV0d2Vlbih0aGlzLmdhcEZyb20gLSB0aGlzLmZyb20sIHRoaXMuZ2FwVG8gLSB0aGlzLmZyb20pLCB0aGlzLmdhcEZyb20gLSB0aGlzLmZyb20sIHRoaXMuc3RydWN0dXJlKTtcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcpIHtcbiAgICAgICAgbGV0IGZyb20gPSBtYXBwaW5nLm1hcFJlc3VsdCh0aGlzLmZyb20sIDEpLCB0byA9IG1hcHBpbmcubWFwUmVzdWx0KHRoaXMudG8sIC0xKTtcbiAgICAgICAgbGV0IGdhcEZyb20gPSB0aGlzLmZyb20gPT0gdGhpcy5nYXBGcm9tID8gZnJvbS5wb3MgOiBtYXBwaW5nLm1hcCh0aGlzLmdhcEZyb20sIC0xKTtcbiAgICAgICAgbGV0IGdhcFRvID0gdGhpcy50byA9PSB0aGlzLmdhcFRvID8gdG8ucG9zIDogbWFwcGluZy5tYXAodGhpcy5nYXBUbywgMSk7XG4gICAgICAgIGlmICgoZnJvbS5kZWxldGVkQWNyb3NzICYmIHRvLmRlbGV0ZWRBY3Jvc3MpIHx8IGdhcEZyb20gPCBmcm9tLnBvcyB8fCBnYXBUbyA+IHRvLnBvcylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VBcm91bmRTdGVwKGZyb20ucG9zLCB0by5wb3MsIGdhcEZyb20sIGdhcFRvLCB0aGlzLnNsaWNlLCB0aGlzLmluc2VydCwgdGhpcy5zdHJ1Y3R1cmUpO1xuICAgIH1cbiAgICB0b0pTT04oKSB7XG4gICAgICAgIGxldCBqc29uID0geyBzdGVwVHlwZTogXCJyZXBsYWNlQXJvdW5kXCIsIGZyb206IHRoaXMuZnJvbSwgdG86IHRoaXMudG8sXG4gICAgICAgICAgICBnYXBGcm9tOiB0aGlzLmdhcEZyb20sIGdhcFRvOiB0aGlzLmdhcFRvLCBpbnNlcnQ6IHRoaXMuaW5zZXJ0IH07XG4gICAgICAgIGlmICh0aGlzLnNsaWNlLnNpemUpXG4gICAgICAgICAgICBqc29uLnNsaWNlID0gdGhpcy5zbGljZS50b0pTT04oKTtcbiAgICAgICAgaWYgKHRoaXMuc3RydWN0dXJlKVxuICAgICAgICAgICAganNvbi5zdHJ1Y3R1cmUgPSB0cnVlO1xuICAgICAgICByZXR1cm4ganNvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZnJvbUpTT04oc2NoZW1hLCBqc29uKSB7XG4gICAgICAgIGlmICh0eXBlb2YganNvbi5mcm9tICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24udG8gIT0gXCJudW1iZXJcIiB8fFxuICAgICAgICAgICAgdHlwZW9mIGpzb24uZ2FwRnJvbSAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiBqc29uLmdhcFRvICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24uaW5zZXJ0ICE9IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5wdXQgZm9yIFJlcGxhY2VBcm91bmRTdGVwLmZyb21KU09OXCIpO1xuICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VBcm91bmRTdGVwKGpzb24uZnJvbSwganNvbi50bywganNvbi5nYXBGcm9tLCBqc29uLmdhcFRvLCBTbGljZS5mcm9tSlNPTihzY2hlbWEsIGpzb24uc2xpY2UpLCBqc29uLmluc2VydCwgISFqc29uLnN0cnVjdHVyZSk7XG4gICAgfVxufVxuU3RlcC5qc29uSUQoXCJyZXBsYWNlQXJvdW5kXCIsIFJlcGxhY2VBcm91bmRTdGVwKTtcbmZ1bmN0aW9uIGNvbnRlbnRCZXR3ZWVuKGRvYywgZnJvbSwgdG8pIHtcbiAgICBsZXQgJGZyb20gPSBkb2MucmVzb2x2ZShmcm9tKSwgZGlzdCA9IHRvIC0gZnJvbSwgZGVwdGggPSAkZnJvbS5kZXB0aDtcbiAgICB3aGlsZSAoZGlzdCA+IDAgJiYgZGVwdGggPiAwICYmICRmcm9tLmluZGV4QWZ0ZXIoZGVwdGgpID09ICRmcm9tLm5vZGUoZGVwdGgpLmNoaWxkQ291bnQpIHtcbiAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgZGlzdC0tO1xuICAgIH1cbiAgICBpZiAoZGlzdCA+IDApIHtcbiAgICAgICAgbGV0IG5leHQgPSAkZnJvbS5ub2RlKGRlcHRoKS5tYXliZUNoaWxkKCRmcm9tLmluZGV4QWZ0ZXIoZGVwdGgpKTtcbiAgICAgICAgd2hpbGUgKGRpc3QgPiAwKSB7XG4gICAgICAgICAgICBpZiAoIW5leHQgfHwgbmV4dC5pc0xlYWYpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBuZXh0ID0gbmV4dC5maXJzdENoaWxkO1xuICAgICAgICAgICAgZGlzdC0tO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gYWRkTWFyayh0ciwgZnJvbSwgdG8sIG1hcmspIHtcbiAgICBsZXQgcmVtb3ZlZCA9IFtdLCBhZGRlZCA9IFtdO1xuICAgIGxldCByZW1vdmluZywgYWRkaW5nO1xuICAgIHRyLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MsIHBhcmVudCkgPT4ge1xuICAgICAgICBpZiAoIW5vZGUuaXNJbmxpbmUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBtYXJrcyA9IG5vZGUubWFya3M7XG4gICAgICAgIGlmICghbWFyay5pc0luU2V0KG1hcmtzKSAmJiBwYXJlbnQudHlwZS5hbGxvd3NNYXJrVHlwZShtYXJrLnR5cGUpKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBNYXRoLm1heChwb3MsIGZyb20pLCBlbmQgPSBNYXRoLm1pbihwb3MgKyBub2RlLm5vZGVTaXplLCB0byk7XG4gICAgICAgICAgICBsZXQgbmV3U2V0ID0gbWFyay5hZGRUb1NldChtYXJrcyk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1hcmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFtYXJrc1tpXS5pc0luU2V0KG5ld1NldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlbW92aW5nICYmIHJlbW92aW5nLnRvID09IHN0YXJ0ICYmIHJlbW92aW5nLm1hcmsuZXEobWFya3NbaV0pKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZpbmcudG8gPSBlbmQ7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZWQucHVzaChyZW1vdmluZyA9IG5ldyBSZW1vdmVNYXJrU3RlcChzdGFydCwgZW5kLCBtYXJrc1tpXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhZGRpbmcgJiYgYWRkaW5nLnRvID09IHN0YXJ0KVxuICAgICAgICAgICAgICAgIGFkZGluZy50byA9IGVuZDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBhZGRlZC5wdXNoKGFkZGluZyA9IG5ldyBBZGRNYXJrU3RlcChzdGFydCwgZW5kLCBtYXJrKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZW1vdmVkLmZvckVhY2gocyA9PiB0ci5zdGVwKHMpKTtcbiAgICBhZGRlZC5mb3JFYWNoKHMgPT4gdHIuc3RlcChzKSk7XG59XG5mdW5jdGlvbiByZW1vdmVNYXJrKHRyLCBmcm9tLCB0bywgbWFyaykge1xuICAgIGxldCBtYXRjaGVkID0gW10sIHN0ZXAgPSAwO1xuICAgIHRyLmRvYy5ub2Rlc0JldHdlZW4oZnJvbSwgdG8sIChub2RlLCBwb3MpID0+IHtcbiAgICAgICAgaWYgKCFub2RlLmlzSW5saW5lKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBzdGVwKys7XG4gICAgICAgIGxldCB0b1JlbW92ZSA9IG51bGw7XG4gICAgICAgIGlmIChtYXJrIGluc3RhbmNlb2YgTWFya1R5cGUpIHtcbiAgICAgICAgICAgIGxldCBzZXQgPSBub2RlLm1hcmtzLCBmb3VuZDtcbiAgICAgICAgICAgIHdoaWxlIChmb3VuZCA9IG1hcmsuaXNJblNldChzZXQpKSB7XG4gICAgICAgICAgICAgICAgKHRvUmVtb3ZlIHx8ICh0b1JlbW92ZSA9IFtdKSkucHVzaChmb3VuZCk7XG4gICAgICAgICAgICAgICAgc2V0ID0gZm91bmQucmVtb3ZlRnJvbVNldChzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1hcmspIHtcbiAgICAgICAgICAgIGlmIChtYXJrLmlzSW5TZXQobm9kZS5tYXJrcykpXG4gICAgICAgICAgICAgICAgdG9SZW1vdmUgPSBbbWFya107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0b1JlbW92ZSA9IG5vZGUubWFya3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvUmVtb3ZlICYmIHRvUmVtb3ZlLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGVuZCA9IE1hdGgubWluKHBvcyArIG5vZGUubm9kZVNpemUsIHRvKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9SZW1vdmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgc3R5bGUgPSB0b1JlbW92ZVtpXSwgZm91bmQ7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBtYXRjaGVkLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtID0gbWF0Y2hlZFtqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG0uc3RlcCA9PSBzdGVwIC0gMSAmJiBzdHlsZS5lcShtYXRjaGVkW2pdLnN0eWxlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kID0gbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kLnRvID0gZW5kO1xuICAgICAgICAgICAgICAgICAgICBmb3VuZC5zdGVwID0gc3RlcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoZWQucHVzaCh7IHN0eWxlLCBmcm9tOiBNYXRoLm1heChwb3MsIGZyb20pLCB0bzogZW5kLCBzdGVwIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIG1hdGNoZWQuZm9yRWFjaChtID0+IHRyLnN0ZXAobmV3IFJlbW92ZU1hcmtTdGVwKG0uZnJvbSwgbS50bywgbS5zdHlsZSkpKTtcbn1cbmZ1bmN0aW9uIGNsZWFySW5jb21wYXRpYmxlKHRyLCBwb3MsIHBhcmVudFR5cGUsIG1hdGNoID0gcGFyZW50VHlwZS5jb250ZW50TWF0Y2gsIGNsZWFyTmV3bGluZXMgPSB0cnVlKSB7XG4gICAgbGV0IG5vZGUgPSB0ci5kb2Mubm9kZUF0KHBvcyk7XG4gICAgbGV0IHJlcGxTdGVwcyA9IFtdLCBjdXIgPSBwb3MgKyAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5jaGlsZENvdW50OyBpKyspIHtcbiAgICAgICAgbGV0IGNoaWxkID0gbm9kZS5jaGlsZChpKSwgZW5kID0gY3VyICsgY2hpbGQubm9kZVNpemU7XG4gICAgICAgIGxldCBhbGxvd2VkID0gbWF0Y2gubWF0Y2hUeXBlKGNoaWxkLnR5cGUpO1xuICAgICAgICBpZiAoIWFsbG93ZWQpIHtcbiAgICAgICAgICAgIHJlcGxTdGVwcy5wdXNoKG5ldyBSZXBsYWNlU3RlcChjdXIsIGVuZCwgU2xpY2UuZW1wdHkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1hdGNoID0gYWxsb3dlZDtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY2hpbGQubWFya3MubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgICAgaWYgKCFwYXJlbnRUeXBlLmFsbG93c01hcmtUeXBlKGNoaWxkLm1hcmtzW2pdLnR5cGUpKVxuICAgICAgICAgICAgICAgICAgICB0ci5zdGVwKG5ldyBSZW1vdmVNYXJrU3RlcChjdXIsIGVuZCwgY2hpbGQubWFya3Nbal0pKTtcbiAgICAgICAgICAgIGlmIChjbGVhck5ld2xpbmVzICYmIGNoaWxkLmlzVGV4dCAmJiBwYXJlbnRUeXBlLndoaXRlc3BhY2UgIT0gXCJwcmVcIikge1xuICAgICAgICAgICAgICAgIGxldCBtLCBuZXdsaW5lID0gL1xccj9cXG58XFxyL2csIHNsaWNlO1xuICAgICAgICAgICAgICAgIHdoaWxlIChtID0gbmV3bGluZS5leGVjKGNoaWxkLnRleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2xpY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBzbGljZSA9IG5ldyBTbGljZShGcmFnbWVudC5mcm9tKHBhcmVudFR5cGUuc2NoZW1hLnRleHQoXCIgXCIsIHBhcmVudFR5cGUuYWxsb3dlZE1hcmtzKGNoaWxkLm1hcmtzKSkpLCAwLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgcmVwbFN0ZXBzLnB1c2gobmV3IFJlcGxhY2VTdGVwKGN1ciArIG0uaW5kZXgsIGN1ciArIG0uaW5kZXggKyBtWzBdLmxlbmd0aCwgc2xpY2UpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY3VyID0gZW5kO1xuICAgIH1cbiAgICBpZiAoIW1hdGNoLnZhbGlkRW5kKSB7XG4gICAgICAgIGxldCBmaWxsID0gbWF0Y2guZmlsbEJlZm9yZShGcmFnbWVudC5lbXB0eSwgdHJ1ZSk7XG4gICAgICAgIHRyLnJlcGxhY2UoY3VyLCBjdXIsIG5ldyBTbGljZShmaWxsLCAwLCAwKSk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSByZXBsU3RlcHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIHRyLnN0ZXAocmVwbFN0ZXBzW2ldKTtcbn1cblxuZnVuY3Rpb24gY2FuQ3V0KG5vZGUsIHN0YXJ0LCBlbmQpIHtcbiAgICByZXR1cm4gKHN0YXJ0ID09IDAgfHwgbm9kZS5jYW5SZXBsYWNlKHN0YXJ0LCBub2RlLmNoaWxkQ291bnQpKSAmJlxuICAgICAgICAoZW5kID09IG5vZGUuY2hpbGRDb3VudCB8fCBub2RlLmNhblJlcGxhY2UoMCwgZW5kKSk7XG59XG4vKipcblRyeSB0byBmaW5kIGEgdGFyZ2V0IGRlcHRoIHRvIHdoaWNoIHRoZSBjb250ZW50IGluIHRoZSBnaXZlbiByYW5nZVxuY2FuIGJlIGxpZnRlZC4gV2lsbCBub3QgZ28gYWNyb3NzXG5baXNvbGF0aW5nXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuTm9kZVNwZWMuaXNvbGF0aW5nKSBwYXJlbnQgbm9kZXMuXG4qL1xuZnVuY3Rpb24gbGlmdFRhcmdldChyYW5nZSkge1xuICAgIGxldCBwYXJlbnQgPSByYW5nZS5wYXJlbnQ7XG4gICAgbGV0IGNvbnRlbnQgPSBwYXJlbnQuY29udGVudC5jdXRCeUluZGV4KHJhbmdlLnN0YXJ0SW5kZXgsIHJhbmdlLmVuZEluZGV4KTtcbiAgICBmb3IgKGxldCBkZXB0aCA9IHJhbmdlLmRlcHRoOzsgLS1kZXB0aCkge1xuICAgICAgICBsZXQgbm9kZSA9IHJhbmdlLiRmcm9tLm5vZGUoZGVwdGgpO1xuICAgICAgICBsZXQgaW5kZXggPSByYW5nZS4kZnJvbS5pbmRleChkZXB0aCksIGVuZEluZGV4ID0gcmFuZ2UuJHRvLmluZGV4QWZ0ZXIoZGVwdGgpO1xuICAgICAgICBpZiAoZGVwdGggPCByYW5nZS5kZXB0aCAmJiBub2RlLmNhblJlcGxhY2UoaW5kZXgsIGVuZEluZGV4LCBjb250ZW50KSlcbiAgICAgICAgICAgIHJldHVybiBkZXB0aDtcbiAgICAgICAgaWYgKGRlcHRoID09IDAgfHwgbm9kZS50eXBlLnNwZWMuaXNvbGF0aW5nIHx8ICFjYW5DdXQobm9kZSwgaW5kZXgsIGVuZEluZGV4KSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGxpZnQodHIsIHJhbmdlLCB0YXJnZXQpIHtcbiAgICBsZXQgeyAkZnJvbSwgJHRvLCBkZXB0aCB9ID0gcmFuZ2U7XG4gICAgbGV0IGdhcFN0YXJ0ID0gJGZyb20uYmVmb3JlKGRlcHRoICsgMSksIGdhcEVuZCA9ICR0by5hZnRlcihkZXB0aCArIDEpO1xuICAgIGxldCBzdGFydCA9IGdhcFN0YXJ0LCBlbmQgPSBnYXBFbmQ7XG4gICAgbGV0IGJlZm9yZSA9IEZyYWdtZW50LmVtcHR5LCBvcGVuU3RhcnQgPSAwO1xuICAgIGZvciAobGV0IGQgPSBkZXB0aCwgc3BsaXR0aW5nID0gZmFsc2U7IGQgPiB0YXJnZXQ7IGQtLSlcbiAgICAgICAgaWYgKHNwbGl0dGluZyB8fCAkZnJvbS5pbmRleChkKSA+IDApIHtcbiAgICAgICAgICAgIHNwbGl0dGluZyA9IHRydWU7XG4gICAgICAgICAgICBiZWZvcmUgPSBGcmFnbWVudC5mcm9tKCRmcm9tLm5vZGUoZCkuY29weShiZWZvcmUpKTtcbiAgICAgICAgICAgIG9wZW5TdGFydCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhcnQtLTtcbiAgICAgICAgfVxuICAgIGxldCBhZnRlciA9IEZyYWdtZW50LmVtcHR5LCBvcGVuRW5kID0gMDtcbiAgICBmb3IgKGxldCBkID0gZGVwdGgsIHNwbGl0dGluZyA9IGZhbHNlOyBkID4gdGFyZ2V0OyBkLS0pXG4gICAgICAgIGlmIChzcGxpdHRpbmcgfHwgJHRvLmFmdGVyKGQgKyAxKSA8ICR0by5lbmQoZCkpIHtcbiAgICAgICAgICAgIHNwbGl0dGluZyA9IHRydWU7XG4gICAgICAgICAgICBhZnRlciA9IEZyYWdtZW50LmZyb20oJHRvLm5vZGUoZCkuY29weShhZnRlcikpO1xuICAgICAgICAgICAgb3BlbkVuZCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZW5kKys7XG4gICAgICAgIH1cbiAgICB0ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcChzdGFydCwgZW5kLCBnYXBTdGFydCwgZ2FwRW5kLCBuZXcgU2xpY2UoYmVmb3JlLmFwcGVuZChhZnRlciksIG9wZW5TdGFydCwgb3BlbkVuZCksIGJlZm9yZS5zaXplIC0gb3BlblN0YXJ0LCB0cnVlKSk7XG59XG4vKipcblRyeSB0byBmaW5kIGEgdmFsaWQgd2F5IHRvIHdyYXAgdGhlIGNvbnRlbnQgaW4gdGhlIGdpdmVuIHJhbmdlIGluIGFcbm5vZGUgb2YgdGhlIGdpdmVuIHR5cGUuIE1heSBpbnRyb2R1Y2UgZXh0cmEgbm9kZXMgYXJvdW5kIGFuZCBpbnNpZGVcbnRoZSB3cmFwcGVyIG5vZGUsIGlmIG5lY2Vzc2FyeS4gUmV0dXJucyBudWxsIGlmIG5vIHZhbGlkIHdyYXBwaW5nXG5jb3VsZCBiZSBmb3VuZC4gV2hlbiBgaW5uZXJSYW5nZWAgaXMgZ2l2ZW4sIHRoYXQgcmFuZ2UncyBjb250ZW50IGlzXG51c2VkIGFzIHRoZSBjb250ZW50IHRvIGZpdCBpbnRvIHRoZSB3cmFwcGluZywgaW5zdGVhZCBvZiB0aGVcbmNvbnRlbnQgb2YgYHJhbmdlYC5cbiovXG5mdW5jdGlvbiBmaW5kV3JhcHBpbmcocmFuZ2UsIG5vZGVUeXBlLCBhdHRycyA9IG51bGwsIGlubmVyUmFuZ2UgPSByYW5nZSkge1xuICAgIGxldCBhcm91bmQgPSBmaW5kV3JhcHBpbmdPdXRzaWRlKHJhbmdlLCBub2RlVHlwZSk7XG4gICAgbGV0IGlubmVyID0gYXJvdW5kICYmIGZpbmRXcmFwcGluZ0luc2lkZShpbm5lclJhbmdlLCBub2RlVHlwZSk7XG4gICAgaWYgKCFpbm5lcilcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIGFyb3VuZC5tYXAod2l0aEF0dHJzKVxuICAgICAgICAuY29uY2F0KHsgdHlwZTogbm9kZVR5cGUsIGF0dHJzIH0pLmNvbmNhdChpbm5lci5tYXAod2l0aEF0dHJzKSk7XG59XG5mdW5jdGlvbiB3aXRoQXR0cnModHlwZSkgeyByZXR1cm4geyB0eXBlLCBhdHRyczogbnVsbCB9OyB9XG5mdW5jdGlvbiBmaW5kV3JhcHBpbmdPdXRzaWRlKHJhbmdlLCB0eXBlKSB7XG4gICAgbGV0IHsgcGFyZW50LCBzdGFydEluZGV4LCBlbmRJbmRleCB9ID0gcmFuZ2U7XG4gICAgbGV0IGFyb3VuZCA9IHBhcmVudC5jb250ZW50TWF0Y2hBdChzdGFydEluZGV4KS5maW5kV3JhcHBpbmcodHlwZSk7XG4gICAgaWYgKCFhcm91bmQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBvdXRlciA9IGFyb3VuZC5sZW5ndGggPyBhcm91bmRbMF0gOiB0eXBlO1xuICAgIHJldHVybiBwYXJlbnQuY2FuUmVwbGFjZVdpdGgoc3RhcnRJbmRleCwgZW5kSW5kZXgsIG91dGVyKSA/IGFyb3VuZCA6IG51bGw7XG59XG5mdW5jdGlvbiBmaW5kV3JhcHBpbmdJbnNpZGUocmFuZ2UsIHR5cGUpIHtcbiAgICBsZXQgeyBwYXJlbnQsIHN0YXJ0SW5kZXgsIGVuZEluZGV4IH0gPSByYW5nZTtcbiAgICBsZXQgaW5uZXIgPSBwYXJlbnQuY2hpbGQoc3RhcnRJbmRleCk7XG4gICAgbGV0IGluc2lkZSA9IHR5cGUuY29udGVudE1hdGNoLmZpbmRXcmFwcGluZyhpbm5lci50eXBlKTtcbiAgICBpZiAoIWluc2lkZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGxhc3RUeXBlID0gaW5zaWRlLmxlbmd0aCA/IGluc2lkZVtpbnNpZGUubGVuZ3RoIC0gMV0gOiB0eXBlO1xuICAgIGxldCBpbm5lck1hdGNoID0gbGFzdFR5cGUuY29udGVudE1hdGNoO1xuICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpbm5lck1hdGNoICYmIGkgPCBlbmRJbmRleDsgaSsrKVxuICAgICAgICBpbm5lck1hdGNoID0gaW5uZXJNYXRjaC5tYXRjaFR5cGUocGFyZW50LmNoaWxkKGkpLnR5cGUpO1xuICAgIGlmICghaW5uZXJNYXRjaCB8fCAhaW5uZXJNYXRjaC52YWxpZEVuZClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIGluc2lkZTtcbn1cbmZ1bmN0aW9uIHdyYXAodHIsIHJhbmdlLCB3cmFwcGVycykge1xuICAgIGxldCBjb250ZW50ID0gRnJhZ21lbnQuZW1wdHk7XG4gICAgZm9yIChsZXQgaSA9IHdyYXBwZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmIChjb250ZW50LnNpemUpIHtcbiAgICAgICAgICAgIGxldCBtYXRjaCA9IHdyYXBwZXJzW2ldLnR5cGUuY29udGVudE1hdGNoLm1hdGNoRnJhZ21lbnQoY29udGVudCk7XG4gICAgICAgICAgICBpZiAoIW1hdGNoIHx8ICFtYXRjaC52YWxpZEVuZClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIldyYXBwZXIgdHlwZSBnaXZlbiB0byBUcmFuc2Zvcm0ud3JhcCBkb2VzIG5vdCBmb3JtIHZhbGlkIGNvbnRlbnQgb2YgaXRzIHBhcmVudCB3cmFwcGVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRlbnQgPSBGcmFnbWVudC5mcm9tKHdyYXBwZXJzW2ldLnR5cGUuY3JlYXRlKHdyYXBwZXJzW2ldLmF0dHJzLCBjb250ZW50KSk7XG4gICAgfVxuICAgIGxldCBzdGFydCA9IHJhbmdlLnN0YXJ0LCBlbmQgPSByYW5nZS5lbmQ7XG4gICAgdHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoc3RhcnQsIGVuZCwgc3RhcnQsIGVuZCwgbmV3IFNsaWNlKGNvbnRlbnQsIDAsIDApLCB3cmFwcGVycy5sZW5ndGgsIHRydWUpKTtcbn1cbmZ1bmN0aW9uIHNldEJsb2NrVHlwZSh0ciwgZnJvbSwgdG8sIHR5cGUsIGF0dHJzKSB7XG4gICAgaWYgKCF0eXBlLmlzVGV4dGJsb2NrKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlR5cGUgZ2l2ZW4gdG8gc2V0QmxvY2tUeXBlIHNob3VsZCBiZSBhIHRleHRibG9ja1wiKTtcbiAgICBsZXQgbWFwRnJvbSA9IHRyLnN0ZXBzLmxlbmd0aDtcbiAgICB0ci5kb2Mubm9kZXNCZXR3ZWVuKGZyb20sIHRvLCAobm9kZSwgcG9zKSA9PiB7XG4gICAgICAgIGxldCBhdHRyc0hlcmUgPSB0eXBlb2YgYXR0cnMgPT0gXCJmdW5jdGlvblwiID8gYXR0cnMobm9kZSkgOiBhdHRycztcbiAgICAgICAgaWYgKG5vZGUuaXNUZXh0YmxvY2sgJiYgIW5vZGUuaGFzTWFya3VwKHR5cGUsIGF0dHJzSGVyZSkgJiZcbiAgICAgICAgICAgIGNhbkNoYW5nZVR5cGUodHIuZG9jLCB0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pLm1hcChwb3MpLCB0eXBlKSkge1xuICAgICAgICAgICAgbGV0IGNvbnZlcnROZXdsaW5lcyA9IG51bGw7XG4gICAgICAgICAgICBpZiAodHlwZS5zY2hlbWEubGluZWJyZWFrUmVwbGFjZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgcHJlID0gdHlwZS53aGl0ZXNwYWNlID09IFwicHJlXCIsIHN1cHBvcnRMaW5lYnJlYWsgPSAhIXR5cGUuY29udGVudE1hdGNoLm1hdGNoVHlwZSh0eXBlLnNjaGVtYS5saW5lYnJlYWtSZXBsYWNlbWVudCk7XG4gICAgICAgICAgICAgICAgaWYgKHByZSAmJiAhc3VwcG9ydExpbmVicmVhaylcbiAgICAgICAgICAgICAgICAgICAgY29udmVydE5ld2xpbmVzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIXByZSAmJiBzdXBwb3J0TGluZWJyZWFrKVxuICAgICAgICAgICAgICAgICAgICBjb252ZXJ0TmV3bGluZXMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRW5zdXJlIGFsbCBtYXJrdXAgdGhhdCBpc24ndCBhbGxvd2VkIGluIHRoZSBuZXcgbm9kZSB0eXBlIGlzIGNsZWFyZWRcbiAgICAgICAgICAgIGlmIChjb252ZXJ0TmV3bGluZXMgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgIHJlcGxhY2VMaW5lYnJlYWtzKHRyLCBub2RlLCBwb3MsIG1hcEZyb20pO1xuICAgICAgICAgICAgY2xlYXJJbmNvbXBhdGlibGUodHIsIHRyLm1hcHBpbmcuc2xpY2UobWFwRnJvbSkubWFwKHBvcywgMSksIHR5cGUsIHVuZGVmaW5lZCwgY29udmVydE5ld2xpbmVzID09PSBudWxsKTtcbiAgICAgICAgICAgIGxldCBtYXBwaW5nID0gdHIubWFwcGluZy5zbGljZShtYXBGcm9tKTtcbiAgICAgICAgICAgIGxldCBzdGFydE0gPSBtYXBwaW5nLm1hcChwb3MsIDEpLCBlbmRNID0gbWFwcGluZy5tYXAocG9zICsgbm9kZS5ub2RlU2l6ZSwgMSk7XG4gICAgICAgICAgICB0ci5zdGVwKG5ldyBSZXBsYWNlQXJvdW5kU3RlcChzdGFydE0sIGVuZE0sIHN0YXJ0TSArIDEsIGVuZE0gLSAxLCBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbSh0eXBlLmNyZWF0ZShhdHRyc0hlcmUsIG51bGwsIG5vZGUubWFya3MpKSwgMCwgMCksIDEsIHRydWUpKTtcbiAgICAgICAgICAgIGlmIChjb252ZXJ0TmV3bGluZXMgPT09IHRydWUpXG4gICAgICAgICAgICAgICAgcmVwbGFjZU5ld2xpbmVzKHRyLCBub2RlLCBwb3MsIG1hcEZyb20pO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5mdW5jdGlvbiByZXBsYWNlTmV3bGluZXModHIsIG5vZGUsIHBvcywgbWFwRnJvbSkge1xuICAgIG5vZGUuZm9yRWFjaCgoY2hpbGQsIG9mZnNldCkgPT4ge1xuICAgICAgICBpZiAoY2hpbGQuaXNUZXh0KSB7XG4gICAgICAgICAgICBsZXQgbSwgbmV3bGluZSA9IC9cXHI/XFxufFxcci9nO1xuICAgICAgICAgICAgd2hpbGUgKG0gPSBuZXdsaW5lLmV4ZWMoY2hpbGQudGV4dCkpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnQgPSB0ci5tYXBwaW5nLnNsaWNlKG1hcEZyb20pLm1hcChwb3MgKyAxICsgb2Zmc2V0ICsgbS5pbmRleCk7XG4gICAgICAgICAgICAgICAgdHIucmVwbGFjZVdpdGgoc3RhcnQsIHN0YXJ0ICsgMSwgbm9kZS50eXBlLnNjaGVtYS5saW5lYnJlYWtSZXBsYWNlbWVudC5jcmVhdGUoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VMaW5lYnJlYWtzKHRyLCBub2RlLCBwb3MsIG1hcEZyb20pIHtcbiAgICBub2RlLmZvckVhY2goKGNoaWxkLCBvZmZzZXQpID0+IHtcbiAgICAgICAgaWYgKGNoaWxkLnR5cGUgPT0gY2hpbGQudHlwZS5zY2hlbWEubGluZWJyZWFrUmVwbGFjZW1lbnQpIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRyLm1hcHBpbmcuc2xpY2UobWFwRnJvbSkubWFwKHBvcyArIDEgKyBvZmZzZXQpO1xuICAgICAgICAgICAgdHIucmVwbGFjZVdpdGgoc3RhcnQsIHN0YXJ0ICsgMSwgbm9kZS50eXBlLnNjaGVtYS50ZXh0KFwiXFxuXCIpKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gY2FuQ2hhbmdlVHlwZShkb2MsIHBvcywgdHlwZSkge1xuICAgIGxldCAkcG9zID0gZG9jLnJlc29sdmUocG9zKSwgaW5kZXggPSAkcG9zLmluZGV4KCk7XG4gICAgcmV0dXJuICRwb3MucGFyZW50LmNhblJlcGxhY2VXaXRoKGluZGV4LCBpbmRleCArIDEsIHR5cGUpO1xufVxuLyoqXG5DaGFuZ2UgdGhlIHR5cGUsIGF0dHJpYnV0ZXMsIGFuZC9vciBtYXJrcyBvZiB0aGUgbm9kZSBhdCBgcG9zYC5cbldoZW4gYHR5cGVgIGlzbid0IGdpdmVuLCB0aGUgZXhpc3Rpbmcgbm9kZSB0eXBlIGlzIHByZXNlcnZlZCxcbiovXG5mdW5jdGlvbiBzZXROb2RlTWFya3VwKHRyLCBwb3MsIHR5cGUsIGF0dHJzLCBtYXJrcykge1xuICAgIGxldCBub2RlID0gdHIuZG9jLm5vZGVBdChwb3MpO1xuICAgIGlmICghbm9kZSlcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJObyBub2RlIGF0IGdpdmVuIHBvc2l0aW9uXCIpO1xuICAgIGlmICghdHlwZSlcbiAgICAgICAgdHlwZSA9IG5vZGUudHlwZTtcbiAgICBsZXQgbmV3Tm9kZSA9IHR5cGUuY3JlYXRlKGF0dHJzLCBudWxsLCBtYXJrcyB8fCBub2RlLm1hcmtzKTtcbiAgICBpZiAobm9kZS5pc0xlYWYpXG4gICAgICAgIHJldHVybiB0ci5yZXBsYWNlV2l0aChwb3MsIHBvcyArIG5vZGUubm9kZVNpemUsIG5ld05vZGUpO1xuICAgIGlmICghdHlwZS52YWxpZENvbnRlbnQobm9kZS5jb250ZW50KSlcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGNvbnRlbnQgZm9yIG5vZGUgdHlwZSBcIiArIHR5cGUubmFtZSk7XG4gICAgdHIuc3RlcChuZXcgUmVwbGFjZUFyb3VuZFN0ZXAocG9zLCBwb3MgKyBub2RlLm5vZGVTaXplLCBwb3MgKyAxLCBwb3MgKyBub2RlLm5vZGVTaXplIC0gMSwgbmV3IFNsaWNlKEZyYWdtZW50LmZyb20obmV3Tm9kZSksIDAsIDApLCAxLCB0cnVlKSk7XG59XG4vKipcbkNoZWNrIHdoZXRoZXIgc3BsaXR0aW5nIGF0IHRoZSBnaXZlbiBwb3NpdGlvbiBpcyBhbGxvd2VkLlxuKi9cbmZ1bmN0aW9uIGNhblNwbGl0KGRvYywgcG9zLCBkZXB0aCA9IDEsIHR5cGVzQWZ0ZXIpIHtcbiAgICBsZXQgJHBvcyA9IGRvYy5yZXNvbHZlKHBvcyksIGJhc2UgPSAkcG9zLmRlcHRoIC0gZGVwdGg7XG4gICAgbGV0IGlubmVyVHlwZSA9ICh0eXBlc0FmdGVyICYmIHR5cGVzQWZ0ZXJbdHlwZXNBZnRlci5sZW5ndGggLSAxXSkgfHwgJHBvcy5wYXJlbnQ7XG4gICAgaWYgKGJhc2UgPCAwIHx8ICRwb3MucGFyZW50LnR5cGUuc3BlYy5pc29sYXRpbmcgfHxcbiAgICAgICAgISRwb3MucGFyZW50LmNhblJlcGxhY2UoJHBvcy5pbmRleCgpLCAkcG9zLnBhcmVudC5jaGlsZENvdW50KSB8fFxuICAgICAgICAhaW5uZXJUeXBlLnR5cGUudmFsaWRDb250ZW50KCRwb3MucGFyZW50LmNvbnRlbnQuY3V0QnlJbmRleCgkcG9zLmluZGV4KCksICRwb3MucGFyZW50LmNoaWxkQ291bnQpKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGQgPSAkcG9zLmRlcHRoIC0gMSwgaSA9IGRlcHRoIC0gMjsgZCA+IGJhc2U7IGQtLSwgaS0tKSB7XG4gICAgICAgIGxldCBub2RlID0gJHBvcy5ub2RlKGQpLCBpbmRleCA9ICRwb3MuaW5kZXgoZCk7XG4gICAgICAgIGlmIChub2RlLnR5cGUuc3BlYy5pc29sYXRpbmcpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCByZXN0ID0gbm9kZS5jb250ZW50LmN1dEJ5SW5kZXgoaW5kZXgsIG5vZGUuY2hpbGRDb3VudCk7XG4gICAgICAgIGxldCBvdmVycmlkZUNoaWxkID0gdHlwZXNBZnRlciAmJiB0eXBlc0FmdGVyW2kgKyAxXTtcbiAgICAgICAgaWYgKG92ZXJyaWRlQ2hpbGQpXG4gICAgICAgICAgICByZXN0ID0gcmVzdC5yZXBsYWNlQ2hpbGQoMCwgb3ZlcnJpZGVDaGlsZC50eXBlLmNyZWF0ZShvdmVycmlkZUNoaWxkLmF0dHJzKSk7XG4gICAgICAgIGxldCBhZnRlciA9ICh0eXBlc0FmdGVyICYmIHR5cGVzQWZ0ZXJbaV0pIHx8IG5vZGU7XG4gICAgICAgIGlmICghbm9kZS5jYW5SZXBsYWNlKGluZGV4ICsgMSwgbm9kZS5jaGlsZENvdW50KSB8fCAhYWZ0ZXIudHlwZS52YWxpZENvbnRlbnQocmVzdCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBpbmRleCA9ICRwb3MuaW5kZXhBZnRlcihiYXNlKTtcbiAgICBsZXQgYmFzZVR5cGUgPSB0eXBlc0FmdGVyICYmIHR5cGVzQWZ0ZXJbMF07XG4gICAgcmV0dXJuICRwb3Mubm9kZShiYXNlKS5jYW5SZXBsYWNlV2l0aChpbmRleCwgaW5kZXgsIGJhc2VUeXBlID8gYmFzZVR5cGUudHlwZSA6ICRwb3Mubm9kZShiYXNlICsgMSkudHlwZSk7XG59XG5mdW5jdGlvbiBzcGxpdCh0ciwgcG9zLCBkZXB0aCA9IDEsIHR5cGVzQWZ0ZXIpIHtcbiAgICBsZXQgJHBvcyA9IHRyLmRvYy5yZXNvbHZlKHBvcyksIGJlZm9yZSA9IEZyYWdtZW50LmVtcHR5LCBhZnRlciA9IEZyYWdtZW50LmVtcHR5O1xuICAgIGZvciAobGV0IGQgPSAkcG9zLmRlcHRoLCBlID0gJHBvcy5kZXB0aCAtIGRlcHRoLCBpID0gZGVwdGggLSAxOyBkID4gZTsgZC0tLCBpLS0pIHtcbiAgICAgICAgYmVmb3JlID0gRnJhZ21lbnQuZnJvbSgkcG9zLm5vZGUoZCkuY29weShiZWZvcmUpKTtcbiAgICAgICAgbGV0IHR5cGVBZnRlciA9IHR5cGVzQWZ0ZXIgJiYgdHlwZXNBZnRlcltpXTtcbiAgICAgICAgYWZ0ZXIgPSBGcmFnbWVudC5mcm9tKHR5cGVBZnRlciA/IHR5cGVBZnRlci50eXBlLmNyZWF0ZSh0eXBlQWZ0ZXIuYXR0cnMsIGFmdGVyKSA6ICRwb3Mubm9kZShkKS5jb3B5KGFmdGVyKSk7XG4gICAgfVxuICAgIHRyLnN0ZXAobmV3IFJlcGxhY2VTdGVwKHBvcywgcG9zLCBuZXcgU2xpY2UoYmVmb3JlLmFwcGVuZChhZnRlciksIGRlcHRoLCBkZXB0aCksIHRydWUpKTtcbn1cbi8qKlxuVGVzdCB3aGV0aGVyIHRoZSBibG9ja3MgYmVmb3JlIGFuZCBhZnRlciBhIGdpdmVuIHBvc2l0aW9uIGNhbiBiZVxuam9pbmVkLlxuKi9cbmZ1bmN0aW9uIGNhbkpvaW4oZG9jLCBwb3MpIHtcbiAgICBsZXQgJHBvcyA9IGRvYy5yZXNvbHZlKHBvcyksIGluZGV4ID0gJHBvcy5pbmRleCgpO1xuICAgIHJldHVybiBqb2luYWJsZSgkcG9zLm5vZGVCZWZvcmUsICRwb3Mubm9kZUFmdGVyKSAmJlxuICAgICAgICAkcG9zLnBhcmVudC5jYW5SZXBsYWNlKGluZGV4LCBpbmRleCArIDEpO1xufVxuZnVuY3Rpb24gY2FuQXBwZW5kV2l0aFN1YnN0aXR1dGVkTGluZWJyZWFrcyhhLCBiKSB7XG4gICAgaWYgKCFiLmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgYS50eXBlLmNvbXBhdGlibGVDb250ZW50KGIudHlwZSk7XG4gICAgbGV0IG1hdGNoID0gYS5jb250ZW50TWF0Y2hBdChhLmNoaWxkQ291bnQpO1xuICAgIGxldCB7IGxpbmVicmVha1JlcGxhY2VtZW50IH0gPSBhLnR5cGUuc2NoZW1hO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYi5jaGlsZENvdW50OyBpKyspIHtcbiAgICAgICAgbGV0IGNoaWxkID0gYi5jaGlsZChpKTtcbiAgICAgICAgbGV0IHR5cGUgPSBjaGlsZC50eXBlID09IGxpbmVicmVha1JlcGxhY2VtZW50ID8gYS50eXBlLnNjaGVtYS5ub2Rlcy50ZXh0IDogY2hpbGQudHlwZTtcbiAgICAgICAgbWF0Y2ggPSBtYXRjaC5tYXRjaFR5cGUodHlwZSk7XG4gICAgICAgIGlmICghbWF0Y2gpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghYS50eXBlLmFsbG93c01hcmtzKGNoaWxkLm1hcmtzKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoLnZhbGlkRW5kO1xufVxuZnVuY3Rpb24gam9pbmFibGUoYSwgYikge1xuICAgIHJldHVybiAhIShhICYmIGIgJiYgIWEuaXNMZWFmICYmIGNhbkFwcGVuZFdpdGhTdWJzdGl0dXRlZExpbmVicmVha3MoYSwgYikpO1xufVxuLyoqXG5GaW5kIGFuIGFuY2VzdG9yIG9mIHRoZSBnaXZlbiBwb3NpdGlvbiB0aGF0IGNhbiBiZSBqb2luZWQgdG8gdGhlXG5ibG9jayBiZWZvcmUgKG9yIGFmdGVyIGlmIGBkaXJgIGlzIHBvc2l0aXZlKS4gUmV0dXJucyB0aGUgam9pbmFibGVcbnBvaW50LCBpZiBhbnkuXG4qL1xuZnVuY3Rpb24gam9pblBvaW50KGRvYywgcG9zLCBkaXIgPSAtMSkge1xuICAgIGxldCAkcG9zID0gZG9jLnJlc29sdmUocG9zKTtcbiAgICBmb3IgKGxldCBkID0gJHBvcy5kZXB0aDs7IGQtLSkge1xuICAgICAgICBsZXQgYmVmb3JlLCBhZnRlciwgaW5kZXggPSAkcG9zLmluZGV4KGQpO1xuICAgICAgICBpZiAoZCA9PSAkcG9zLmRlcHRoKSB7XG4gICAgICAgICAgICBiZWZvcmUgPSAkcG9zLm5vZGVCZWZvcmU7XG4gICAgICAgICAgICBhZnRlciA9ICRwb3Mubm9kZUFmdGVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRpciA+IDApIHtcbiAgICAgICAgICAgIGJlZm9yZSA9ICRwb3Mubm9kZShkICsgMSk7XG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgYWZ0ZXIgPSAkcG9zLm5vZGUoZCkubWF5YmVDaGlsZChpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBiZWZvcmUgPSAkcG9zLm5vZGUoZCkubWF5YmVDaGlsZChpbmRleCAtIDEpO1xuICAgICAgICAgICAgYWZ0ZXIgPSAkcG9zLm5vZGUoZCArIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiZWZvcmUgJiYgIWJlZm9yZS5pc1RleHRibG9jayAmJiBqb2luYWJsZShiZWZvcmUsIGFmdGVyKSAmJlxuICAgICAgICAgICAgJHBvcy5ub2RlKGQpLmNhblJlcGxhY2UoaW5kZXgsIGluZGV4ICsgMSkpXG4gICAgICAgICAgICByZXR1cm4gcG9zO1xuICAgICAgICBpZiAoZCA9PSAwKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIHBvcyA9IGRpciA8IDAgPyAkcG9zLmJlZm9yZShkKSA6ICRwb3MuYWZ0ZXIoZCk7XG4gICAgfVxufVxuZnVuY3Rpb24gam9pbih0ciwgcG9zLCBkZXB0aCkge1xuICAgIGxldCBjb252ZXJ0TmV3bGluZXMgPSBudWxsO1xuICAgIGxldCB7IGxpbmVicmVha1JlcGxhY2VtZW50IH0gPSB0ci5kb2MudHlwZS5zY2hlbWE7XG4gICAgbGV0ICRiZWZvcmUgPSB0ci5kb2MucmVzb2x2ZShwb3MgLSBkZXB0aCksIGJlZm9yZVR5cGUgPSAkYmVmb3JlLm5vZGUoKS50eXBlO1xuICAgIGlmIChsaW5lYnJlYWtSZXBsYWNlbWVudCAmJiBiZWZvcmVUeXBlLmlubGluZUNvbnRlbnQpIHtcbiAgICAgICAgbGV0IHByZSA9IGJlZm9yZVR5cGUud2hpdGVzcGFjZSA9PSBcInByZVwiO1xuICAgICAgICBsZXQgc3VwcG9ydExpbmVicmVhayA9ICEhYmVmb3JlVHlwZS5jb250ZW50TWF0Y2gubWF0Y2hUeXBlKGxpbmVicmVha1JlcGxhY2VtZW50KTtcbiAgICAgICAgaWYgKHByZSAmJiAhc3VwcG9ydExpbmVicmVhaylcbiAgICAgICAgICAgIGNvbnZlcnROZXdsaW5lcyA9IGZhbHNlO1xuICAgICAgICBlbHNlIGlmICghcHJlICYmIHN1cHBvcnRMaW5lYnJlYWspXG4gICAgICAgICAgICBjb252ZXJ0TmV3bGluZXMgPSB0cnVlO1xuICAgIH1cbiAgICBsZXQgbWFwRnJvbSA9IHRyLnN0ZXBzLmxlbmd0aDtcbiAgICBpZiAoY29udmVydE5ld2xpbmVzID09PSBmYWxzZSkge1xuICAgICAgICBsZXQgJGFmdGVyID0gdHIuZG9jLnJlc29sdmUocG9zICsgZGVwdGgpO1xuICAgICAgICByZXBsYWNlTGluZWJyZWFrcyh0ciwgJGFmdGVyLm5vZGUoKSwgJGFmdGVyLmJlZm9yZSgpLCBtYXBGcm9tKTtcbiAgICB9XG4gICAgaWYgKGJlZm9yZVR5cGUuaW5saW5lQ29udGVudClcbiAgICAgICAgY2xlYXJJbmNvbXBhdGlibGUodHIsIHBvcyArIGRlcHRoIC0gMSwgYmVmb3JlVHlwZSwgJGJlZm9yZS5ub2RlKCkuY29udGVudE1hdGNoQXQoJGJlZm9yZS5pbmRleCgpKSwgY29udmVydE5ld2xpbmVzID09IG51bGwpO1xuICAgIGxldCBtYXBwaW5nID0gdHIubWFwcGluZy5zbGljZShtYXBGcm9tKSwgc3RhcnQgPSBtYXBwaW5nLm1hcChwb3MgLSBkZXB0aCk7XG4gICAgdHIuc3RlcChuZXcgUmVwbGFjZVN0ZXAoc3RhcnQsIG1hcHBpbmcubWFwKHBvcyArIGRlcHRoLCAtMSksIFNsaWNlLmVtcHR5LCB0cnVlKSk7XG4gICAgaWYgKGNvbnZlcnROZXdsaW5lcyA9PT0gdHJ1ZSkge1xuICAgICAgICBsZXQgJGZ1bGwgPSB0ci5kb2MucmVzb2x2ZShzdGFydCk7XG4gICAgICAgIHJlcGxhY2VOZXdsaW5lcyh0ciwgJGZ1bGwubm9kZSgpLCAkZnVsbC5iZWZvcmUoKSwgdHIuc3RlcHMubGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRyO1xufVxuLyoqXG5UcnkgdG8gZmluZCBhIHBvaW50IHdoZXJlIGEgbm9kZSBvZiB0aGUgZ2l2ZW4gdHlwZSBjYW4gYmUgaW5zZXJ0ZWRcbm5lYXIgYHBvc2AsIGJ5IHNlYXJjaGluZyB1cCB0aGUgbm9kZSBoaWVyYXJjaHkgd2hlbiBgcG9zYCBpdHNlbGZcbmlzbid0IGEgdmFsaWQgcGxhY2UgYnV0IGlzIGF0IHRoZSBzdGFydCBvciBlbmQgb2YgYSBub2RlLiBSZXR1cm5cbm51bGwgaWYgbm8gcG9zaXRpb24gd2FzIGZvdW5kLlxuKi9cbmZ1bmN0aW9uIGluc2VydFBvaW50KGRvYywgcG9zLCBub2RlVHlwZSkge1xuICAgIGxldCAkcG9zID0gZG9jLnJlc29sdmUocG9zKTtcbiAgICBpZiAoJHBvcy5wYXJlbnQuY2FuUmVwbGFjZVdpdGgoJHBvcy5pbmRleCgpLCAkcG9zLmluZGV4KCksIG5vZGVUeXBlKSlcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICBpZiAoJHBvcy5wYXJlbnRPZmZzZXQgPT0gMClcbiAgICAgICAgZm9yIChsZXQgZCA9ICRwb3MuZGVwdGggLSAxOyBkID49IDA7IGQtLSkge1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gJHBvcy5pbmRleChkKTtcbiAgICAgICAgICAgIGlmICgkcG9zLm5vZGUoZCkuY2FuUmVwbGFjZVdpdGgoaW5kZXgsIGluZGV4LCBub2RlVHlwZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuICRwb3MuYmVmb3JlKGQgKyAxKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICBpZiAoJHBvcy5wYXJlbnRPZmZzZXQgPT0gJHBvcy5wYXJlbnQuY29udGVudC5zaXplKVxuICAgICAgICBmb3IgKGxldCBkID0gJHBvcy5kZXB0aCAtIDE7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSAkcG9zLmluZGV4QWZ0ZXIoZCk7XG4gICAgICAgICAgICBpZiAoJHBvcy5ub2RlKGQpLmNhblJlcGxhY2VXaXRoKGluZGV4LCBpbmRleCwgbm9kZVR5cGUpKVxuICAgICAgICAgICAgICAgIHJldHVybiAkcG9zLmFmdGVyKGQgKyAxKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA8ICRwb3Mubm9kZShkKS5jaGlsZENvdW50KVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vKipcbkZpbmRzIGEgcG9zaXRpb24gYXQgb3IgYXJvdW5kIHRoZSBnaXZlbiBwb3NpdGlvbiB3aGVyZSB0aGUgZ2l2ZW5cbnNsaWNlIGNhbiBiZSBpbnNlcnRlZC4gV2lsbCBsb29rIGF0IHBhcmVudCBub2RlcycgbmVhcmVzdCBib3VuZGFyeVxuYW5kIHRyeSB0aGVyZSwgZXZlbiBpZiB0aGUgb3JpZ2luYWwgcG9zaXRpb24gd2Fzbid0IGRpcmVjdGx5IGF0IHRoZVxuc3RhcnQgb3IgZW5kIG9mIHRoYXQgbm9kZS4gUmV0dXJucyBudWxsIHdoZW4gbm8gcG9zaXRpb24gd2FzIGZvdW5kLlxuKi9cbmZ1bmN0aW9uIGRyb3BQb2ludChkb2MsIHBvcywgc2xpY2UpIHtcbiAgICBsZXQgJHBvcyA9IGRvYy5yZXNvbHZlKHBvcyk7XG4gICAgaWYgKCFzbGljZS5jb250ZW50LnNpemUpXG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgbGV0IGNvbnRlbnQgPSBzbGljZS5jb250ZW50O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2xpY2Uub3BlblN0YXJ0OyBpKyspXG4gICAgICAgIGNvbnRlbnQgPSBjb250ZW50LmZpcnN0Q2hpbGQuY29udGVudDtcbiAgICBmb3IgKGxldCBwYXNzID0gMTsgcGFzcyA8PSAoc2xpY2Uub3BlblN0YXJ0ID09IDAgJiYgc2xpY2Uuc2l6ZSA/IDIgOiAxKTsgcGFzcysrKSB7XG4gICAgICAgIGZvciAobGV0IGQgPSAkcG9zLmRlcHRoOyBkID49IDA7IGQtLSkge1xuICAgICAgICAgICAgbGV0IGJpYXMgPSBkID09ICRwb3MuZGVwdGggPyAwIDogJHBvcy5wb3MgPD0gKCRwb3Muc3RhcnQoZCArIDEpICsgJHBvcy5lbmQoZCArIDEpKSAvIDIgPyAtMSA6IDE7XG4gICAgICAgICAgICBsZXQgaW5zZXJ0UG9zID0gJHBvcy5pbmRleChkKSArIChiaWFzID4gMCA/IDEgOiAwKTtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSAkcG9zLm5vZGUoZCksIGZpdHMgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChwYXNzID09IDEpIHtcbiAgICAgICAgICAgICAgICBmaXRzID0gcGFyZW50LmNhblJlcGxhY2UoaW5zZXJ0UG9zLCBpbnNlcnRQb3MsIGNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHdyYXBwaW5nID0gcGFyZW50LmNvbnRlbnRNYXRjaEF0KGluc2VydFBvcykuZmluZFdyYXBwaW5nKGNvbnRlbnQuZmlyc3RDaGlsZC50eXBlKTtcbiAgICAgICAgICAgICAgICBmaXRzID0gd3JhcHBpbmcgJiYgcGFyZW50LmNhblJlcGxhY2VXaXRoKGluc2VydFBvcywgaW5zZXJ0UG9zLCB3cmFwcGluZ1swXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZml0cylcbiAgICAgICAgICAgICAgICByZXR1cm4gYmlhcyA9PSAwID8gJHBvcy5wb3MgOiBiaWFzIDwgMCA/ICRwb3MuYmVmb3JlKGQgKyAxKSA6ICRwb3MuYWZ0ZXIoZCArIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG4vKipcbuKAmEZpdOKAmSBhIHNsaWNlIGludG8gYSBnaXZlbiBwb3NpdGlvbiBpbiB0aGUgZG9jdW1lbnQsIHByb2R1Y2luZyBhXG5bc3RlcF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3RyYW5zZm9ybS5TdGVwKSB0aGF0IGluc2VydHMgaXQuIFdpbGwgcmV0dXJuIG51bGwgaWZcbnRoZXJlJ3Mgbm8gbWVhbmluZ2Z1bCB3YXkgdG8gaW5zZXJ0IHRoZSBzbGljZSBoZXJlLCBvciBpbnNlcnRpbmcgaXRcbndvdWxkIGJlIGEgbm8tb3AgKGFuIGVtcHR5IHNsaWNlIG92ZXIgYW4gZW1wdHkgcmFuZ2UpLlxuKi9cbmZ1bmN0aW9uIHJlcGxhY2VTdGVwKGRvYywgZnJvbSwgdG8gPSBmcm9tLCBzbGljZSA9IFNsaWNlLmVtcHR5KSB7XG4gICAgaWYgKGZyb20gPT0gdG8gJiYgIXNsaWNlLnNpemUpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCAkZnJvbSA9IGRvYy5yZXNvbHZlKGZyb20pLCAkdG8gPSBkb2MucmVzb2x2ZSh0byk7XG4gICAgLy8gT3B0aW1pemF0aW9uIC0tIGF2b2lkIHdvcmsgaWYgaXQncyBvYnZpb3VzIHRoYXQgaXQncyBub3QgbmVlZGVkLlxuICAgIGlmIChmaXRzVHJpdmlhbGx5KCRmcm9tLCAkdG8sIHNsaWNlKSlcbiAgICAgICAgcmV0dXJuIG5ldyBSZXBsYWNlU3RlcChmcm9tLCB0bywgc2xpY2UpO1xuICAgIHJldHVybiBuZXcgRml0dGVyKCRmcm9tLCAkdG8sIHNsaWNlKS5maXQoKTtcbn1cbmZ1bmN0aW9uIGZpdHNUcml2aWFsbHkoJGZyb20sICR0bywgc2xpY2UpIHtcbiAgICByZXR1cm4gIXNsaWNlLm9wZW5TdGFydCAmJiAhc2xpY2Uub3BlbkVuZCAmJiAkZnJvbS5zdGFydCgpID09ICR0by5zdGFydCgpICYmXG4gICAgICAgICRmcm9tLnBhcmVudC5jYW5SZXBsYWNlKCRmcm9tLmluZGV4KCksICR0by5pbmRleCgpLCBzbGljZS5jb250ZW50KTtcbn1cbi8vIEFsZ29yaXRobSBmb3IgJ3BsYWNpbmcnIHRoZSBlbGVtZW50cyBvZiBhIHNsaWNlIGludG8gYSBnYXA6XG4vL1xuLy8gV2UgY29uc2lkZXIgdGhlIGNvbnRlbnQgb2YgZWFjaCBub2RlIHRoYXQgaXMgb3BlbiB0byB0aGUgbGVmdCB0byBiZVxuLy8gaW5kZXBlbmRlbnRseSBwbGFjZWFibGUuIEkuZS4gaW4gPHAoXCJmb29cIiksIHAoXCJiYXJcIik+LCB3aGVuIHRoZVxuLy8gcGFyYWdyYXBoIG9uIHRoZSBsZWZ0IGlzIG9wZW4sIFwiZm9vXCIgY2FuIGJlIHBsYWNlZCAoc29tZXdoZXJlIG9uXG4vLyB0aGUgbGVmdCBzaWRlIG9mIHRoZSByZXBsYWNlbWVudCBnYXApIGluZGVwZW5kZW50bHkgZnJvbSBwKFwiYmFyXCIpLlxuLy9cbi8vIFRoaXMgY2xhc3MgdHJhY2tzIHRoZSBzdGF0ZSBvZiB0aGUgcGxhY2VtZW50IHByb2dyZXNzIGluIHRoZVxuLy8gZm9sbG93aW5nIHByb3BlcnRpZXM6XG4vL1xuLy8gIC0gYGZyb250aWVyYCBob2xkcyBhIHN0YWNrIG9mIGB7dHlwZSwgbWF0Y2h9YCBvYmplY3RzIHRoYXRcbi8vICAgIHJlcHJlc2VudCB0aGUgb3BlbiBzaWRlIG9mIHRoZSByZXBsYWNlbWVudC4gSXQgc3RhcnRzIGF0XG4vLyAgICBgJGZyb21gLCB0aGVuIG1vdmVzIGZvcndhcmQgYXMgY29udGVudCBpcyBwbGFjZWQsIGFuZCBpcyBmaW5hbGx5XG4vLyAgICByZWNvbmNpbGVkIHdpdGggYCR0b2AuXG4vL1xuLy8gIC0gYHVucGxhY2VkYCBpcyBhIHNsaWNlIHRoYXQgcmVwcmVzZW50cyB0aGUgY29udGVudCB0aGF0IGhhc24ndFxuLy8gICAgYmVlbiBwbGFjZWQgeWV0LlxuLy9cbi8vICAtIGBwbGFjZWRgIGlzIGEgZnJhZ21lbnQgb2YgcGxhY2VkIGNvbnRlbnQuIEl0cyBvcGVuLXN0YXJ0IHZhbHVlXG4vLyAgICBpcyBpbXBsaWNpdCBpbiBgJGZyb21gLCBhbmQgaXRzIG9wZW4tZW5kIHZhbHVlIGluIGBmcm9udGllcmAuXG5jbGFzcyBGaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKCRmcm9tLCAkdG8sIHVucGxhY2VkKSB7XG4gICAgICAgIHRoaXMuJGZyb20gPSAkZnJvbTtcbiAgICAgICAgdGhpcy4kdG8gPSAkdG87XG4gICAgICAgIHRoaXMudW5wbGFjZWQgPSB1bnBsYWNlZDtcbiAgICAgICAgdGhpcy5mcm9udGllciA9IFtdO1xuICAgICAgICB0aGlzLnBsYWNlZCA9IEZyYWdtZW50LmVtcHR5O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSAkZnJvbS5kZXB0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbm9kZSA9ICRmcm9tLm5vZGUoaSk7XG4gICAgICAgICAgICB0aGlzLmZyb250aWVyLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IG5vZGUudHlwZSxcbiAgICAgICAgICAgICAgICBtYXRjaDogbm9kZS5jb250ZW50TWF0Y2hBdCgkZnJvbS5pbmRleEFmdGVyKGkpKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9ICRmcm9tLmRlcHRoOyBpID4gMDsgaS0tKVxuICAgICAgICAgICAgdGhpcy5wbGFjZWQgPSBGcmFnbWVudC5mcm9tKCRmcm9tLm5vZGUoaSkuY29weSh0aGlzLnBsYWNlZCkpO1xuICAgIH1cbiAgICBnZXQgZGVwdGgoKSB7IHJldHVybiB0aGlzLmZyb250aWVyLmxlbmd0aCAtIDE7IH1cbiAgICBmaXQoKSB7XG4gICAgICAgIC8vIEFzIGxvbmcgYXMgdGhlcmUncyB1bnBsYWNlZCBjb250ZW50LCB0cnkgdG8gcGxhY2Ugc29tZSBvZiBpdC5cbiAgICAgICAgLy8gSWYgdGhhdCBmYWlscywgZWl0aGVyIGluY3JlYXNlIHRoZSBvcGVuIHNjb3JlIG9mIHRoZSB1bnBsYWNlZFxuICAgICAgICAvLyBzbGljZSwgb3IgZHJvcCBub2RlcyBmcm9tIGl0LCBhbmQgdGhlbiB0cnkgYWdhaW4uXG4gICAgICAgIHdoaWxlICh0aGlzLnVucGxhY2VkLnNpemUpIHtcbiAgICAgICAgICAgIGxldCBmaXQgPSB0aGlzLmZpbmRGaXR0YWJsZSgpO1xuICAgICAgICAgICAgaWYgKGZpdClcbiAgICAgICAgICAgICAgICB0aGlzLnBsYWNlTm9kZXMoZml0KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW5Nb3JlKCkgfHwgdGhpcy5kcm9wTm9kZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdoZW4gdGhlcmUncyBpbmxpbmUgY29udGVudCBkaXJlY3RseSBhZnRlciB0aGUgZnJvbnRpZXIgX2FuZF9cbiAgICAgICAgLy8gZGlyZWN0bHkgYWZ0ZXIgYHRoaXMuJHRvYCwgd2UgbXVzdCBnZW5lcmF0ZSBhIGBSZXBsYWNlQXJvdW5kYFxuICAgICAgICAvLyBzdGVwIHRoYXQgcHVsbHMgdGhhdCBjb250ZW50IGludG8gdGhlIG5vZGUgYWZ0ZXIgdGhlIGZyb250aWVyLlxuICAgICAgICAvLyBUaGF0IG1lYW5zIHRoZSBmaXR0aW5nIG11c3QgYmUgZG9uZSB0byB0aGUgZW5kIG9mIHRoZSB0ZXh0YmxvY2tcbiAgICAgICAgLy8gbm9kZSBhZnRlciBgdGhpcy4kdG9gLCBub3QgYHRoaXMuJHRvYCBpdHNlbGYuXG4gICAgICAgIGxldCBtb3ZlSW5saW5lID0gdGhpcy5tdXN0TW92ZUlubGluZSgpLCBwbGFjZWRTaXplID0gdGhpcy5wbGFjZWQuc2l6ZSAtIHRoaXMuZGVwdGggLSB0aGlzLiRmcm9tLmRlcHRoO1xuICAgICAgICBsZXQgJGZyb20gPSB0aGlzLiRmcm9tLCAkdG8gPSB0aGlzLmNsb3NlKG1vdmVJbmxpbmUgPCAwID8gdGhpcy4kdG8gOiAkZnJvbS5kb2MucmVzb2x2ZShtb3ZlSW5saW5lKSk7XG4gICAgICAgIGlmICghJHRvKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIC8vIElmIGNsb3NpbmcgdG8gYCR0b2Agc3VjY2VlZGVkLCBjcmVhdGUgYSBzdGVwXG4gICAgICAgIGxldCBjb250ZW50ID0gdGhpcy5wbGFjZWQsIG9wZW5TdGFydCA9ICRmcm9tLmRlcHRoLCBvcGVuRW5kID0gJHRvLmRlcHRoO1xuICAgICAgICB3aGlsZSAob3BlblN0YXJ0ICYmIG9wZW5FbmQgJiYgY29udGVudC5jaGlsZENvdW50ID09IDEpIHsgLy8gTm9ybWFsaXplIGJ5IGRyb3BwaW5nIG9wZW4gcGFyZW50IG5vZGVzXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5maXJzdENoaWxkLmNvbnRlbnQ7XG4gICAgICAgICAgICBvcGVuU3RhcnQtLTtcbiAgICAgICAgICAgIG9wZW5FbmQtLTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2xpY2UgPSBuZXcgU2xpY2UoY29udGVudCwgb3BlblN0YXJ0LCBvcGVuRW5kKTtcbiAgICAgICAgaWYgKG1vdmVJbmxpbmUgPiAtMSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVwbGFjZUFyb3VuZFN0ZXAoJGZyb20ucG9zLCBtb3ZlSW5saW5lLCB0aGlzLiR0by5wb3MsIHRoaXMuJHRvLmVuZCgpLCBzbGljZSwgcGxhY2VkU2l6ZSk7XG4gICAgICAgIGlmIChzbGljZS5zaXplIHx8ICRmcm9tLnBvcyAhPSB0aGlzLiR0by5wb3MpIC8vIERvbid0IGdlbmVyYXRlIG5vLW9wIHN0ZXBzXG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlcGxhY2VTdGVwKCRmcm9tLnBvcywgJHRvLnBvcywgc2xpY2UpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gRmluZCBhIHBvc2l0aW9uIG9uIHRoZSBzdGFydCBzcGluZSBvZiBgdGhpcy51bnBsYWNlZGAgdGhhdCBoYXNcbiAgICAvLyBjb250ZW50IHRoYXQgY2FuIGJlIG1vdmVkIHNvbWV3aGVyZSBvbiB0aGUgZnJvbnRpZXIuIFJldHVybnMgdHdvXG4gICAgLy8gZGVwdGhzLCBvbmUgZm9yIHRoZSBzbGljZSBhbmQgb25lIGZvciB0aGUgZnJvbnRpZXIuXG4gICAgZmluZEZpdHRhYmxlKCkge1xuICAgICAgICBsZXQgc3RhcnREZXB0aCA9IHRoaXMudW5wbGFjZWQub3BlblN0YXJ0O1xuICAgICAgICBmb3IgKGxldCBjdXIgPSB0aGlzLnVucGxhY2VkLmNvbnRlbnQsIGQgPSAwLCBvcGVuRW5kID0gdGhpcy51bnBsYWNlZC5vcGVuRW5kOyBkIDwgc3RhcnREZXB0aDsgZCsrKSB7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IGN1ci5maXJzdENoaWxkO1xuICAgICAgICAgICAgaWYgKGN1ci5jaGlsZENvdW50ID4gMSlcbiAgICAgICAgICAgICAgICBvcGVuRW5kID0gMDtcbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUuc3BlYy5pc29sYXRpbmcgJiYgb3BlbkVuZCA8PSBkKSB7XG4gICAgICAgICAgICAgICAgc3RhcnREZXB0aCA9IGQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXIgPSBub2RlLmNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT25seSB0cnkgd3JhcHBpbmcgbm9kZXMgKHBhc3MgMikgYWZ0ZXIgZmluZGluZyBhIHBsYWNlIHdpdGhvdXRcbiAgICAgICAgLy8gd3JhcHBpbmcgZmFpbGVkLlxuICAgICAgICBmb3IgKGxldCBwYXNzID0gMTsgcGFzcyA8PSAyOyBwYXNzKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHNsaWNlRGVwdGggPSBwYXNzID09IDEgPyBzdGFydERlcHRoIDogdGhpcy51bnBsYWNlZC5vcGVuU3RhcnQ7IHNsaWNlRGVwdGggPj0gMDsgc2xpY2VEZXB0aC0tKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyYWdtZW50LCBwYXJlbnQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChzbGljZURlcHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudCA9IGNvbnRlbnRBdCh0aGlzLnVucGxhY2VkLmNvbnRlbnQsIHNsaWNlRGVwdGggLSAxKS5maXJzdENoaWxkO1xuICAgICAgICAgICAgICAgICAgICBmcmFnbWVudCA9IHBhcmVudC5jb250ZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQgPSB0aGlzLnVucGxhY2VkLmNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBmaXJzdCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgZnJvbnRpZXJEZXB0aCA9IHRoaXMuZGVwdGg7IGZyb250aWVyRGVwdGggPj0gMDsgZnJvbnRpZXJEZXB0aC0tKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCB7IHR5cGUsIG1hdGNoIH0gPSB0aGlzLmZyb250aWVyW2Zyb250aWVyRGVwdGhdLCB3cmFwLCBpbmplY3QgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAvLyBJbiBwYXNzIDEsIGlmIHRoZSBuZXh0IG5vZGUgbWF0Y2hlcywgb3IgdGhlcmUgaXMgbm8gbmV4dFxuICAgICAgICAgICAgICAgICAgICAvLyBub2RlIGJ1dCB0aGUgcGFyZW50cyBsb29rIGNvbXBhdGlibGUsIHdlJ3ZlIGZvdW5kIGFcbiAgICAgICAgICAgICAgICAgICAgLy8gcGxhY2UuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXNzID09IDEgJiYgKGZpcnN0ID8gbWF0Y2gubWF0Y2hUeXBlKGZpcnN0LnR5cGUpIHx8IChpbmplY3QgPSBtYXRjaC5maWxsQmVmb3JlKEZyYWdtZW50LmZyb20oZmlyc3QpLCBmYWxzZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHBhcmVudCAmJiB0eXBlLmNvbXBhdGlibGVDb250ZW50KHBhcmVudC50eXBlKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBzbGljZURlcHRoLCBmcm9udGllckRlcHRoLCBwYXJlbnQsIGluamVjdCB9O1xuICAgICAgICAgICAgICAgICAgICAvLyBJbiBwYXNzIDIsIGxvb2sgZm9yIGEgc2V0IG9mIHdyYXBwaW5nIG5vZGVzIHRoYXQgbWFrZVxuICAgICAgICAgICAgICAgICAgICAvLyBgZmlyc3RgIGZpdCBoZXJlLlxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXNzID09IDIgJiYgZmlyc3QgJiYgKHdyYXAgPSBtYXRjaC5maW5kV3JhcHBpbmcoZmlyc3QudHlwZSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgc2xpY2VEZXB0aCwgZnJvbnRpZXJEZXB0aCwgcGFyZW50LCB3cmFwIH07XG4gICAgICAgICAgICAgICAgICAgIC8vIERvbid0IGNvbnRpbnVlIGxvb2tpbmcgZnVydGhlciB1cCBpZiB0aGUgcGFyZW50IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgLy8gd291bGQgZml0IGhlcmUuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnQgJiYgbWF0Y2gubWF0Y2hUeXBlKHBhcmVudC50eXBlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBvcGVuTW9yZSgpIHtcbiAgICAgICAgbGV0IHsgY29udGVudCwgb3BlblN0YXJ0LCBvcGVuRW5kIH0gPSB0aGlzLnVucGxhY2VkO1xuICAgICAgICBsZXQgaW5uZXIgPSBjb250ZW50QXQoY29udGVudCwgb3BlblN0YXJ0KTtcbiAgICAgICAgaWYgKCFpbm5lci5jaGlsZENvdW50IHx8IGlubmVyLmZpcnN0Q2hpbGQuaXNMZWFmKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLnVucGxhY2VkID0gbmV3IFNsaWNlKGNvbnRlbnQsIG9wZW5TdGFydCArIDEsIE1hdGgubWF4KG9wZW5FbmQsIGlubmVyLnNpemUgKyBvcGVuU3RhcnQgPj0gY29udGVudC5zaXplIC0gb3BlbkVuZCA/IG9wZW5TdGFydCArIDEgOiAwKSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBkcm9wTm9kZSgpIHtcbiAgICAgICAgbGV0IHsgY29udGVudCwgb3BlblN0YXJ0LCBvcGVuRW5kIH0gPSB0aGlzLnVucGxhY2VkO1xuICAgICAgICBsZXQgaW5uZXIgPSBjb250ZW50QXQoY29udGVudCwgb3BlblN0YXJ0KTtcbiAgICAgICAgaWYgKGlubmVyLmNoaWxkQ291bnQgPD0gMSAmJiBvcGVuU3RhcnQgPiAwKSB7XG4gICAgICAgICAgICBsZXQgb3BlbkF0RW5kID0gY29udGVudC5zaXplIC0gb3BlblN0YXJ0IDw9IG9wZW5TdGFydCArIGlubmVyLnNpemU7XG4gICAgICAgICAgICB0aGlzLnVucGxhY2VkID0gbmV3IFNsaWNlKGRyb3BGcm9tRnJhZ21lbnQoY29udGVudCwgb3BlblN0YXJ0IC0gMSwgMSksIG9wZW5TdGFydCAtIDEsIG9wZW5BdEVuZCA/IG9wZW5TdGFydCAtIDEgOiBvcGVuRW5kKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudW5wbGFjZWQgPSBuZXcgU2xpY2UoZHJvcEZyb21GcmFnbWVudChjb250ZW50LCBvcGVuU3RhcnQsIDEpLCBvcGVuU3RhcnQsIG9wZW5FbmQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIE1vdmUgY29udGVudCBmcm9tIHRoZSB1bnBsYWNlZCBzbGljZSBhdCBgc2xpY2VEZXB0aGAgdG8gdGhlXG4gICAgLy8gZnJvbnRpZXIgbm9kZSBhdCBgZnJvbnRpZXJEZXB0aGAuIENsb3NlIHRoYXQgZnJvbnRpZXIgbm9kZSB3aGVuXG4gICAgLy8gYXBwbGljYWJsZS5cbiAgICBwbGFjZU5vZGVzKHsgc2xpY2VEZXB0aCwgZnJvbnRpZXJEZXB0aCwgcGFyZW50LCBpbmplY3QsIHdyYXAgfSkge1xuICAgICAgICB3aGlsZSAodGhpcy5kZXB0aCA+IGZyb250aWVyRGVwdGgpXG4gICAgICAgICAgICB0aGlzLmNsb3NlRnJvbnRpZXJOb2RlKCk7XG4gICAgICAgIGlmICh3cmFwKVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3cmFwLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIHRoaXMub3BlbkZyb250aWVyTm9kZSh3cmFwW2ldKTtcbiAgICAgICAgbGV0IHNsaWNlID0gdGhpcy51bnBsYWNlZCwgZnJhZ21lbnQgPSBwYXJlbnQgPyBwYXJlbnQuY29udGVudCA6IHNsaWNlLmNvbnRlbnQ7XG4gICAgICAgIGxldCBvcGVuU3RhcnQgPSBzbGljZS5vcGVuU3RhcnQgLSBzbGljZURlcHRoO1xuICAgICAgICBsZXQgdGFrZW4gPSAwLCBhZGQgPSBbXTtcbiAgICAgICAgbGV0IHsgbWF0Y2gsIHR5cGUgfSA9IHRoaXMuZnJvbnRpZXJbZnJvbnRpZXJEZXB0aF07XG4gICAgICAgIGlmIChpbmplY3QpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5qZWN0LmNoaWxkQ291bnQ7IGkrKylcbiAgICAgICAgICAgICAgICBhZGQucHVzaChpbmplY3QuY2hpbGQoaSkpO1xuICAgICAgICAgICAgbWF0Y2ggPSBtYXRjaC5tYXRjaEZyYWdtZW50KGluamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHV0ZXMgdGhlIGFtb3VudCBvZiAoZW5kKSBvcGVuIG5vZGVzIGF0IHRoZSBlbmQgb2YgdGhlXG4gICAgICAgIC8vIGZyYWdtZW50LiBXaGVuIDAsIHRoZSBwYXJlbnQgaXMgb3BlbiwgYnV0IG5vIG1vcmUuIFdoZW5cbiAgICAgICAgLy8gbmVnYXRpdmUsIG5vdGhpbmcgaXMgb3Blbi5cbiAgICAgICAgbGV0IG9wZW5FbmRDb3VudCA9IChmcmFnbWVudC5zaXplICsgc2xpY2VEZXB0aCkgLSAoc2xpY2UuY29udGVudC5zaXplIC0gc2xpY2Uub3BlbkVuZCk7XG4gICAgICAgIC8vIFNjYW4gb3ZlciB0aGUgZnJhZ21lbnQsIGZpdHRpbmcgYXMgbWFueSBjaGlsZCBub2RlcyBhc1xuICAgICAgICAvLyBwb3NzaWJsZS5cbiAgICAgICAgd2hpbGUgKHRha2VuIDwgZnJhZ21lbnQuY2hpbGRDb3VudCkge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBmcmFnbWVudC5jaGlsZCh0YWtlbiksIG1hdGNoZXMgPSBtYXRjaC5tYXRjaFR5cGUobmV4dC50eXBlKTtcbiAgICAgICAgICAgIGlmICghbWF0Y2hlcylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHRha2VuKys7XG4gICAgICAgICAgICBpZiAodGFrZW4gPiAxIHx8IG9wZW5TdGFydCA9PSAwIHx8IG5leHQuY29udGVudC5zaXplKSB7IC8vIERyb3AgZW1wdHkgb3BlbiBub2Rlc1xuICAgICAgICAgICAgICAgIG1hdGNoID0gbWF0Y2hlcztcbiAgICAgICAgICAgICAgICBhZGQucHVzaChjbG9zZU5vZGVTdGFydChuZXh0Lm1hcmsodHlwZS5hbGxvd2VkTWFya3MobmV4dC5tYXJrcykpLCB0YWtlbiA9PSAxID8gb3BlblN0YXJ0IDogMCwgdGFrZW4gPT0gZnJhZ21lbnQuY2hpbGRDb3VudCA/IG9wZW5FbmRDb3VudCA6IC0xKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRvRW5kID0gdGFrZW4gPT0gZnJhZ21lbnQuY2hpbGRDb3VudDtcbiAgICAgICAgaWYgKCF0b0VuZClcbiAgICAgICAgICAgIG9wZW5FbmRDb3VudCA9IC0xO1xuICAgICAgICB0aGlzLnBsYWNlZCA9IGFkZFRvRnJhZ21lbnQodGhpcy5wbGFjZWQsIGZyb250aWVyRGVwdGgsIEZyYWdtZW50LmZyb20oYWRkKSk7XG4gICAgICAgIHRoaXMuZnJvbnRpZXJbZnJvbnRpZXJEZXB0aF0ubWF0Y2ggPSBtYXRjaDtcbiAgICAgICAgLy8gSWYgdGhlIHBhcmVudCB0eXBlcyBtYXRjaCwgYW5kIHRoZSBlbnRpcmUgbm9kZSB3YXMgbW92ZWQsIGFuZFxuICAgICAgICAvLyBpdCdzIG5vdCBvcGVuLCBjbG9zZSB0aGlzIGZyb250aWVyIG5vZGUgcmlnaHQgYXdheS5cbiAgICAgICAgaWYgKHRvRW5kICYmIG9wZW5FbmRDb3VudCA8IDAgJiYgcGFyZW50ICYmIHBhcmVudC50eXBlID09IHRoaXMuZnJvbnRpZXJbdGhpcy5kZXB0aF0udHlwZSAmJiB0aGlzLmZyb250aWVyLmxlbmd0aCA+IDEpXG4gICAgICAgICAgICB0aGlzLmNsb3NlRnJvbnRpZXJOb2RlKCk7XG4gICAgICAgIC8vIEFkZCBuZXcgZnJvbnRpZXIgbm9kZXMgZm9yIGFueSBvcGVuIG5vZGVzIGF0IHRoZSBlbmQuXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBjdXIgPSBmcmFnbWVudDsgaSA8IG9wZW5FbmRDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbm9kZSA9IGN1ci5sYXN0Q2hpbGQ7XG4gICAgICAgICAgICB0aGlzLmZyb250aWVyLnB1c2goeyB0eXBlOiBub2RlLnR5cGUsIG1hdGNoOiBub2RlLmNvbnRlbnRNYXRjaEF0KG5vZGUuY2hpbGRDb3VudCkgfSk7XG4gICAgICAgICAgICBjdXIgPSBub2RlLmNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIGB0aGlzLnVucGxhY2VkYC4gRHJvcCB0aGUgZW50aXJlIG5vZGUgZnJvbSB3aGljaCB3ZVxuICAgICAgICAvLyBwbGFjZWQgaXQgd2UgZ290IHRvIGl0cyBlbmQsIG90aGVyd2lzZSBqdXN0IGRyb3AgdGhlIHBsYWNlZFxuICAgICAgICAvLyBub2Rlcy5cbiAgICAgICAgdGhpcy51bnBsYWNlZCA9ICF0b0VuZCA/IG5ldyBTbGljZShkcm9wRnJvbUZyYWdtZW50KHNsaWNlLmNvbnRlbnQsIHNsaWNlRGVwdGgsIHRha2VuKSwgc2xpY2Uub3BlblN0YXJ0LCBzbGljZS5vcGVuRW5kKVxuICAgICAgICAgICAgOiBzbGljZURlcHRoID09IDAgPyBTbGljZS5lbXB0eVxuICAgICAgICAgICAgICAgIDogbmV3IFNsaWNlKGRyb3BGcm9tRnJhZ21lbnQoc2xpY2UuY29udGVudCwgc2xpY2VEZXB0aCAtIDEsIDEpLCBzbGljZURlcHRoIC0gMSwgb3BlbkVuZENvdW50IDwgMCA/IHNsaWNlLm9wZW5FbmQgOiBzbGljZURlcHRoIC0gMSk7XG4gICAgfVxuICAgIG11c3RNb3ZlSW5saW5lKCkge1xuICAgICAgICBpZiAoIXRoaXMuJHRvLnBhcmVudC5pc1RleHRibG9jaylcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgbGV0IHRvcCA9IHRoaXMuZnJvbnRpZXJbdGhpcy5kZXB0aF0sIGxldmVsO1xuICAgICAgICBpZiAoIXRvcC50eXBlLmlzVGV4dGJsb2NrIHx8ICFjb250ZW50QWZ0ZXJGaXRzKHRoaXMuJHRvLCB0aGlzLiR0by5kZXB0aCwgdG9wLnR5cGUsIHRvcC5tYXRjaCwgZmFsc2UpIHx8XG4gICAgICAgICAgICAodGhpcy4kdG8uZGVwdGggPT0gdGhpcy5kZXB0aCAmJiAobGV2ZWwgPSB0aGlzLmZpbmRDbG9zZUxldmVsKHRoaXMuJHRvKSkgJiYgbGV2ZWwuZGVwdGggPT0gdGhpcy5kZXB0aCkpXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIGxldCB7IGRlcHRoIH0gPSB0aGlzLiR0bywgYWZ0ZXIgPSB0aGlzLiR0by5hZnRlcihkZXB0aCk7XG4gICAgICAgIHdoaWxlIChkZXB0aCA+IDEgJiYgYWZ0ZXIgPT0gdGhpcy4kdG8uZW5kKC0tZGVwdGgpKVxuICAgICAgICAgICAgKythZnRlcjtcbiAgICAgICAgcmV0dXJuIGFmdGVyO1xuICAgIH1cbiAgICBmaW5kQ2xvc2VMZXZlbCgkdG8pIHtcbiAgICAgICAgc2NhbjogZm9yIChsZXQgaSA9IE1hdGgubWluKHRoaXMuZGVwdGgsICR0by5kZXB0aCk7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgeyBtYXRjaCwgdHlwZSB9ID0gdGhpcy5mcm9udGllcltpXTtcbiAgICAgICAgICAgIGxldCBkcm9wSW5uZXIgPSBpIDwgJHRvLmRlcHRoICYmICR0by5lbmQoaSArIDEpID09ICR0by5wb3MgKyAoJHRvLmRlcHRoIC0gKGkgKyAxKSk7XG4gICAgICAgICAgICBsZXQgZml0ID0gY29udGVudEFmdGVyRml0cygkdG8sIGksIHR5cGUsIG1hdGNoLCBkcm9wSW5uZXIpO1xuICAgICAgICAgICAgaWYgKCFmaXQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBmb3IgKGxldCBkID0gaSAtIDE7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgbWF0Y2gsIHR5cGUgfSA9IHRoaXMuZnJvbnRpZXJbZF07XG4gICAgICAgICAgICAgICAgbGV0IG1hdGNoZXMgPSBjb250ZW50QWZ0ZXJGaXRzKCR0bywgZCwgdHlwZSwgbWF0Y2gsIHRydWUpO1xuICAgICAgICAgICAgICAgIGlmICghbWF0Y2hlcyB8fCBtYXRjaGVzLmNoaWxkQ291bnQpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHNjYW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBkZXB0aDogaSwgZml0LCBtb3ZlOiBkcm9wSW5uZXIgPyAkdG8uZG9jLnJlc29sdmUoJHRvLmFmdGVyKGkgKyAxKSkgOiAkdG8gfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbG9zZSgkdG8pIHtcbiAgICAgICAgbGV0IGNsb3NlID0gdGhpcy5maW5kQ2xvc2VMZXZlbCgkdG8pO1xuICAgICAgICBpZiAoIWNsb3NlKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHdoaWxlICh0aGlzLmRlcHRoID4gY2xvc2UuZGVwdGgpXG4gICAgICAgICAgICB0aGlzLmNsb3NlRnJvbnRpZXJOb2RlKCk7XG4gICAgICAgIGlmIChjbG9zZS5maXQuY2hpbGRDb3VudClcbiAgICAgICAgICAgIHRoaXMucGxhY2VkID0gYWRkVG9GcmFnbWVudCh0aGlzLnBsYWNlZCwgY2xvc2UuZGVwdGgsIGNsb3NlLmZpdCk7XG4gICAgICAgICR0byA9IGNsb3NlLm1vdmU7XG4gICAgICAgIGZvciAobGV0IGQgPSBjbG9zZS5kZXB0aCArIDE7IGQgPD0gJHRvLmRlcHRoOyBkKyspIHtcbiAgICAgICAgICAgIGxldCBub2RlID0gJHRvLm5vZGUoZCksIGFkZCA9IG5vZGUudHlwZS5jb250ZW50TWF0Y2guZmlsbEJlZm9yZShub2RlLmNvbnRlbnQsIHRydWUsICR0by5pbmRleChkKSk7XG4gICAgICAgICAgICB0aGlzLm9wZW5Gcm9udGllck5vZGUobm9kZS50eXBlLCBub2RlLmF0dHJzLCBhZGQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAkdG87XG4gICAgfVxuICAgIG9wZW5Gcm9udGllck5vZGUodHlwZSwgYXR0cnMgPSBudWxsLCBjb250ZW50KSB7XG4gICAgICAgIGxldCB0b3AgPSB0aGlzLmZyb250aWVyW3RoaXMuZGVwdGhdO1xuICAgICAgICB0b3AubWF0Y2ggPSB0b3AubWF0Y2gubWF0Y2hUeXBlKHR5cGUpO1xuICAgICAgICB0aGlzLnBsYWNlZCA9IGFkZFRvRnJhZ21lbnQodGhpcy5wbGFjZWQsIHRoaXMuZGVwdGgsIEZyYWdtZW50LmZyb20odHlwZS5jcmVhdGUoYXR0cnMsIGNvbnRlbnQpKSk7XG4gICAgICAgIHRoaXMuZnJvbnRpZXIucHVzaCh7IHR5cGUsIG1hdGNoOiB0eXBlLmNvbnRlbnRNYXRjaCB9KTtcbiAgICB9XG4gICAgY2xvc2VGcm9udGllck5vZGUoKSB7XG4gICAgICAgIGxldCBvcGVuID0gdGhpcy5mcm9udGllci5wb3AoKTtcbiAgICAgICAgbGV0IGFkZCA9IG9wZW4ubWF0Y2guZmlsbEJlZm9yZShGcmFnbWVudC5lbXB0eSwgdHJ1ZSk7XG4gICAgICAgIGlmIChhZGQuY2hpbGRDb3VudClcbiAgICAgICAgICAgIHRoaXMucGxhY2VkID0gYWRkVG9GcmFnbWVudCh0aGlzLnBsYWNlZCwgdGhpcy5mcm9udGllci5sZW5ndGgsIGFkZCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZHJvcEZyb21GcmFnbWVudChmcmFnbWVudCwgZGVwdGgsIGNvdW50KSB7XG4gICAgaWYgKGRlcHRoID09IDApXG4gICAgICAgIHJldHVybiBmcmFnbWVudC5jdXRCeUluZGV4KGNvdW50LCBmcmFnbWVudC5jaGlsZENvdW50KTtcbiAgICByZXR1cm4gZnJhZ21lbnQucmVwbGFjZUNoaWxkKDAsIGZyYWdtZW50LmZpcnN0Q2hpbGQuY29weShkcm9wRnJvbUZyYWdtZW50KGZyYWdtZW50LmZpcnN0Q2hpbGQuY29udGVudCwgZGVwdGggLSAxLCBjb3VudCkpKTtcbn1cbmZ1bmN0aW9uIGFkZFRvRnJhZ21lbnQoZnJhZ21lbnQsIGRlcHRoLCBjb250ZW50KSB7XG4gICAgaWYgKGRlcHRoID09IDApXG4gICAgICAgIHJldHVybiBmcmFnbWVudC5hcHBlbmQoY29udGVudCk7XG4gICAgcmV0dXJuIGZyYWdtZW50LnJlcGxhY2VDaGlsZChmcmFnbWVudC5jaGlsZENvdW50IC0gMSwgZnJhZ21lbnQubGFzdENoaWxkLmNvcHkoYWRkVG9GcmFnbWVudChmcmFnbWVudC5sYXN0Q2hpbGQuY29udGVudCwgZGVwdGggLSAxLCBjb250ZW50KSkpO1xufVxuZnVuY3Rpb24gY29udGVudEF0KGZyYWdtZW50LCBkZXB0aCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVwdGg7IGkrKylcbiAgICAgICAgZnJhZ21lbnQgPSBmcmFnbWVudC5maXJzdENoaWxkLmNvbnRlbnQ7XG4gICAgcmV0dXJuIGZyYWdtZW50O1xufVxuZnVuY3Rpb24gY2xvc2VOb2RlU3RhcnQobm9kZSwgb3BlblN0YXJ0LCBvcGVuRW5kKSB7XG4gICAgaWYgKG9wZW5TdGFydCA8PSAwKVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICBsZXQgZnJhZyA9IG5vZGUuY29udGVudDtcbiAgICBpZiAob3BlblN0YXJ0ID4gMSlcbiAgICAgICAgZnJhZyA9IGZyYWcucmVwbGFjZUNoaWxkKDAsIGNsb3NlTm9kZVN0YXJ0KGZyYWcuZmlyc3RDaGlsZCwgb3BlblN0YXJ0IC0gMSwgZnJhZy5jaGlsZENvdW50ID09IDEgPyBvcGVuRW5kIC0gMSA6IDApKTtcbiAgICBpZiAob3BlblN0YXJ0ID4gMCkge1xuICAgICAgICBmcmFnID0gbm9kZS50eXBlLmNvbnRlbnRNYXRjaC5maWxsQmVmb3JlKGZyYWcpLmFwcGVuZChmcmFnKTtcbiAgICAgICAgaWYgKG9wZW5FbmQgPD0gMClcbiAgICAgICAgICAgIGZyYWcgPSBmcmFnLmFwcGVuZChub2RlLnR5cGUuY29udGVudE1hdGNoLm1hdGNoRnJhZ21lbnQoZnJhZykuZmlsbEJlZm9yZShGcmFnbWVudC5lbXB0eSwgdHJ1ZSkpO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZS5jb3B5KGZyYWcpO1xufVxuZnVuY3Rpb24gY29udGVudEFmdGVyRml0cygkdG8sIGRlcHRoLCB0eXBlLCBtYXRjaCwgb3Blbikge1xuICAgIGxldCBub2RlID0gJHRvLm5vZGUoZGVwdGgpLCBpbmRleCA9IG9wZW4gPyAkdG8uaW5kZXhBZnRlcihkZXB0aCkgOiAkdG8uaW5kZXgoZGVwdGgpO1xuICAgIGlmIChpbmRleCA9PSBub2RlLmNoaWxkQ291bnQgJiYgIXR5cGUuY29tcGF0aWJsZUNvbnRlbnQobm9kZS50eXBlKSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IGZpdCA9IG1hdGNoLmZpbGxCZWZvcmUobm9kZS5jb250ZW50LCB0cnVlLCBpbmRleCk7XG4gICAgcmV0dXJuIGZpdCAmJiAhaW52YWxpZE1hcmtzKHR5cGUsIG5vZGUuY29udGVudCwgaW5kZXgpID8gZml0IDogbnVsbDtcbn1cbmZ1bmN0aW9uIGludmFsaWRNYXJrcyh0eXBlLCBmcmFnbWVudCwgc3RhcnQpIHtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBmcmFnbWVudC5jaGlsZENvdW50OyBpKyspXG4gICAgICAgIGlmICghdHlwZS5hbGxvd3NNYXJrcyhmcmFnbWVudC5jaGlsZChpKS5tYXJrcykpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBkZWZpbmVzQ29udGVudCh0eXBlKSB7XG4gICAgcmV0dXJuIHR5cGUuc3BlYy5kZWZpbmluZyB8fCB0eXBlLnNwZWMuZGVmaW5pbmdGb3JDb250ZW50O1xufVxuZnVuY3Rpb24gcmVwbGFjZVJhbmdlKHRyLCBmcm9tLCB0bywgc2xpY2UpIHtcbiAgICBpZiAoIXNsaWNlLnNpemUpXG4gICAgICAgIHJldHVybiB0ci5kZWxldGVSYW5nZShmcm9tLCB0byk7XG4gICAgbGV0ICRmcm9tID0gdHIuZG9jLnJlc29sdmUoZnJvbSksICR0byA9IHRyLmRvYy5yZXNvbHZlKHRvKTtcbiAgICBpZiAoZml0c1RyaXZpYWxseSgkZnJvbSwgJHRvLCBzbGljZSkpXG4gICAgICAgIHJldHVybiB0ci5zdGVwKG5ldyBSZXBsYWNlU3RlcChmcm9tLCB0bywgc2xpY2UpKTtcbiAgICBsZXQgdGFyZ2V0RGVwdGhzID0gY292ZXJlZERlcHRocygkZnJvbSwgdHIuZG9jLnJlc29sdmUodG8pKTtcbiAgICAvLyBDYW4ndCByZXBsYWNlIHRoZSB3aG9sZSBkb2N1bWVudCwgc28gcmVtb3ZlIDAgaWYgaXQncyBwcmVzZW50XG4gICAgaWYgKHRhcmdldERlcHRoc1t0YXJnZXREZXB0aHMubGVuZ3RoIC0gMV0gPT0gMClcbiAgICAgICAgdGFyZ2V0RGVwdGhzLnBvcCgpO1xuICAgIC8vIE5lZ2F0aXZlIG51bWJlcnMgcmVwcmVzZW50IG5vdCBleHBhbnNpb24gb3ZlciB0aGUgd2hvbGUgbm9kZSBhdFxuICAgIC8vIHRoYXQgZGVwdGgsIGJ1dCByZXBsYWNpbmcgZnJvbSAkZnJvbS5iZWZvcmUoLUQpIHRvICR0by5wb3MuXG4gICAgbGV0IHByZWZlcnJlZFRhcmdldCA9IC0oJGZyb20uZGVwdGggKyAxKTtcbiAgICB0YXJnZXREZXB0aHMudW5zaGlmdChwcmVmZXJyZWRUYXJnZXQpO1xuICAgIC8vIFRoaXMgbG9vcCBwaWNrcyBhIHByZWZlcnJlZCB0YXJnZXQgZGVwdGgsIGlmIG9uZSBvZiB0aGUgY292ZXJpbmdcbiAgICAvLyBkZXB0aHMgaXMgbm90IG91dHNpZGUgb2YgYSBkZWZpbmluZyBub2RlLCBhbmQgYWRkcyBuZWdhdGl2ZVxuICAgIC8vIGRlcHRocyBmb3IgYW55IGRlcHRoIHRoYXQgaGFzICRmcm9tIGF0IGl0cyBzdGFydCBhbmQgZG9lcyBub3RcbiAgICAvLyBjcm9zcyBhIGRlZmluaW5nIG5vZGUuXG4gICAgZm9yIChsZXQgZCA9ICRmcm9tLmRlcHRoLCBwb3MgPSAkZnJvbS5wb3MgLSAxOyBkID4gMDsgZC0tLCBwb3MtLSkge1xuICAgICAgICBsZXQgc3BlYyA9ICRmcm9tLm5vZGUoZCkudHlwZS5zcGVjO1xuICAgICAgICBpZiAoc3BlYy5kZWZpbmluZyB8fCBzcGVjLmRlZmluaW5nQXNDb250ZXh0IHx8IHNwZWMuaXNvbGF0aW5nKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmICh0YXJnZXREZXB0aHMuaW5kZXhPZihkKSA+IC0xKVxuICAgICAgICAgICAgcHJlZmVycmVkVGFyZ2V0ID0gZDtcbiAgICAgICAgZWxzZSBpZiAoJGZyb20uYmVmb3JlKGQpID09IHBvcylcbiAgICAgICAgICAgIHRhcmdldERlcHRocy5zcGxpY2UoMSwgMCwgLWQpO1xuICAgIH1cbiAgICAvLyBUcnkgdG8gZml0IGVhY2ggcG9zc2libGUgZGVwdGggb2YgdGhlIHNsaWNlIGludG8gZWFjaCBwb3NzaWJsZVxuICAgIC8vIHRhcmdldCBkZXB0aCwgc3RhcnRpbmcgd2l0aCB0aGUgcHJlZmVycmVkIGRlcHRocy5cbiAgICBsZXQgcHJlZmVycmVkVGFyZ2V0SW5kZXggPSB0YXJnZXREZXB0aHMuaW5kZXhPZihwcmVmZXJyZWRUYXJnZXQpO1xuICAgIGxldCBsZWZ0Tm9kZXMgPSBbXSwgcHJlZmVycmVkRGVwdGggPSBzbGljZS5vcGVuU3RhcnQ7XG4gICAgZm9yIChsZXQgY29udGVudCA9IHNsaWNlLmNvbnRlbnQsIGkgPSAwOzsgaSsrKSB7XG4gICAgICAgIGxldCBub2RlID0gY29udGVudC5maXJzdENoaWxkO1xuICAgICAgICBsZWZ0Tm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgaWYgKGkgPT0gc2xpY2Uub3BlblN0YXJ0KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNvbnRlbnQgPSBub2RlLmNvbnRlbnQ7XG4gICAgfVxuICAgIC8vIEJhY2sgdXAgcHJlZmVycmVkRGVwdGggdG8gY292ZXIgZGVmaW5pbmcgdGV4dGJsb2NrcyBkaXJlY3RseVxuICAgIC8vIGFib3ZlIGl0LCBwb3NzaWJseSBza2lwcGluZyBhIG5vbi1kZWZpbmluZyB0ZXh0YmxvY2suXG4gICAgZm9yIChsZXQgZCA9IHByZWZlcnJlZERlcHRoIC0gMTsgZCA+PSAwOyBkLS0pIHtcbiAgICAgICAgbGV0IGxlZnROb2RlID0gbGVmdE5vZGVzW2RdLCBkZWYgPSBkZWZpbmVzQ29udGVudChsZWZ0Tm9kZS50eXBlKTtcbiAgICAgICAgaWYgKGRlZiAmJiAhbGVmdE5vZGUuc2FtZU1hcmt1cCgkZnJvbS5ub2RlKE1hdGguYWJzKHByZWZlcnJlZFRhcmdldCkgLSAxKSkpXG4gICAgICAgICAgICBwcmVmZXJyZWREZXB0aCA9IGQ7XG4gICAgICAgIGVsc2UgaWYgKGRlZiB8fCAhbGVmdE5vZGUudHlwZS5pc1RleHRibG9jaylcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBmb3IgKGxldCBqID0gc2xpY2Uub3BlblN0YXJ0OyBqID49IDA7IGotLSkge1xuICAgICAgICBsZXQgb3BlbkRlcHRoID0gKGogKyBwcmVmZXJyZWREZXB0aCArIDEpICUgKHNsaWNlLm9wZW5TdGFydCArIDEpO1xuICAgICAgICBsZXQgaW5zZXJ0ID0gbGVmdE5vZGVzW29wZW5EZXB0aF07XG4gICAgICAgIGlmICghaW5zZXJ0KVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFyZ2V0RGVwdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBMb29wIG92ZXIgcG9zc2libGUgZXhwYW5zaW9uIGxldmVscywgc3RhcnRpbmcgd2l0aCB0aGVcbiAgICAgICAgICAgIC8vIHByZWZlcnJlZCBvbmVcbiAgICAgICAgICAgIGxldCB0YXJnZXREZXB0aCA9IHRhcmdldERlcHRoc1soaSArIHByZWZlcnJlZFRhcmdldEluZGV4KSAlIHRhcmdldERlcHRocy5sZW5ndGhdLCBleHBhbmQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRhcmdldERlcHRoIDwgMCkge1xuICAgICAgICAgICAgICAgIGV4cGFuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRhcmdldERlcHRoID0gLXRhcmdldERlcHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHBhcmVudCA9ICRmcm9tLm5vZGUodGFyZ2V0RGVwdGggLSAxKSwgaW5kZXggPSAkZnJvbS5pbmRleCh0YXJnZXREZXB0aCAtIDEpO1xuICAgICAgICAgICAgaWYgKHBhcmVudC5jYW5SZXBsYWNlV2l0aChpbmRleCwgaW5kZXgsIGluc2VydC50eXBlLCBpbnNlcnQubWFya3MpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0ci5yZXBsYWNlKCRmcm9tLmJlZm9yZSh0YXJnZXREZXB0aCksIGV4cGFuZCA/ICR0by5hZnRlcih0YXJnZXREZXB0aCkgOiB0bywgbmV3IFNsaWNlKGNsb3NlRnJhZ21lbnQoc2xpY2UuY29udGVudCwgMCwgc2xpY2Uub3BlblN0YXJ0LCBvcGVuRGVwdGgpLCBvcGVuRGVwdGgsIHNsaWNlLm9wZW5FbmQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgc3RhcnRTdGVwcyA9IHRyLnN0ZXBzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gdGFyZ2V0RGVwdGhzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHRyLnJlcGxhY2UoZnJvbSwgdG8sIHNsaWNlKTtcbiAgICAgICAgaWYgKHRyLnN0ZXBzLmxlbmd0aCA+IHN0YXJ0U3RlcHMpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgbGV0IGRlcHRoID0gdGFyZ2V0RGVwdGhzW2ldO1xuICAgICAgICBpZiAoZGVwdGggPCAwKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGZyb20gPSAkZnJvbS5iZWZvcmUoZGVwdGgpO1xuICAgICAgICB0byA9ICR0by5hZnRlcihkZXB0aCk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2xvc2VGcmFnbWVudChmcmFnbWVudCwgZGVwdGgsIG9sZE9wZW4sIG5ld09wZW4sIHBhcmVudCkge1xuICAgIGlmIChkZXB0aCA8IG9sZE9wZW4pIHtcbiAgICAgICAgbGV0IGZpcnN0ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgZnJhZ21lbnQgPSBmcmFnbWVudC5yZXBsYWNlQ2hpbGQoMCwgZmlyc3QuY29weShjbG9zZUZyYWdtZW50KGZpcnN0LmNvbnRlbnQsIGRlcHRoICsgMSwgb2xkT3BlbiwgbmV3T3BlbiwgZmlyc3QpKSk7XG4gICAgfVxuICAgIGlmIChkZXB0aCA+IG5ld09wZW4pIHtcbiAgICAgICAgbGV0IG1hdGNoID0gcGFyZW50LmNvbnRlbnRNYXRjaEF0KDApO1xuICAgICAgICBsZXQgc3RhcnQgPSBtYXRjaC5maWxsQmVmb3JlKGZyYWdtZW50KS5hcHBlbmQoZnJhZ21lbnQpO1xuICAgICAgICBmcmFnbWVudCA9IHN0YXJ0LmFwcGVuZChtYXRjaC5tYXRjaEZyYWdtZW50KHN0YXJ0KS5maWxsQmVmb3JlKEZyYWdtZW50LmVtcHR5LCB0cnVlKSk7XG4gICAgfVxuICAgIHJldHVybiBmcmFnbWVudDtcbn1cbmZ1bmN0aW9uIHJlcGxhY2VSYW5nZVdpdGgodHIsIGZyb20sIHRvLCBub2RlKSB7XG4gICAgaWYgKCFub2RlLmlzSW5saW5lICYmIGZyb20gPT0gdG8gJiYgdHIuZG9jLnJlc29sdmUoZnJvbSkucGFyZW50LmNvbnRlbnQuc2l6ZSkge1xuICAgICAgICBsZXQgcG9pbnQgPSBpbnNlcnRQb2ludCh0ci5kb2MsIGZyb20sIG5vZGUudHlwZSk7XG4gICAgICAgIGlmIChwb2ludCAhPSBudWxsKVxuICAgICAgICAgICAgZnJvbSA9IHRvID0gcG9pbnQ7XG4gICAgfVxuICAgIHRyLnJlcGxhY2VSYW5nZShmcm9tLCB0bywgbmV3IFNsaWNlKEZyYWdtZW50LmZyb20obm9kZSksIDAsIDApKTtcbn1cbmZ1bmN0aW9uIGRlbGV0ZVJhbmdlKHRyLCBmcm9tLCB0bykge1xuICAgIGxldCAkZnJvbSA9IHRyLmRvYy5yZXNvbHZlKGZyb20pLCAkdG8gPSB0ci5kb2MucmVzb2x2ZSh0byk7XG4gICAgbGV0IGNvdmVyZWQgPSBjb3ZlcmVkRGVwdGhzKCRmcm9tLCAkdG8pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY292ZXJlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgZGVwdGggPSBjb3ZlcmVkW2ldLCBsYXN0ID0gaSA9PSBjb3ZlcmVkLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmICgobGFzdCAmJiBkZXB0aCA9PSAwKSB8fCAkZnJvbS5ub2RlKGRlcHRoKS50eXBlLmNvbnRlbnRNYXRjaC52YWxpZEVuZClcbiAgICAgICAgICAgIHJldHVybiB0ci5kZWxldGUoJGZyb20uc3RhcnQoZGVwdGgpLCAkdG8uZW5kKGRlcHRoKSk7XG4gICAgICAgIGlmIChkZXB0aCA+IDAgJiYgKGxhc3QgfHwgJGZyb20ubm9kZShkZXB0aCAtIDEpLmNhblJlcGxhY2UoJGZyb20uaW5kZXgoZGVwdGggLSAxKSwgJHRvLmluZGV4QWZ0ZXIoZGVwdGggLSAxKSkpKVxuICAgICAgICAgICAgcmV0dXJuIHRyLmRlbGV0ZSgkZnJvbS5iZWZvcmUoZGVwdGgpLCAkdG8uYWZ0ZXIoZGVwdGgpKTtcbiAgICB9XG4gICAgZm9yIChsZXQgZCA9IDE7IGQgPD0gJGZyb20uZGVwdGggJiYgZCA8PSAkdG8uZGVwdGg7IGQrKykge1xuICAgICAgICBpZiAoZnJvbSAtICRmcm9tLnN0YXJ0KGQpID09ICRmcm9tLmRlcHRoIC0gZCAmJiB0byA+ICRmcm9tLmVuZChkKSAmJiAkdG8uZW5kKGQpIC0gdG8gIT0gJHRvLmRlcHRoIC0gZCAmJlxuICAgICAgICAgICAgJGZyb20uc3RhcnQoZCAtIDEpID09ICR0by5zdGFydChkIC0gMSkgJiYgJGZyb20ubm9kZShkIC0gMSkuY2FuUmVwbGFjZSgkZnJvbS5pbmRleChkIC0gMSksICR0by5pbmRleChkIC0gMSkpKVxuICAgICAgICAgICAgcmV0dXJuIHRyLmRlbGV0ZSgkZnJvbS5iZWZvcmUoZCksIHRvKTtcbiAgICB9XG4gICAgdHIuZGVsZXRlKGZyb20sIHRvKTtcbn1cbi8vIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIGRlcHRocyBmb3Igd2hpY2ggJGZyb20gLSAkdG8gc3BhbnMgdGhlXG4vLyB3aG9sZSBjb250ZW50IG9mIHRoZSBub2RlcyBhdCB0aGF0IGRlcHRoLlxuZnVuY3Rpb24gY292ZXJlZERlcHRocygkZnJvbSwgJHRvKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdLCBtaW5EZXB0aCA9IE1hdGgubWluKCRmcm9tLmRlcHRoLCAkdG8uZGVwdGgpO1xuICAgIGZvciAobGV0IGQgPSBtaW5EZXB0aDsgZCA+PSAwOyBkLS0pIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gJGZyb20uc3RhcnQoZCk7XG4gICAgICAgIGlmIChzdGFydCA8ICRmcm9tLnBvcyAtICgkZnJvbS5kZXB0aCAtIGQpIHx8XG4gICAgICAgICAgICAkdG8uZW5kKGQpID4gJHRvLnBvcyArICgkdG8uZGVwdGggLSBkKSB8fFxuICAgICAgICAgICAgJGZyb20ubm9kZShkKS50eXBlLnNwZWMuaXNvbGF0aW5nIHx8XG4gICAgICAgICAgICAkdG8ubm9kZShkKS50eXBlLnNwZWMuaXNvbGF0aW5nKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChzdGFydCA9PSAkdG8uc3RhcnQoZCkgfHxcbiAgICAgICAgICAgIChkID09ICRmcm9tLmRlcHRoICYmIGQgPT0gJHRvLmRlcHRoICYmICRmcm9tLnBhcmVudC5pbmxpbmVDb250ZW50ICYmICR0by5wYXJlbnQuaW5saW5lQ29udGVudCAmJlxuICAgICAgICAgICAgICAgIGQgJiYgJHRvLnN0YXJ0KGQgLSAxKSA9PSBzdGFydCAtIDEpKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuVXBkYXRlIGFuIGF0dHJpYnV0ZSBpbiBhIHNwZWNpZmljIG5vZGUuXG4qL1xuY2xhc3MgQXR0clN0ZXAgZXh0ZW5kcyBTdGVwIHtcbiAgICAvKipcbiAgICBDb25zdHJ1Y3QgYW4gYXR0cmlidXRlIHN0ZXAuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgcG9zaXRpb24gb2YgdGhlIHRhcmdldCBub2RlLlxuICAgICovXG4gICAgcG9zLCBcbiAgICAvKipcbiAgICBUaGUgYXR0cmlidXRlIHRvIHNldC5cbiAgICAqL1xuICAgIGF0dHIsIFxuICAgIC8vIFRoZSBhdHRyaWJ1dGUncyBuZXcgdmFsdWUuXG4gICAgdmFsdWUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMuYXR0ciA9IGF0dHI7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgYXBwbHkoZG9jKSB7XG4gICAgICAgIGxldCBub2RlID0gZG9jLm5vZGVBdCh0aGlzLnBvcyk7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZhaWwoXCJObyBub2RlIGF0IGF0dHJpYnV0ZSBzdGVwJ3MgcG9zaXRpb25cIik7XG4gICAgICAgIGxldCBhdHRycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gbm9kZS5hdHRycylcbiAgICAgICAgICAgIGF0dHJzW25hbWVdID0gbm9kZS5hdHRyc1tuYW1lXTtcbiAgICAgICAgYXR0cnNbdGhpcy5hdHRyXSA9IHRoaXMudmFsdWU7XG4gICAgICAgIGxldCB1cGRhdGVkID0gbm9kZS50eXBlLmNyZWF0ZShhdHRycywgbnVsbCwgbm9kZS5tYXJrcyk7XG4gICAgICAgIHJldHVybiBTdGVwUmVzdWx0LmZyb21SZXBsYWNlKGRvYywgdGhpcy5wb3MsIHRoaXMucG9zICsgMSwgbmV3IFNsaWNlKEZyYWdtZW50LmZyb20odXBkYXRlZCksIDAsIG5vZGUuaXNMZWFmID8gMCA6IDEpKTtcbiAgICB9XG4gICAgZ2V0TWFwKCkge1xuICAgICAgICByZXR1cm4gU3RlcE1hcC5lbXB0eTtcbiAgICB9XG4gICAgaW52ZXJ0KGRvYykge1xuICAgICAgICByZXR1cm4gbmV3IEF0dHJTdGVwKHRoaXMucG9zLCB0aGlzLmF0dHIsIGRvYy5ub2RlQXQodGhpcy5wb3MpLmF0dHJzW3RoaXMuYXR0cl0pO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICBsZXQgcG9zID0gbWFwcGluZy5tYXBSZXN1bHQodGhpcy5wb3MsIDEpO1xuICAgICAgICByZXR1cm4gcG9zLmRlbGV0ZWRBZnRlciA/IG51bGwgOiBuZXcgQXR0clN0ZXAocG9zLnBvcywgdGhpcy5hdHRyLCB0aGlzLnZhbHVlKTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyBzdGVwVHlwZTogXCJhdHRyXCIsIHBvczogdGhpcy5wb3MsIGF0dHI6IHRoaXMuYXR0ciwgdmFsdWU6IHRoaXMudmFsdWUgfTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24ucG9zICE9IFwibnVtYmVyXCIgfHwgdHlwZW9mIGpzb24uYXR0ciAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBBdHRyU3RlcC5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBdHRyU3RlcChqc29uLnBvcywganNvbi5hdHRyLCBqc29uLnZhbHVlKTtcbiAgICB9XG59XG5TdGVwLmpzb25JRChcImF0dHJcIiwgQXR0clN0ZXApO1xuLyoqXG5VcGRhdGUgYW4gYXR0cmlidXRlIGluIHRoZSBkb2Mgbm9kZS5cbiovXG5jbGFzcyBEb2NBdHRyU3RlcCBleHRlbmRzIFN0ZXAge1xuICAgIC8qKlxuICAgIENvbnN0cnVjdCBhbiBhdHRyaWJ1dGUgc3RlcC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBhdHRyaWJ1dGUgdG8gc2V0LlxuICAgICovXG4gICAgYXR0ciwgXG4gICAgLy8gVGhlIGF0dHJpYnV0ZSdzIG5ldyB2YWx1ZS5cbiAgICB2YWx1ZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmF0dHIgPSBhdHRyO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGFwcGx5KGRvYykge1xuICAgICAgICBsZXQgYXR0cnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBmb3IgKGxldCBuYW1lIGluIGRvYy5hdHRycylcbiAgICAgICAgICAgIGF0dHJzW25hbWVdID0gZG9jLmF0dHJzW25hbWVdO1xuICAgICAgICBhdHRyc1t0aGlzLmF0dHJdID0gdGhpcy52YWx1ZTtcbiAgICAgICAgbGV0IHVwZGF0ZWQgPSBkb2MudHlwZS5jcmVhdGUoYXR0cnMsIGRvYy5jb250ZW50LCBkb2MubWFya3MpO1xuICAgICAgICByZXR1cm4gU3RlcFJlc3VsdC5vayh1cGRhdGVkKTtcbiAgICB9XG4gICAgZ2V0TWFwKCkge1xuICAgICAgICByZXR1cm4gU3RlcE1hcC5lbXB0eTtcbiAgICB9XG4gICAgaW52ZXJ0KGRvYykge1xuICAgICAgICByZXR1cm4gbmV3IERvY0F0dHJTdGVwKHRoaXMuYXR0ciwgZG9jLmF0dHJzW3RoaXMuYXR0cl0pO1xuICAgIH1cbiAgICBtYXAobWFwcGluZykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4geyBzdGVwVHlwZTogXCJkb2NBdHRyXCIsIGF0dHI6IHRoaXMuYXR0ciwgdmFsdWU6IHRoaXMudmFsdWUgfTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21KU09OKHNjaGVtYSwganNvbikge1xuICAgICAgICBpZiAodHlwZW9mIGpzb24uYXR0ciAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIGlucHV0IGZvciBEb2NBdHRyU3RlcC5mcm9tSlNPTlwiKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEb2NBdHRyU3RlcChqc29uLmF0dHIsIGpzb24udmFsdWUpO1xuICAgIH1cbn1cblN0ZXAuanNvbklEKFwiZG9jQXR0clwiLCBEb2NBdHRyU3RlcCk7XG5cbi8qKlxuQGludGVybmFsXG4qL1xubGV0IFRyYW5zZm9ybUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG59O1xuVHJhbnNmb3JtRXJyb3IgPSBmdW5jdGlvbiBUcmFuc2Zvcm1FcnJvcihtZXNzYWdlKSB7XG4gICAgbGV0IGVyciA9IEVycm9yLmNhbGwodGhpcywgbWVzc2FnZSk7XG4gICAgZXJyLl9fcHJvdG9fXyA9IFRyYW5zZm9ybUVycm9yLnByb3RvdHlwZTtcbiAgICByZXR1cm4gZXJyO1xufTtcblRyYW5zZm9ybUVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtcblRyYW5zZm9ybUVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFRyYW5zZm9ybUVycm9yO1xuVHJhbnNmb3JtRXJyb3IucHJvdG90eXBlLm5hbWUgPSBcIlRyYW5zZm9ybUVycm9yXCI7XG4vKipcbkFic3RyYWN0aW9uIHRvIGJ1aWxkIHVwIGFuZCB0cmFjayBhbiBhcnJheSBvZlxuW3N0ZXBzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdHJhbnNmb3JtLlN0ZXApIHJlcHJlc2VudGluZyBhIGRvY3VtZW50IHRyYW5zZm9ybWF0aW9uLlxuXG5Nb3N0IHRyYW5zZm9ybWluZyBtZXRob2RzIHJldHVybiB0aGUgYFRyYW5zZm9ybWAgb2JqZWN0IGl0c2VsZiwgc29cbnRoYXQgdGhleSBjYW4gYmUgY2hhaW5lZC5cbiovXG5jbGFzcyBUcmFuc2Zvcm0ge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHRyYW5zZm9ybSB0aGF0IHN0YXJ0cyB3aXRoIHRoZSBnaXZlbiBkb2N1bWVudC5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBjdXJyZW50IGRvY3VtZW50ICh0aGUgcmVzdWx0IG9mIGFwcGx5aW5nIHRoZSBzdGVwcyBpbiB0aGVcbiAgICB0cmFuc2Zvcm0pLlxuICAgICovXG4gICAgZG9jKSB7XG4gICAgICAgIHRoaXMuZG9jID0gZG9jO1xuICAgICAgICAvKipcbiAgICAgICAgVGhlIHN0ZXBzIGluIHRoaXMgdHJhbnNmb3JtLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0ZXBzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICBUaGUgZG9jdW1lbnRzIGJlZm9yZSBlYWNoIG9mIHRoZSBzdGVwcy5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kb2NzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICBBIG1hcHBpbmcgd2l0aCB0aGUgbWFwcyBmb3IgZWFjaCBvZiB0aGUgc3RlcHMgaW4gdGhpcyB0cmFuc2Zvcm0uXG4gICAgICAgICovXG4gICAgICAgIHRoaXMubWFwcGluZyA9IG5ldyBNYXBwaW5nO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgc3RhcnRpbmcgZG9jdW1lbnQuXG4gICAgKi9cbiAgICBnZXQgYmVmb3JlKCkgeyByZXR1cm4gdGhpcy5kb2NzLmxlbmd0aCA/IHRoaXMuZG9jc1swXSA6IHRoaXMuZG9jOyB9XG4gICAgLyoqXG4gICAgQXBwbHkgYSBuZXcgc3RlcCBpbiB0aGlzIHRyYW5zZm9ybSwgc2F2aW5nIHRoZSByZXN1bHQuIFRocm93cyBhblxuICAgIGVycm9yIHdoZW4gdGhlIHN0ZXAgZmFpbHMuXG4gICAgKi9cbiAgICBzdGVwKHN0ZXApIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMubWF5YmVTdGVwKHN0ZXApO1xuICAgICAgICBpZiAocmVzdWx0LmZhaWxlZClcbiAgICAgICAgICAgIHRocm93IG5ldyBUcmFuc2Zvcm1FcnJvcihyZXN1bHQuZmFpbGVkKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFRyeSB0byBhcHBseSBhIHN0ZXAgaW4gdGhpcyB0cmFuc2Zvcm1hdGlvbiwgaWdub3JpbmcgaXQgaWYgaXRcbiAgICBmYWlscy4gUmV0dXJucyB0aGUgc3RlcCByZXN1bHQuXG4gICAgKi9cbiAgICBtYXliZVN0ZXAoc3RlcCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gc3RlcC5hcHBseSh0aGlzLmRvYyk7XG4gICAgICAgIGlmICghcmVzdWx0LmZhaWxlZClcbiAgICAgICAgICAgIHRoaXMuYWRkU3RlcChzdGVwLCByZXN1bHQuZG9jKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoZSBkb2N1bWVudCBoYXMgYmVlbiBjaGFuZ2VkICh3aGVuIHRoZXJlIGFyZSBhbnlcbiAgICBzdGVwcykuXG4gICAgKi9cbiAgICBnZXQgZG9jQ2hhbmdlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RlcHMubGVuZ3RoID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBhZGRTdGVwKHN0ZXAsIGRvYykge1xuICAgICAgICB0aGlzLmRvY3MucHVzaCh0aGlzLmRvYyk7XG4gICAgICAgIHRoaXMuc3RlcHMucHVzaChzdGVwKTtcbiAgICAgICAgdGhpcy5tYXBwaW5nLmFwcGVuZE1hcChzdGVwLmdldE1hcCgpKTtcbiAgICAgICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlcGxhY2UgdGhlIHBhcnQgb2YgdGhlIGRvY3VtZW50IGJldHdlZW4gYGZyb21gIGFuZCBgdG9gIHdpdGggdGhlXG4gICAgZ2l2ZW4gYHNsaWNlYC5cbiAgICAqL1xuICAgIHJlcGxhY2UoZnJvbSwgdG8gPSBmcm9tLCBzbGljZSA9IFNsaWNlLmVtcHR5KSB7XG4gICAgICAgIGxldCBzdGVwID0gcmVwbGFjZVN0ZXAodGhpcy5kb2MsIGZyb20sIHRvLCBzbGljZSk7XG4gICAgICAgIGlmIChzdGVwKVxuICAgICAgICAgICAgdGhpcy5zdGVwKHN0ZXApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmVwbGFjZSB0aGUgZ2l2ZW4gcmFuZ2Ugd2l0aCB0aGUgZ2l2ZW4gY29udGVudCwgd2hpY2ggbWF5IGJlIGFcbiAgICBmcmFnbWVudCwgbm9kZSwgb3IgYXJyYXkgb2Ygbm9kZXMuXG4gICAgKi9cbiAgICByZXBsYWNlV2l0aChmcm9tLCB0bywgY29udGVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXBsYWNlKGZyb20sIHRvLCBuZXcgU2xpY2UoRnJhZ21lbnQuZnJvbShjb250ZW50KSwgMCwgMCkpO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWxldGUgdGhlIGNvbnRlbnQgYmV0d2VlbiB0aGUgZ2l2ZW4gcG9zaXRpb25zLlxuICAgICovXG4gICAgZGVsZXRlKGZyb20sIHRvKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlcGxhY2UoZnJvbSwgdG8sIFNsaWNlLmVtcHR5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgSW5zZXJ0IHRoZSBnaXZlbiBjb250ZW50IGF0IHRoZSBnaXZlbiBwb3NpdGlvbi5cbiAgICAqL1xuICAgIGluc2VydChwb3MsIGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVwbGFjZVdpdGgocG9zLCBwb3MsIGNvbnRlbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXBsYWNlIGEgcmFuZ2Ugb2YgdGhlIGRvY3VtZW50IHdpdGggYSBnaXZlbiBzbGljZSwgdXNpbmdcbiAgICBgZnJvbWAsIGB0b2AsIGFuZCB0aGUgc2xpY2Unc1xuICAgIFtgb3BlblN0YXJ0YF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLlNsaWNlLm9wZW5TdGFydCkgcHJvcGVydHkgYXMgaGludHMsIHJhdGhlclxuICAgIHRoYW4gZml4ZWQgc3RhcnQgYW5kIGVuZCBwb2ludHMuIFRoaXMgbWV0aG9kIG1heSBncm93IHRoZVxuICAgIHJlcGxhY2VkIGFyZWEgb3IgY2xvc2Ugb3BlbiBub2RlcyBpbiB0aGUgc2xpY2UgaW4gb3JkZXIgdG8gZ2V0IGFcbiAgICBmaXQgdGhhdCBpcyBtb3JlIGluIGxpbmUgd2l0aCBXWVNJV1lHIGV4cGVjdGF0aW9ucywgYnkgZHJvcHBpbmdcbiAgICBmdWxseSBjb3ZlcmVkIHBhcmVudCBub2RlcyBvZiB0aGUgcmVwbGFjZWQgcmVnaW9uIHdoZW4gdGhleSBhcmVcbiAgICBtYXJrZWQgW25vbi1kZWZpbmluZyBhc1xuICAgIGNvbnRleHRdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlU3BlYy5kZWZpbmluZ0FzQ29udGV4dCksIG9yIGluY2x1ZGluZyBhblxuICAgIG9wZW4gcGFyZW50IG5vZGUgZnJvbSB0aGUgc2xpY2UgdGhhdCBfaXNfIG1hcmtlZCBhcyBbZGVmaW5pbmdcbiAgICBpdHMgY29udGVudF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI21vZGVsLk5vZGVTcGVjLmRlZmluaW5nRm9yQ29udGVudCkuXG4gICAgXG4gICAgVGhpcyBpcyB0aGUgbWV0aG9kLCBmb3IgZXhhbXBsZSwgdG8gaGFuZGxlIHBhc3RlLiBUaGUgc2ltaWxhclxuICAgIFtgcmVwbGFjZWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN0cmFuc2Zvcm0uVHJhbnNmb3JtLnJlcGxhY2UpIG1ldGhvZCBpcyBhIG1vcmVcbiAgICBwcmltaXRpdmUgdG9vbCB3aGljaCB3aWxsIF9ub3RfIG1vdmUgdGhlIHN0YXJ0IGFuZCBlbmQgb2YgaXRzIGdpdmVuXG4gICAgcmFuZ2UsIGFuZCBpcyB1c2VmdWwgaW4gc2l0dWF0aW9ucyB3aGVyZSB5b3UgbmVlZCBtb3JlIHByZWNpc2VcbiAgICBjb250cm9sIG92ZXIgd2hhdCBoYXBwZW5zLlxuICAgICovXG4gICAgcmVwbGFjZVJhbmdlKGZyb20sIHRvLCBzbGljZSkge1xuICAgICAgICByZXBsYWNlUmFuZ2UodGhpcywgZnJvbSwgdG8sIHNsaWNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlcGxhY2UgdGhlIGdpdmVuIHJhbmdlIHdpdGggYSBub2RlLCBidXQgdXNlIGBmcm9tYCBhbmQgYHRvYCBhc1xuICAgIGhpbnRzLCByYXRoZXIgdGhhbiBwcmVjaXNlIHBvc2l0aW9ucy4gV2hlbiBmcm9tIGFuZCB0byBhcmUgdGhlIHNhbWVcbiAgICBhbmQgYXJlIGF0IHRoZSBzdGFydCBvciBlbmQgb2YgYSBwYXJlbnQgbm9kZSBpbiB3aGljaCB0aGUgZ2l2ZW5cbiAgICBub2RlIGRvZXNuJ3QgZml0LCB0aGlzIG1ldGhvZCBtYXkgX21vdmVfIHRoZW0gb3V0IHRvd2FyZHMgYSBwYXJlbnRcbiAgICB0aGF0IGRvZXMgYWxsb3cgdGhlIGdpdmVuIG5vZGUgdG8gYmUgcGxhY2VkLiBXaGVuIHRoZSBnaXZlbiByYW5nZVxuICAgIGNvbXBsZXRlbHkgY292ZXJzIGEgcGFyZW50IG5vZGUsIHRoaXMgbWV0aG9kIG1heSBjb21wbGV0ZWx5IHJlcGxhY2VcbiAgICB0aGF0IHBhcmVudCBub2RlLlxuICAgICovXG4gICAgcmVwbGFjZVJhbmdlV2l0aChmcm9tLCB0bywgbm9kZSkge1xuICAgICAgICByZXBsYWNlUmFuZ2VXaXRoKHRoaXMsIGZyb20sIHRvLCBub2RlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIERlbGV0ZSB0aGUgZ2l2ZW4gcmFuZ2UsIGV4cGFuZGluZyBpdCB0byBjb3ZlciBmdWxseSBjb3ZlcmVkXG4gICAgcGFyZW50IG5vZGVzIHVudGlsIGEgdmFsaWQgcmVwbGFjZSBpcyBmb3VuZC5cbiAgICAqL1xuICAgIGRlbGV0ZVJhbmdlKGZyb20sIHRvKSB7XG4gICAgICAgIGRlbGV0ZVJhbmdlKHRoaXMsIGZyb20sIHRvKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFNwbGl0IHRoZSBjb250ZW50IGluIHRoZSBnaXZlbiByYW5nZSBvZmYgZnJvbSBpdHMgcGFyZW50LCBpZiB0aGVyZVxuICAgIGlzIHNpYmxpbmcgY29udGVudCBiZWZvcmUgb3IgYWZ0ZXIgaXQsIGFuZCBtb3ZlIGl0IHVwIHRoZSB0cmVlIHRvXG4gICAgdGhlIGRlcHRoIHNwZWNpZmllZCBieSBgdGFyZ2V0YC4gWW91J2xsIHByb2JhYmx5IHdhbnQgdG8gdXNlXG4gICAgW2BsaWZ0VGFyZ2V0YF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3RyYW5zZm9ybS5saWZ0VGFyZ2V0KSB0byBjb21wdXRlIGB0YXJnZXRgLCB0byBtYWtlXG4gICAgc3VyZSB0aGUgbGlmdCBpcyB2YWxpZC5cbiAgICAqL1xuICAgIGxpZnQocmFuZ2UsIHRhcmdldCkge1xuICAgICAgICBsaWZ0KHRoaXMsIHJhbmdlLCB0YXJnZXQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgSm9pbiB0aGUgYmxvY2tzIGFyb3VuZCB0aGUgZ2l2ZW4gcG9zaXRpb24uIElmIGRlcHRoIGlzIDIsIHRoZWlyXG4gICAgbGFzdCBhbmQgZmlyc3Qgc2libGluZ3MgYXJlIGFsc28gam9pbmVkLCBhbmQgc28gb24uXG4gICAgKi9cbiAgICBqb2luKHBvcywgZGVwdGggPSAxKSB7XG4gICAgICAgIGpvaW4odGhpcywgcG9zLCBkZXB0aCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBXcmFwIHRoZSBnaXZlbiBbcmFuZ2VdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyNtb2RlbC5Ob2RlUmFuZ2UpIGluIHRoZSBnaXZlbiBzZXQgb2Ygd3JhcHBlcnMuXG4gICAgVGhlIHdyYXBwZXJzIGFyZSBhc3N1bWVkIHRvIGJlIHZhbGlkIGluIHRoaXMgcG9zaXRpb24sIGFuZCBzaG91bGRcbiAgICBwcm9iYWJseSBiZSBjb21wdXRlZCB3aXRoIFtgZmluZFdyYXBwaW5nYF0oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3RyYW5zZm9ybS5maW5kV3JhcHBpbmcpLlxuICAgICovXG4gICAgd3JhcChyYW5nZSwgd3JhcHBlcnMpIHtcbiAgICAgICAgd3JhcCh0aGlzLCByYW5nZSwgd3JhcHBlcnMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgU2V0IHRoZSB0eXBlIG9mIGFsbCB0ZXh0YmxvY2tzIChwYXJ0bHkpIGJldHdlZW4gYGZyb21gIGFuZCBgdG9gIHRvXG4gICAgdGhlIGdpdmVuIG5vZGUgdHlwZSB3aXRoIHRoZSBnaXZlbiBhdHRyaWJ1dGVzLlxuICAgICovXG4gICAgc2V0QmxvY2tUeXBlKGZyb20sIHRvID0gZnJvbSwgdHlwZSwgYXR0cnMgPSBudWxsKSB7XG4gICAgICAgIHNldEJsb2NrVHlwZSh0aGlzLCBmcm9tLCB0bywgdHlwZSwgYXR0cnMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgQ2hhbmdlIHRoZSB0eXBlLCBhdHRyaWJ1dGVzLCBhbmQvb3IgbWFya3Mgb2YgdGhlIG5vZGUgYXQgYHBvc2AuXG4gICAgV2hlbiBgdHlwZWAgaXNuJ3QgZ2l2ZW4sIHRoZSBleGlzdGluZyBub2RlIHR5cGUgaXMgcHJlc2VydmVkLFxuICAgICovXG4gICAgc2V0Tm9kZU1hcmt1cChwb3MsIHR5cGUsIGF0dHJzID0gbnVsbCwgbWFya3MpIHtcbiAgICAgICAgc2V0Tm9kZU1hcmt1cCh0aGlzLCBwb3MsIHR5cGUsIGF0dHJzLCBtYXJrcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBTZXQgYSBzaW5nbGUgYXR0cmlidXRlIG9uIGEgZ2l2ZW4gbm9kZSB0byBhIG5ldyB2YWx1ZS5cbiAgICBUaGUgYHBvc2AgYWRkcmVzc2VzIHRoZSBkb2N1bWVudCBjb250ZW50LiBVc2UgYHNldERvY0F0dHJpYnV0ZWBcbiAgICB0byBzZXQgYXR0cmlidXRlcyBvbiB0aGUgZG9jdW1lbnQgaXRzZWxmLlxuICAgICovXG4gICAgc2V0Tm9kZUF0dHJpYnV0ZShwb3MsIGF0dHIsIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuc3RlcChuZXcgQXR0clN0ZXAocG9zLCBhdHRyLCB2YWx1ZSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgU2V0IGEgc2luZ2xlIGF0dHJpYnV0ZSBvbiB0aGUgZG9jdW1lbnQgdG8gYSBuZXcgdmFsdWUuXG4gICAgKi9cbiAgICBzZXREb2NBdHRyaWJ1dGUoYXR0ciwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5zdGVwKG5ldyBEb2NBdHRyU3RlcChhdHRyLCB2YWx1ZSkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgQWRkIGEgbWFyayB0byB0aGUgbm9kZSBhdCBwb3NpdGlvbiBgcG9zYC5cbiAgICAqL1xuICAgIGFkZE5vZGVNYXJrKHBvcywgbWFyaykge1xuICAgICAgICB0aGlzLnN0ZXAobmV3IEFkZE5vZGVNYXJrU3RlcChwb3MsIG1hcmspKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlbW92ZSBhIG1hcmsgKG9yIGFsbCBtYXJrcyBvZiB0aGUgZ2l2ZW4gdHlwZSkgZnJvbSB0aGUgbm9kZSBhdFxuICAgIHBvc2l0aW9uIGBwb3NgLlxuICAgICovXG4gICAgcmVtb3ZlTm9kZU1hcmsocG9zLCBtYXJrKSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5kb2Mubm9kZUF0KHBvcyk7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm8gbm9kZSBhdCBwb3NpdGlvbiBcIiArIHBvcyk7XG4gICAgICAgIGlmIChtYXJrIGluc3RhbmNlb2YgTWFyaykge1xuICAgICAgICAgICAgaWYgKG1hcmsuaXNJblNldChub2RlLm1hcmtzKSlcbiAgICAgICAgICAgICAgICB0aGlzLnN0ZXAobmV3IFJlbW92ZU5vZGVNYXJrU3RlcChwb3MsIG1hcmspKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBzZXQgPSBub2RlLm1hcmtzLCBmb3VuZCwgc3RlcHMgPSBbXTtcbiAgICAgICAgICAgIHdoaWxlIChmb3VuZCA9IG1hcmsuaXNJblNldChzZXQpKSB7XG4gICAgICAgICAgICAgICAgc3RlcHMucHVzaChuZXcgUmVtb3ZlTm9kZU1hcmtTdGVwKHBvcywgZm91bmQpKTtcbiAgICAgICAgICAgICAgICBzZXQgPSBmb3VuZC5yZW1vdmVGcm9tU2V0KHNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gc3RlcHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgICAgICAgICAgdGhpcy5zdGVwKHN0ZXBzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgU3BsaXQgdGhlIG5vZGUgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLCBhbmQgb3B0aW9uYWxseSwgaWYgYGRlcHRoYCBpc1xuICAgIGdyZWF0ZXIgdGhhbiBvbmUsIGFueSBudW1iZXIgb2Ygbm9kZXMgYWJvdmUgdGhhdC4gQnkgZGVmYXVsdCwgdGhlXG4gICAgcGFydHMgc3BsaXQgb2ZmIHdpbGwgaW5oZXJpdCB0aGUgbm9kZSB0eXBlIG9mIHRoZSBvcmlnaW5hbCBub2RlLlxuICAgIFRoaXMgY2FuIGJlIGNoYW5nZWQgYnkgcGFzc2luZyBhbiBhcnJheSBvZiB0eXBlcyBhbmQgYXR0cmlidXRlcyB0b1xuICAgIHVzZSBhZnRlciB0aGUgc3BsaXQgKHdpdGggdGhlIG91dGVybW9zdCBub2RlcyBjb21pbmcgZmlyc3QpLlxuICAgICovXG4gICAgc3BsaXQocG9zLCBkZXB0aCA9IDEsIHR5cGVzQWZ0ZXIpIHtcbiAgICAgICAgc3BsaXQodGhpcywgcG9zLCBkZXB0aCwgdHlwZXNBZnRlcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBBZGQgdGhlIGdpdmVuIG1hcmsgdG8gdGhlIGlubGluZSBjb250ZW50IGJldHdlZW4gYGZyb21gIGFuZCBgdG9gLlxuICAgICovXG4gICAgYWRkTWFyayhmcm9tLCB0bywgbWFyaykge1xuICAgICAgICBhZGRNYXJrKHRoaXMsIGZyb20sIHRvLCBtYXJrKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlbW92ZSBtYXJrcyBmcm9tIGlubGluZSBub2RlcyBiZXR3ZWVuIGBmcm9tYCBhbmQgYHRvYC4gV2hlblxuICAgIGBtYXJrYCBpcyBhIHNpbmdsZSBtYXJrLCByZW1vdmUgcHJlY2lzZWx5IHRoYXQgbWFyay4gV2hlbiBpdCBpc1xuICAgIGEgbWFyayB0eXBlLCByZW1vdmUgYWxsIG1hcmtzIG9mIHRoYXQgdHlwZS4gV2hlbiBpdCBpcyBudWxsLFxuICAgIHJlbW92ZSBhbGwgbWFya3Mgb2YgYW55IHR5cGUuXG4gICAgKi9cbiAgICByZW1vdmVNYXJrKGZyb20sIHRvLCBtYXJrKSB7XG4gICAgICAgIHJlbW92ZU1hcmsodGhpcywgZnJvbSwgdG8sIG1hcmspO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgUmVtb3ZlcyBhbGwgbWFya3MgYW5kIG5vZGVzIGZyb20gdGhlIGNvbnRlbnQgb2YgdGhlIG5vZGUgYXRcbiAgICBgcG9zYCB0aGF0IGRvbid0IG1hdGNoIHRoZSBnaXZlbiBuZXcgcGFyZW50IG5vZGUgdHlwZS4gQWNjZXB0c1xuICAgIGFuIG9wdGlvbmFsIHN0YXJ0aW5nIFtjb250ZW50IG1hdGNoXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jbW9kZWwuQ29udGVudE1hdGNoKSBhc1xuICAgIHRoaXJkIGFyZ3VtZW50LlxuICAgICovXG4gICAgY2xlYXJJbmNvbXBhdGlibGUocG9zLCBwYXJlbnRUeXBlLCBtYXRjaCkge1xuICAgICAgICBjbGVhckluY29tcGF0aWJsZSh0aGlzLCBwb3MsIHBhcmVudFR5cGUsIG1hdGNoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuXG5leHBvcnQgeyBBZGRNYXJrU3RlcCwgQWRkTm9kZU1hcmtTdGVwLCBBdHRyU3RlcCwgRG9jQXR0clN0ZXAsIE1hcFJlc3VsdCwgTWFwcGluZywgUmVtb3ZlTWFya1N0ZXAsIFJlbW92ZU5vZGVNYXJrU3RlcCwgUmVwbGFjZUFyb3VuZFN0ZXAsIFJlcGxhY2VTdGVwLCBTdGVwLCBTdGVwTWFwLCBTdGVwUmVzdWx0LCBUcmFuc2Zvcm0sIFRyYW5zZm9ybUVycm9yLCBjYW5Kb2luLCBjYW5TcGxpdCwgZHJvcFBvaW50LCBmaW5kV3JhcHBpbmcsIGluc2VydFBvaW50LCBqb2luUG9pbnQsIGxpZnRUYXJnZXQsIHJlcGxhY2VTdGVwIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prosemirror-transform/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/prosemirror-view/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/prosemirror-view/dist/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Decoration: function() { return /* binding */ Decoration; },\n/* harmony export */   DecorationSet: function() { return /* binding */ DecorationSet; },\n/* harmony export */   EditorView: function() { return /* binding */ EditorView; },\n/* harmony export */   __endComposition: function() { return /* binding */ __endComposition; },\n/* harmony export */   __parseFromClipboard: function() { return /* binding */ __parseFromClipboard; }\n/* harmony export */ });\n/* harmony import */ var prosemirror_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prosemirror-state */ \"(app-pages-browser)/./node_modules/prosemirror-state/dist/index.js\");\n/* harmony import */ var prosemirror_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prosemirror-model */ \"(app-pages-browser)/./node_modules/prosemirror-model/dist/index.js\");\n/* harmony import */ var prosemirror_transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! prosemirror-transform */ \"(app-pages-browser)/./node_modules/prosemirror-transform/dist/index.js\");\n\n\n\n\nconst domIndex = function (node) {\n    for (var index = 0;; index++) {\n        node = node.previousSibling;\n        if (!node)\n            return index;\n    }\n};\nconst parentNode = function (node) {\n    let parent = node.assignedSlot || node.parentNode;\n    return parent && parent.nodeType == 11 ? parent.host : parent;\n};\nlet reusedRange = null;\n// Note that this will always return the same range, because DOM range\n// objects are every expensive, and keep slowing down subsequent DOM\n// updates, for some reason.\nconst textRange = function (node, from, to) {\n    let range = reusedRange || (reusedRange = document.createRange());\n    range.setEnd(node, to == null ? node.nodeValue.length : to);\n    range.setStart(node, from || 0);\n    return range;\n};\nconst clearReusedRange = function () {\n    reusedRange = null;\n};\n// Scans forward and backward through DOM positions equivalent to the\n// given one to see if the two are in the same place (i.e. after a\n// text node vs at the end of that text node)\nconst isEquivalentPosition = function (node, off, targetNode, targetOff) {\n    return targetNode && (scanFor(node, off, targetNode, targetOff, -1) ||\n        scanFor(node, off, targetNode, targetOff, 1));\n};\nconst atomElements = /^(img|br|input|textarea|hr)$/i;\nfunction scanFor(node, off, targetNode, targetOff, dir) {\n    var _a;\n    for (;;) {\n        if (node == targetNode && off == targetOff)\n            return true;\n        if (off == (dir < 0 ? 0 : nodeSize(node))) {\n            let parent = node.parentNode;\n            if (!parent || parent.nodeType != 1 || hasBlockDesc(node) || atomElements.test(node.nodeName) ||\n                node.contentEditable == \"false\")\n                return false;\n            off = domIndex(node) + (dir < 0 ? 0 : 1);\n            node = parent;\n        }\n        else if (node.nodeType == 1) {\n            let child = node.childNodes[off + (dir < 0 ? -1 : 0)];\n            if (child.nodeType == 1 && child.contentEditable == \"false\") {\n                if ((_a = child.pmViewDesc) === null || _a === void 0 ? void 0 : _a.ignoreForSelection)\n                    off += dir;\n                else\n                    return false;\n            }\n            else {\n                node = child;\n                off = dir < 0 ? nodeSize(node) : 0;\n            }\n        }\n        else {\n            return false;\n        }\n    }\n}\nfunction nodeSize(node) {\n    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;\n}\nfunction textNodeBefore$1(node, offset) {\n    for (;;) {\n        if (node.nodeType == 3 && offset)\n            return node;\n        if (node.nodeType == 1 && offset > 0) {\n            if (node.contentEditable == \"false\")\n                return null;\n            node = node.childNodes[offset - 1];\n            offset = nodeSize(node);\n        }\n        else if (node.parentNode && !hasBlockDesc(node)) {\n            offset = domIndex(node);\n            node = node.parentNode;\n        }\n        else {\n            return null;\n        }\n    }\n}\nfunction textNodeAfter$1(node, offset) {\n    for (;;) {\n        if (node.nodeType == 3 && offset < node.nodeValue.length)\n            return node;\n        if (node.nodeType == 1 && offset < node.childNodes.length) {\n            if (node.contentEditable == \"false\")\n                return null;\n            node = node.childNodes[offset];\n            offset = 0;\n        }\n        else if (node.parentNode && !hasBlockDesc(node)) {\n            offset = domIndex(node) + 1;\n            node = node.parentNode;\n        }\n        else {\n            return null;\n        }\n    }\n}\nfunction isOnEdge(node, offset, parent) {\n    for (let atStart = offset == 0, atEnd = offset == nodeSize(node); atStart || atEnd;) {\n        if (node == parent)\n            return true;\n        let index = domIndex(node);\n        node = node.parentNode;\n        if (!node)\n            return false;\n        atStart = atStart && index == 0;\n        atEnd = atEnd && index == nodeSize(node);\n    }\n}\nfunction hasBlockDesc(dom) {\n    let desc;\n    for (let cur = dom; cur; cur = cur.parentNode)\n        if (desc = cur.pmViewDesc)\n            break;\n    return desc && desc.node && desc.node.isBlock && (desc.dom == dom || desc.contentDOM == dom);\n}\n// Work around Chrome issue https://bugs.chromium.org/p/chromium/issues/detail?id=447523\n// (isCollapsed inappropriately returns true in shadow dom)\nconst selectionCollapsed = function (domSel) {\n    return domSel.focusNode && isEquivalentPosition(domSel.focusNode, domSel.focusOffset, domSel.anchorNode, domSel.anchorOffset);\n};\nfunction keyEvent(keyCode, key) {\n    let event = document.createEvent(\"Event\");\n    event.initEvent(\"keydown\", true, true);\n    event.keyCode = keyCode;\n    event.key = event.code = key;\n    return event;\n}\nfunction deepActiveElement(doc) {\n    let elt = doc.activeElement;\n    while (elt && elt.shadowRoot)\n        elt = elt.shadowRoot.activeElement;\n    return elt;\n}\nfunction caretFromPoint(doc, x, y) {\n    if (doc.caretPositionFromPoint) {\n        try { // Firefox throws for this call in hard-to-predict circumstances (#994)\n            let pos = doc.caretPositionFromPoint(x, y);\n            // Clip the offset, because Chrome will return a text offset\n            // into <input> nodes, which can't be treated as a regular DOM\n            // offset\n            if (pos)\n                return { node: pos.offsetNode, offset: Math.min(nodeSize(pos.offsetNode), pos.offset) };\n        }\n        catch (_) { }\n    }\n    if (doc.caretRangeFromPoint) {\n        let range = doc.caretRangeFromPoint(x, y);\n        if (range)\n            return { node: range.startContainer, offset: Math.min(nodeSize(range.startContainer), range.startOffset) };\n    }\n}\n\nconst nav = typeof navigator != \"undefined\" ? navigator : null;\nconst doc = typeof document != \"undefined\" ? document : null;\nconst agent = (nav && nav.userAgent) || \"\";\nconst ie_edge = /Edge\\/(\\d+)/.exec(agent);\nconst ie_upto10 = /MSIE \\d/.exec(agent);\nconst ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(agent);\nconst ie = !!(ie_upto10 || ie_11up || ie_edge);\nconst ie_version = ie_upto10 ? document.documentMode : ie_11up ? +ie_11up[1] : ie_edge ? +ie_edge[1] : 0;\nconst gecko = !ie && /gecko\\/(\\d+)/i.test(agent);\ngecko && +(/Firefox\\/(\\d+)/.exec(agent) || [0, 0])[1];\nconst _chrome = !ie && /Chrome\\/(\\d+)/.exec(agent);\nconst chrome = !!_chrome;\nconst chrome_version = _chrome ? +_chrome[1] : 0;\nconst safari = !ie && !!nav && /Apple Computer/.test(nav.vendor);\n// Is true for both iOS and iPadOS for convenience\nconst ios = safari && (/Mobile\\/\\w+/.test(agent) || !!nav && nav.maxTouchPoints > 2);\nconst mac = ios || (nav ? /Mac/.test(nav.platform) : false);\nconst windows = nav ? /Win/.test(nav.platform) : false;\nconst android = /Android \\d/.test(agent);\nconst webkit = !!doc && \"webkitFontSmoothing\" in doc.documentElement.style;\nconst webkit_version = webkit ? +(/\\bAppleWebKit\\/(\\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;\n\nfunction windowRect(doc) {\n    let vp = doc.defaultView && doc.defaultView.visualViewport;\n    if (vp)\n        return {\n            left: 0, right: vp.width,\n            top: 0, bottom: vp.height\n        };\n    return { left: 0, right: doc.documentElement.clientWidth,\n        top: 0, bottom: doc.documentElement.clientHeight };\n}\nfunction getSide(value, side) {\n    return typeof value == \"number\" ? value : value[side];\n}\nfunction clientRect(node) {\n    let rect = node.getBoundingClientRect();\n    // Adjust for elements with style \"transform: scale()\"\n    let scaleX = (rect.width / node.offsetWidth) || 1;\n    let scaleY = (rect.height / node.offsetHeight) || 1;\n    // Make sure scrollbar width isn't included in the rectangle\n    return { left: rect.left, right: rect.left + node.clientWidth * scaleX,\n        top: rect.top, bottom: rect.top + node.clientHeight * scaleY };\n}\nfunction scrollRectIntoView(view, rect, startDOM) {\n    let scrollThreshold = view.someProp(\"scrollThreshold\") || 0, scrollMargin = view.someProp(\"scrollMargin\") || 5;\n    let doc = view.dom.ownerDocument;\n    for (let parent = startDOM || view.dom;;) {\n        if (!parent)\n            break;\n        if (parent.nodeType != 1) {\n            parent = parentNode(parent);\n            continue;\n        }\n        let elt = parent;\n        let atTop = elt == doc.body;\n        let bounding = atTop ? windowRect(doc) : clientRect(elt);\n        let moveX = 0, moveY = 0;\n        if (rect.top < bounding.top + getSide(scrollThreshold, \"top\"))\n            moveY = -(bounding.top - rect.top + getSide(scrollMargin, \"top\"));\n        else if (rect.bottom > bounding.bottom - getSide(scrollThreshold, \"bottom\"))\n            moveY = rect.bottom - rect.top > bounding.bottom - bounding.top\n                ? rect.top + getSide(scrollMargin, \"top\") - bounding.top\n                : rect.bottom - bounding.bottom + getSide(scrollMargin, \"bottom\");\n        if (rect.left < bounding.left + getSide(scrollThreshold, \"left\"))\n            moveX = -(bounding.left - rect.left + getSide(scrollMargin, \"left\"));\n        else if (rect.right > bounding.right - getSide(scrollThreshold, \"right\"))\n            moveX = rect.right - bounding.right + getSide(scrollMargin, \"right\");\n        if (moveX || moveY) {\n            if (atTop) {\n                doc.defaultView.scrollBy(moveX, moveY);\n            }\n            else {\n                let startX = elt.scrollLeft, startY = elt.scrollTop;\n                if (moveY)\n                    elt.scrollTop += moveY;\n                if (moveX)\n                    elt.scrollLeft += moveX;\n                let dX = elt.scrollLeft - startX, dY = elt.scrollTop - startY;\n                rect = { left: rect.left - dX, top: rect.top - dY, right: rect.right - dX, bottom: rect.bottom - dY };\n            }\n        }\n        let pos = atTop ? \"fixed\" : getComputedStyle(parent).position;\n        if (/^(fixed|sticky)$/.test(pos))\n            break;\n        parent = pos == \"absolute\" ? parent.offsetParent : parentNode(parent);\n    }\n}\n// Store the scroll position of the editor's parent nodes, along with\n// the top position of an element near the top of the editor, which\n// will be used to make sure the visible viewport remains stable even\n// when the size of the content above changes.\nfunction storeScrollPos(view) {\n    let rect = view.dom.getBoundingClientRect(), startY = Math.max(0, rect.top);\n    let refDOM, refTop;\n    for (let x = (rect.left + rect.right) / 2, y = startY + 1; y < Math.min(innerHeight, rect.bottom); y += 5) {\n        let dom = view.root.elementFromPoint(x, y);\n        if (!dom || dom == view.dom || !view.dom.contains(dom))\n            continue;\n        let localRect = dom.getBoundingClientRect();\n        if (localRect.top >= startY - 20) {\n            refDOM = dom;\n            refTop = localRect.top;\n            break;\n        }\n    }\n    return { refDOM: refDOM, refTop: refTop, stack: scrollStack(view.dom) };\n}\nfunction scrollStack(dom) {\n    let stack = [], doc = dom.ownerDocument;\n    for (let cur = dom; cur; cur = parentNode(cur)) {\n        stack.push({ dom: cur, top: cur.scrollTop, left: cur.scrollLeft });\n        if (dom == doc)\n            break;\n    }\n    return stack;\n}\n// Reset the scroll position of the editor's parent nodes to that what\n// it was before, when storeScrollPos was called.\nfunction resetScrollPos({ refDOM, refTop, stack }) {\n    let newRefTop = refDOM ? refDOM.getBoundingClientRect().top : 0;\n    restoreScrollStack(stack, newRefTop == 0 ? 0 : newRefTop - refTop);\n}\nfunction restoreScrollStack(stack, dTop) {\n    for (let i = 0; i < stack.length; i++) {\n        let { dom, top, left } = stack[i];\n        if (dom.scrollTop != top + dTop)\n            dom.scrollTop = top + dTop;\n        if (dom.scrollLeft != left)\n            dom.scrollLeft = left;\n    }\n}\nlet preventScrollSupported = null;\n// Feature-detects support for .focus({preventScroll: true}), and uses\n// a fallback kludge when not supported.\nfunction focusPreventScroll(dom) {\n    if (dom.setActive)\n        return dom.setActive(); // in IE\n    if (preventScrollSupported)\n        return dom.focus(preventScrollSupported);\n    let stored = scrollStack(dom);\n    dom.focus(preventScrollSupported == null ? {\n        get preventScroll() {\n            preventScrollSupported = { preventScroll: true };\n            return true;\n        }\n    } : undefined);\n    if (!preventScrollSupported) {\n        preventScrollSupported = false;\n        restoreScrollStack(stored, 0);\n    }\n}\nfunction findOffsetInNode(node, coords) {\n    let closest, dxClosest = 2e8, coordsClosest, offset = 0;\n    let rowBot = coords.top, rowTop = coords.top;\n    let firstBelow, coordsBelow;\n    for (let child = node.firstChild, childIndex = 0; child; child = child.nextSibling, childIndex++) {\n        let rects;\n        if (child.nodeType == 1)\n            rects = child.getClientRects();\n        else if (child.nodeType == 3)\n            rects = textRange(child).getClientRects();\n        else\n            continue;\n        for (let i = 0; i < rects.length; i++) {\n            let rect = rects[i];\n            if (rect.top <= rowBot && rect.bottom >= rowTop) {\n                rowBot = Math.max(rect.bottom, rowBot);\n                rowTop = Math.min(rect.top, rowTop);\n                let dx = rect.left > coords.left ? rect.left - coords.left\n                    : rect.right < coords.left ? coords.left - rect.right : 0;\n                if (dx < dxClosest) {\n                    closest = child;\n                    dxClosest = dx;\n                    coordsClosest = dx && closest.nodeType == 3 ? {\n                        left: rect.right < coords.left ? rect.right : rect.left,\n                        top: coords.top\n                    } : coords;\n                    if (child.nodeType == 1 && dx)\n                        offset = childIndex + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0);\n                    continue;\n                }\n            }\n            else if (rect.top > coords.top && !firstBelow && rect.left <= coords.left && rect.right >= coords.left) {\n                firstBelow = child;\n                coordsBelow = { left: Math.max(rect.left, Math.min(rect.right, coords.left)), top: rect.top };\n            }\n            if (!closest && (coords.left >= rect.right && coords.top >= rect.top ||\n                coords.left >= rect.left && coords.top >= rect.bottom))\n                offset = childIndex + 1;\n        }\n    }\n    if (!closest && firstBelow) {\n        closest = firstBelow;\n        coordsClosest = coordsBelow;\n        dxClosest = 0;\n    }\n    if (closest && closest.nodeType == 3)\n        return findOffsetInText(closest, coordsClosest);\n    if (!closest || (dxClosest && closest.nodeType == 1))\n        return { node, offset };\n    return findOffsetInNode(closest, coordsClosest);\n}\nfunction findOffsetInText(node, coords) {\n    let len = node.nodeValue.length;\n    let range = document.createRange();\n    for (let i = 0; i < len; i++) {\n        range.setEnd(node, i + 1);\n        range.setStart(node, i);\n        let rect = singleRect(range, 1);\n        if (rect.top == rect.bottom)\n            continue;\n        if (inRect(coords, rect))\n            return { node, offset: i + (coords.left >= (rect.left + rect.right) / 2 ? 1 : 0) };\n    }\n    return { node, offset: 0 };\n}\nfunction inRect(coords, rect) {\n    return coords.left >= rect.left - 1 && coords.left <= rect.right + 1 &&\n        coords.top >= rect.top - 1 && coords.top <= rect.bottom + 1;\n}\nfunction targetKludge(dom, coords) {\n    let parent = dom.parentNode;\n    if (parent && /^li$/i.test(parent.nodeName) && coords.left < dom.getBoundingClientRect().left)\n        return parent;\n    return dom;\n}\nfunction posFromElement(view, elt, coords) {\n    let { node, offset } = findOffsetInNode(elt, coords), bias = -1;\n    if (node.nodeType == 1 && !node.firstChild) {\n        let rect = node.getBoundingClientRect();\n        bias = rect.left != rect.right && coords.left > (rect.left + rect.right) / 2 ? 1 : -1;\n    }\n    return view.docView.posFromDOM(node, offset, bias);\n}\nfunction posFromCaret(view, node, offset, coords) {\n    // Browser (in caretPosition/RangeFromPoint) will agressively\n    // normalize towards nearby inline nodes. Since we are interested in\n    // positions between block nodes too, we first walk up the hierarchy\n    // of nodes to see if there are block nodes that the coordinates\n    // fall outside of. If so, we take the position before/after that\n    // block. If not, we call `posFromDOM` on the raw node/offset.\n    let outsideBlock = -1;\n    for (let cur = node, sawBlock = false;;) {\n        if (cur == view.dom)\n            break;\n        let desc = view.docView.nearestDesc(cur, true), rect;\n        if (!desc)\n            return null;\n        if (desc.dom.nodeType == 1 && (desc.node.isBlock && desc.parent || !desc.contentDOM) &&\n            // Ignore elements with zero-size bounding rectangles\n            ((rect = desc.dom.getBoundingClientRect()).width || rect.height)) {\n            if (desc.node.isBlock && desc.parent && !/^T(R|BODY|HEAD|FOOT)$/.test(desc.dom.nodeName)) {\n                // Only apply the horizontal test to the innermost block. Vertical for any parent.\n                if (!sawBlock && rect.left > coords.left || rect.top > coords.top)\n                    outsideBlock = desc.posBefore;\n                else if (!sawBlock && rect.right < coords.left || rect.bottom < coords.top)\n                    outsideBlock = desc.posAfter;\n                sawBlock = true;\n            }\n            if (!desc.contentDOM && outsideBlock < 0 && !desc.node.isText) {\n                // If we are inside a leaf, return the side of the leaf closer to the coords\n                let before = desc.node.isBlock ? coords.top < (rect.top + rect.bottom) / 2\n                    : coords.left < (rect.left + rect.right) / 2;\n                return before ? desc.posBefore : desc.posAfter;\n            }\n        }\n        cur = desc.dom.parentNode;\n    }\n    return outsideBlock > -1 ? outsideBlock : view.docView.posFromDOM(node, offset, -1);\n}\nfunction elementFromPoint(element, coords, box) {\n    let len = element.childNodes.length;\n    if (len && box.top < box.bottom) {\n        for (let startI = Math.max(0, Math.min(len - 1, Math.floor(len * (coords.top - box.top) / (box.bottom - box.top)) - 2)), i = startI;;) {\n            let child = element.childNodes[i];\n            if (child.nodeType == 1) {\n                let rects = child.getClientRects();\n                for (let j = 0; j < rects.length; j++) {\n                    let rect = rects[j];\n                    if (inRect(coords, rect))\n                        return elementFromPoint(child, coords, rect);\n                }\n            }\n            if ((i = (i + 1) % len) == startI)\n                break;\n        }\n    }\n    return element;\n}\n// Given an x,y position on the editor, get the position in the document.\nfunction posAtCoords(view, coords) {\n    let doc = view.dom.ownerDocument, node, offset = 0;\n    let caret = caretFromPoint(doc, coords.left, coords.top);\n    if (caret)\n        ({ node, offset } = caret);\n    let elt = (view.root.elementFromPoint ? view.root : doc)\n        .elementFromPoint(coords.left, coords.top);\n    let pos;\n    if (!elt || !view.dom.contains(elt.nodeType != 1 ? elt.parentNode : elt)) {\n        let box = view.dom.getBoundingClientRect();\n        if (!inRect(coords, box))\n            return null;\n        elt = elementFromPoint(view.dom, coords, box);\n        if (!elt)\n            return null;\n    }\n    // Safari's caretRangeFromPoint returns nonsense when on a draggable element\n    if (safari) {\n        for (let p = elt; node && p; p = parentNode(p))\n            if (p.draggable)\n                node = undefined;\n    }\n    elt = targetKludge(elt, coords);\n    if (node) {\n        if (gecko && node.nodeType == 1) {\n            // Firefox will sometimes return offsets into <input> nodes, which\n            // have no actual children, from caretPositionFromPoint (#953)\n            offset = Math.min(offset, node.childNodes.length);\n            // It'll also move the returned position before image nodes,\n            // even if those are behind it.\n            if (offset < node.childNodes.length) {\n                let next = node.childNodes[offset], box;\n                if (next.nodeName == \"IMG\" && (box = next.getBoundingClientRect()).right <= coords.left &&\n                    box.bottom > coords.top)\n                    offset++;\n            }\n        }\n        let prev;\n        // When clicking above the right side of an uneditable node, Chrome will report a cursor position after that node.\n        if (webkit && offset && node.nodeType == 1 && (prev = node.childNodes[offset - 1]).nodeType == 1 &&\n            prev.contentEditable == \"false\" && prev.getBoundingClientRect().top >= coords.top)\n            offset--;\n        // Suspiciously specific kludge to work around caret*FromPoint\n        // never returning a position at the end of the document\n        if (node == view.dom && offset == node.childNodes.length - 1 && node.lastChild.nodeType == 1 &&\n            coords.top > node.lastChild.getBoundingClientRect().bottom)\n            pos = view.state.doc.content.size;\n        // Ignore positions directly after a BR, since caret*FromPoint\n        // 'round up' positions that would be more accurately placed\n        // before the BR node.\n        else if (offset == 0 || node.nodeType != 1 || node.childNodes[offset - 1].nodeName != \"BR\")\n            pos = posFromCaret(view, node, offset, coords);\n    }\n    if (pos == null)\n        pos = posFromElement(view, elt, coords);\n    let desc = view.docView.nearestDesc(elt, true);\n    return { pos, inside: desc ? desc.posAtStart - desc.border : -1 };\n}\nfunction nonZero(rect) {\n    return rect.top < rect.bottom || rect.left < rect.right;\n}\nfunction singleRect(target, bias) {\n    let rects = target.getClientRects();\n    if (rects.length) {\n        let first = rects[bias < 0 ? 0 : rects.length - 1];\n        if (nonZero(first))\n            return first;\n    }\n    return Array.prototype.find.call(rects, nonZero) || target.getBoundingClientRect();\n}\nconst BIDI = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n// Given a position in the document model, get a bounding box of the\n// character at that position, relative to the window.\nfunction coordsAtPos(view, pos, side) {\n    let { node, offset, atom } = view.docView.domFromPos(pos, side < 0 ? -1 : 1);\n    let supportEmptyRange = webkit || gecko;\n    if (node.nodeType == 3) {\n        // These browsers support querying empty text ranges. Prefer that in\n        // bidi context or when at the end of a node.\n        if (supportEmptyRange && (BIDI.test(node.nodeValue) || (side < 0 ? !offset : offset == node.nodeValue.length))) {\n            let rect = singleRect(textRange(node, offset, offset), side);\n            // Firefox returns bad results (the position before the space)\n            // when querying a position directly after line-broken\n            // whitespace. Detect this situation and and kludge around it\n            if (gecko && offset && /\\s/.test(node.nodeValue[offset - 1]) && offset < node.nodeValue.length) {\n                let rectBefore = singleRect(textRange(node, offset - 1, offset - 1), -1);\n                if (rectBefore.top == rect.top) {\n                    let rectAfter = singleRect(textRange(node, offset, offset + 1), -1);\n                    if (rectAfter.top != rect.top)\n                        return flattenV(rectAfter, rectAfter.left < rectBefore.left);\n                }\n            }\n            return rect;\n        }\n        else {\n            let from = offset, to = offset, takeSide = side < 0 ? 1 : -1;\n            if (side < 0 && !offset) {\n                to++;\n                takeSide = -1;\n            }\n            else if (side >= 0 && offset == node.nodeValue.length) {\n                from--;\n                takeSide = 1;\n            }\n            else if (side < 0) {\n                from--;\n            }\n            else {\n                to++;\n            }\n            return flattenV(singleRect(textRange(node, from, to), takeSide), takeSide < 0);\n        }\n    }\n    let $dom = view.state.doc.resolve(pos - (atom || 0));\n    // Return a horizontal line in block context\n    if (!$dom.parent.inlineContent) {\n        if (atom == null && offset && (side < 0 || offset == nodeSize(node))) {\n            let before = node.childNodes[offset - 1];\n            if (before.nodeType == 1)\n                return flattenH(before.getBoundingClientRect(), false);\n        }\n        if (atom == null && offset < nodeSize(node)) {\n            let after = node.childNodes[offset];\n            if (after.nodeType == 1)\n                return flattenH(after.getBoundingClientRect(), true);\n        }\n        return flattenH(node.getBoundingClientRect(), side >= 0);\n    }\n    // Inline, not in text node (this is not Bidi-safe)\n    if (atom == null && offset && (side < 0 || offset == nodeSize(node))) {\n        let before = node.childNodes[offset - 1];\n        let target = before.nodeType == 3 ? textRange(before, nodeSize(before) - (supportEmptyRange ? 0 : 1))\n            // BR nodes tend to only return the rectangle before them.\n            // Only use them if they are the last element in their parent\n            : before.nodeType == 1 && (before.nodeName != \"BR\" || !before.nextSibling) ? before : null;\n        if (target)\n            return flattenV(singleRect(target, 1), false);\n    }\n    if (atom == null && offset < nodeSize(node)) {\n        let after = node.childNodes[offset];\n        while (after.pmViewDesc && after.pmViewDesc.ignoreForCoords)\n            after = after.nextSibling;\n        let target = !after ? null : after.nodeType == 3 ? textRange(after, 0, (supportEmptyRange ? 0 : 1))\n            : after.nodeType == 1 ? after : null;\n        if (target)\n            return flattenV(singleRect(target, -1), true);\n    }\n    // All else failed, just try to get a rectangle for the target node\n    return flattenV(singleRect(node.nodeType == 3 ? textRange(node) : node, -side), side >= 0);\n}\nfunction flattenV(rect, left) {\n    if (rect.width == 0)\n        return rect;\n    let x = left ? rect.left : rect.right;\n    return { top: rect.top, bottom: rect.bottom, left: x, right: x };\n}\nfunction flattenH(rect, top) {\n    if (rect.height == 0)\n        return rect;\n    let y = top ? rect.top : rect.bottom;\n    return { top: y, bottom: y, left: rect.left, right: rect.right };\n}\nfunction withFlushedState(view, state, f) {\n    let viewState = view.state, active = view.root.activeElement;\n    if (viewState != state)\n        view.updateState(state);\n    if (active != view.dom)\n        view.focus();\n    try {\n        return f();\n    }\n    finally {\n        if (viewState != state)\n            view.updateState(viewState);\n        if (active != view.dom && active)\n            active.focus();\n    }\n}\n// Whether vertical position motion in a given direction\n// from a position would leave a text block.\nfunction endOfTextblockVertical(view, state, dir) {\n    let sel = state.selection;\n    let $pos = dir == \"up\" ? sel.$from : sel.$to;\n    return withFlushedState(view, state, () => {\n        let { node: dom } = view.docView.domFromPos($pos.pos, dir == \"up\" ? -1 : 1);\n        for (;;) {\n            let nearest = view.docView.nearestDesc(dom, true);\n            if (!nearest)\n                break;\n            if (nearest.node.isBlock) {\n                dom = nearest.contentDOM || nearest.dom;\n                break;\n            }\n            dom = nearest.dom.parentNode;\n        }\n        let coords = coordsAtPos(view, $pos.pos, 1);\n        for (let child = dom.firstChild; child; child = child.nextSibling) {\n            let boxes;\n            if (child.nodeType == 1)\n                boxes = child.getClientRects();\n            else if (child.nodeType == 3)\n                boxes = textRange(child, 0, child.nodeValue.length).getClientRects();\n            else\n                continue;\n            for (let i = 0; i < boxes.length; i++) {\n                let box = boxes[i];\n                if (box.bottom > box.top + 1 &&\n                    (dir == \"up\" ? coords.top - box.top > (box.bottom - coords.top) * 2\n                        : box.bottom - coords.bottom > (coords.bottom - box.top) * 2))\n                    return false;\n            }\n        }\n        return true;\n    });\n}\nconst maybeRTL = /[\\u0590-\\u08ac]/;\nfunction endOfTextblockHorizontal(view, state, dir) {\n    let { $head } = state.selection;\n    if (!$head.parent.isTextblock)\n        return false;\n    let offset = $head.parentOffset, atStart = !offset, atEnd = offset == $head.parent.content.size;\n    let sel = view.domSelection();\n    if (!sel)\n        return $head.pos == $head.start() || $head.pos == $head.end();\n    // If the textblock is all LTR, or the browser doesn't support\n    // Selection.modify (Edge), fall back to a primitive approach\n    if (!maybeRTL.test($head.parent.textContent) || !sel.modify)\n        return dir == \"left\" || dir == \"backward\" ? atStart : atEnd;\n    return withFlushedState(view, state, () => {\n        // This is a huge hack, but appears to be the best we can\n        // currently do: use `Selection.modify` to move the selection by\n        // one character, and see if that moves the cursor out of the\n        // textblock (or doesn't move it at all, when at the start/end of\n        // the document).\n        let { focusNode: oldNode, focusOffset: oldOff, anchorNode, anchorOffset } = view.domSelectionRange();\n        let oldBidiLevel = sel.caretBidiLevel // Only for Firefox\n        ;\n        sel.modify(\"move\", dir, \"character\");\n        let parentDOM = $head.depth ? view.docView.domAfterPos($head.before()) : view.dom;\n        let { focusNode: newNode, focusOffset: newOff } = view.domSelectionRange();\n        let result = newNode && !parentDOM.contains(newNode.nodeType == 1 ? newNode : newNode.parentNode) ||\n            (oldNode == newNode && oldOff == newOff);\n        // Restore the previous selection\n        try {\n            sel.collapse(anchorNode, anchorOffset);\n            if (oldNode && (oldNode != anchorNode || oldOff != anchorOffset) && sel.extend)\n                sel.extend(oldNode, oldOff);\n        }\n        catch (_) { }\n        if (oldBidiLevel != null)\n            sel.caretBidiLevel = oldBidiLevel;\n        return result;\n    });\n}\nlet cachedState = null;\nlet cachedDir = null;\nlet cachedResult = false;\nfunction endOfTextblock(view, state, dir) {\n    if (cachedState == state && cachedDir == dir)\n        return cachedResult;\n    cachedState = state;\n    cachedDir = dir;\n    return cachedResult = dir == \"up\" || dir == \"down\"\n        ? endOfTextblockVertical(view, state, dir)\n        : endOfTextblockHorizontal(view, state, dir);\n}\n\n// View descriptions are data structures that describe the DOM that is\n// used to represent the editor's content. They are used for:\n//\n// - Incremental redrawing when the document changes\n//\n// - Figuring out what part of the document a given DOM position\n//   corresponds to\n//\n// - Wiring in custom implementations of the editing interface for a\n//   given node\n//\n// They form a doubly-linked mutable tree, starting at `view.docView`.\nconst NOT_DIRTY = 0, CHILD_DIRTY = 1, CONTENT_DIRTY = 2, NODE_DIRTY = 3;\n// Superclass for the various kinds of descriptions. Defines their\n// basic structure and shared methods.\nclass ViewDesc {\n    constructor(parent, children, dom, \n    // This is the node that holds the child views. It may be null for\n    // descs that don't have children.\n    contentDOM) {\n        this.parent = parent;\n        this.children = children;\n        this.dom = dom;\n        this.contentDOM = contentDOM;\n        this.dirty = NOT_DIRTY;\n        // An expando property on the DOM node provides a link back to its\n        // description.\n        dom.pmViewDesc = this;\n    }\n    // Used to check whether a given description corresponds to a\n    // widget/mark/node.\n    matchesWidget(widget) { return false; }\n    matchesMark(mark) { return false; }\n    matchesNode(node, outerDeco, innerDeco) { return false; }\n    matchesHack(nodeName) { return false; }\n    // When parsing in-editor content (in domchange.js), we allow\n    // descriptions to determine the parse rules that should be used to\n    // parse them.\n    parseRule() { return null; }\n    // Used by the editor's event handler to ignore events that come\n    // from certain descs.\n    stopEvent(event) { return false; }\n    // The size of the content represented by this desc.\n    get size() {\n        let size = 0;\n        for (let i = 0; i < this.children.length; i++)\n            size += this.children[i].size;\n        return size;\n    }\n    // For block nodes, this represents the space taken up by their\n    // start/end tokens.\n    get border() { return 0; }\n    destroy() {\n        this.parent = undefined;\n        if (this.dom.pmViewDesc == this)\n            this.dom.pmViewDesc = undefined;\n        for (let i = 0; i < this.children.length; i++)\n            this.children[i].destroy();\n    }\n    posBeforeChild(child) {\n        for (let i = 0, pos = this.posAtStart;; i++) {\n            let cur = this.children[i];\n            if (cur == child)\n                return pos;\n            pos += cur.size;\n        }\n    }\n    get posBefore() {\n        return this.parent.posBeforeChild(this);\n    }\n    get posAtStart() {\n        return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;\n    }\n    get posAfter() {\n        return this.posBefore + this.size;\n    }\n    get posAtEnd() {\n        return this.posAtStart + this.size - 2 * this.border;\n    }\n    localPosFromDOM(dom, offset, bias) {\n        // If the DOM position is in the content, use the child desc after\n        // it to figure out a position.\n        if (this.contentDOM && this.contentDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode)) {\n            if (bias < 0) {\n                let domBefore, desc;\n                if (dom == this.contentDOM) {\n                    domBefore = dom.childNodes[offset - 1];\n                }\n                else {\n                    while (dom.parentNode != this.contentDOM)\n                        dom = dom.parentNode;\n                    domBefore = dom.previousSibling;\n                }\n                while (domBefore && !((desc = domBefore.pmViewDesc) && desc.parent == this))\n                    domBefore = domBefore.previousSibling;\n                return domBefore ? this.posBeforeChild(desc) + desc.size : this.posAtStart;\n            }\n            else {\n                let domAfter, desc;\n                if (dom == this.contentDOM) {\n                    domAfter = dom.childNodes[offset];\n                }\n                else {\n                    while (dom.parentNode != this.contentDOM)\n                        dom = dom.parentNode;\n                    domAfter = dom.nextSibling;\n                }\n                while (domAfter && !((desc = domAfter.pmViewDesc) && desc.parent == this))\n                    domAfter = domAfter.nextSibling;\n                return domAfter ? this.posBeforeChild(desc) : this.posAtEnd;\n            }\n        }\n        // Otherwise, use various heuristics, falling back on the bias\n        // parameter, to determine whether to return the position at the\n        // start or at the end of this view desc.\n        let atEnd;\n        if (dom == this.dom && this.contentDOM) {\n            atEnd = offset > domIndex(this.contentDOM);\n        }\n        else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) {\n            atEnd = dom.compareDocumentPosition(this.contentDOM) & 2;\n        }\n        else if (this.dom.firstChild) {\n            if (offset == 0)\n                for (let search = dom;; search = search.parentNode) {\n                    if (search == this.dom) {\n                        atEnd = false;\n                        break;\n                    }\n                    if (search.previousSibling)\n                        break;\n                }\n            if (atEnd == null && offset == dom.childNodes.length)\n                for (let search = dom;; search = search.parentNode) {\n                    if (search == this.dom) {\n                        atEnd = true;\n                        break;\n                    }\n                    if (search.nextSibling)\n                        break;\n                }\n        }\n        return (atEnd == null ? bias > 0 : atEnd) ? this.posAtEnd : this.posAtStart;\n    }\n    nearestDesc(dom, onlyNodes = false) {\n        for (let first = true, cur = dom; cur; cur = cur.parentNode) {\n            let desc = this.getDesc(cur), nodeDOM;\n            if (desc && (!onlyNodes || desc.node)) {\n                // If dom is outside of this desc's nodeDOM, don't count it.\n                if (first && (nodeDOM = desc.nodeDOM) &&\n                    !(nodeDOM.nodeType == 1 ? nodeDOM.contains(dom.nodeType == 1 ? dom : dom.parentNode) : nodeDOM == dom))\n                    first = false;\n                else\n                    return desc;\n            }\n        }\n    }\n    getDesc(dom) {\n        let desc = dom.pmViewDesc;\n        for (let cur = desc; cur; cur = cur.parent)\n            if (cur == this)\n                return desc;\n    }\n    posFromDOM(dom, offset, bias) {\n        for (let scan = dom; scan; scan = scan.parentNode) {\n            let desc = this.getDesc(scan);\n            if (desc)\n                return desc.localPosFromDOM(dom, offset, bias);\n        }\n        return -1;\n    }\n    // Find the desc for the node after the given pos, if any. (When a\n    // parent node overrode rendering, there might not be one.)\n    descAt(pos) {\n        for (let i = 0, offset = 0; i < this.children.length; i++) {\n            let child = this.children[i], end = offset + child.size;\n            if (offset == pos && end != offset) {\n                while (!child.border && child.children.length) {\n                    for (let i = 0; i < child.children.length; i++) {\n                        let inner = child.children[i];\n                        if (inner.size) {\n                            child = inner;\n                            break;\n                        }\n                    }\n                }\n                return child;\n            }\n            if (pos < end)\n                return child.descAt(pos - offset - child.border);\n            offset = end;\n        }\n    }\n    domFromPos(pos, side) {\n        if (!this.contentDOM)\n            return { node: this.dom, offset: 0, atom: pos + 1 };\n        // First find the position in the child array\n        let i = 0, offset = 0;\n        for (let curPos = 0; i < this.children.length; i++) {\n            let child = this.children[i], end = curPos + child.size;\n            if (end > pos || child instanceof TrailingHackViewDesc) {\n                offset = pos - curPos;\n                break;\n            }\n            curPos = end;\n        }\n        // If this points into the middle of a child, call through\n        if (offset)\n            return this.children[i].domFromPos(offset - this.children[i].border, side);\n        // Go back if there were any zero-length widgets with side >= 0 before this point\n        for (let prev; i && !(prev = this.children[i - 1]).size && prev instanceof WidgetViewDesc && prev.side >= 0; i--) { }\n        // Scan towards the first useable node\n        if (side <= 0) {\n            let prev, enter = true;\n            for (;; i--, enter = false) {\n                prev = i ? this.children[i - 1] : null;\n                if (!prev || prev.dom.parentNode == this.contentDOM)\n                    break;\n            }\n            if (prev && side && enter && !prev.border && !prev.domAtom)\n                return prev.domFromPos(prev.size, side);\n            return { node: this.contentDOM, offset: prev ? domIndex(prev.dom) + 1 : 0 };\n        }\n        else {\n            let next, enter = true;\n            for (;; i++, enter = false) {\n                next = i < this.children.length ? this.children[i] : null;\n                if (!next || next.dom.parentNode == this.contentDOM)\n                    break;\n            }\n            if (next && enter && !next.border && !next.domAtom)\n                return next.domFromPos(0, side);\n            return { node: this.contentDOM, offset: next ? domIndex(next.dom) : this.contentDOM.childNodes.length };\n        }\n    }\n    // Used to find a DOM range in a single parent for a given changed\n    // range.\n    parseRange(from, to, base = 0) {\n        if (this.children.length == 0)\n            return { node: this.contentDOM, from, to, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };\n        let fromOffset = -1, toOffset = -1;\n        for (let offset = base, i = 0;; i++) {\n            let child = this.children[i], end = offset + child.size;\n            if (fromOffset == -1 && from <= end) {\n                let childBase = offset + child.border;\n                // FIXME maybe descend mark views to parse a narrower range?\n                if (from >= childBase && to <= end - child.border && child.node &&\n                    child.contentDOM && this.contentDOM.contains(child.contentDOM))\n                    return child.parseRange(from, to, childBase);\n                from = offset;\n                for (let j = i; j > 0; j--) {\n                    let prev = this.children[j - 1];\n                    if (prev.size && prev.dom.parentNode == this.contentDOM && !prev.emptyChildAt(1)) {\n                        fromOffset = domIndex(prev.dom) + 1;\n                        break;\n                    }\n                    from -= prev.size;\n                }\n                if (fromOffset == -1)\n                    fromOffset = 0;\n            }\n            if (fromOffset > -1 && (end > to || i == this.children.length - 1)) {\n                to = end;\n                for (let j = i + 1; j < this.children.length; j++) {\n                    let next = this.children[j];\n                    if (next.size && next.dom.parentNode == this.contentDOM && !next.emptyChildAt(-1)) {\n                        toOffset = domIndex(next.dom);\n                        break;\n                    }\n                    to += next.size;\n                }\n                if (toOffset == -1)\n                    toOffset = this.contentDOM.childNodes.length;\n                break;\n            }\n            offset = end;\n        }\n        return { node: this.contentDOM, from, to, fromOffset, toOffset };\n    }\n    emptyChildAt(side) {\n        if (this.border || !this.contentDOM || !this.children.length)\n            return false;\n        let child = this.children[side < 0 ? 0 : this.children.length - 1];\n        return child.size == 0 || child.emptyChildAt(side);\n    }\n    domAfterPos(pos) {\n        let { node, offset } = this.domFromPos(pos, 0);\n        if (node.nodeType != 1 || offset == node.childNodes.length)\n            throw new RangeError(\"No node after pos \" + pos);\n        return node.childNodes[offset];\n    }\n    // View descs are responsible for setting any selection that falls\n    // entirely inside of them, so that custom implementations can do\n    // custom things with the selection. Note that this falls apart when\n    // a selection starts in such a node and ends in another, in which\n    // case we just use whatever domFromPos produces as a best effort.\n    setSelection(anchor, head, view, force = false) {\n        // If the selection falls entirely in a child, give it to that child\n        let from = Math.min(anchor, head), to = Math.max(anchor, head);\n        for (let i = 0, offset = 0; i < this.children.length; i++) {\n            let child = this.children[i], end = offset + child.size;\n            if (from > offset && to < end)\n                return child.setSelection(anchor - offset - child.border, head - offset - child.border, view, force);\n            offset = end;\n        }\n        let anchorDOM = this.domFromPos(anchor, anchor ? -1 : 1);\n        let headDOM = head == anchor ? anchorDOM : this.domFromPos(head, head ? -1 : 1);\n        let domSel = view.root.getSelection();\n        let selRange = view.domSelectionRange();\n        let brKludge = false;\n        // On Firefox, using Selection.collapse to put the cursor after a\n        // BR node for some reason doesn't always work (#1073). On Safari,\n        // the cursor sometimes inexplicable visually lags behind its\n        // reported position in such situations (#1092).\n        if ((gecko || safari) && anchor == head) {\n            let { node, offset } = anchorDOM;\n            if (node.nodeType == 3) {\n                brKludge = !!(offset && node.nodeValue[offset - 1] == \"\\n\");\n                // Issue #1128\n                if (brKludge && offset == node.nodeValue.length) {\n                    for (let scan = node, after; scan; scan = scan.parentNode) {\n                        if (after = scan.nextSibling) {\n                            if (after.nodeName == \"BR\")\n                                anchorDOM = headDOM = { node: after.parentNode, offset: domIndex(after) + 1 };\n                            break;\n                        }\n                        let desc = scan.pmViewDesc;\n                        if (desc && desc.node && desc.node.isBlock)\n                            break;\n                    }\n                }\n            }\n            else {\n                let prev = node.childNodes[offset - 1];\n                brKludge = prev && (prev.nodeName == \"BR\" || prev.contentEditable == \"false\");\n            }\n        }\n        // Firefox can act strangely when the selection is in front of an\n        // uneditable node. See #1163 and https://bugzilla.mozilla.org/show_bug.cgi?id=1709536\n        if (gecko && selRange.focusNode && selRange.focusNode != headDOM.node && selRange.focusNode.nodeType == 1) {\n            let after = selRange.focusNode.childNodes[selRange.focusOffset];\n            if (after && after.contentEditable == \"false\")\n                force = true;\n        }\n        if (!(force || brKludge && safari) &&\n            isEquivalentPosition(anchorDOM.node, anchorDOM.offset, selRange.anchorNode, selRange.anchorOffset) &&\n            isEquivalentPosition(headDOM.node, headDOM.offset, selRange.focusNode, selRange.focusOffset))\n            return;\n        // Selection.extend can be used to create an 'inverted' selection\n        // (one where the focus is before the anchor), but not all\n        // browsers support it yet.\n        let domSelExtended = false;\n        if ((domSel.extend || anchor == head) && !(brKludge && gecko)) {\n            domSel.collapse(anchorDOM.node, anchorDOM.offset);\n            try {\n                if (anchor != head)\n                    domSel.extend(headDOM.node, headDOM.offset);\n                domSelExtended = true;\n            }\n            catch (_) {\n                // In some cases with Chrome the selection is empty after calling\n                // collapse, even when it should be valid. This appears to be a bug, but\n                // it is difficult to isolate. If this happens fallback to the old path\n                // without using extend.\n                // Similarly, this could crash on Safari if the editor is hidden, and\n                // there was no selection.\n            }\n        }\n        if (!domSelExtended) {\n            if (anchor > head) {\n                let tmp = anchorDOM;\n                anchorDOM = headDOM;\n                headDOM = tmp;\n            }\n            let range = document.createRange();\n            range.setEnd(headDOM.node, headDOM.offset);\n            range.setStart(anchorDOM.node, anchorDOM.offset);\n            domSel.removeAllRanges();\n            domSel.addRange(range);\n        }\n    }\n    ignoreMutation(mutation) {\n        return !this.contentDOM && mutation.type != \"selection\";\n    }\n    get contentLost() {\n        return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);\n    }\n    // Remove a subtree of the element tree that has been touched\n    // by a DOM change, so that the next update will redraw it.\n    markDirty(from, to) {\n        for (let offset = 0, i = 0; i < this.children.length; i++) {\n            let child = this.children[i], end = offset + child.size;\n            if (offset == end ? from <= end && to >= offset : from < end && to > offset) {\n                let startInside = offset + child.border, endInside = end - child.border;\n                if (from >= startInside && to <= endInside) {\n                    this.dirty = from == offset || to == end ? CONTENT_DIRTY : CHILD_DIRTY;\n                    if (from == startInside && to == endInside &&\n                        (child.contentLost || child.dom.parentNode != this.contentDOM))\n                        child.dirty = NODE_DIRTY;\n                    else\n                        child.markDirty(from - startInside, to - startInside);\n                    return;\n                }\n                else {\n                    child.dirty = child.dom == child.contentDOM && child.dom.parentNode == this.contentDOM && !child.children.length\n                        ? CONTENT_DIRTY : NODE_DIRTY;\n                }\n            }\n            offset = end;\n        }\n        this.dirty = CONTENT_DIRTY;\n    }\n    markParentsDirty() {\n        let level = 1;\n        for (let node = this.parent; node; node = node.parent, level++) {\n            let dirty = level == 1 ? CONTENT_DIRTY : CHILD_DIRTY;\n            if (node.dirty < dirty)\n                node.dirty = dirty;\n        }\n    }\n    get domAtom() { return false; }\n    get ignoreForCoords() { return false; }\n    get ignoreForSelection() { return false; }\n    isText(text) { return false; }\n}\n// A widget desc represents a widget decoration, which is a DOM node\n// drawn between the document nodes.\nclass WidgetViewDesc extends ViewDesc {\n    constructor(parent, widget, view, pos) {\n        let self, dom = widget.type.toDOM;\n        if (typeof dom == \"function\")\n            dom = dom(view, () => {\n                if (!self)\n                    return pos;\n                if (self.parent)\n                    return self.parent.posBeforeChild(self);\n            });\n        if (!widget.type.spec.raw) {\n            if (dom.nodeType != 1) {\n                let wrap = document.createElement(\"span\");\n                wrap.appendChild(dom);\n                dom = wrap;\n            }\n            dom.contentEditable = \"false\";\n            dom.classList.add(\"ProseMirror-widget\");\n        }\n        super(parent, [], dom, null);\n        this.widget = widget;\n        this.widget = widget;\n        self = this;\n    }\n    matchesWidget(widget) {\n        return this.dirty == NOT_DIRTY && widget.type.eq(this.widget.type);\n    }\n    parseRule() { return { ignore: true }; }\n    stopEvent(event) {\n        let stop = this.widget.spec.stopEvent;\n        return stop ? stop(event) : false;\n    }\n    ignoreMutation(mutation) {\n        return mutation.type != \"selection\" || this.widget.spec.ignoreSelection;\n    }\n    destroy() {\n        this.widget.type.destroy(this.dom);\n        super.destroy();\n    }\n    get domAtom() { return true; }\n    get ignoreForSelection() { return !!this.widget.type.spec.relaxedSide; }\n    get side() { return this.widget.type.side; }\n}\nclass CompositionViewDesc extends ViewDesc {\n    constructor(parent, dom, textDOM, text) {\n        super(parent, [], dom, null);\n        this.textDOM = textDOM;\n        this.text = text;\n    }\n    get size() { return this.text.length; }\n    localPosFromDOM(dom, offset) {\n        if (dom != this.textDOM)\n            return this.posAtStart + (offset ? this.size : 0);\n        return this.posAtStart + offset;\n    }\n    domFromPos(pos) {\n        return { node: this.textDOM, offset: pos };\n    }\n    ignoreMutation(mut) {\n        return mut.type === 'characterData' && mut.target.nodeValue == mut.oldValue;\n    }\n}\n// A mark desc represents a mark. May have multiple children,\n// depending on how the mark is split. Note that marks are drawn using\n// a fixed nesting order, for simplicity and predictability, so in\n// some cases they will be split more often than would appear\n// necessary.\nclass MarkViewDesc extends ViewDesc {\n    constructor(parent, mark, dom, contentDOM, spec) {\n        super(parent, [], dom, contentDOM);\n        this.mark = mark;\n        this.spec = spec;\n    }\n    static create(parent, mark, inline, view) {\n        let custom = view.nodeViews[mark.type.name];\n        let spec = custom && custom(mark, view, inline);\n        if (!spec || !spec.dom)\n            spec = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer.renderSpec(document, mark.type.spec.toDOM(mark, inline), null, mark.attrs);\n        return new MarkViewDesc(parent, mark, spec.dom, spec.contentDOM || spec.dom, spec);\n    }\n    parseRule() {\n        if ((this.dirty & NODE_DIRTY) || this.mark.type.spec.reparseInView)\n            return null;\n        return { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };\n    }\n    matchesMark(mark) { return this.dirty != NODE_DIRTY && this.mark.eq(mark); }\n    markDirty(from, to) {\n        super.markDirty(from, to);\n        // Move dirty info to nearest node view\n        if (this.dirty != NOT_DIRTY) {\n            let parent = this.parent;\n            while (!parent.node)\n                parent = parent.parent;\n            if (parent.dirty < this.dirty)\n                parent.dirty = this.dirty;\n            this.dirty = NOT_DIRTY;\n        }\n    }\n    slice(from, to, view) {\n        let copy = MarkViewDesc.create(this.parent, this.mark, true, view);\n        let nodes = this.children, size = this.size;\n        if (to < size)\n            nodes = replaceNodes(nodes, to, size, view);\n        if (from > 0)\n            nodes = replaceNodes(nodes, 0, from, view);\n        for (let i = 0; i < nodes.length; i++)\n            nodes[i].parent = copy;\n        copy.children = nodes;\n        return copy;\n    }\n    ignoreMutation(mutation) {\n        return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);\n    }\n    destroy() {\n        if (this.spec.destroy)\n            this.spec.destroy();\n        super.destroy();\n    }\n}\n// Node view descs are the main, most common type of view desc, and\n// correspond to an actual node in the document. Unlike mark descs,\n// they populate their child array themselves.\nclass NodeViewDesc extends ViewDesc {\n    constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos) {\n        super(parent, [], dom, contentDOM);\n        this.node = node;\n        this.outerDeco = outerDeco;\n        this.innerDeco = innerDeco;\n        this.nodeDOM = nodeDOM;\n    }\n    // By default, a node is rendered using the `toDOM` method from the\n    // node type spec. But client code can use the `nodeViews` spec to\n    // supply a custom node view, which can influence various aspects of\n    // the way the node works.\n    //\n    // (Using subclassing for this was intentionally decided against,\n    // since it'd require exposing a whole slew of finicky\n    // implementation details to the user code that they probably will\n    // never need.)\n    static create(parent, node, outerDeco, innerDeco, view, pos) {\n        let custom = view.nodeViews[node.type.name], descObj;\n        let spec = custom && custom(node, view, () => {\n            // (This is a function that allows the custom view to find its\n            // own position)\n            if (!descObj)\n                return pos;\n            if (descObj.parent)\n                return descObj.parent.posBeforeChild(descObj);\n        }, outerDeco, innerDeco);\n        let dom = spec && spec.dom, contentDOM = spec && spec.contentDOM;\n        if (node.isText) {\n            if (!dom)\n                dom = document.createTextNode(node.text);\n            else if (dom.nodeType != 3)\n                throw new RangeError(\"Text must be rendered as a DOM text node\");\n        }\n        else if (!dom) {\n            let spec = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer.renderSpec(document, node.type.spec.toDOM(node), null, node.attrs);\n            ({ dom, contentDOM } = spec);\n        }\n        if (!contentDOM && !node.isText && dom.nodeName != \"BR\") { // Chrome gets confused by <br contenteditable=false>\n            if (!dom.hasAttribute(\"contenteditable\"))\n                dom.contentEditable = \"false\";\n            if (node.type.spec.draggable)\n                dom.draggable = true;\n        }\n        let nodeDOM = dom;\n        dom = applyOuterDeco(dom, outerDeco, node);\n        if (spec)\n            return descObj = new CustomNodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, spec, view, pos + 1);\n        else if (node.isText)\n            return new TextViewDesc(parent, node, outerDeco, innerDeco, dom, nodeDOM, view);\n        else\n            return new NodeViewDesc(parent, node, outerDeco, innerDeco, dom, contentDOM || null, nodeDOM, view, pos + 1);\n    }\n    parseRule() {\n        // Experimental kludge to allow opt-in re-parsing of nodes\n        if (this.node.type.spec.reparseInView)\n            return null;\n        // FIXME the assumption that this can always return the current\n        // attrs means that if the user somehow manages to change the\n        // attrs in the dom, that won't be picked up. Not entirely sure\n        // whether this is a problem\n        let rule = { node: this.node.type.name, attrs: this.node.attrs };\n        if (this.node.type.whitespace == \"pre\")\n            rule.preserveWhitespace = \"full\";\n        if (!this.contentDOM) {\n            rule.getContent = () => this.node.content;\n        }\n        else if (!this.contentLost) {\n            rule.contentElement = this.contentDOM;\n        }\n        else {\n            // Chrome likes to randomly recreate parent nodes when\n            // backspacing things. When that happens, this tries to find the\n            // new parent.\n            for (let i = this.children.length - 1; i >= 0; i--) {\n                let child = this.children[i];\n                if (this.dom.contains(child.dom.parentNode)) {\n                    rule.contentElement = child.dom.parentNode;\n                    break;\n                }\n            }\n            if (!rule.contentElement)\n                rule.getContent = () => prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty;\n        }\n        return rule;\n    }\n    matchesNode(node, outerDeco, innerDeco) {\n        return this.dirty == NOT_DIRTY && node.eq(this.node) &&\n            sameOuterDeco(outerDeco, this.outerDeco) && innerDeco.eq(this.innerDeco);\n    }\n    get size() { return this.node.nodeSize; }\n    get border() { return this.node.isLeaf ? 0 : 1; }\n    // Syncs `this.children` to match `this.node.content` and the local\n    // decorations, possibly introducing nesting for marks. Then, in a\n    // separate step, syncs the DOM inside `this.contentDOM` to\n    // `this.children`.\n    updateChildren(view, pos) {\n        let inline = this.node.inlineContent, off = pos;\n        let composition = view.composing ? this.localCompositionInfo(view, pos) : null;\n        let localComposition = composition && composition.pos > -1 ? composition : null;\n        let compositionInChild = composition && composition.pos < 0;\n        let updater = new ViewTreeUpdater(this, localComposition && localComposition.node, view);\n        iterDeco(this.node, this.innerDeco, (widget, i, insideNode) => {\n            if (widget.spec.marks)\n                updater.syncToMarks(widget.spec.marks, inline, view);\n            else if (widget.type.side >= 0 && !insideNode)\n                updater.syncToMarks(i == this.node.childCount ? prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Mark.none : this.node.child(i).marks, inline, view);\n            // If the next node is a desc matching this widget, reuse it,\n            // otherwise insert the widget as a new view desc.\n            updater.placeWidget(widget, view, off);\n        }, (child, outerDeco, innerDeco, i) => {\n            // Make sure the wrapping mark descs match the node's marks.\n            updater.syncToMarks(child.marks, inline, view);\n            // Try several strategies for drawing this node\n            let compIndex;\n            if (updater.findNodeMatch(child, outerDeco, innerDeco, i)) ;\n            else if (compositionInChild && view.state.selection.from > off &&\n                view.state.selection.to < off + child.nodeSize &&\n                (compIndex = updater.findIndexWithChild(composition.node)) > -1 &&\n                updater.updateNodeAt(child, outerDeco, innerDeco, compIndex, view)) ;\n            else if (updater.updateNextNode(child, outerDeco, innerDeco, view, i, off)) ;\n            else {\n                // Add it as a new view\n                updater.addNode(child, outerDeco, innerDeco, view, off);\n            }\n            off += child.nodeSize;\n        });\n        // Drop all remaining descs after the current position.\n        updater.syncToMarks([], inline, view);\n        if (this.node.isTextblock)\n            updater.addTextblockHacks();\n        updater.destroyRest();\n        // Sync the DOM if anything changed\n        if (updater.changed || this.dirty == CONTENT_DIRTY) {\n            // May have to protect focused DOM from being changed if a composition is active\n            if (localComposition)\n                this.protectLocalComposition(view, localComposition);\n            renderDescs(this.contentDOM, this.children, view);\n            if (ios)\n                iosHacks(this.dom);\n        }\n    }\n    localCompositionInfo(view, pos) {\n        // Only do something if both the selection and a focused text node\n        // are inside of this node\n        let { from, to } = view.state.selection;\n        if (!(view.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection) || from < pos || to > pos + this.node.content.size)\n            return null;\n        let textNode = view.input.compositionNode;\n        if (!textNode || !this.dom.contains(textNode.parentNode))\n            return null;\n        if (this.node.inlineContent) {\n            // Find the text in the focused node in the node, stop if it's not\n            // there (may have been modified through other means, in which\n            // case it should overwritten)\n            let text = textNode.nodeValue;\n            let textPos = findTextInFragment(this.node.content, text, from - pos, to - pos);\n            return textPos < 0 ? null : { node: textNode, pos: textPos, text };\n        }\n        else {\n            return { node: textNode, pos: -1, text: \"\" };\n        }\n    }\n    protectLocalComposition(view, { node, pos, text }) {\n        // The node is already part of a local view desc, leave it there\n        if (this.getDesc(node))\n            return;\n        // Create a composition view for the orphaned nodes\n        let topNode = node;\n        for (;; topNode = topNode.parentNode) {\n            if (topNode.parentNode == this.contentDOM)\n                break;\n            while (topNode.previousSibling)\n                topNode.parentNode.removeChild(topNode.previousSibling);\n            while (topNode.nextSibling)\n                topNode.parentNode.removeChild(topNode.nextSibling);\n            if (topNode.pmViewDesc)\n                topNode.pmViewDesc = undefined;\n        }\n        let desc = new CompositionViewDesc(this, topNode, node, text);\n        view.input.compositionNodes.push(desc);\n        // Patch up this.children to contain the composition view\n        this.children = replaceNodes(this.children, pos, pos + text.length, view, desc);\n    }\n    // If this desc must be updated to match the given node decoration,\n    // do so and return true.\n    update(node, outerDeco, innerDeco, view) {\n        if (this.dirty == NODE_DIRTY ||\n            !node.sameMarkup(this.node))\n            return false;\n        this.updateInner(node, outerDeco, innerDeco, view);\n        return true;\n    }\n    updateInner(node, outerDeco, innerDeco, view) {\n        this.updateOuterDeco(outerDeco);\n        this.node = node;\n        this.innerDeco = innerDeco;\n        if (this.contentDOM)\n            this.updateChildren(view, this.posAtStart);\n        this.dirty = NOT_DIRTY;\n    }\n    updateOuterDeco(outerDeco) {\n        if (sameOuterDeco(outerDeco, this.outerDeco))\n            return;\n        let needsWrap = this.nodeDOM.nodeType != 1;\n        let oldDOM = this.dom;\n        this.dom = patchOuterDeco(this.dom, this.nodeDOM, computeOuterDeco(this.outerDeco, this.node, needsWrap), computeOuterDeco(outerDeco, this.node, needsWrap));\n        if (this.dom != oldDOM) {\n            oldDOM.pmViewDesc = undefined;\n            this.dom.pmViewDesc = this;\n        }\n        this.outerDeco = outerDeco;\n    }\n    // Mark this node as being the selected node.\n    selectNode() {\n        if (this.nodeDOM.nodeType == 1) {\n            this.nodeDOM.classList.add(\"ProseMirror-selectednode\");\n            if (this.contentDOM || !this.node.type.spec.draggable)\n                this.nodeDOM.draggable = true;\n        }\n    }\n    // Remove selected node marking from this node.\n    deselectNode() {\n        if (this.nodeDOM.nodeType == 1) {\n            this.nodeDOM.classList.remove(\"ProseMirror-selectednode\");\n            if (this.contentDOM || !this.node.type.spec.draggable)\n                this.nodeDOM.removeAttribute(\"draggable\");\n        }\n    }\n    get domAtom() { return this.node.isAtom; }\n}\n// Create a view desc for the top-level document node, to be exported\n// and used by the view class.\nfunction docViewDesc(doc, outerDeco, innerDeco, dom, view) {\n    applyOuterDeco(dom, outerDeco, doc);\n    let docView = new NodeViewDesc(undefined, doc, outerDeco, innerDeco, dom, dom, dom, view, 0);\n    if (docView.contentDOM)\n        docView.updateChildren(view, 0);\n    return docView;\n}\nclass TextViewDesc extends NodeViewDesc {\n    constructor(parent, node, outerDeco, innerDeco, dom, nodeDOM, view) {\n        super(parent, node, outerDeco, innerDeco, dom, null, nodeDOM, view, 0);\n    }\n    parseRule() {\n        let skip = this.nodeDOM.parentNode;\n        while (skip && skip != this.dom && !skip.pmIsDeco)\n            skip = skip.parentNode;\n        return { skip: (skip || true) };\n    }\n    update(node, outerDeco, innerDeco, view) {\n        if (this.dirty == NODE_DIRTY || (this.dirty != NOT_DIRTY && !this.inParent()) ||\n            !node.sameMarkup(this.node))\n            return false;\n        this.updateOuterDeco(outerDeco);\n        if ((this.dirty != NOT_DIRTY || node.text != this.node.text) && node.text != this.nodeDOM.nodeValue) {\n            this.nodeDOM.nodeValue = node.text;\n            if (view.trackWrites == this.nodeDOM)\n                view.trackWrites = null;\n        }\n        this.node = node;\n        this.dirty = NOT_DIRTY;\n        return true;\n    }\n    inParent() {\n        let parentDOM = this.parent.contentDOM;\n        for (let n = this.nodeDOM; n; n = n.parentNode)\n            if (n == parentDOM)\n                return true;\n        return false;\n    }\n    domFromPos(pos) {\n        return { node: this.nodeDOM, offset: pos };\n    }\n    localPosFromDOM(dom, offset, bias) {\n        if (dom == this.nodeDOM)\n            return this.posAtStart + Math.min(offset, this.node.text.length);\n        return super.localPosFromDOM(dom, offset, bias);\n    }\n    ignoreMutation(mutation) {\n        return mutation.type != \"characterData\" && mutation.type != \"selection\";\n    }\n    slice(from, to, view) {\n        let node = this.node.cut(from, to), dom = document.createTextNode(node.text);\n        return new TextViewDesc(this.parent, node, this.outerDeco, this.innerDeco, dom, dom, view);\n    }\n    markDirty(from, to) {\n        super.markDirty(from, to);\n        if (this.dom != this.nodeDOM && (from == 0 || to == this.nodeDOM.nodeValue.length))\n            this.dirty = NODE_DIRTY;\n    }\n    get domAtom() { return false; }\n    isText(text) { return this.node.text == text; }\n}\n// A dummy desc used to tag trailing BR or IMG nodes created to work\n// around contentEditable terribleness.\nclass TrailingHackViewDesc extends ViewDesc {\n    parseRule() { return { ignore: true }; }\n    matchesHack(nodeName) { return this.dirty == NOT_DIRTY && this.dom.nodeName == nodeName; }\n    get domAtom() { return true; }\n    get ignoreForCoords() { return this.dom.nodeName == \"IMG\"; }\n}\n// A separate subclass is used for customized node views, so that the\n// extra checks only have to be made for nodes that are actually\n// customized.\nclass CustomNodeViewDesc extends NodeViewDesc {\n    constructor(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, spec, view, pos) {\n        super(parent, node, outerDeco, innerDeco, dom, contentDOM, nodeDOM, view, pos);\n        this.spec = spec;\n    }\n    // A custom `update` method gets to decide whether the update goes\n    // through. If it does, and there's a `contentDOM` node, our logic\n    // updates the children.\n    update(node, outerDeco, innerDeco, view) {\n        if (this.dirty == NODE_DIRTY)\n            return false;\n        if (this.spec.update && (this.node.type == node.type || this.spec.multiType)) {\n            let result = this.spec.update(node, outerDeco, innerDeco);\n            if (result)\n                this.updateInner(node, outerDeco, innerDeco, view);\n            return result;\n        }\n        else if (!this.contentDOM && !node.isLeaf) {\n            return false;\n        }\n        else {\n            return super.update(node, outerDeco, innerDeco, view);\n        }\n    }\n    selectNode() {\n        this.spec.selectNode ? this.spec.selectNode() : super.selectNode();\n    }\n    deselectNode() {\n        this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();\n    }\n    setSelection(anchor, head, view, force) {\n        this.spec.setSelection ? this.spec.setSelection(anchor, head, view.root)\n            : super.setSelection(anchor, head, view, force);\n    }\n    destroy() {\n        if (this.spec.destroy)\n            this.spec.destroy();\n        super.destroy();\n    }\n    stopEvent(event) {\n        return this.spec.stopEvent ? this.spec.stopEvent(event) : false;\n    }\n    ignoreMutation(mutation) {\n        return this.spec.ignoreMutation ? this.spec.ignoreMutation(mutation) : super.ignoreMutation(mutation);\n    }\n}\n// Sync the content of the given DOM node with the nodes associated\n// with the given array of view descs, recursing into mark descs\n// because this should sync the subtree for a whole node at a time.\nfunction renderDescs(parentDOM, descs, view) {\n    let dom = parentDOM.firstChild, written = false;\n    for (let i = 0; i < descs.length; i++) {\n        let desc = descs[i], childDOM = desc.dom;\n        if (childDOM.parentNode == parentDOM) {\n            while (childDOM != dom) {\n                dom = rm(dom);\n                written = true;\n            }\n            dom = dom.nextSibling;\n        }\n        else {\n            written = true;\n            parentDOM.insertBefore(childDOM, dom);\n        }\n        if (desc instanceof MarkViewDesc) {\n            let pos = dom ? dom.previousSibling : parentDOM.lastChild;\n            renderDescs(desc.contentDOM, desc.children, view);\n            dom = pos ? pos.nextSibling : parentDOM.firstChild;\n        }\n    }\n    while (dom) {\n        dom = rm(dom);\n        written = true;\n    }\n    if (written && view.trackWrites == parentDOM)\n        view.trackWrites = null;\n}\nconst OuterDecoLevel = function (nodeName) {\n    if (nodeName)\n        this.nodeName = nodeName;\n};\nOuterDecoLevel.prototype = Object.create(null);\nconst noDeco = [new OuterDecoLevel];\nfunction computeOuterDeco(outerDeco, node, needsWrap) {\n    if (outerDeco.length == 0)\n        return noDeco;\n    let top = needsWrap ? noDeco[0] : new OuterDecoLevel, result = [top];\n    for (let i = 0; i < outerDeco.length; i++) {\n        let attrs = outerDeco[i].type.attrs;\n        if (!attrs)\n            continue;\n        if (attrs.nodeName)\n            result.push(top = new OuterDecoLevel(attrs.nodeName));\n        for (let name in attrs) {\n            let val = attrs[name];\n            if (val == null)\n                continue;\n            if (needsWrap && result.length == 1)\n                result.push(top = new OuterDecoLevel(node.isInline ? \"span\" : \"div\"));\n            if (name == \"class\")\n                top.class = (top.class ? top.class + \" \" : \"\") + val;\n            else if (name == \"style\")\n                top.style = (top.style ? top.style + \";\" : \"\") + val;\n            else if (name != \"nodeName\")\n                top[name] = val;\n        }\n    }\n    return result;\n}\nfunction patchOuterDeco(outerDOM, nodeDOM, prevComputed, curComputed) {\n    // Shortcut for trivial case\n    if (prevComputed == noDeco && curComputed == noDeco)\n        return nodeDOM;\n    let curDOM = nodeDOM;\n    for (let i = 0; i < curComputed.length; i++) {\n        let deco = curComputed[i], prev = prevComputed[i];\n        if (i) {\n            let parent;\n            if (prev && prev.nodeName == deco.nodeName && curDOM != outerDOM &&\n                (parent = curDOM.parentNode) && parent.nodeName.toLowerCase() == deco.nodeName) {\n                curDOM = parent;\n            }\n            else {\n                parent = document.createElement(deco.nodeName);\n                parent.pmIsDeco = true;\n                parent.appendChild(curDOM);\n                prev = noDeco[0];\n                curDOM = parent;\n            }\n        }\n        patchAttributes(curDOM, prev || noDeco[0], deco);\n    }\n    return curDOM;\n}\nfunction patchAttributes(dom, prev, cur) {\n    for (let name in prev)\n        if (name != \"class\" && name != \"style\" && name != \"nodeName\" && !(name in cur))\n            dom.removeAttribute(name);\n    for (let name in cur)\n        if (name != \"class\" && name != \"style\" && name != \"nodeName\" && cur[name] != prev[name])\n            dom.setAttribute(name, cur[name]);\n    if (prev.class != cur.class) {\n        let prevList = prev.class ? prev.class.split(\" \").filter(Boolean) : [];\n        let curList = cur.class ? cur.class.split(\" \").filter(Boolean) : [];\n        for (let i = 0; i < prevList.length; i++)\n            if (curList.indexOf(prevList[i]) == -1)\n                dom.classList.remove(prevList[i]);\n        for (let i = 0; i < curList.length; i++)\n            if (prevList.indexOf(curList[i]) == -1)\n                dom.classList.add(curList[i]);\n        if (dom.classList.length == 0)\n            dom.removeAttribute(\"class\");\n    }\n    if (prev.style != cur.style) {\n        if (prev.style) {\n            let prop = /\\s*([\\w\\-\\xa1-\\uffff]+)\\s*:(?:\"(?:\\\\.|[^\"])*\"|'(?:\\\\.|[^'])*'|\\(.*?\\)|[^;])*/g, m;\n            while (m = prop.exec(prev.style))\n                dom.style.removeProperty(m[1]);\n        }\n        if (cur.style)\n            dom.style.cssText += cur.style;\n    }\n}\nfunction applyOuterDeco(dom, deco, node) {\n    return patchOuterDeco(dom, dom, noDeco, computeOuterDeco(deco, node, dom.nodeType != 1));\n}\nfunction sameOuterDeco(a, b) {\n    if (a.length != b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (!a[i].type.eq(b[i].type))\n            return false;\n    return true;\n}\n// Remove a DOM node and return its next sibling.\nfunction rm(dom) {\n    let next = dom.nextSibling;\n    dom.parentNode.removeChild(dom);\n    return next;\n}\n// Helper class for incrementally updating a tree of mark descs and\n// the widget and node descs inside of them.\nclass ViewTreeUpdater {\n    constructor(top, lock, view) {\n        this.lock = lock;\n        this.view = view;\n        // Index into `this.top`'s child array, represents the current\n        // update position.\n        this.index = 0;\n        // When entering a mark, the current top and index are pushed\n        // onto this.\n        this.stack = [];\n        // Tracks whether anything was changed\n        this.changed = false;\n        this.top = top;\n        this.preMatch = preMatch(top.node.content, top);\n    }\n    // Destroy and remove the children between the given indices in\n    // `this.top`.\n    destroyBetween(start, end) {\n        if (start == end)\n            return;\n        for (let i = start; i < end; i++)\n            this.top.children[i].destroy();\n        this.top.children.splice(start, end - start);\n        this.changed = true;\n    }\n    // Destroy all remaining children in `this.top`.\n    destroyRest() {\n        this.destroyBetween(this.index, this.top.children.length);\n    }\n    // Sync the current stack of mark descs with the given array of\n    // marks, reusing existing mark descs when possible.\n    syncToMarks(marks, inline, view) {\n        let keep = 0, depth = this.stack.length >> 1;\n        let maxKeep = Math.min(depth, marks.length);\n        while (keep < maxKeep &&\n            (keep == depth - 1 ? this.top : this.stack[(keep + 1) << 1])\n                .matchesMark(marks[keep]) && marks[keep].type.spec.spanning !== false)\n            keep++;\n        while (keep < depth) {\n            this.destroyRest();\n            this.top.dirty = NOT_DIRTY;\n            this.index = this.stack.pop();\n            this.top = this.stack.pop();\n            depth--;\n        }\n        while (depth < marks.length) {\n            this.stack.push(this.top, this.index + 1);\n            let found = -1;\n            for (let i = this.index; i < Math.min(this.index + 3, this.top.children.length); i++) {\n                let next = this.top.children[i];\n                if (next.matchesMark(marks[depth]) && !this.isLocked(next.dom)) {\n                    found = i;\n                    break;\n                }\n            }\n            if (found > -1) {\n                if (found > this.index) {\n                    this.changed = true;\n                    this.destroyBetween(this.index, found);\n                }\n                this.top = this.top.children[this.index];\n            }\n            else {\n                let markDesc = MarkViewDesc.create(this.top, marks[depth], inline, view);\n                this.top.children.splice(this.index, 0, markDesc);\n                this.top = markDesc;\n                this.changed = true;\n            }\n            this.index = 0;\n            depth++;\n        }\n    }\n    // Try to find a node desc matching the given data. Skip over it and\n    // return true when successful.\n    findNodeMatch(node, outerDeco, innerDeco, index) {\n        let found = -1, targetDesc;\n        if (index >= this.preMatch.index &&\n            (targetDesc = this.preMatch.matches[index - this.preMatch.index]).parent == this.top &&\n            targetDesc.matchesNode(node, outerDeco, innerDeco)) {\n            found = this.top.children.indexOf(targetDesc, this.index);\n        }\n        else {\n            for (let i = this.index, e = Math.min(this.top.children.length, i + 5); i < e; i++) {\n                let child = this.top.children[i];\n                if (child.matchesNode(node, outerDeco, innerDeco) && !this.preMatch.matched.has(child)) {\n                    found = i;\n                    break;\n                }\n            }\n        }\n        if (found < 0)\n            return false;\n        this.destroyBetween(this.index, found);\n        this.index++;\n        return true;\n    }\n    updateNodeAt(node, outerDeco, innerDeco, index, view) {\n        let child = this.top.children[index];\n        if (child.dirty == NODE_DIRTY && child.dom == child.contentDOM)\n            child.dirty = CONTENT_DIRTY;\n        if (!child.update(node, outerDeco, innerDeco, view))\n            return false;\n        this.destroyBetween(this.index, index);\n        this.index++;\n        return true;\n    }\n    findIndexWithChild(domNode) {\n        for (;;) {\n            let parent = domNode.parentNode;\n            if (!parent)\n                return -1;\n            if (parent == this.top.contentDOM) {\n                let desc = domNode.pmViewDesc;\n                if (desc)\n                    for (let i = this.index; i < this.top.children.length; i++) {\n                        if (this.top.children[i] == desc)\n                            return i;\n                    }\n                return -1;\n            }\n            domNode = parent;\n        }\n    }\n    // Try to update the next node, if any, to the given data. Checks\n    // pre-matches to avoid overwriting nodes that could still be used.\n    updateNextNode(node, outerDeco, innerDeco, view, index, pos) {\n        for (let i = this.index; i < this.top.children.length; i++) {\n            let next = this.top.children[i];\n            if (next instanceof NodeViewDesc) {\n                let preMatch = this.preMatch.matched.get(next);\n                if (preMatch != null && preMatch != index)\n                    return false;\n                let nextDOM = next.dom, updated;\n                // Can't update if nextDOM is or contains this.lock, except if\n                // it's a text node whose content already matches the new text\n                // and whose decorations match the new ones.\n                let locked = this.isLocked(nextDOM) &&\n                    !(node.isText && next.node && next.node.isText && next.nodeDOM.nodeValue == node.text &&\n                        next.dirty != NODE_DIRTY && sameOuterDeco(outerDeco, next.outerDeco));\n                if (!locked && next.update(node, outerDeco, innerDeco, view)) {\n                    this.destroyBetween(this.index, i);\n                    if (next.dom != nextDOM)\n                        this.changed = true;\n                    this.index++;\n                    return true;\n                }\n                else if (!locked && (updated = this.recreateWrapper(next, node, outerDeco, innerDeco, view, pos))) {\n                    this.destroyBetween(this.index, i);\n                    this.top.children[this.index] = updated;\n                    if (updated.contentDOM) {\n                        updated.dirty = CONTENT_DIRTY;\n                        updated.updateChildren(view, pos + 1);\n                        updated.dirty = NOT_DIRTY;\n                    }\n                    this.changed = true;\n                    this.index++;\n                    return true;\n                }\n                break;\n            }\n        }\n        return false;\n    }\n    // When a node with content is replaced by a different node with\n    // identical content, move over its children.\n    recreateWrapper(next, node, outerDeco, innerDeco, view, pos) {\n        if (next.dirty || node.isAtom || !next.children.length ||\n            !next.node.content.eq(node.content) ||\n            !sameOuterDeco(outerDeco, next.outerDeco) || !innerDeco.eq(next.innerDeco))\n            return null;\n        let wrapper = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);\n        if (wrapper.contentDOM) {\n            wrapper.children = next.children;\n            next.children = [];\n            for (let ch of wrapper.children)\n                ch.parent = wrapper;\n        }\n        next.destroy();\n        return wrapper;\n    }\n    // Insert the node as a newly created node desc.\n    addNode(node, outerDeco, innerDeco, view, pos) {\n        let desc = NodeViewDesc.create(this.top, node, outerDeco, innerDeco, view, pos);\n        if (desc.contentDOM)\n            desc.updateChildren(view, pos + 1);\n        this.top.children.splice(this.index++, 0, desc);\n        this.changed = true;\n    }\n    placeWidget(widget, view, pos) {\n        let next = this.index < this.top.children.length ? this.top.children[this.index] : null;\n        if (next && next.matchesWidget(widget) &&\n            (widget == next.widget || !next.widget.type.toDOM.parentNode)) {\n            this.index++;\n        }\n        else {\n            let desc = new WidgetViewDesc(this.top, widget, view, pos);\n            this.top.children.splice(this.index++, 0, desc);\n            this.changed = true;\n        }\n    }\n    // Make sure a textblock looks and behaves correctly in\n    // contentEditable.\n    addTextblockHacks() {\n        let lastChild = this.top.children[this.index - 1], parent = this.top;\n        while (lastChild instanceof MarkViewDesc) {\n            parent = lastChild;\n            lastChild = parent.children[parent.children.length - 1];\n        }\n        if (!lastChild || // Empty textblock\n            !(lastChild instanceof TextViewDesc) ||\n            /\\n$/.test(lastChild.node.text) ||\n            (this.view.requiresGeckoHackNode && /\\s$/.test(lastChild.node.text))) {\n            // Avoid bugs in Safari's cursor drawing (#1165) and Chrome's mouse selection (#1152)\n            if ((safari || chrome) && lastChild && lastChild.dom.contentEditable == \"false\")\n                this.addHackNode(\"IMG\", parent);\n            this.addHackNode(\"BR\", this.top);\n        }\n    }\n    addHackNode(nodeName, parent) {\n        if (parent == this.top && this.index < parent.children.length && parent.children[this.index].matchesHack(nodeName)) {\n            this.index++;\n        }\n        else {\n            let dom = document.createElement(nodeName);\n            if (nodeName == \"IMG\") {\n                dom.className = \"ProseMirror-separator\";\n                dom.alt = \"\";\n            }\n            if (nodeName == \"BR\")\n                dom.className = \"ProseMirror-trailingBreak\";\n            let hack = new TrailingHackViewDesc(this.top, [], dom, null);\n            if (parent != this.top)\n                parent.children.push(hack);\n            else\n                parent.children.splice(this.index++, 0, hack);\n            this.changed = true;\n        }\n    }\n    isLocked(node) {\n        return this.lock && (node == this.lock || node.nodeType == 1 && node.contains(this.lock.parentNode));\n    }\n}\n// Iterate from the end of the fragment and array of descs to find\n// directly matching ones, in order to avoid overeagerly reusing those\n// for other nodes. Returns the fragment index of the first node that\n// is part of the sequence of matched nodes at the end of the\n// fragment.\nfunction preMatch(frag, parentDesc) {\n    let curDesc = parentDesc, descI = curDesc.children.length;\n    let fI = frag.childCount, matched = new Map, matches = [];\n    outer: while (fI > 0) {\n        let desc;\n        for (;;) {\n            if (descI) {\n                let next = curDesc.children[descI - 1];\n                if (next instanceof MarkViewDesc) {\n                    curDesc = next;\n                    descI = next.children.length;\n                }\n                else {\n                    desc = next;\n                    descI--;\n                    break;\n                }\n            }\n            else if (curDesc == parentDesc) {\n                break outer;\n            }\n            else {\n                // FIXME\n                descI = curDesc.parent.children.indexOf(curDesc);\n                curDesc = curDesc.parent;\n            }\n        }\n        let node = desc.node;\n        if (!node)\n            continue;\n        if (node != frag.child(fI - 1))\n            break;\n        --fI;\n        matched.set(desc, fI);\n        matches.push(desc);\n    }\n    return { index: fI, matched, matches: matches.reverse() };\n}\nfunction compareSide(a, b) {\n    return a.type.side - b.type.side;\n}\n// This function abstracts iterating over the nodes and decorations in\n// a fragment. Calls `onNode` for each node, with its local and child\n// decorations. Splits text nodes when there is a decoration starting\n// or ending inside of them. Calls `onWidget` for each widget.\nfunction iterDeco(parent, deco, onWidget, onNode) {\n    let locals = deco.locals(parent), offset = 0;\n    // Simple, cheap variant for when there are no local decorations\n    if (locals.length == 0) {\n        for (let i = 0; i < parent.childCount; i++) {\n            let child = parent.child(i);\n            onNode(child, locals, deco.forChild(offset, child), i);\n            offset += child.nodeSize;\n        }\n        return;\n    }\n    let decoIndex = 0, active = [], restNode = null;\n    for (let parentIndex = 0;;) {\n        let widget, widgets;\n        while (decoIndex < locals.length && locals[decoIndex].to == offset) {\n            let next = locals[decoIndex++];\n            if (next.widget) {\n                if (!widget)\n                    widget = next;\n                else\n                    (widgets || (widgets = [widget])).push(next);\n            }\n        }\n        if (widget) {\n            if (widgets) {\n                widgets.sort(compareSide);\n                for (let i = 0; i < widgets.length; i++)\n                    onWidget(widgets[i], parentIndex, !!restNode);\n            }\n            else {\n                onWidget(widget, parentIndex, !!restNode);\n            }\n        }\n        let child, index;\n        if (restNode) {\n            index = -1;\n            child = restNode;\n            restNode = null;\n        }\n        else if (parentIndex < parent.childCount) {\n            index = parentIndex;\n            child = parent.child(parentIndex++);\n        }\n        else {\n            break;\n        }\n        for (let i = 0; i < active.length; i++)\n            if (active[i].to <= offset)\n                active.splice(i--, 1);\n        while (decoIndex < locals.length && locals[decoIndex].from <= offset && locals[decoIndex].to > offset)\n            active.push(locals[decoIndex++]);\n        let end = offset + child.nodeSize;\n        if (child.isText) {\n            let cutAt = end;\n            if (decoIndex < locals.length && locals[decoIndex].from < cutAt)\n                cutAt = locals[decoIndex].from;\n            for (let i = 0; i < active.length; i++)\n                if (active[i].to < cutAt)\n                    cutAt = active[i].to;\n            if (cutAt < end) {\n                restNode = child.cut(cutAt - offset);\n                child = child.cut(0, cutAt - offset);\n                end = cutAt;\n                index = -1;\n            }\n        }\n        else {\n            while (decoIndex < locals.length && locals[decoIndex].to < end)\n                decoIndex++;\n        }\n        let outerDeco = child.isInline && !child.isLeaf ? active.filter(d => !d.inline) : active.slice();\n        onNode(child, outerDeco, deco.forChild(offset, child), index);\n        offset = end;\n    }\n}\n// List markers in Mobile Safari will mysteriously disappear\n// sometimes. This works around that.\nfunction iosHacks(dom) {\n    if (dom.nodeName == \"UL\" || dom.nodeName == \"OL\") {\n        let oldCSS = dom.style.cssText;\n        dom.style.cssText = oldCSS + \"; list-style: square !important\";\n        window.getComputedStyle(dom).listStyle;\n        dom.style.cssText = oldCSS;\n    }\n}\n// Find a piece of text in an inline fragment, overlapping from-to\nfunction findTextInFragment(frag, text, from, to) {\n    for (let i = 0, pos = 0; i < frag.childCount && pos <= to;) {\n        let child = frag.child(i++), childStart = pos;\n        pos += child.nodeSize;\n        if (!child.isText)\n            continue;\n        let str = child.text;\n        while (i < frag.childCount) {\n            let next = frag.child(i++);\n            pos += next.nodeSize;\n            if (!next.isText)\n                break;\n            str += next.text;\n        }\n        if (pos >= from) {\n            if (pos >= to && str.slice(to - text.length - childStart, to - childStart) == text)\n                return to - text.length;\n            let found = childStart < to ? str.lastIndexOf(text, to - childStart - 1) : -1;\n            if (found >= 0 && found + text.length + childStart >= from)\n                return childStart + found;\n            if (from == to && str.length >= (to + text.length) - childStart &&\n                str.slice(to - childStart, to - childStart + text.length) == text)\n                return to;\n        }\n    }\n    return -1;\n}\n// Replace range from-to in an array of view descs with replacement\n// (may be null to just delete). This goes very much against the grain\n// of the rest of this code, which tends to create nodes with the\n// right shape in one go, rather than messing with them after\n// creation, but is necessary in the composition hack.\nfunction replaceNodes(nodes, from, to, view, replacement) {\n    let result = [];\n    for (let i = 0, off = 0; i < nodes.length; i++) {\n        let child = nodes[i], start = off, end = off += child.size;\n        if (start >= to || end <= from) {\n            result.push(child);\n        }\n        else {\n            if (start < from)\n                result.push(child.slice(0, from - start, view));\n            if (replacement) {\n                result.push(replacement);\n                replacement = undefined;\n            }\n            if (end > to)\n                result.push(child.slice(to - start, child.size, view));\n        }\n    }\n    return result;\n}\n\nfunction selectionFromDOM(view, origin = null) {\n    let domSel = view.domSelectionRange(), doc = view.state.doc;\n    if (!domSel.focusNode)\n        return null;\n    let nearestDesc = view.docView.nearestDesc(domSel.focusNode), inWidget = nearestDesc && nearestDesc.size == 0;\n    let head = view.docView.posFromDOM(domSel.focusNode, domSel.focusOffset, 1);\n    if (head < 0)\n        return null;\n    let $head = doc.resolve(head), anchor, selection;\n    if (selectionCollapsed(domSel)) {\n        anchor = head;\n        while (nearestDesc && !nearestDesc.node)\n            nearestDesc = nearestDesc.parent;\n        let nearestDescNode = nearestDesc.node;\n        if (nearestDesc && nearestDescNode.isAtom && prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(nearestDescNode) && nearestDesc.parent\n            && !(nearestDescNode.isInline && isOnEdge(domSel.focusNode, domSel.focusOffset, nearestDesc.dom))) {\n            let pos = nearestDesc.posBefore;\n            selection = new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection(head == pos ? $head : doc.resolve(pos));\n        }\n    }\n    else {\n        if (domSel instanceof view.dom.ownerDocument.defaultView.Selection && domSel.rangeCount > 1) {\n            let min = head, max = head;\n            for (let i = 0; i < domSel.rangeCount; i++) {\n                let range = domSel.getRangeAt(i);\n                min = Math.min(min, view.docView.posFromDOM(range.startContainer, range.startOffset, 1));\n                max = Math.max(max, view.docView.posFromDOM(range.endContainer, range.endOffset, -1));\n            }\n            if (min < 0)\n                return null;\n            [anchor, head] = max == view.state.selection.anchor ? [max, min] : [min, max];\n            $head = doc.resolve(head);\n        }\n        else {\n            anchor = view.docView.posFromDOM(domSel.anchorNode, domSel.anchorOffset, 1);\n        }\n        if (anchor < 0)\n            return null;\n    }\n    let $anchor = doc.resolve(anchor);\n    if (!selection) {\n        let bias = origin == \"pointer\" || (view.state.selection.head < $head.pos && !inWidget) ? 1 : -1;\n        selection = selectionBetween(view, $anchor, $head, bias);\n    }\n    return selection;\n}\nfunction editorOwnsSelection(view) {\n    return view.editable ? view.hasFocus() :\n        hasSelection(view) && document.activeElement && document.activeElement.contains(view.dom);\n}\nfunction selectionToDOM(view, force = false) {\n    let sel = view.state.selection;\n    syncNodeSelection(view, sel);\n    if (!editorOwnsSelection(view))\n        return;\n    // The delayed drag selection causes issues with Cell Selections\n    // in Safari. And the drag selection delay is to workarond issues\n    // which only present in Chrome.\n    if (!force && view.input.mouseDown && view.input.mouseDown.allowDefault && chrome) {\n        let domSel = view.domSelectionRange(), curSel = view.domObserver.currentSelection;\n        if (domSel.anchorNode && curSel.anchorNode &&\n            isEquivalentPosition(domSel.anchorNode, domSel.anchorOffset, curSel.anchorNode, curSel.anchorOffset)) {\n            view.input.mouseDown.delayedSelectionSync = true;\n            view.domObserver.setCurSelection();\n            return;\n        }\n    }\n    view.domObserver.disconnectSelection();\n    if (view.cursorWrapper) {\n        selectCursorWrapper(view);\n    }\n    else {\n        let { anchor, head } = sel, resetEditableFrom, resetEditableTo;\n        if (brokenSelectBetweenUneditable && !(sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection)) {\n            if (!sel.$from.parent.inlineContent)\n                resetEditableFrom = temporarilyEditableNear(view, sel.from);\n            if (!sel.empty && !sel.$from.parent.inlineContent)\n                resetEditableTo = temporarilyEditableNear(view, sel.to);\n        }\n        view.docView.setSelection(anchor, head, view, force);\n        if (brokenSelectBetweenUneditable) {\n            if (resetEditableFrom)\n                resetEditable(resetEditableFrom);\n            if (resetEditableTo)\n                resetEditable(resetEditableTo);\n        }\n        if (sel.visible) {\n            view.dom.classList.remove(\"ProseMirror-hideselection\");\n        }\n        else {\n            view.dom.classList.add(\"ProseMirror-hideselection\");\n            if (\"onselectionchange\" in document)\n                removeClassOnSelectionChange(view);\n        }\n    }\n    view.domObserver.setCurSelection();\n    view.domObserver.connectSelection();\n}\n// Kludge to work around Webkit not allowing a selection to start/end\n// between non-editable block nodes. We briefly make something\n// editable, set the selection, then set it uneditable again.\nconst brokenSelectBetweenUneditable = safari || chrome && chrome_version < 63;\nfunction temporarilyEditableNear(view, pos) {\n    let { node, offset } = view.docView.domFromPos(pos, 0);\n    let after = offset < node.childNodes.length ? node.childNodes[offset] : null;\n    let before = offset ? node.childNodes[offset - 1] : null;\n    if (safari && after && after.contentEditable == \"false\")\n        return setEditable(after);\n    if ((!after || after.contentEditable == \"false\") &&\n        (!before || before.contentEditable == \"false\")) {\n        if (after)\n            return setEditable(after);\n        else if (before)\n            return setEditable(before);\n    }\n}\nfunction setEditable(element) {\n    element.contentEditable = \"true\";\n    if (safari && element.draggable) {\n        element.draggable = false;\n        element.wasDraggable = true;\n    }\n    return element;\n}\nfunction resetEditable(element) {\n    element.contentEditable = \"false\";\n    if (element.wasDraggable) {\n        element.draggable = true;\n        element.wasDraggable = null;\n    }\n}\nfunction removeClassOnSelectionChange(view) {\n    let doc = view.dom.ownerDocument;\n    doc.removeEventListener(\"selectionchange\", view.input.hideSelectionGuard);\n    let domSel = view.domSelectionRange();\n    let node = domSel.anchorNode, offset = domSel.anchorOffset;\n    doc.addEventListener(\"selectionchange\", view.input.hideSelectionGuard = () => {\n        if (domSel.anchorNode != node || domSel.anchorOffset != offset) {\n            doc.removeEventListener(\"selectionchange\", view.input.hideSelectionGuard);\n            setTimeout(() => {\n                if (!editorOwnsSelection(view) || view.state.selection.visible)\n                    view.dom.classList.remove(\"ProseMirror-hideselection\");\n            }, 20);\n        }\n    });\n}\nfunction selectCursorWrapper(view) {\n    let domSel = view.domSelection();\n    if (!domSel)\n        return;\n    let node = view.cursorWrapper.dom, img = node.nodeName == \"IMG\";\n    if (img)\n        domSel.collapse(node.parentNode, domIndex(node) + 1);\n    else\n        domSel.collapse(node, 0);\n    // Kludge to kill 'control selection' in IE11 when selecting an\n    // invisible cursor wrapper, since that would result in those weird\n    // resize handles and a selection that considers the absolutely\n    // positioned wrapper, rather than the root editable node, the\n    // focused element.\n    if (!img && !view.state.selection.visible && ie && ie_version <= 11) {\n        node.disabled = true;\n        node.disabled = false;\n    }\n}\nfunction syncNodeSelection(view, sel) {\n    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection) {\n        let desc = view.docView.descAt(sel.from);\n        if (desc != view.lastSelectedViewDesc) {\n            clearNodeSelection(view);\n            if (desc)\n                desc.selectNode();\n            view.lastSelectedViewDesc = desc;\n        }\n    }\n    else {\n        clearNodeSelection(view);\n    }\n}\n// Clear all DOM statefulness of the last node selection.\nfunction clearNodeSelection(view) {\n    if (view.lastSelectedViewDesc) {\n        if (view.lastSelectedViewDesc.parent)\n            view.lastSelectedViewDesc.deselectNode();\n        view.lastSelectedViewDesc = undefined;\n    }\n}\nfunction selectionBetween(view, $anchor, $head, bias) {\n    return view.someProp(\"createSelectionBetween\", f => f(view, $anchor, $head))\n        || prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.between($anchor, $head, bias);\n}\nfunction hasFocusAndSelection(view) {\n    if (view.editable && !view.hasFocus())\n        return false;\n    return hasSelection(view);\n}\nfunction hasSelection(view) {\n    let sel = view.domSelectionRange();\n    if (!sel.anchorNode)\n        return false;\n    try {\n        // Firefox will raise 'permission denied' errors when accessing\n        // properties of `sel.anchorNode` when it's in a generated CSS\n        // element.\n        return view.dom.contains(sel.anchorNode.nodeType == 3 ? sel.anchorNode.parentNode : sel.anchorNode) &&\n            (view.editable || view.dom.contains(sel.focusNode.nodeType == 3 ? sel.focusNode.parentNode : sel.focusNode));\n    }\n    catch (_) {\n        return false;\n    }\n}\nfunction anchorInRightPlace(view) {\n    let anchorDOM = view.docView.domFromPos(view.state.selection.anchor, 0);\n    let domSel = view.domSelectionRange();\n    return isEquivalentPosition(anchorDOM.node, anchorDOM.offset, domSel.anchorNode, domSel.anchorOffset);\n}\n\nfunction moveSelectionBlock(state, dir) {\n    let { $anchor, $head } = state.selection;\n    let $side = dir > 0 ? $anchor.max($head) : $anchor.min($head);\n    let $start = !$side.parent.inlineContent ? $side : $side.depth ? state.doc.resolve(dir > 0 ? $side.after() : $side.before()) : null;\n    return $start && prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom($start, dir);\n}\nfunction apply(view, sel) {\n    view.dispatch(view.state.tr.setSelection(sel).scrollIntoView());\n    return true;\n}\nfunction selectHorizontally(view, dir, mods) {\n    let sel = view.state.selection;\n    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection) {\n        if (mods.indexOf(\"s\") > -1) {\n            let { $head } = sel, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter;\n            if (!node || node.isText || !node.isLeaf)\n                return false;\n            let $newHead = view.state.doc.resolve($head.pos + node.nodeSize * (dir < 0 ? -1 : 1));\n            return apply(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection(sel.$anchor, $newHead));\n        }\n        else if (!sel.empty) {\n            return false;\n        }\n        else if (view.endOfTextblock(dir > 0 ? \"forward\" : \"backward\")) {\n            let next = moveSelectionBlock(view.state, dir);\n            if (next && (next instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection))\n                return apply(view, next);\n            return false;\n        }\n        else if (!(mac && mods.indexOf(\"m\") > -1)) {\n            let $head = sel.$head, node = $head.textOffset ? null : dir < 0 ? $head.nodeBefore : $head.nodeAfter, desc;\n            if (!node || node.isText)\n                return false;\n            let nodePos = dir < 0 ? $head.pos - node.nodeSize : $head.pos;\n            if (!(node.isAtom || (desc = view.docView.descAt(nodePos)) && !desc.contentDOM))\n                return false;\n            if (prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node)) {\n                return apply(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection(dir < 0 ? view.state.doc.resolve($head.pos - node.nodeSize) : $head));\n            }\n            else if (webkit) {\n                // Chrome and Safari will introduce extra pointless cursor\n                // positions around inline uneditable nodes, so we have to\n                // take over and move the cursor past them (#937)\n                return apply(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection(view.state.doc.resolve(dir < 0 ? nodePos : nodePos + node.nodeSize)));\n            }\n            else {\n                return false;\n            }\n        }\n    }\n    else if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection && sel.node.isInline) {\n        return apply(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection(dir > 0 ? sel.$to : sel.$from));\n    }\n    else {\n        let next = moveSelectionBlock(view.state, dir);\n        if (next)\n            return apply(view, next);\n        return false;\n    }\n}\nfunction nodeLen(node) {\n    return node.nodeType == 3 ? node.nodeValue.length : node.childNodes.length;\n}\nfunction isIgnorable(dom, dir) {\n    let desc = dom.pmViewDesc;\n    return desc && desc.size == 0 && (dir < 0 || dom.nextSibling || dom.nodeName != \"BR\");\n}\nfunction skipIgnoredNodes(view, dir) {\n    return dir < 0 ? skipIgnoredNodesBefore(view) : skipIgnoredNodesAfter(view);\n}\n// Make sure the cursor isn't directly after one or more ignored\n// nodes, which will confuse the browser's cursor motion logic.\nfunction skipIgnoredNodesBefore(view) {\n    let sel = view.domSelectionRange();\n    let node = sel.focusNode, offset = sel.focusOffset;\n    if (!node)\n        return;\n    let moveNode, moveOffset, force = false;\n    // Gecko will do odd things when the selection is directly in front\n    // of a non-editable node, so in that case, move it into the next\n    // node if possible. Issue prosemirror/prosemirror#832.\n    if (gecko && node.nodeType == 1 && offset < nodeLen(node) && isIgnorable(node.childNodes[offset], -1))\n        force = true;\n    for (;;) {\n        if (offset > 0) {\n            if (node.nodeType != 1) {\n                break;\n            }\n            else {\n                let before = node.childNodes[offset - 1];\n                if (isIgnorable(before, -1)) {\n                    moveNode = node;\n                    moveOffset = --offset;\n                }\n                else if (before.nodeType == 3) {\n                    node = before;\n                    offset = node.nodeValue.length;\n                }\n                else\n                    break;\n            }\n        }\n        else if (isBlockNode(node)) {\n            break;\n        }\n        else {\n            let prev = node.previousSibling;\n            while (prev && isIgnorable(prev, -1)) {\n                moveNode = node.parentNode;\n                moveOffset = domIndex(prev);\n                prev = prev.previousSibling;\n            }\n            if (!prev) {\n                node = node.parentNode;\n                if (node == view.dom)\n                    break;\n                offset = 0;\n            }\n            else {\n                node = prev;\n                offset = nodeLen(node);\n            }\n        }\n    }\n    if (force)\n        setSelFocus(view, node, offset);\n    else if (moveNode)\n        setSelFocus(view, moveNode, moveOffset);\n}\n// Make sure the cursor isn't directly before one or more ignored\n// nodes.\nfunction skipIgnoredNodesAfter(view) {\n    let sel = view.domSelectionRange();\n    let node = sel.focusNode, offset = sel.focusOffset;\n    if (!node)\n        return;\n    let len = nodeLen(node);\n    let moveNode, moveOffset;\n    for (;;) {\n        if (offset < len) {\n            if (node.nodeType != 1)\n                break;\n            let after = node.childNodes[offset];\n            if (isIgnorable(after, 1)) {\n                moveNode = node;\n                moveOffset = ++offset;\n            }\n            else\n                break;\n        }\n        else if (isBlockNode(node)) {\n            break;\n        }\n        else {\n            let next = node.nextSibling;\n            while (next && isIgnorable(next, 1)) {\n                moveNode = next.parentNode;\n                moveOffset = domIndex(next) + 1;\n                next = next.nextSibling;\n            }\n            if (!next) {\n                node = node.parentNode;\n                if (node == view.dom)\n                    break;\n                offset = len = 0;\n            }\n            else {\n                node = next;\n                offset = 0;\n                len = nodeLen(node);\n            }\n        }\n    }\n    if (moveNode)\n        setSelFocus(view, moveNode, moveOffset);\n}\nfunction isBlockNode(dom) {\n    let desc = dom.pmViewDesc;\n    return desc && desc.node && desc.node.isBlock;\n}\nfunction textNodeAfter(node, offset) {\n    while (node && offset == node.childNodes.length && !hasBlockDesc(node)) {\n        offset = domIndex(node) + 1;\n        node = node.parentNode;\n    }\n    while (node && offset < node.childNodes.length) {\n        let next = node.childNodes[offset];\n        if (next.nodeType == 3)\n            return next;\n        if (next.nodeType == 1 && next.contentEditable == \"false\")\n            break;\n        node = next;\n        offset = 0;\n    }\n}\nfunction textNodeBefore(node, offset) {\n    while (node && !offset && !hasBlockDesc(node)) {\n        offset = domIndex(node);\n        node = node.parentNode;\n    }\n    while (node && offset) {\n        let next = node.childNodes[offset - 1];\n        if (next.nodeType == 3)\n            return next;\n        if (next.nodeType == 1 && next.contentEditable == \"false\")\n            break;\n        node = next;\n        offset = node.childNodes.length;\n    }\n}\nfunction setSelFocus(view, node, offset) {\n    if (node.nodeType != 3) {\n        let before, after;\n        if (after = textNodeAfter(node, offset)) {\n            node = after;\n            offset = 0;\n        }\n        else if (before = textNodeBefore(node, offset)) {\n            node = before;\n            offset = before.nodeValue.length;\n        }\n    }\n    let sel = view.domSelection();\n    if (!sel)\n        return;\n    if (selectionCollapsed(sel)) {\n        let range = document.createRange();\n        range.setEnd(node, offset);\n        range.setStart(node, offset);\n        sel.removeAllRanges();\n        sel.addRange(range);\n    }\n    else if (sel.extend) {\n        sel.extend(node, offset);\n    }\n    view.domObserver.setCurSelection();\n    let { state } = view;\n    // If no state update ends up happening, reset the selection.\n    setTimeout(() => {\n        if (view.state == state)\n            selectionToDOM(view);\n    }, 50);\n}\nfunction findDirection(view, pos) {\n    let $pos = view.state.doc.resolve(pos);\n    if (!(chrome || windows) && $pos.parent.inlineContent) {\n        let coords = view.coordsAtPos(pos);\n        if (pos > $pos.start()) {\n            let before = view.coordsAtPos(pos - 1);\n            let mid = (before.top + before.bottom) / 2;\n            if (mid > coords.top && mid < coords.bottom && Math.abs(before.left - coords.left) > 1)\n                return before.left < coords.left ? \"ltr\" : \"rtl\";\n        }\n        if (pos < $pos.end()) {\n            let after = view.coordsAtPos(pos + 1);\n            let mid = (after.top + after.bottom) / 2;\n            if (mid > coords.top && mid < coords.bottom && Math.abs(after.left - coords.left) > 1)\n                return after.left > coords.left ? \"ltr\" : \"rtl\";\n        }\n    }\n    let computed = getComputedStyle(view.dom).direction;\n    return computed == \"rtl\" ? \"rtl\" : \"ltr\";\n}\n// Check whether vertical selection motion would involve node\n// selections. If so, apply it (if not, the result is left to the\n// browser)\nfunction selectVertically(view, dir, mods) {\n    let sel = view.state.selection;\n    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection && !sel.empty || mods.indexOf(\"s\") > -1)\n        return false;\n    if (mac && mods.indexOf(\"m\") > -1)\n        return false;\n    let { $from, $to } = sel;\n    if (!$from.parent.inlineContent || view.endOfTextblock(dir < 0 ? \"up\" : \"down\")) {\n        let next = moveSelectionBlock(view.state, dir);\n        if (next && (next instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection))\n            return apply(view, next);\n    }\n    if (!$from.parent.inlineContent) {\n        let side = dir < 0 ? $from : $to;\n        let beyond = sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.AllSelection ? prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.near(side, dir) : prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.findFrom(side, dir);\n        return beyond ? apply(view, beyond) : false;\n    }\n    return false;\n}\nfunction stopNativeHorizontalDelete(view, dir) {\n    if (!(view.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection))\n        return true;\n    let { $head, $anchor, empty } = view.state.selection;\n    if (!$head.sameParent($anchor))\n        return true;\n    if (!empty)\n        return false;\n    if (view.endOfTextblock(dir > 0 ? \"forward\" : \"backward\"))\n        return true;\n    let nextNode = !$head.textOffset && (dir < 0 ? $head.nodeBefore : $head.nodeAfter);\n    if (nextNode && !nextNode.isText) {\n        let tr = view.state.tr;\n        if (dir < 0)\n            tr.delete($head.pos - nextNode.nodeSize, $head.pos);\n        else\n            tr.delete($head.pos, $head.pos + nextNode.nodeSize);\n        view.dispatch(tr);\n        return true;\n    }\n    return false;\n}\nfunction switchEditable(view, node, state) {\n    view.domObserver.stop();\n    node.contentEditable = state;\n    view.domObserver.start();\n}\n// Issue #867 / #1090 / https://bugs.chromium.org/p/chromium/issues/detail?id=903821\n// In which Safari (and at some point in the past, Chrome) does really\n// wrong things when the down arrow is pressed when the cursor is\n// directly at the start of a textblock and has an uneditable node\n// after it\nfunction safariDownArrowBug(view) {\n    if (!safari || view.state.selection.$head.parentOffset > 0)\n        return false;\n    let { focusNode, focusOffset } = view.domSelectionRange();\n    if (focusNode && focusNode.nodeType == 1 && focusOffset == 0 &&\n        focusNode.firstChild && focusNode.firstChild.contentEditable == \"false\") {\n        let child = focusNode.firstChild;\n        switchEditable(view, child, \"true\");\n        setTimeout(() => switchEditable(view, child, \"false\"), 20);\n    }\n    return false;\n}\n// A backdrop key mapping used to make sure we always suppress keys\n// that have a dangerous default effect, even if the commands they are\n// bound to return false, and to make sure that cursor-motion keys\n// find a cursor (as opposed to a node selection) when pressed. For\n// cursor-motion keys, the code in the handlers also takes care of\n// block selections.\nfunction getMods(event) {\n    let result = \"\";\n    if (event.ctrlKey)\n        result += \"c\";\n    if (event.metaKey)\n        result += \"m\";\n    if (event.altKey)\n        result += \"a\";\n    if (event.shiftKey)\n        result += \"s\";\n    return result;\n}\nfunction captureKeyDown(view, event) {\n    let code = event.keyCode, mods = getMods(event);\n    if (code == 8 || (mac && code == 72 && mods == \"c\")) { // Backspace, Ctrl-h on Mac\n        return stopNativeHorizontalDelete(view, -1) || skipIgnoredNodes(view, -1);\n    }\n    else if ((code == 46 && !event.shiftKey) || (mac && code == 68 && mods == \"c\")) { // Delete, Ctrl-d on Mac\n        return stopNativeHorizontalDelete(view, 1) || skipIgnoredNodes(view, 1);\n    }\n    else if (code == 13 || code == 27) { // Enter, Esc\n        return true;\n    }\n    else if (code == 37 || (mac && code == 66 && mods == \"c\")) { // Left arrow, Ctrl-b on Mac\n        let dir = code == 37 ? (findDirection(view, view.state.selection.from) == \"ltr\" ? -1 : 1) : -1;\n        return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);\n    }\n    else if (code == 39 || (mac && code == 70 && mods == \"c\")) { // Right arrow, Ctrl-f on Mac\n        let dir = code == 39 ? (findDirection(view, view.state.selection.from) == \"ltr\" ? 1 : -1) : 1;\n        return selectHorizontally(view, dir, mods) || skipIgnoredNodes(view, dir);\n    }\n    else if (code == 38 || (mac && code == 80 && mods == \"c\")) { // Up arrow, Ctrl-p on Mac\n        return selectVertically(view, -1, mods) || skipIgnoredNodes(view, -1);\n    }\n    else if (code == 40 || (mac && code == 78 && mods == \"c\")) { // Down arrow, Ctrl-n on Mac\n        return safariDownArrowBug(view) || selectVertically(view, 1, mods) || skipIgnoredNodes(view, 1);\n    }\n    else if (mods == (mac ? \"m\" : \"c\") &&\n        (code == 66 || code == 73 || code == 89 || code == 90)) { // Mod-[biyz]\n        return true;\n    }\n    return false;\n}\n\nfunction serializeForClipboard(view, slice) {\n    view.someProp(\"transformCopied\", f => { slice = f(slice, view); });\n    let context = [], { content, openStart, openEnd } = slice;\n    while (openStart > 1 && openEnd > 1 && content.childCount == 1 && content.firstChild.childCount == 1) {\n        openStart--;\n        openEnd--;\n        let node = content.firstChild;\n        context.push(node.type.name, node.attrs != node.type.defaultAttrs ? node.attrs : null);\n        content = node.content;\n    }\n    let serializer = view.someProp(\"clipboardSerializer\") || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer.fromSchema(view.state.schema);\n    let doc = detachedDoc(), wrap = doc.createElement(\"div\");\n    wrap.appendChild(serializer.serializeFragment(content, { document: doc }));\n    let firstChild = wrap.firstChild, needsWrap, wrappers = 0;\n    while (firstChild && firstChild.nodeType == 1 && (needsWrap = wrapMap[firstChild.nodeName.toLowerCase()])) {\n        for (let i = needsWrap.length - 1; i >= 0; i--) {\n            let wrapper = doc.createElement(needsWrap[i]);\n            while (wrap.firstChild)\n                wrapper.appendChild(wrap.firstChild);\n            wrap.appendChild(wrapper);\n            wrappers++;\n        }\n        firstChild = wrap.firstChild;\n    }\n    if (firstChild && firstChild.nodeType == 1)\n        firstChild.setAttribute(\"data-pm-slice\", `${openStart} ${openEnd}${wrappers ? ` -${wrappers}` : \"\"} ${JSON.stringify(context)}`);\n    let text = view.someProp(\"clipboardTextSerializer\", f => f(slice, view)) ||\n        slice.content.textBetween(0, slice.content.size, \"\\n\\n\");\n    return { dom: wrap, text, slice };\n}\n// Read a slice of content from the clipboard (or drop data).\nfunction parseFromClipboard(view, text, html, plainText, $context) {\n    let inCode = $context.parent.type.spec.code;\n    let dom, slice;\n    if (!html && !text)\n        return null;\n    let asText = !!text && (plainText || inCode || !html);\n    if (asText) {\n        view.someProp(\"transformPastedText\", f => { text = f(text, inCode || plainText, view); });\n        if (inCode) {\n            slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(view.state.schema.text(text.replace(/\\r\\n?/g, \"\\n\"))), 0, 0);\n            view.someProp(\"transformPasted\", f => { slice = f(slice, view, true); });\n            return slice;\n        }\n        let parsed = view.someProp(\"clipboardTextParser\", f => f(text, $context, plainText, view));\n        if (parsed) {\n            slice = parsed;\n        }\n        else {\n            let marks = $context.marks();\n            let { schema } = view.state, serializer = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMSerializer.fromSchema(schema);\n            dom = document.createElement(\"div\");\n            text.split(/(?:\\r\\n?|\\n)+/).forEach(block => {\n                let p = dom.appendChild(document.createElement(\"p\"));\n                if (block)\n                    p.appendChild(serializer.serializeNode(schema.text(block, marks)));\n            });\n        }\n    }\n    else {\n        view.someProp(\"transformPastedHTML\", f => { html = f(html, view); });\n        dom = readHTML(html);\n        if (webkit)\n            restoreReplacedSpaces(dom);\n    }\n    let contextNode = dom && dom.querySelector(\"[data-pm-slice]\");\n    let sliceData = contextNode && /^(\\d+) (\\d+)(?: -(\\d+))? (.*)/.exec(contextNode.getAttribute(\"data-pm-slice\") || \"\");\n    if (sliceData && sliceData[3])\n        for (let i = +sliceData[3]; i > 0; i--) {\n            let child = dom.firstChild;\n            while (child && child.nodeType != 1)\n                child = child.nextSibling;\n            if (!child)\n                break;\n            dom = child;\n        }\n    if (!slice) {\n        let parser = view.someProp(\"clipboardParser\") || view.someProp(\"domParser\") || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMParser.fromSchema(view.state.schema);\n        slice = parser.parseSlice(dom, {\n            preserveWhitespace: !!(asText || sliceData),\n            context: $context,\n            ruleFromNode(dom) {\n                if (dom.nodeName == \"BR\" && !dom.nextSibling &&\n                    dom.parentNode && !inlineParents.test(dom.parentNode.nodeName))\n                    return { ignore: true };\n                return null;\n            }\n        });\n    }\n    if (sliceData) {\n        slice = addContext(closeSlice(slice, +sliceData[1], +sliceData[2]), sliceData[4]);\n    }\n    else { // HTML wasn't created by ProseMirror. Make sure top-level siblings are coherent\n        slice = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.maxOpen(normalizeSiblings(slice.content, $context), true);\n        if (slice.openStart || slice.openEnd) {\n            let openStart = 0, openEnd = 0;\n            for (let node = slice.content.firstChild; openStart < slice.openStart && !node.type.spec.isolating; openStart++, node = node.firstChild) { }\n            for (let node = slice.content.lastChild; openEnd < slice.openEnd && !node.type.spec.isolating; openEnd++, node = node.lastChild) { }\n            slice = closeSlice(slice, openStart, openEnd);\n        }\n    }\n    view.someProp(\"transformPasted\", f => { slice = f(slice, view, asText); });\n    return slice;\n}\nconst inlineParents = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;\n// Takes a slice parsed with parseSlice, which means there hasn't been\n// any content-expression checking done on the top nodes, tries to\n// find a parent node in the current context that might fit the nodes,\n// and if successful, rebuilds the slice so that it fits into that parent.\n//\n// This addresses the problem that Transform.replace expects a\n// coherent slice, and will fail to place a set of siblings that don't\n// fit anywhere in the schema.\nfunction normalizeSiblings(fragment, $context) {\n    if (fragment.childCount < 2)\n        return fragment;\n    for (let d = $context.depth; d >= 0; d--) {\n        let parent = $context.node(d);\n        let match = parent.contentMatchAt($context.index(d));\n        let lastWrap, result = [];\n        fragment.forEach(node => {\n            if (!result)\n                return;\n            let wrap = match.findWrapping(node.type), inLast;\n            if (!wrap)\n                return result = null;\n            if (inLast = result.length && lastWrap.length && addToSibling(wrap, lastWrap, node, result[result.length - 1], 0)) {\n                result[result.length - 1] = inLast;\n            }\n            else {\n                if (result.length)\n                    result[result.length - 1] = closeRight(result[result.length - 1], lastWrap.length);\n                let wrapped = withWrappers(node, wrap);\n                result.push(wrapped);\n                match = match.matchType(wrapped.type);\n                lastWrap = wrap;\n            }\n        });\n        if (result)\n            return prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(result);\n    }\n    return fragment;\n}\nfunction withWrappers(node, wrap, from = 0) {\n    for (let i = wrap.length - 1; i >= from; i--)\n        node = wrap[i].create(null, prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(node));\n    return node;\n}\n// Used to group adjacent nodes wrapped in similar parents by\n// normalizeSiblings into the same parent node\nfunction addToSibling(wrap, lastWrap, node, sibling, depth) {\n    if (depth < wrap.length && depth < lastWrap.length && wrap[depth] == lastWrap[depth]) {\n        let inner = addToSibling(wrap, lastWrap, node, sibling.lastChild, depth + 1);\n        if (inner)\n            return sibling.copy(sibling.content.replaceChild(sibling.childCount - 1, inner));\n        let match = sibling.contentMatchAt(sibling.childCount);\n        if (match.matchType(depth == wrap.length - 1 ? node.type : wrap[depth + 1]))\n            return sibling.copy(sibling.content.append(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(withWrappers(node, wrap, depth + 1))));\n    }\n}\nfunction closeRight(node, depth) {\n    if (depth == 0)\n        return node;\n    let fragment = node.content.replaceChild(node.childCount - 1, closeRight(node.lastChild, depth - 1));\n    let fill = node.contentMatchAt(node.childCount).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true);\n    return node.copy(fragment.append(fill));\n}\nfunction closeRange(fragment, side, from, to, depth, openEnd) {\n    let node = side < 0 ? fragment.firstChild : fragment.lastChild, inner = node.content;\n    if (fragment.childCount > 1)\n        openEnd = 0;\n    if (depth < to - 1)\n        inner = closeRange(inner, side, from, to, depth + 1, openEnd);\n    if (depth >= from)\n        inner = side < 0 ? node.contentMatchAt(0).fillBefore(inner, openEnd <= depth).append(inner)\n            : inner.append(node.contentMatchAt(node.childCount).fillBefore(prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.empty, true));\n    return fragment.replaceChild(side < 0 ? 0 : fragment.childCount - 1, node.copy(inner));\n}\nfunction closeSlice(slice, openStart, openEnd) {\n    if (openStart < slice.openStart)\n        slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(closeRange(slice.content, -1, openStart, slice.openStart, 0, slice.openEnd), openStart, slice.openEnd);\n    if (openEnd < slice.openEnd)\n        slice = new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(closeRange(slice.content, 1, openEnd, slice.openEnd, 0, 0), slice.openStart, openEnd);\n    return slice;\n}\n// Trick from jQuery -- some elements must be wrapped in other\n// elements for innerHTML to work. I.e. if you do `div.innerHTML =\n// \"<td>..</td>\"` the table cells are ignored.\nconst wrapMap = {\n    thead: [\"table\"],\n    tbody: [\"table\"],\n    tfoot: [\"table\"],\n    caption: [\"table\"],\n    colgroup: [\"table\"],\n    col: [\"table\", \"colgroup\"],\n    tr: [\"table\", \"tbody\"],\n    td: [\"table\", \"tbody\", \"tr\"],\n    th: [\"table\", \"tbody\", \"tr\"]\n};\nlet _detachedDoc = null;\nfunction detachedDoc() {\n    return _detachedDoc || (_detachedDoc = document.implementation.createHTMLDocument(\"title\"));\n}\nlet _policy = null;\nfunction maybeWrapTrusted(html) {\n    let trustedTypes = window.trustedTypes;\n    if (!trustedTypes)\n        return html;\n    // With the require-trusted-types-for CSP, Chrome will block\n    // innerHTML, even on a detached document. This wraps the string in\n    // a way that makes the browser allow us to use its parser again.\n    if (!_policy)\n        _policy = trustedTypes.defaultPolicy || trustedTypes.createPolicy(\"ProseMirrorClipboard\", { createHTML: (s) => s });\n    return _policy.createHTML(html);\n}\nfunction readHTML(html) {\n    let metas = /^(\\s*<meta [^>]*>)*/.exec(html);\n    if (metas)\n        html = html.slice(metas[0].length);\n    let elt = detachedDoc().createElement(\"div\");\n    let firstTag = /<([a-z][^>\\s]+)/i.exec(html), wrap;\n    if (wrap = firstTag && wrapMap[firstTag[1].toLowerCase()])\n        html = wrap.map(n => \"<\" + n + \">\").join(\"\") + html + wrap.map(n => \"</\" + n + \">\").reverse().join(\"\");\n    elt.innerHTML = maybeWrapTrusted(html);\n    if (wrap)\n        for (let i = 0; i < wrap.length; i++)\n            elt = elt.querySelector(wrap[i]) || elt;\n    return elt;\n}\n// Webkit browsers do some hard-to-predict replacement of regular\n// spaces with non-breaking spaces when putting content on the\n// clipboard. This tries to convert such non-breaking spaces (which\n// will be wrapped in a plain span on Chrome, a span with class\n// Apple-converted-space on Safari) back to regular spaces.\nfunction restoreReplacedSpaces(dom) {\n    let nodes = dom.querySelectorAll(chrome ? \"span:not([class]):not([style])\" : \"span.Apple-converted-space\");\n    for (let i = 0; i < nodes.length; i++) {\n        let node = nodes[i];\n        if (node.childNodes.length == 1 && node.textContent == \"\\u00a0\" && node.parentNode)\n            node.parentNode.replaceChild(dom.ownerDocument.createTextNode(\" \"), node);\n    }\n}\nfunction addContext(slice, context) {\n    if (!slice.size)\n        return slice;\n    let schema = slice.content.firstChild.type.schema, array;\n    try {\n        array = JSON.parse(context);\n    }\n    catch (e) {\n        return slice;\n    }\n    let { content, openStart, openEnd } = slice;\n    for (let i = array.length - 2; i >= 0; i -= 2) {\n        let type = schema.nodes[array[i]];\n        if (!type || type.hasRequiredAttrs())\n            break;\n        content = prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(type.create(array[i + 1], content));\n        openStart++;\n        openEnd++;\n    }\n    return new prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice(content, openStart, openEnd);\n}\n\n// A collection of DOM events that occur within the editor, and callback functions\n// to invoke when the event fires.\nconst handlers = {};\nconst editHandlers = {};\nconst passiveHandlers = { touchstart: true, touchmove: true };\nclass InputState {\n    constructor() {\n        this.shiftKey = false;\n        this.mouseDown = null;\n        this.lastKeyCode = null;\n        this.lastKeyCodeTime = 0;\n        this.lastClick = { time: 0, x: 0, y: 0, type: \"\", button: 0 };\n        this.lastSelectionOrigin = null;\n        this.lastSelectionTime = 0;\n        this.lastIOSEnter = 0;\n        this.lastIOSEnterFallbackTimeout = -1;\n        this.lastFocus = 0;\n        this.lastTouch = 0;\n        this.lastChromeDelete = 0;\n        this.composing = false;\n        this.compositionNode = null;\n        this.composingTimeout = -1;\n        this.compositionNodes = [];\n        this.compositionEndedAt = -2e8;\n        this.compositionID = 1;\n        // Set to a composition ID when there are pending changes at compositionend\n        this.compositionPendingChanges = 0;\n        this.domChangeCount = 0;\n        this.eventHandlers = Object.create(null);\n        this.hideSelectionGuard = null;\n    }\n}\nfunction initInput(view) {\n    for (let event in handlers) {\n        let handler = handlers[event];\n        view.dom.addEventListener(event, view.input.eventHandlers[event] = (event) => {\n            if (eventBelongsToView(view, event) && !runCustomHandler(view, event) &&\n                (view.editable || !(event.type in editHandlers)))\n                handler(view, event);\n        }, passiveHandlers[event] ? { passive: true } : undefined);\n    }\n    // On Safari, for reasons beyond my understanding, adding an input\n    // event handler makes an issue where the composition vanishes when\n    // you press enter go away.\n    if (safari)\n        view.dom.addEventListener(\"input\", () => null);\n    ensureListeners(view);\n}\nfunction setSelectionOrigin(view, origin) {\n    view.input.lastSelectionOrigin = origin;\n    view.input.lastSelectionTime = Date.now();\n}\nfunction destroyInput(view) {\n    view.domObserver.stop();\n    for (let type in view.input.eventHandlers)\n        view.dom.removeEventListener(type, view.input.eventHandlers[type]);\n    clearTimeout(view.input.composingTimeout);\n    clearTimeout(view.input.lastIOSEnterFallbackTimeout);\n}\nfunction ensureListeners(view) {\n    view.someProp(\"handleDOMEvents\", currentHandlers => {\n        for (let type in currentHandlers)\n            if (!view.input.eventHandlers[type])\n                view.dom.addEventListener(type, view.input.eventHandlers[type] = event => runCustomHandler(view, event));\n    });\n}\nfunction runCustomHandler(view, event) {\n    return view.someProp(\"handleDOMEvents\", handlers => {\n        let handler = handlers[event.type];\n        return handler ? handler(view, event) || event.defaultPrevented : false;\n    });\n}\nfunction eventBelongsToView(view, event) {\n    if (!event.bubbles)\n        return true;\n    if (event.defaultPrevented)\n        return false;\n    for (let node = event.target; node != view.dom; node = node.parentNode)\n        if (!node || node.nodeType == 11 ||\n            (node.pmViewDesc && node.pmViewDesc.stopEvent(event)))\n            return false;\n    return true;\n}\nfunction dispatchEvent(view, event) {\n    if (!runCustomHandler(view, event) && handlers[event.type] &&\n        (view.editable || !(event.type in editHandlers)))\n        handlers[event.type](view, event);\n}\neditHandlers.keydown = (view, _event) => {\n    let event = _event;\n    view.input.shiftKey = event.keyCode == 16 || event.shiftKey;\n    if (inOrNearComposition(view, event))\n        return;\n    view.input.lastKeyCode = event.keyCode;\n    view.input.lastKeyCodeTime = Date.now();\n    // Suppress enter key events on Chrome Android, because those tend\n    // to be part of a confused sequence of composition events fired,\n    // and handling them eagerly tends to corrupt the input.\n    if (android && chrome && event.keyCode == 13)\n        return;\n    if (event.keyCode != 229)\n        view.domObserver.forceFlush();\n    // On iOS, if we preventDefault enter key presses, the virtual\n    // keyboard gets confused. So the hack here is to set a flag that\n    // makes the DOM change code recognize that what just happens should\n    // be replaced by whatever the Enter key handlers do.\n    if (ios && event.keyCode == 13 && !event.ctrlKey && !event.altKey && !event.metaKey) {\n        let now = Date.now();\n        view.input.lastIOSEnter = now;\n        view.input.lastIOSEnterFallbackTimeout = setTimeout(() => {\n            if (view.input.lastIOSEnter == now) {\n                view.someProp(\"handleKeyDown\", f => f(view, keyEvent(13, \"Enter\")));\n                view.input.lastIOSEnter = 0;\n            }\n        }, 200);\n    }\n    else if (view.someProp(\"handleKeyDown\", f => f(view, event)) || captureKeyDown(view, event)) {\n        event.preventDefault();\n    }\n    else {\n        setSelectionOrigin(view, \"key\");\n    }\n};\neditHandlers.keyup = (view, event) => {\n    if (event.keyCode == 16)\n        view.input.shiftKey = false;\n};\neditHandlers.keypress = (view, _event) => {\n    let event = _event;\n    if (inOrNearComposition(view, event) || !event.charCode ||\n        event.ctrlKey && !event.altKey || mac && event.metaKey)\n        return;\n    if (view.someProp(\"handleKeyPress\", f => f(view, event))) {\n        event.preventDefault();\n        return;\n    }\n    let sel = view.state.selection;\n    if (!(sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection) || !sel.$from.sameParent(sel.$to)) {\n        let text = String.fromCharCode(event.charCode);\n        let deflt = () => view.state.tr.insertText(text).scrollIntoView();\n        if (!/[\\r\\n]/.test(text) && !view.someProp(\"handleTextInput\", f => f(view, sel.$from.pos, sel.$to.pos, text, deflt)))\n            view.dispatch(deflt());\n        event.preventDefault();\n    }\n};\nfunction eventCoords(event) { return { left: event.clientX, top: event.clientY }; }\nfunction isNear(event, click) {\n    let dx = click.x - event.clientX, dy = click.y - event.clientY;\n    return dx * dx + dy * dy < 100;\n}\nfunction runHandlerOnContext(view, propName, pos, inside, event) {\n    if (inside == -1)\n        return false;\n    let $pos = view.state.doc.resolve(inside);\n    for (let i = $pos.depth + 1; i > 0; i--) {\n        if (view.someProp(propName, f => i > $pos.depth ? f(view, pos, $pos.nodeAfter, $pos.before(i), event, true)\n            : f(view, pos, $pos.node(i), $pos.before(i), event, false)))\n            return true;\n    }\n    return false;\n}\nfunction updateSelection(view, selection, origin) {\n    if (!view.focused)\n        view.focus();\n    if (view.state.selection.eq(selection))\n        return;\n    let tr = view.state.tr.setSelection(selection);\n    if (origin == \"pointer\")\n        tr.setMeta(\"pointer\", true);\n    view.dispatch(tr);\n}\nfunction selectClickedLeaf(view, inside) {\n    if (inside == -1)\n        return false;\n    let $pos = view.state.doc.resolve(inside), node = $pos.nodeAfter;\n    if (node && node.isAtom && prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node)) {\n        updateSelection(view, new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection($pos), \"pointer\");\n        return true;\n    }\n    return false;\n}\nfunction selectClickedNode(view, inside) {\n    if (inside == -1)\n        return false;\n    let sel = view.state.selection, selectedNode, selectAt;\n    if (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection)\n        selectedNode = sel.node;\n    let $pos = view.state.doc.resolve(inside);\n    for (let i = $pos.depth + 1; i > 0; i--) {\n        let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);\n        if (prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node)) {\n            if (selectedNode && sel.$from.depth > 0 &&\n                i >= sel.$from.depth && $pos.before(sel.$from.depth + 1) == sel.$from.pos)\n                selectAt = $pos.before(sel.$from.depth);\n            else\n                selectAt = $pos.before(i);\n            break;\n        }\n    }\n    if (selectAt != null) {\n        updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(view.state.doc, selectAt), \"pointer\");\n        return true;\n    }\n    else {\n        return false;\n    }\n}\nfunction handleSingleClick(view, pos, inside, event, selectNode) {\n    return runHandlerOnContext(view, \"handleClickOn\", pos, inside, event) ||\n        view.someProp(\"handleClick\", f => f(view, pos, event)) ||\n        (selectNode ? selectClickedNode(view, inside) : selectClickedLeaf(view, inside));\n}\nfunction handleDoubleClick(view, pos, inside, event) {\n    return runHandlerOnContext(view, \"handleDoubleClickOn\", pos, inside, event) ||\n        view.someProp(\"handleDoubleClick\", f => f(view, pos, event));\n}\nfunction handleTripleClick(view, pos, inside, event) {\n    return runHandlerOnContext(view, \"handleTripleClickOn\", pos, inside, event) ||\n        view.someProp(\"handleTripleClick\", f => f(view, pos, event)) ||\n        defaultTripleClick(view, inside, event);\n}\nfunction defaultTripleClick(view, inside, event) {\n    if (event.button != 0)\n        return false;\n    let doc = view.state.doc;\n    if (inside == -1) {\n        if (doc.inlineContent) {\n            updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(doc, 0, doc.content.size), \"pointer\");\n            return true;\n        }\n        return false;\n    }\n    let $pos = doc.resolve(inside);\n    for (let i = $pos.depth + 1; i > 0; i--) {\n        let node = i > $pos.depth ? $pos.nodeAfter : $pos.node(i);\n        let nodePos = $pos.before(i);\n        if (node.inlineContent)\n            updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection.create(doc, nodePos + 1, nodePos + 1 + node.content.size), \"pointer\");\n        else if (prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(node))\n            updateSelection(view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(doc, nodePos), \"pointer\");\n        else\n            continue;\n        return true;\n    }\n}\nfunction forceDOMFlush(view) {\n    return endComposition(view);\n}\nconst selectNodeModifier = mac ? \"metaKey\" : \"ctrlKey\";\nhandlers.mousedown = (view, _event) => {\n    let event = _event;\n    view.input.shiftKey = event.shiftKey;\n    let flushed = forceDOMFlush(view);\n    let now = Date.now(), type = \"singleClick\";\n    if (now - view.input.lastClick.time < 500 && isNear(event, view.input.lastClick) && !event[selectNodeModifier] &&\n        view.input.lastClick.button == event.button) {\n        if (view.input.lastClick.type == \"singleClick\")\n            type = \"doubleClick\";\n        else if (view.input.lastClick.type == \"doubleClick\")\n            type = \"tripleClick\";\n    }\n    view.input.lastClick = { time: now, x: event.clientX, y: event.clientY, type, button: event.button };\n    let pos = view.posAtCoords(eventCoords(event));\n    if (!pos)\n        return;\n    if (type == \"singleClick\") {\n        if (view.input.mouseDown)\n            view.input.mouseDown.done();\n        view.input.mouseDown = new MouseDown(view, pos, event, !!flushed);\n    }\n    else if ((type == \"doubleClick\" ? handleDoubleClick : handleTripleClick)(view, pos.pos, pos.inside, event)) {\n        event.preventDefault();\n    }\n    else {\n        setSelectionOrigin(view, \"pointer\");\n    }\n};\nclass MouseDown {\n    constructor(view, pos, event, flushed) {\n        this.view = view;\n        this.pos = pos;\n        this.event = event;\n        this.flushed = flushed;\n        this.delayedSelectionSync = false;\n        this.mightDrag = null;\n        this.startDoc = view.state.doc;\n        this.selectNode = !!event[selectNodeModifier];\n        this.allowDefault = event.shiftKey;\n        let targetNode, targetPos;\n        if (pos.inside > -1) {\n            targetNode = view.state.doc.nodeAt(pos.inside);\n            targetPos = pos.inside;\n        }\n        else {\n            let $pos = view.state.doc.resolve(pos.pos);\n            targetNode = $pos.parent;\n            targetPos = $pos.depth ? $pos.before() : 0;\n        }\n        const target = flushed ? null : event.target;\n        const targetDesc = target ? view.docView.nearestDesc(target, true) : null;\n        this.target = targetDesc && targetDesc.nodeDOM.nodeType == 1 ? targetDesc.nodeDOM : null;\n        let { selection } = view.state;\n        if (event.button == 0 &&\n            targetNode.type.spec.draggable && targetNode.type.spec.selectable !== false ||\n            selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection && selection.from <= targetPos && selection.to > targetPos)\n            this.mightDrag = {\n                node: targetNode,\n                pos: targetPos,\n                addAttr: !!(this.target && !this.target.draggable),\n                setUneditable: !!(this.target && gecko && !this.target.hasAttribute(\"contentEditable\"))\n            };\n        if (this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable)) {\n            this.view.domObserver.stop();\n            if (this.mightDrag.addAttr)\n                this.target.draggable = true;\n            if (this.mightDrag.setUneditable)\n                setTimeout(() => {\n                    if (this.view.input.mouseDown == this)\n                        this.target.setAttribute(\"contentEditable\", \"false\");\n                }, 20);\n            this.view.domObserver.start();\n        }\n        view.root.addEventListener(\"mouseup\", this.up = this.up.bind(this));\n        view.root.addEventListener(\"mousemove\", this.move = this.move.bind(this));\n        setSelectionOrigin(view, \"pointer\");\n    }\n    done() {\n        this.view.root.removeEventListener(\"mouseup\", this.up);\n        this.view.root.removeEventListener(\"mousemove\", this.move);\n        if (this.mightDrag && this.target) {\n            this.view.domObserver.stop();\n            if (this.mightDrag.addAttr)\n                this.target.removeAttribute(\"draggable\");\n            if (this.mightDrag.setUneditable)\n                this.target.removeAttribute(\"contentEditable\");\n            this.view.domObserver.start();\n        }\n        if (this.delayedSelectionSync)\n            setTimeout(() => selectionToDOM(this.view));\n        this.view.input.mouseDown = null;\n    }\n    up(event) {\n        this.done();\n        if (!this.view.dom.contains(event.target))\n            return;\n        let pos = this.pos;\n        if (this.view.state.doc != this.startDoc)\n            pos = this.view.posAtCoords(eventCoords(event));\n        this.updateAllowDefault(event);\n        if (this.allowDefault || !pos) {\n            setSelectionOrigin(this.view, \"pointer\");\n        }\n        else if (handleSingleClick(this.view, pos.pos, pos.inside, event, this.selectNode)) {\n            event.preventDefault();\n        }\n        else if (event.button == 0 &&\n            (this.flushed ||\n                // Safari ignores clicks on draggable elements\n                (safari && this.mightDrag && !this.mightDrag.node.isAtom) ||\n                // Chrome will sometimes treat a node selection as a\n                // cursor, but still report that the node is selected\n                // when asked through getSelection. You'll then get a\n                // situation where clicking at the point where that\n                // (hidden) cursor is doesn't change the selection, and\n                // thus doesn't get a reaction from ProseMirror. This\n                // works around that.\n                (chrome && !this.view.state.selection.visible &&\n                    Math.min(Math.abs(pos.pos - this.view.state.selection.from), Math.abs(pos.pos - this.view.state.selection.to)) <= 2))) {\n            updateSelection(this.view, prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.near(this.view.state.doc.resolve(pos.pos)), \"pointer\");\n            event.preventDefault();\n        }\n        else {\n            setSelectionOrigin(this.view, \"pointer\");\n        }\n    }\n    move(event) {\n        this.updateAllowDefault(event);\n        setSelectionOrigin(this.view, \"pointer\");\n        if (event.buttons == 0)\n            this.done();\n    }\n    updateAllowDefault(event) {\n        if (!this.allowDefault && (Math.abs(this.event.x - event.clientX) > 4 ||\n            Math.abs(this.event.y - event.clientY) > 4))\n            this.allowDefault = true;\n    }\n}\nhandlers.touchstart = view => {\n    view.input.lastTouch = Date.now();\n    forceDOMFlush(view);\n    setSelectionOrigin(view, \"pointer\");\n};\nhandlers.touchmove = view => {\n    view.input.lastTouch = Date.now();\n    setSelectionOrigin(view, \"pointer\");\n};\nhandlers.contextmenu = view => forceDOMFlush(view);\nfunction inOrNearComposition(view, event) {\n    if (view.composing)\n        return true;\n    // See https://www.stum.de/2016/06/24/handling-ime-events-in-javascript/.\n    // On Japanese input method editors (IMEs), the Enter key is used to confirm character\n    // selection. On Safari, when Enter is pressed, compositionend and keydown events are\n    // emitted. The keydown event triggers newline insertion, which we don't want.\n    // This method returns true if the keydown event should be ignored.\n    // We only ignore it once, as pressing Enter a second time *should* insert a newline.\n    // Furthermore, the keydown event timestamp must be close to the compositionEndedAt timestamp.\n    // This guards against the case where compositionend is triggered without the keyboard\n    // (e.g. character confirmation may be done with the mouse), and keydown is triggered\n    // afterwards- we wouldn't want to ignore the keydown event in this case.\n    if (safari && Math.abs(event.timeStamp - view.input.compositionEndedAt) < 500) {\n        view.input.compositionEndedAt = -2e8;\n        return true;\n    }\n    return false;\n}\n// Drop active composition after 5 seconds of inactivity on Android\nconst timeoutComposition = android ? 5000 : -1;\neditHandlers.compositionstart = editHandlers.compositionupdate = view => {\n    if (!view.composing) {\n        view.domObserver.flush();\n        let { state } = view, $pos = state.selection.$to;\n        if (state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection &&\n            (state.storedMarks ||\n                (!$pos.textOffset && $pos.parentOffset && $pos.nodeBefore.marks.some(m => m.type.spec.inclusive === false)))) {\n            // Need to wrap the cursor in mark nodes different from the ones in the DOM context\n            view.markCursor = view.state.storedMarks || $pos.marks();\n            endComposition(view, true);\n            view.markCursor = null;\n        }\n        else {\n            endComposition(view, !state.selection.empty);\n            // In firefox, if the cursor is after but outside a marked node,\n            // the inserted text won't inherit the marks. So this moves it\n            // inside if necessary.\n            if (gecko && state.selection.empty && $pos.parentOffset && !$pos.textOffset && $pos.nodeBefore.marks.length) {\n                let sel = view.domSelectionRange();\n                for (let node = sel.focusNode, offset = sel.focusOffset; node && node.nodeType == 1 && offset != 0;) {\n                    let before = offset < 0 ? node.lastChild : node.childNodes[offset - 1];\n                    if (!before)\n                        break;\n                    if (before.nodeType == 3) {\n                        let sel = view.domSelection();\n                        if (sel)\n                            sel.collapse(before, before.nodeValue.length);\n                        break;\n                    }\n                    else {\n                        node = before;\n                        offset = -1;\n                    }\n                }\n            }\n        }\n        view.input.composing = true;\n    }\n    scheduleComposeEnd(view, timeoutComposition);\n};\neditHandlers.compositionend = (view, event) => {\n    if (view.composing) {\n        view.input.composing = false;\n        view.input.compositionEndedAt = event.timeStamp;\n        view.input.compositionPendingChanges = view.domObserver.pendingRecords().length ? view.input.compositionID : 0;\n        view.input.compositionNode = null;\n        if (view.input.compositionPendingChanges)\n            Promise.resolve().then(() => view.domObserver.flush());\n        view.input.compositionID++;\n        scheduleComposeEnd(view, 20);\n    }\n};\nfunction scheduleComposeEnd(view, delay) {\n    clearTimeout(view.input.composingTimeout);\n    if (delay > -1)\n        view.input.composingTimeout = setTimeout(() => endComposition(view), delay);\n}\nfunction clearComposition(view) {\n    if (view.composing) {\n        view.input.composing = false;\n        view.input.compositionEndedAt = timestampFromCustomEvent();\n    }\n    while (view.input.compositionNodes.length > 0)\n        view.input.compositionNodes.pop().markParentsDirty();\n}\nfunction findCompositionNode(view) {\n    let sel = view.domSelectionRange();\n    if (!sel.focusNode)\n        return null;\n    let textBefore = textNodeBefore$1(sel.focusNode, sel.focusOffset);\n    let textAfter = textNodeAfter$1(sel.focusNode, sel.focusOffset);\n    if (textBefore && textAfter && textBefore != textAfter) {\n        let descAfter = textAfter.pmViewDesc, lastChanged = view.domObserver.lastChangedTextNode;\n        if (textBefore == lastChanged || textAfter == lastChanged)\n            return lastChanged;\n        if (!descAfter || !descAfter.isText(textAfter.nodeValue)) {\n            return textAfter;\n        }\n        else if (view.input.compositionNode == textAfter) {\n            let descBefore = textBefore.pmViewDesc;\n            if (!(!descBefore || !descBefore.isText(textBefore.nodeValue)))\n                return textAfter;\n        }\n    }\n    return textBefore || textAfter;\n}\nfunction timestampFromCustomEvent() {\n    let event = document.createEvent(\"Event\");\n    event.initEvent(\"event\", true, true);\n    return event.timeStamp;\n}\n/**\n@internal\n*/\nfunction endComposition(view, restarting = false) {\n    if (android && view.domObserver.flushingSoon >= 0)\n        return;\n    view.domObserver.forceFlush();\n    clearComposition(view);\n    if (restarting || view.docView && view.docView.dirty) {\n        let sel = selectionFromDOM(view), cur = view.state.selection;\n        if (sel && !sel.eq(cur))\n            view.dispatch(view.state.tr.setSelection(sel));\n        else if ((view.markCursor || restarting) && !cur.$from.node(cur.$from.sharedDepth(cur.to)).inlineContent)\n            view.dispatch(view.state.tr.deleteSelection());\n        else\n            view.updateState(view.state);\n        return true;\n    }\n    return false;\n}\nfunction captureCopy(view, dom) {\n    // The extra wrapper is somehow necessary on IE/Edge to prevent the\n    // content from being mangled when it is put onto the clipboard\n    if (!view.dom.parentNode)\n        return;\n    let wrap = view.dom.parentNode.appendChild(document.createElement(\"div\"));\n    wrap.appendChild(dom);\n    wrap.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n    let sel = getSelection(), range = document.createRange();\n    range.selectNodeContents(dom);\n    // Done because IE will fire a selectionchange moving the selection\n    // to its start when removeAllRanges is called and the editor still\n    // has focus (which will mess up the editor's selection state).\n    view.dom.blur();\n    sel.removeAllRanges();\n    sel.addRange(range);\n    setTimeout(() => {\n        if (wrap.parentNode)\n            wrap.parentNode.removeChild(wrap);\n        view.focus();\n    }, 50);\n}\n// This is very crude, but unfortunately both these browsers _pretend_\n// that they have a clipboard API—all the objects and methods are\n// there, they just don't work, and they are hard to test.\nconst brokenClipboardAPI = (ie && ie_version < 15) ||\n    (ios && webkit_version < 604);\nhandlers.copy = editHandlers.cut = (view, _event) => {\n    let event = _event;\n    let sel = view.state.selection, cut = event.type == \"cut\";\n    if (sel.empty)\n        return;\n    // IE and Edge's clipboard interface is completely broken\n    let data = brokenClipboardAPI ? null : event.clipboardData;\n    let slice = sel.content(), { dom, text } = serializeForClipboard(view, slice);\n    if (data) {\n        event.preventDefault();\n        data.clearData();\n        data.setData(\"text/html\", dom.innerHTML);\n        data.setData(\"text/plain\", text);\n    }\n    else {\n        captureCopy(view, dom);\n    }\n    if (cut)\n        view.dispatch(view.state.tr.deleteSelection().scrollIntoView().setMeta(\"uiEvent\", \"cut\"));\n};\nfunction sliceSingleNode(slice) {\n    return slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1 ? slice.content.firstChild : null;\n}\nfunction capturePaste(view, event) {\n    if (!view.dom.parentNode)\n        return;\n    let plainText = view.input.shiftKey || view.state.selection.$from.parent.type.spec.code;\n    let target = view.dom.parentNode.appendChild(document.createElement(plainText ? \"textarea\" : \"div\"));\n    if (!plainText)\n        target.contentEditable = \"true\";\n    target.style.cssText = \"position: fixed; left: -10000px; top: 10px\";\n    target.focus();\n    let plain = view.input.shiftKey && view.input.lastKeyCode != 45;\n    setTimeout(() => {\n        view.focus();\n        if (target.parentNode)\n            target.parentNode.removeChild(target);\n        if (plainText)\n            doPaste(view, target.value, null, plain, event);\n        else\n            doPaste(view, target.textContent, target.innerHTML, plain, event);\n    }, 50);\n}\nfunction doPaste(view, text, html, preferPlain, event) {\n    let slice = parseFromClipboard(view, text, html, preferPlain, view.state.selection.$from);\n    if (view.someProp(\"handlePaste\", f => f(view, event, slice || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty)))\n        return true;\n    if (!slice)\n        return false;\n    let singleNode = sliceSingleNode(slice);\n    let tr = singleNode\n        ? view.state.tr.replaceSelectionWith(singleNode, preferPlain)\n        : view.state.tr.replaceSelection(slice);\n    view.dispatch(tr.scrollIntoView().setMeta(\"paste\", true).setMeta(\"uiEvent\", \"paste\"));\n    return true;\n}\nfunction getText(clipboardData) {\n    let text = clipboardData.getData(\"text/plain\") || clipboardData.getData(\"Text\");\n    if (text)\n        return text;\n    let uris = clipboardData.getData(\"text/uri-list\");\n    return uris ? uris.replace(/\\r?\\n/g, \" \") : \"\";\n}\neditHandlers.paste = (view, _event) => {\n    let event = _event;\n    // Handling paste from JavaScript during composition is very poorly\n    // handled by browsers, so as a dodgy but preferable kludge, we just\n    // let the browser do its native thing there, except on Android,\n    // where the editor is almost always composing.\n    if (view.composing && !android)\n        return;\n    let data = brokenClipboardAPI ? null : event.clipboardData;\n    let plain = view.input.shiftKey && view.input.lastKeyCode != 45;\n    if (data && doPaste(view, getText(data), data.getData(\"text/html\"), plain, event))\n        event.preventDefault();\n    else\n        capturePaste(view, event);\n};\nclass Dragging {\n    constructor(slice, move, node) {\n        this.slice = slice;\n        this.move = move;\n        this.node = node;\n    }\n}\nconst dragCopyModifier = mac ? \"altKey\" : \"ctrlKey\";\nfunction dragMoves(view, event) {\n    let moves = view.someProp(\"dragCopies\", test => !test(event));\n    return moves != null ? moves : !event[dragCopyModifier];\n}\nhandlers.dragstart = (view, _event) => {\n    let event = _event;\n    let mouseDown = view.input.mouseDown;\n    if (mouseDown)\n        mouseDown.done();\n    if (!event.dataTransfer)\n        return;\n    let sel = view.state.selection;\n    let pos = sel.empty ? null : view.posAtCoords(eventCoords(event));\n    let node;\n    if (pos && pos.pos >= sel.from && pos.pos <= (sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection ? sel.to - 1 : sel.to)) ;\n    else if (mouseDown && mouseDown.mightDrag) {\n        node = prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(view.state.doc, mouseDown.mightDrag.pos);\n    }\n    else if (event.target && event.target.nodeType == 1) {\n        let desc = view.docView.nearestDesc(event.target, true);\n        if (desc && desc.node.type.spec.draggable && desc != view.docView)\n            node = prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(view.state.doc, desc.posBefore);\n    }\n    let draggedSlice = (node || view.state.selection).content();\n    let { dom, text, slice } = serializeForClipboard(view, draggedSlice);\n    // Pre-120 Chrome versions clear files when calling `clearData` (#1472)\n    if (!event.dataTransfer.files.length || !chrome || chrome_version > 120)\n        event.dataTransfer.clearData();\n    event.dataTransfer.setData(brokenClipboardAPI ? \"Text\" : \"text/html\", dom.innerHTML);\n    // See https://github.com/ProseMirror/prosemirror/issues/1156\n    event.dataTransfer.effectAllowed = \"copyMove\";\n    if (!brokenClipboardAPI)\n        event.dataTransfer.setData(\"text/plain\", text);\n    view.dragging = new Dragging(slice, dragMoves(view, event), node);\n};\nhandlers.dragend = view => {\n    let dragging = view.dragging;\n    window.setTimeout(() => {\n        if (view.dragging == dragging)\n            view.dragging = null;\n    }, 50);\n};\neditHandlers.dragover = editHandlers.dragenter = (_, e) => e.preventDefault();\neditHandlers.drop = (view, _event) => {\n    let event = _event;\n    let dragging = view.dragging;\n    view.dragging = null;\n    if (!event.dataTransfer)\n        return;\n    let eventPos = view.posAtCoords(eventCoords(event));\n    if (!eventPos)\n        return;\n    let $mouse = view.state.doc.resolve(eventPos.pos);\n    let slice = dragging && dragging.slice;\n    if (slice) {\n        view.someProp(\"transformPasted\", f => { slice = f(slice, view, false); });\n    }\n    else {\n        slice = parseFromClipboard(view, getText(event.dataTransfer), brokenClipboardAPI ? null : event.dataTransfer.getData(\"text/html\"), false, $mouse);\n    }\n    let move = !!(dragging && dragMoves(view, event));\n    if (view.someProp(\"handleDrop\", f => f(view, event, slice || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Slice.empty, move))) {\n        event.preventDefault();\n        return;\n    }\n    if (!slice)\n        return;\n    event.preventDefault();\n    let insertPos = slice ? (0,prosemirror_transform__WEBPACK_IMPORTED_MODULE_2__.dropPoint)(view.state.doc, $mouse.pos, slice) : $mouse.pos;\n    if (insertPos == null)\n        insertPos = $mouse.pos;\n    let tr = view.state.tr;\n    if (move) {\n        let { node } = dragging;\n        if (node)\n            node.replace(tr);\n        else\n            tr.deleteSelection();\n    }\n    let pos = tr.mapping.map(insertPos);\n    let isNode = slice.openStart == 0 && slice.openEnd == 0 && slice.content.childCount == 1;\n    let beforeInsert = tr.doc;\n    if (isNode)\n        tr.replaceRangeWith(pos, pos, slice.content.firstChild);\n    else\n        tr.replaceRange(pos, pos, slice);\n    if (tr.doc.eq(beforeInsert))\n        return;\n    let $pos = tr.doc.resolve(pos);\n    if (isNode && prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.isSelectable(slice.content.firstChild) &&\n        $pos.nodeAfter && $pos.nodeAfter.sameMarkup(slice.content.firstChild)) {\n        tr.setSelection(new prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection($pos));\n    }\n    else {\n        let end = tr.mapping.map(insertPos);\n        tr.mapping.maps[tr.mapping.maps.length - 1].forEach((_from, _to, _newFrom, newTo) => end = newTo);\n        tr.setSelection(selectionBetween(view, $pos, tr.doc.resolve(end)));\n    }\n    view.focus();\n    view.dispatch(tr.setMeta(\"uiEvent\", \"drop\"));\n};\nhandlers.focus = view => {\n    view.input.lastFocus = Date.now();\n    if (!view.focused) {\n        view.domObserver.stop();\n        view.dom.classList.add(\"ProseMirror-focused\");\n        view.domObserver.start();\n        view.focused = true;\n        setTimeout(() => {\n            if (view.docView && view.hasFocus() && !view.domObserver.currentSelection.eq(view.domSelectionRange()))\n                selectionToDOM(view);\n        }, 20);\n    }\n};\nhandlers.blur = (view, _event) => {\n    let event = _event;\n    if (view.focused) {\n        view.domObserver.stop();\n        view.dom.classList.remove(\"ProseMirror-focused\");\n        view.domObserver.start();\n        if (event.relatedTarget && view.dom.contains(event.relatedTarget))\n            view.domObserver.currentSelection.clear();\n        view.focused = false;\n    }\n};\nhandlers.beforeinput = (view, _event) => {\n    let event = _event;\n    // We should probably do more with beforeinput events, but support\n    // is so spotty that I'm still waiting to see where they are going.\n    // Very specific hack to deal with backspace sometimes failing on\n    // Chrome Android when after an uneditable node.\n    if (chrome && android && event.inputType == \"deleteContentBackward\") {\n        view.domObserver.flushSoon();\n        let { domChangeCount } = view.input;\n        setTimeout(() => {\n            if (view.input.domChangeCount != domChangeCount)\n                return; // Event already had some effect\n            // This bug tends to close the virtual keyboard, so we refocus\n            view.dom.blur();\n            view.focus();\n            if (view.someProp(\"handleKeyDown\", f => f(view, keyEvent(8, \"Backspace\"))))\n                return;\n            let { $cursor } = view.state.selection;\n            // Crude approximation of backspace behavior when no command handled it\n            if ($cursor && $cursor.pos > 0)\n                view.dispatch(view.state.tr.delete($cursor.pos - 1, $cursor.pos).scrollIntoView());\n        }, 50);\n    }\n};\n// Make sure all handlers get registered\nfor (let prop in editHandlers)\n    handlers[prop] = editHandlers[prop];\n\nfunction compareObjs(a, b) {\n    if (a == b)\n        return true;\n    for (let p in a)\n        if (a[p] !== b[p])\n            return false;\n    for (let p in b)\n        if (!(p in a))\n            return false;\n    return true;\n}\nclass WidgetType {\n    constructor(toDOM, spec) {\n        this.toDOM = toDOM;\n        this.spec = spec || noSpec;\n        this.side = this.spec.side || 0;\n    }\n    map(mapping, span, offset, oldOffset) {\n        let { pos, deleted } = mapping.mapResult(span.from + oldOffset, this.side < 0 ? -1 : 1);\n        return deleted ? null : new Decoration(pos - offset, pos - offset, this);\n    }\n    valid() { return true; }\n    eq(other) {\n        return this == other ||\n            (other instanceof WidgetType &&\n                (this.spec.key && this.spec.key == other.spec.key ||\n                    this.toDOM == other.toDOM && compareObjs(this.spec, other.spec)));\n    }\n    destroy(node) {\n        if (this.spec.destroy)\n            this.spec.destroy(node);\n    }\n}\nclass InlineType {\n    constructor(attrs, spec) {\n        this.attrs = attrs;\n        this.spec = spec || noSpec;\n    }\n    map(mapping, span, offset, oldOffset) {\n        let from = mapping.map(span.from + oldOffset, this.spec.inclusiveStart ? -1 : 1) - offset;\n        let to = mapping.map(span.to + oldOffset, this.spec.inclusiveEnd ? 1 : -1) - offset;\n        return from >= to ? null : new Decoration(from, to, this);\n    }\n    valid(_, span) { return span.from < span.to; }\n    eq(other) {\n        return this == other ||\n            (other instanceof InlineType && compareObjs(this.attrs, other.attrs) &&\n                compareObjs(this.spec, other.spec));\n    }\n    static is(span) { return span.type instanceof InlineType; }\n    destroy() { }\n}\nclass NodeType {\n    constructor(attrs, spec) {\n        this.attrs = attrs;\n        this.spec = spec || noSpec;\n    }\n    map(mapping, span, offset, oldOffset) {\n        let from = mapping.mapResult(span.from + oldOffset, 1);\n        if (from.deleted)\n            return null;\n        let to = mapping.mapResult(span.to + oldOffset, -1);\n        if (to.deleted || to.pos <= from.pos)\n            return null;\n        return new Decoration(from.pos - offset, to.pos - offset, this);\n    }\n    valid(node, span) {\n        let { index, offset } = node.content.findIndex(span.from), child;\n        return offset == span.from && !(child = node.child(index)).isText && offset + child.nodeSize == span.to;\n    }\n    eq(other) {\n        return this == other ||\n            (other instanceof NodeType && compareObjs(this.attrs, other.attrs) &&\n                compareObjs(this.spec, other.spec));\n    }\n    destroy() { }\n}\n/**\nDecoration objects can be provided to the view through the\n[`decorations` prop](https://prosemirror.net/docs/ref/#view.EditorProps.decorations). They come in\nseveral variants—see the static members of this class for details.\n*/\nclass Decoration {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The start position of the decoration.\n    */\n    from, \n    /**\n    The end position. Will be the same as `from` for [widget\n    decorations](https://prosemirror.net/docs/ref/#view.Decoration^widget).\n    */\n    to, \n    /**\n    @internal\n    */\n    type) {\n        this.from = from;\n        this.to = to;\n        this.type = type;\n    }\n    /**\n    @internal\n    */\n    copy(from, to) {\n        return new Decoration(from, to, this.type);\n    }\n    /**\n    @internal\n    */\n    eq(other, offset = 0) {\n        return this.type.eq(other.type) && this.from + offset == other.from && this.to + offset == other.to;\n    }\n    /**\n    @internal\n    */\n    map(mapping, offset, oldOffset) {\n        return this.type.map(mapping, this, offset, oldOffset);\n    }\n    /**\n    Creates a widget decoration, which is a DOM node that's shown in\n    the document at the given position. It is recommended that you\n    delay rendering the widget by passing a function that will be\n    called when the widget is actually drawn in a view, but you can\n    also directly pass a DOM node. `getPos` can be used to find the\n    widget's current document position.\n    */\n    static widget(pos, toDOM, spec) {\n        return new Decoration(pos, pos, new WidgetType(toDOM, spec));\n    }\n    /**\n    Creates an inline decoration, which adds the given attributes to\n    each inline node between `from` and `to`.\n    */\n    static inline(from, to, attrs, spec) {\n        return new Decoration(from, to, new InlineType(attrs, spec));\n    }\n    /**\n    Creates a node decoration. `from` and `to` should point precisely\n    before and after a node in the document. That node, and only that\n    node, will receive the given attributes.\n    */\n    static node(from, to, attrs, spec) {\n        return new Decoration(from, to, new NodeType(attrs, spec));\n    }\n    /**\n    The spec provided when creating this decoration. Can be useful\n    if you've stored extra information in that object.\n    */\n    get spec() { return this.type.spec; }\n    /**\n    @internal\n    */\n    get inline() { return this.type instanceof InlineType; }\n    /**\n    @internal\n    */\n    get widget() { return this.type instanceof WidgetType; }\n}\nconst none = [], noSpec = {};\n/**\nA collection of [decorations](https://prosemirror.net/docs/ref/#view.Decoration), organized in such\na way that the drawing algorithm can efficiently use and compare\nthem. This is a persistent data structure—it is not modified,\nupdates create a new value.\n*/\nclass DecorationSet {\n    /**\n    @internal\n    */\n    constructor(local, children) {\n        this.local = local.length ? local : none;\n        this.children = children.length ? children : none;\n    }\n    /**\n    Create a set of decorations, using the structure of the given\n    document. This will consume (modify) the `decorations` array, so\n    you must make a copy if you want need to preserve that.\n    */\n    static create(doc, decorations) {\n        return decorations.length ? buildTree(decorations, doc, 0, noSpec) : empty;\n    }\n    /**\n    Find all decorations in this set which touch the given range\n    (including decorations that start or end directly at the\n    boundaries) and match the given predicate on their spec. When\n    `start` and `end` are omitted, all decorations in the set are\n    considered. When `predicate` isn't given, all decorations are\n    assumed to match.\n    */\n    find(start, end, predicate) {\n        let result = [];\n        this.findInner(start == null ? 0 : start, end == null ? 1e9 : end, result, 0, predicate);\n        return result;\n    }\n    findInner(start, end, result, offset, predicate) {\n        for (let i = 0; i < this.local.length; i++) {\n            let span = this.local[i];\n            if (span.from <= end && span.to >= start && (!predicate || predicate(span.spec)))\n                result.push(span.copy(span.from + offset, span.to + offset));\n        }\n        for (let i = 0; i < this.children.length; i += 3) {\n            if (this.children[i] < end && this.children[i + 1] > start) {\n                let childOff = this.children[i] + 1;\n                this.children[i + 2].findInner(start - childOff, end - childOff, result, offset + childOff, predicate);\n            }\n        }\n    }\n    /**\n    Map the set of decorations in response to a change in the\n    document.\n    */\n    map(mapping, doc, options) {\n        if (this == empty || mapping.maps.length == 0)\n            return this;\n        return this.mapInner(mapping, doc, 0, 0, options || noSpec);\n    }\n    /**\n    @internal\n    */\n    mapInner(mapping, node, offset, oldOffset, options) {\n        let newLocal;\n        for (let i = 0; i < this.local.length; i++) {\n            let mapped = this.local[i].map(mapping, offset, oldOffset);\n            if (mapped && mapped.type.valid(node, mapped))\n                (newLocal || (newLocal = [])).push(mapped);\n            else if (options.onRemove)\n                options.onRemove(this.local[i].spec);\n        }\n        if (this.children.length)\n            return mapChildren(this.children, newLocal || [], mapping, node, offset, oldOffset, options);\n        else\n            return newLocal ? new DecorationSet(newLocal.sort(byPos), none) : empty;\n    }\n    /**\n    Add the given array of decorations to the ones in the set,\n    producing a new set. Consumes the `decorations` array. Needs\n    access to the current document to create the appropriate tree\n    structure.\n    */\n    add(doc, decorations) {\n        if (!decorations.length)\n            return this;\n        if (this == empty)\n            return DecorationSet.create(doc, decorations);\n        return this.addInner(doc, decorations, 0);\n    }\n    addInner(doc, decorations, offset) {\n        let children, childIndex = 0;\n        doc.forEach((childNode, childOffset) => {\n            let baseOffset = childOffset + offset, found;\n            if (!(found = takeSpansForNode(decorations, childNode, baseOffset)))\n                return;\n            if (!children)\n                children = this.children.slice();\n            while (childIndex < children.length && children[childIndex] < childOffset)\n                childIndex += 3;\n            if (children[childIndex] == childOffset)\n                children[childIndex + 2] = children[childIndex + 2].addInner(childNode, found, baseOffset + 1);\n            else\n                children.splice(childIndex, 0, childOffset, childOffset + childNode.nodeSize, buildTree(found, childNode, baseOffset + 1, noSpec));\n            childIndex += 3;\n        });\n        let local = moveSpans(childIndex ? withoutNulls(decorations) : decorations, -offset);\n        for (let i = 0; i < local.length; i++)\n            if (!local[i].type.valid(doc, local[i]))\n                local.splice(i--, 1);\n        return new DecorationSet(local.length ? this.local.concat(local).sort(byPos) : this.local, children || this.children);\n    }\n    /**\n    Create a new set that contains the decorations in this set, minus\n    the ones in the given array.\n    */\n    remove(decorations) {\n        if (decorations.length == 0 || this == empty)\n            return this;\n        return this.removeInner(decorations, 0);\n    }\n    removeInner(decorations, offset) {\n        let children = this.children, local = this.local;\n        for (let i = 0; i < children.length; i += 3) {\n            let found;\n            let from = children[i] + offset, to = children[i + 1] + offset;\n            for (let j = 0, span; j < decorations.length; j++)\n                if (span = decorations[j]) {\n                    if (span.from > from && span.to < to) {\n                        decorations[j] = null;\n                        (found || (found = [])).push(span);\n                    }\n                }\n            if (!found)\n                continue;\n            if (children == this.children)\n                children = this.children.slice();\n            let removed = children[i + 2].removeInner(found, from + 1);\n            if (removed != empty) {\n                children[i + 2] = removed;\n            }\n            else {\n                children.splice(i, 3);\n                i -= 3;\n            }\n        }\n        if (local.length)\n            for (let i = 0, span; i < decorations.length; i++)\n                if (span = decorations[i]) {\n                    for (let j = 0; j < local.length; j++)\n                        if (local[j].eq(span, offset)) {\n                            if (local == this.local)\n                                local = this.local.slice();\n                            local.splice(j--, 1);\n                        }\n                }\n        if (children == this.children && local == this.local)\n            return this;\n        return local.length || children.length ? new DecorationSet(local, children) : empty;\n    }\n    forChild(offset, node) {\n        if (this == empty)\n            return this;\n        if (node.isLeaf)\n            return DecorationSet.empty;\n        let child, local;\n        for (let i = 0; i < this.children.length; i += 3)\n            if (this.children[i] >= offset) {\n                if (this.children[i] == offset)\n                    child = this.children[i + 2];\n                break;\n            }\n        let start = offset + 1, end = start + node.content.size;\n        for (let i = 0; i < this.local.length; i++) {\n            let dec = this.local[i];\n            if (dec.from < end && dec.to > start && (dec.type instanceof InlineType)) {\n                let from = Math.max(start, dec.from) - start, to = Math.min(end, dec.to) - start;\n                if (from < to)\n                    (local || (local = [])).push(dec.copy(from, to));\n            }\n        }\n        if (local) {\n            let localSet = new DecorationSet(local.sort(byPos), none);\n            return child ? new DecorationGroup([localSet, child]) : localSet;\n        }\n        return child || empty;\n    }\n    /**\n    @internal\n    */\n    eq(other) {\n        if (this == other)\n            return true;\n        if (!(other instanceof DecorationSet) ||\n            this.local.length != other.local.length ||\n            this.children.length != other.children.length)\n            return false;\n        for (let i = 0; i < this.local.length; i++)\n            if (!this.local[i].eq(other.local[i]))\n                return false;\n        for (let i = 0; i < this.children.length; i += 3)\n            if (this.children[i] != other.children[i] ||\n                this.children[i + 1] != other.children[i + 1] ||\n                !this.children[i + 2].eq(other.children[i + 2]))\n                return false;\n        return true;\n    }\n    /**\n    @internal\n    */\n    locals(node) {\n        return removeOverlap(this.localsInner(node));\n    }\n    /**\n    @internal\n    */\n    localsInner(node) {\n        if (this == empty)\n            return none;\n        if (node.inlineContent || !this.local.some(InlineType.is))\n            return this.local;\n        let result = [];\n        for (let i = 0; i < this.local.length; i++) {\n            if (!(this.local[i].type instanceof InlineType))\n                result.push(this.local[i]);\n        }\n        return result;\n    }\n    forEachSet(f) { f(this); }\n}\n/**\nThe empty set of decorations.\n*/\nDecorationSet.empty = new DecorationSet([], []);\n/**\n@internal\n*/\nDecorationSet.removeOverlap = removeOverlap;\nconst empty = DecorationSet.empty;\n// An abstraction that allows the code dealing with decorations to\n// treat multiple DecorationSet objects as if it were a single object\n// with (a subset of) the same interface.\nclass DecorationGroup {\n    constructor(members) {\n        this.members = members;\n    }\n    map(mapping, doc) {\n        const mappedDecos = this.members.map(member => member.map(mapping, doc, noSpec));\n        return DecorationGroup.from(mappedDecos);\n    }\n    forChild(offset, child) {\n        if (child.isLeaf)\n            return DecorationSet.empty;\n        let found = [];\n        for (let i = 0; i < this.members.length; i++) {\n            let result = this.members[i].forChild(offset, child);\n            if (result == empty)\n                continue;\n            if (result instanceof DecorationGroup)\n                found = found.concat(result.members);\n            else\n                found.push(result);\n        }\n        return DecorationGroup.from(found);\n    }\n    eq(other) {\n        if (!(other instanceof DecorationGroup) ||\n            other.members.length != this.members.length)\n            return false;\n        for (let i = 0; i < this.members.length; i++)\n            if (!this.members[i].eq(other.members[i]))\n                return false;\n        return true;\n    }\n    locals(node) {\n        let result, sorted = true;\n        for (let i = 0; i < this.members.length; i++) {\n            let locals = this.members[i].localsInner(node);\n            if (!locals.length)\n                continue;\n            if (!result) {\n                result = locals;\n            }\n            else {\n                if (sorted) {\n                    result = result.slice();\n                    sorted = false;\n                }\n                for (let j = 0; j < locals.length; j++)\n                    result.push(locals[j]);\n            }\n        }\n        return result ? removeOverlap(sorted ? result : result.sort(byPos)) : none;\n    }\n    // Create a group for the given array of decoration sets, or return\n    // a single set when possible.\n    static from(members) {\n        switch (members.length) {\n            case 0: return empty;\n            case 1: return members[0];\n            default: return new DecorationGroup(members.every(m => m instanceof DecorationSet) ? members :\n                members.reduce((r, m) => r.concat(m instanceof DecorationSet ? m : m.members), []));\n        }\n    }\n    forEachSet(f) {\n        for (let i = 0; i < this.members.length; i++)\n            this.members[i].forEachSet(f);\n    }\n}\nfunction mapChildren(oldChildren, newLocal, mapping, node, offset, oldOffset, options) {\n    let children = oldChildren.slice();\n    // Mark the children that are directly touched by changes, and\n    // move those that are after the changes.\n    for (let i = 0, baseOffset = oldOffset; i < mapping.maps.length; i++) {\n        let moved = 0;\n        mapping.maps[i].forEach((oldStart, oldEnd, newStart, newEnd) => {\n            let dSize = (newEnd - newStart) - (oldEnd - oldStart);\n            for (let i = 0; i < children.length; i += 3) {\n                let end = children[i + 1];\n                if (end < 0 || oldStart > end + baseOffset - moved)\n                    continue;\n                let start = children[i] + baseOffset - moved;\n                if (oldEnd >= start) {\n                    children[i + 1] = oldStart <= start ? -2 : -1;\n                }\n                else if (oldStart >= baseOffset && dSize) {\n                    children[i] += dSize;\n                    children[i + 1] += dSize;\n                }\n            }\n            moved += dSize;\n        });\n        baseOffset = mapping.maps[i].map(baseOffset, -1);\n    }\n    // Find the child nodes that still correspond to a single node,\n    // recursively call mapInner on them and update their positions.\n    let mustRebuild = false;\n    for (let i = 0; i < children.length; i += 3)\n        if (children[i + 1] < 0) { // Touched nodes\n            if (children[i + 1] == -2) {\n                mustRebuild = true;\n                children[i + 1] = -1;\n                continue;\n            }\n            let from = mapping.map(oldChildren[i] + oldOffset), fromLocal = from - offset;\n            if (fromLocal < 0 || fromLocal >= node.content.size) {\n                mustRebuild = true;\n                continue;\n            }\n            // Must read oldChildren because children was tagged with -1\n            let to = mapping.map(oldChildren[i + 1] + oldOffset, -1), toLocal = to - offset;\n            let { index, offset: childOffset } = node.content.findIndex(fromLocal);\n            let childNode = node.maybeChild(index);\n            if (childNode && childOffset == fromLocal && childOffset + childNode.nodeSize == toLocal) {\n                let mapped = children[i + 2]\n                    .mapInner(mapping, childNode, from + 1, oldChildren[i] + oldOffset + 1, options);\n                if (mapped != empty) {\n                    children[i] = fromLocal;\n                    children[i + 1] = toLocal;\n                    children[i + 2] = mapped;\n                }\n                else {\n                    children[i + 1] = -2;\n                    mustRebuild = true;\n                }\n            }\n            else {\n                mustRebuild = true;\n            }\n        }\n    // Remaining children must be collected and rebuilt into the appropriate structure\n    if (mustRebuild) {\n        let decorations = mapAndGatherRemainingDecorations(children, oldChildren, newLocal, mapping, offset, oldOffset, options);\n        let built = buildTree(decorations, node, 0, options);\n        newLocal = built.local;\n        for (let i = 0; i < children.length; i += 3)\n            if (children[i + 1] < 0) {\n                children.splice(i, 3);\n                i -= 3;\n            }\n        for (let i = 0, j = 0; i < built.children.length; i += 3) {\n            let from = built.children[i];\n            while (j < children.length && children[j] < from)\n                j += 3;\n            children.splice(j, 0, built.children[i], built.children[i + 1], built.children[i + 2]);\n        }\n    }\n    return new DecorationSet(newLocal.sort(byPos), children);\n}\nfunction moveSpans(spans, offset) {\n    if (!offset || !spans.length)\n        return spans;\n    let result = [];\n    for (let i = 0; i < spans.length; i++) {\n        let span = spans[i];\n        result.push(new Decoration(span.from + offset, span.to + offset, span.type));\n    }\n    return result;\n}\nfunction mapAndGatherRemainingDecorations(children, oldChildren, decorations, mapping, offset, oldOffset, options) {\n    // Gather all decorations from the remaining marked children\n    function gather(set, oldOffset) {\n        for (let i = 0; i < set.local.length; i++) {\n            let mapped = set.local[i].map(mapping, offset, oldOffset);\n            if (mapped)\n                decorations.push(mapped);\n            else if (options.onRemove)\n                options.onRemove(set.local[i].spec);\n        }\n        for (let i = 0; i < set.children.length; i += 3)\n            gather(set.children[i + 2], set.children[i] + oldOffset + 1);\n    }\n    for (let i = 0; i < children.length; i += 3)\n        if (children[i + 1] == -1)\n            gather(children[i + 2], oldChildren[i] + oldOffset + 1);\n    return decorations;\n}\nfunction takeSpansForNode(spans, node, offset) {\n    if (node.isLeaf)\n        return null;\n    let end = offset + node.nodeSize, found = null;\n    for (let i = 0, span; i < spans.length; i++) {\n        if ((span = spans[i]) && span.from > offset && span.to < end) {\n            (found || (found = [])).push(span);\n            spans[i] = null;\n        }\n    }\n    return found;\n}\nfunction withoutNulls(array) {\n    let result = [];\n    for (let i = 0; i < array.length; i++)\n        if (array[i] != null)\n            result.push(array[i]);\n    return result;\n}\n// Build up a tree that corresponds to a set of decorations. `offset`\n// is a base offset that should be subtracted from the `from` and `to`\n// positions in the spans (so that we don't have to allocate new spans\n// for recursive calls).\nfunction buildTree(spans, node, offset, options) {\n    let children = [], hasNulls = false;\n    node.forEach((childNode, localStart) => {\n        let found = takeSpansForNode(spans, childNode, localStart + offset);\n        if (found) {\n            hasNulls = true;\n            let subtree = buildTree(found, childNode, offset + localStart + 1, options);\n            if (subtree != empty)\n                children.push(localStart, localStart + childNode.nodeSize, subtree);\n        }\n    });\n    let locals = moveSpans(hasNulls ? withoutNulls(spans) : spans, -offset).sort(byPos);\n    for (let i = 0; i < locals.length; i++)\n        if (!locals[i].type.valid(node, locals[i])) {\n            if (options.onRemove)\n                options.onRemove(locals[i].spec);\n            locals.splice(i--, 1);\n        }\n    return locals.length || children.length ? new DecorationSet(locals, children) : empty;\n}\n// Used to sort decorations so that ones with a low start position\n// come first, and within a set with the same start position, those\n// with an smaller end position come first.\nfunction byPos(a, b) {\n    return a.from - b.from || a.to - b.to;\n}\n// Scan a sorted array of decorations for partially overlapping spans,\n// and split those so that only fully overlapping spans are left (to\n// make subsequent rendering easier). Will return the input array if\n// no partially overlapping spans are found (the common case).\nfunction removeOverlap(spans) {\n    let working = spans;\n    for (let i = 0; i < working.length - 1; i++) {\n        let span = working[i];\n        if (span.from != span.to)\n            for (let j = i + 1; j < working.length; j++) {\n                let next = working[j];\n                if (next.from == span.from) {\n                    if (next.to != span.to) {\n                        if (working == spans)\n                            working = spans.slice();\n                        // Followed by a partially overlapping larger span. Split that\n                        // span.\n                        working[j] = next.copy(next.from, span.to);\n                        insertAhead(working, j + 1, next.copy(span.to, next.to));\n                    }\n                    continue;\n                }\n                else {\n                    if (next.from < span.to) {\n                        if (working == spans)\n                            working = spans.slice();\n                        // The end of this one overlaps with a subsequent span. Split\n                        // this one.\n                        working[i] = span.copy(span.from, next.from);\n                        insertAhead(working, j, span.copy(next.from, span.to));\n                    }\n                    break;\n                }\n            }\n    }\n    return working;\n}\nfunction insertAhead(array, i, deco) {\n    while (i < array.length && byPos(deco, array[i]) > 0)\n        i++;\n    array.splice(i, 0, deco);\n}\n// Get the decorations associated with the current props of a view.\nfunction viewDecorations(view) {\n    let found = [];\n    view.someProp(\"decorations\", f => {\n        let result = f(view.state);\n        if (result && result != empty)\n            found.push(result);\n    });\n    if (view.cursorWrapper)\n        found.push(DecorationSet.create(view.state.doc, [view.cursorWrapper.deco]));\n    return DecorationGroup.from(found);\n}\n\nconst observeOptions = {\n    childList: true,\n    characterData: true,\n    characterDataOldValue: true,\n    attributes: true,\n    attributeOldValue: true,\n    subtree: true\n};\n// IE11 has very broken mutation observers, so we also listen to DOMCharacterDataModified\nconst useCharData = ie && ie_version <= 11;\nclass SelectionState {\n    constructor() {\n        this.anchorNode = null;\n        this.anchorOffset = 0;\n        this.focusNode = null;\n        this.focusOffset = 0;\n    }\n    set(sel) {\n        this.anchorNode = sel.anchorNode;\n        this.anchorOffset = sel.anchorOffset;\n        this.focusNode = sel.focusNode;\n        this.focusOffset = sel.focusOffset;\n    }\n    clear() {\n        this.anchorNode = this.focusNode = null;\n    }\n    eq(sel) {\n        return sel.anchorNode == this.anchorNode && sel.anchorOffset == this.anchorOffset &&\n            sel.focusNode == this.focusNode && sel.focusOffset == this.focusOffset;\n    }\n}\nclass DOMObserver {\n    constructor(view, handleDOMChange) {\n        this.view = view;\n        this.handleDOMChange = handleDOMChange;\n        this.queue = [];\n        this.flushingSoon = -1;\n        this.observer = null;\n        this.currentSelection = new SelectionState;\n        this.onCharData = null;\n        this.suppressingSelectionUpdates = false;\n        this.lastChangedTextNode = null;\n        this.observer = window.MutationObserver &&\n            new window.MutationObserver(mutations => {\n                for (let i = 0; i < mutations.length; i++)\n                    this.queue.push(mutations[i]);\n                // IE11 will sometimes (on backspacing out a single character\n                // text node after a BR node) call the observer callback\n                // before actually updating the DOM, which will cause\n                // ProseMirror to miss the change (see #930)\n                if (ie && ie_version <= 11 && mutations.some(m => m.type == \"childList\" && m.removedNodes.length ||\n                    m.type == \"characterData\" && m.oldValue.length > m.target.nodeValue.length))\n                    this.flushSoon();\n                else\n                    this.flush();\n            });\n        if (useCharData) {\n            this.onCharData = e => {\n                this.queue.push({ target: e.target, type: \"characterData\", oldValue: e.prevValue });\n                this.flushSoon();\n            };\n        }\n        this.onSelectionChange = this.onSelectionChange.bind(this);\n    }\n    flushSoon() {\n        if (this.flushingSoon < 0)\n            this.flushingSoon = window.setTimeout(() => { this.flushingSoon = -1; this.flush(); }, 20);\n    }\n    forceFlush() {\n        if (this.flushingSoon > -1) {\n            window.clearTimeout(this.flushingSoon);\n            this.flushingSoon = -1;\n            this.flush();\n        }\n    }\n    start() {\n        if (this.observer) {\n            this.observer.takeRecords();\n            this.observer.observe(this.view.dom, observeOptions);\n        }\n        if (this.onCharData)\n            this.view.dom.addEventListener(\"DOMCharacterDataModified\", this.onCharData);\n        this.connectSelection();\n    }\n    stop() {\n        if (this.observer) {\n            let take = this.observer.takeRecords();\n            if (take.length) {\n                for (let i = 0; i < take.length; i++)\n                    this.queue.push(take[i]);\n                window.setTimeout(() => this.flush(), 20);\n            }\n            this.observer.disconnect();\n        }\n        if (this.onCharData)\n            this.view.dom.removeEventListener(\"DOMCharacterDataModified\", this.onCharData);\n        this.disconnectSelection();\n    }\n    connectSelection() {\n        this.view.dom.ownerDocument.addEventListener(\"selectionchange\", this.onSelectionChange);\n    }\n    disconnectSelection() {\n        this.view.dom.ownerDocument.removeEventListener(\"selectionchange\", this.onSelectionChange);\n    }\n    suppressSelectionUpdates() {\n        this.suppressingSelectionUpdates = true;\n        setTimeout(() => this.suppressingSelectionUpdates = false, 50);\n    }\n    onSelectionChange() {\n        if (!hasFocusAndSelection(this.view))\n            return;\n        if (this.suppressingSelectionUpdates)\n            return selectionToDOM(this.view);\n        // Deletions on IE11 fire their events in the wrong order, giving\n        // us a selection change event before the DOM changes are\n        // reported.\n        if (ie && ie_version <= 11 && !this.view.state.selection.empty) {\n            let sel = this.view.domSelectionRange();\n            // Selection.isCollapsed isn't reliable on IE\n            if (sel.focusNode && isEquivalentPosition(sel.focusNode, sel.focusOffset, sel.anchorNode, sel.anchorOffset))\n                return this.flushSoon();\n        }\n        this.flush();\n    }\n    setCurSelection() {\n        this.currentSelection.set(this.view.domSelectionRange());\n    }\n    ignoreSelectionChange(sel) {\n        if (!sel.focusNode)\n            return true;\n        let ancestors = new Set, container;\n        for (let scan = sel.focusNode; scan; scan = parentNode(scan))\n            ancestors.add(scan);\n        for (let scan = sel.anchorNode; scan; scan = parentNode(scan))\n            if (ancestors.has(scan)) {\n                container = scan;\n                break;\n            }\n        let desc = container && this.view.docView.nearestDesc(container);\n        if (desc && desc.ignoreMutation({\n            type: \"selection\",\n            target: container.nodeType == 3 ? container.parentNode : container\n        })) {\n            this.setCurSelection();\n            return true;\n        }\n    }\n    pendingRecords() {\n        if (this.observer)\n            for (let mut of this.observer.takeRecords())\n                this.queue.push(mut);\n        return this.queue;\n    }\n    flush() {\n        let { view } = this;\n        if (!view.docView || this.flushingSoon > -1)\n            return;\n        let mutations = this.pendingRecords();\n        if (mutations.length)\n            this.queue = [];\n        let sel = view.domSelectionRange();\n        let newSel = !this.suppressingSelectionUpdates && !this.currentSelection.eq(sel) && hasFocusAndSelection(view) && !this.ignoreSelectionChange(sel);\n        let from = -1, to = -1, typeOver = false, added = [];\n        if (view.editable) {\n            for (let i = 0; i < mutations.length; i++) {\n                let result = this.registerMutation(mutations[i], added);\n                if (result) {\n                    from = from < 0 ? result.from : Math.min(result.from, from);\n                    to = to < 0 ? result.to : Math.max(result.to, to);\n                    if (result.typeOver)\n                        typeOver = true;\n                }\n            }\n        }\n        if (gecko && added.length) {\n            let brs = added.filter(n => n.nodeName == \"BR\");\n            if (brs.length == 2) {\n                let [a, b] = brs;\n                if (a.parentNode && a.parentNode.parentNode == b.parentNode)\n                    b.remove();\n                else\n                    a.remove();\n            }\n            else {\n                let { focusNode } = this.currentSelection;\n                for (let br of brs) {\n                    let parent = br.parentNode;\n                    if (parent && parent.nodeName == \"LI\" && (!focusNode || blockParent(view, focusNode) != parent))\n                        br.remove();\n                }\n            }\n        }\n        let readSel = null;\n        // If it looks like the browser has reset the selection to the\n        // start of the document after focus, restore the selection from\n        // the state\n        if (from < 0 && newSel && view.input.lastFocus > Date.now() - 200 &&\n            Math.max(view.input.lastTouch, view.input.lastClick.time) < Date.now() - 300 &&\n            selectionCollapsed(sel) && (readSel = selectionFromDOM(view)) &&\n            readSel.eq(prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.Selection.near(view.state.doc.resolve(0), 1))) {\n            view.input.lastFocus = 0;\n            selectionToDOM(view);\n            this.currentSelection.set(sel);\n            view.scrollToSelection();\n        }\n        else if (from > -1 || newSel) {\n            if (from > -1) {\n                view.docView.markDirty(from, to);\n                checkCSS(view);\n            }\n            this.handleDOMChange(from, to, typeOver, added);\n            if (view.docView && view.docView.dirty)\n                view.updateState(view.state);\n            else if (!this.currentSelection.eq(sel))\n                selectionToDOM(view);\n            this.currentSelection.set(sel);\n        }\n    }\n    registerMutation(mut, added) {\n        // Ignore mutations inside nodes that were already noted as inserted\n        if (added.indexOf(mut.target) > -1)\n            return null;\n        let desc = this.view.docView.nearestDesc(mut.target);\n        if (mut.type == \"attributes\" &&\n            (desc == this.view.docView || mut.attributeName == \"contenteditable\" ||\n                // Firefox sometimes fires spurious events for null/empty styles\n                (mut.attributeName == \"style\" && !mut.oldValue && !mut.target.getAttribute(\"style\"))))\n            return null;\n        if (!desc || desc.ignoreMutation(mut))\n            return null;\n        if (mut.type == \"childList\") {\n            for (let i = 0; i < mut.addedNodes.length; i++) {\n                let node = mut.addedNodes[i];\n                added.push(node);\n                if (node.nodeType == 3)\n                    this.lastChangedTextNode = node;\n            }\n            if (desc.contentDOM && desc.contentDOM != desc.dom && !desc.contentDOM.contains(mut.target))\n                return { from: desc.posBefore, to: desc.posAfter };\n            let prev = mut.previousSibling, next = mut.nextSibling;\n            if (ie && ie_version <= 11 && mut.addedNodes.length) {\n                // IE11 gives us incorrect next/prev siblings for some\n                // insertions, so if there are added nodes, recompute those\n                for (let i = 0; i < mut.addedNodes.length; i++) {\n                    let { previousSibling, nextSibling } = mut.addedNodes[i];\n                    if (!previousSibling || Array.prototype.indexOf.call(mut.addedNodes, previousSibling) < 0)\n                        prev = previousSibling;\n                    if (!nextSibling || Array.prototype.indexOf.call(mut.addedNodes, nextSibling) < 0)\n                        next = nextSibling;\n                }\n            }\n            let fromOffset = prev && prev.parentNode == mut.target\n                ? domIndex(prev) + 1 : 0;\n            let from = desc.localPosFromDOM(mut.target, fromOffset, -1);\n            let toOffset = next && next.parentNode == mut.target\n                ? domIndex(next) : mut.target.childNodes.length;\n            let to = desc.localPosFromDOM(mut.target, toOffset, 1);\n            return { from, to };\n        }\n        else if (mut.type == \"attributes\") {\n            return { from: desc.posAtStart - desc.border, to: desc.posAtEnd + desc.border };\n        }\n        else { // \"characterData\"\n            this.lastChangedTextNode = mut.target;\n            return {\n                from: desc.posAtStart,\n                to: desc.posAtEnd,\n                // An event was generated for a text change that didn't change\n                // any text. Mark the dom change to fall back to assuming the\n                // selection was typed over with an identical value if it can't\n                // find another change.\n                typeOver: mut.target.nodeValue == mut.oldValue\n            };\n        }\n    }\n}\nlet cssChecked = new WeakMap();\nlet cssCheckWarned = false;\nfunction checkCSS(view) {\n    if (cssChecked.has(view))\n        return;\n    cssChecked.set(view, null);\n    if (['normal', 'nowrap', 'pre-line'].indexOf(getComputedStyle(view.dom).whiteSpace) !== -1) {\n        view.requiresGeckoHackNode = gecko;\n        if (cssCheckWarned)\n            return;\n        console[\"warn\"](\"ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package.\");\n        cssCheckWarned = true;\n    }\n}\nfunction rangeToSelectionRange(view, range) {\n    let anchorNode = range.startContainer, anchorOffset = range.startOffset;\n    let focusNode = range.endContainer, focusOffset = range.endOffset;\n    let currentAnchor = view.domAtPos(view.state.selection.anchor);\n    // Since such a range doesn't distinguish between anchor and head,\n    // use a heuristic that flips it around if its end matches the\n    // current anchor.\n    if (isEquivalentPosition(currentAnchor.node, currentAnchor.offset, focusNode, focusOffset))\n        [anchorNode, anchorOffset, focusNode, focusOffset] = [focusNode, focusOffset, anchorNode, anchorOffset];\n    return { anchorNode, anchorOffset, focusNode, focusOffset };\n}\n// Used to work around a Safari Selection/shadow DOM bug\n// Based on https://github.com/codemirror/dev/issues/414 fix\nfunction safariShadowSelectionRange(view, selection) {\n    if (selection.getComposedRanges) {\n        let range = selection.getComposedRanges(view.root)[0];\n        if (range)\n            return rangeToSelectionRange(view, range);\n    }\n    let found;\n    function read(event) {\n        event.preventDefault();\n        event.stopImmediatePropagation();\n        found = event.getTargetRanges()[0];\n    }\n    // Because Safari (at least in 2018-2022) doesn't provide regular\n    // access to the selection inside a shadowRoot, we have to perform a\n    // ridiculous hack to get at it—using `execCommand` to trigger a\n    // `beforeInput` event so that we can read the target range from the\n    // event.\n    view.dom.addEventListener(\"beforeinput\", read, true);\n    document.execCommand(\"indent\");\n    view.dom.removeEventListener(\"beforeinput\", read, true);\n    return found ? rangeToSelectionRange(view, found) : null;\n}\nfunction blockParent(view, node) {\n    for (let p = node.parentNode; p && p != view.dom; p = p.parentNode) {\n        let desc = view.docView.nearestDesc(p, true);\n        if (desc && desc.node.isBlock)\n            return p;\n    }\n    return null;\n}\n\n// Note that all referencing and parsing is done with the\n// start-of-operation selection and document, since that's the one\n// that the DOM represents. If any changes came in in the meantime,\n// the modification is mapped over those before it is applied, in\n// readDOMChange.\nfunction parseBetween(view, from_, to_) {\n    let { node: parent, fromOffset, toOffset, from, to } = view.docView.parseRange(from_, to_);\n    let domSel = view.domSelectionRange();\n    let find;\n    let anchor = domSel.anchorNode;\n    if (anchor && view.dom.contains(anchor.nodeType == 1 ? anchor : anchor.parentNode)) {\n        find = [{ node: anchor, offset: domSel.anchorOffset }];\n        if (!selectionCollapsed(domSel))\n            find.push({ node: domSel.focusNode, offset: domSel.focusOffset });\n    }\n    // Work around issue in Chrome where backspacing sometimes replaces\n    // the deleted content with a random BR node (issues #799, #831)\n    if (chrome && view.input.lastKeyCode === 8) {\n        for (let off = toOffset; off > fromOffset; off--) {\n            let node = parent.childNodes[off - 1], desc = node.pmViewDesc;\n            if (node.nodeName == \"BR\" && !desc) {\n                toOffset = off;\n                break;\n            }\n            if (!desc || desc.size)\n                break;\n        }\n    }\n    let startDoc = view.state.doc;\n    let parser = view.someProp(\"domParser\") || prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.DOMParser.fromSchema(view.state.schema);\n    let $from = startDoc.resolve(from);\n    let sel = null, doc = parser.parse(parent, {\n        topNode: $from.parent,\n        topMatch: $from.parent.contentMatchAt($from.index()),\n        topOpen: true,\n        from: fromOffset,\n        to: toOffset,\n        preserveWhitespace: $from.parent.type.whitespace == \"pre\" ? \"full\" : true,\n        findPositions: find,\n        ruleFromNode,\n        context: $from\n    });\n    if (find && find[0].pos != null) {\n        let anchor = find[0].pos, head = find[1] && find[1].pos;\n        if (head == null)\n            head = anchor;\n        sel = { anchor: anchor + from, head: head + from };\n    }\n    return { doc, sel, from, to };\n}\nfunction ruleFromNode(dom) {\n    let desc = dom.pmViewDesc;\n    if (desc) {\n        return desc.parseRule();\n    }\n    else if (dom.nodeName == \"BR\" && dom.parentNode) {\n        // Safari replaces the list item or table cell with a BR\n        // directly in the list node (?!) if you delete the last\n        // character in a list item or table cell (#708, #862)\n        if (safari && /^(ul|ol)$/i.test(dom.parentNode.nodeName)) {\n            let skip = document.createElement(\"div\");\n            skip.appendChild(document.createElement(\"li\"));\n            return { skip };\n        }\n        else if (dom.parentNode.lastChild == dom || safari && /^(tr|table)$/i.test(dom.parentNode.nodeName)) {\n            return { ignore: true };\n        }\n    }\n    else if (dom.nodeName == \"IMG\" && dom.getAttribute(\"mark-placeholder\")) {\n        return { ignore: true };\n    }\n    return null;\n}\nconst isInline = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|img|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;\nfunction readDOMChange(view, from, to, typeOver, addedNodes) {\n    let compositionID = view.input.compositionPendingChanges || (view.composing ? view.input.compositionID : 0);\n    view.input.compositionPendingChanges = 0;\n    if (from < 0) {\n        let origin = view.input.lastSelectionTime > Date.now() - 50 ? view.input.lastSelectionOrigin : null;\n        let newSel = selectionFromDOM(view, origin);\n        if (newSel && !view.state.selection.eq(newSel)) {\n            if (chrome && android &&\n                view.input.lastKeyCode === 13 && Date.now() - 100 < view.input.lastKeyCodeTime &&\n                view.someProp(\"handleKeyDown\", f => f(view, keyEvent(13, \"Enter\"))))\n                return;\n            let tr = view.state.tr.setSelection(newSel);\n            if (origin == \"pointer\")\n                tr.setMeta(\"pointer\", true);\n            else if (origin == \"key\")\n                tr.scrollIntoView();\n            if (compositionID)\n                tr.setMeta(\"composition\", compositionID);\n            view.dispatch(tr);\n        }\n        return;\n    }\n    let $before = view.state.doc.resolve(from);\n    let shared = $before.sharedDepth(to);\n    from = $before.before(shared + 1);\n    to = view.state.doc.resolve(to).after(shared + 1);\n    let sel = view.state.selection;\n    let parse = parseBetween(view, from, to);\n    let doc = view.state.doc, compare = doc.slice(parse.from, parse.to);\n    let preferredPos, preferredSide;\n    // Prefer anchoring to end when Backspace is pressed\n    if (view.input.lastKeyCode === 8 && Date.now() - 100 < view.input.lastKeyCodeTime) {\n        preferredPos = view.state.selection.to;\n        preferredSide = \"end\";\n    }\n    else {\n        preferredPos = view.state.selection.from;\n        preferredSide = \"start\";\n    }\n    view.input.lastKeyCode = null;\n    let change = findDiff(compare.content, parse.doc.content, parse.from, preferredPos, preferredSide);\n    if (change)\n        view.input.domChangeCount++;\n    if ((ios && view.input.lastIOSEnter > Date.now() - 225 || android) &&\n        addedNodes.some(n => n.nodeType == 1 && !isInline.test(n.nodeName)) &&\n        (!change || change.endA >= change.endB) &&\n        view.someProp(\"handleKeyDown\", f => f(view, keyEvent(13, \"Enter\")))) {\n        view.input.lastIOSEnter = 0;\n        return;\n    }\n    if (!change) {\n        if (typeOver && sel instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection && !sel.empty && sel.$head.sameParent(sel.$anchor) &&\n            !view.composing && !(parse.sel && parse.sel.anchor != parse.sel.head)) {\n            change = { start: sel.from, endA: sel.to, endB: sel.to };\n        }\n        else {\n            if (parse.sel) {\n                let sel = resolveSelection(view, view.state.doc, parse.sel);\n                if (sel && !sel.eq(view.state.selection)) {\n                    let tr = view.state.tr.setSelection(sel);\n                    if (compositionID)\n                        tr.setMeta(\"composition\", compositionID);\n                    view.dispatch(tr);\n                }\n            }\n            return;\n        }\n    }\n    // Handle the case where overwriting a selection by typing matches\n    // the start or end of the selected content, creating a change\n    // that's smaller than what was actually overwritten.\n    if (view.state.selection.from < view.state.selection.to &&\n        change.start == change.endB &&\n        view.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.TextSelection) {\n        if (change.start > view.state.selection.from && change.start <= view.state.selection.from + 2 &&\n            view.state.selection.from >= parse.from) {\n            change.start = view.state.selection.from;\n        }\n        else if (change.endA < view.state.selection.to && change.endA >= view.state.selection.to - 2 &&\n            view.state.selection.to <= parse.to) {\n            change.endB += (view.state.selection.to - change.endA);\n            change.endA = view.state.selection.to;\n        }\n    }\n    // IE11 will insert a non-breaking space _ahead_ of the space after\n    // the cursor space when adding a space before another space. When\n    // that happened, adjust the change to cover the space instead.\n    if (ie && ie_version <= 11 && change.endB == change.start + 1 &&\n        change.endA == change.start && change.start > parse.from &&\n        parse.doc.textBetween(change.start - parse.from - 1, change.start - parse.from + 1) == \" \\u00a0\") {\n        change.start--;\n        change.endA--;\n        change.endB--;\n    }\n    let $from = parse.doc.resolveNoCache(change.start - parse.from);\n    let $to = parse.doc.resolveNoCache(change.endB - parse.from);\n    let $fromA = doc.resolve(change.start);\n    let inlineChange = $from.sameParent($to) && $from.parent.inlineContent && $fromA.end() >= change.endA;\n    // If this looks like the effect of pressing Enter (or was recorded\n    // as being an iOS enter press), just dispatch an Enter key instead.\n    if (((ios && view.input.lastIOSEnter > Date.now() - 225 &&\n        (!inlineChange || addedNodes.some(n => n.nodeName == \"DIV\" || n.nodeName == \"P\"))) ||\n        (!inlineChange && $from.pos < parse.doc.content.size &&\n            (!$from.sameParent($to) || !$from.parent.inlineContent) &&\n            $from.pos < $to.pos && !/\\S/.test(parse.doc.textBetween($from.pos, $to.pos, \"\", \"\")))) &&\n        view.someProp(\"handleKeyDown\", f => f(view, keyEvent(13, \"Enter\")))) {\n        view.input.lastIOSEnter = 0;\n        return;\n    }\n    // Same for backspace\n    if (view.state.selection.anchor > change.start &&\n        looksLikeBackspace(doc, change.start, change.endA, $from, $to) &&\n        view.someProp(\"handleKeyDown\", f => f(view, keyEvent(8, \"Backspace\")))) {\n        if (android && chrome)\n            view.domObserver.suppressSelectionUpdates(); // #820\n        return;\n    }\n    // Chrome will occasionally, during composition, delete the\n    // entire composition and then immediately insert it again. This is\n    // used to detect that situation.\n    if (chrome && change.endB == change.start)\n        view.input.lastChromeDelete = Date.now();\n    // This tries to detect Android virtual keyboard\n    // enter-and-pick-suggestion action. That sometimes (see issue\n    // #1059) first fires a DOM mutation, before moving the selection to\n    // the newly created block. And then, because ProseMirror cleans up\n    // the DOM selection, it gives up moving the selection entirely,\n    // leaving the cursor in the wrong place. When that happens, we drop\n    // the new paragraph from the initial change, and fire a simulated\n    // enter key afterwards.\n    if (android && !inlineChange && $from.start() != $to.start() && $to.parentOffset == 0 && $from.depth == $to.depth &&\n        parse.sel && parse.sel.anchor == parse.sel.head && parse.sel.head == change.endA) {\n        change.endB -= 2;\n        $to = parse.doc.resolveNoCache(change.endB - parse.from);\n        setTimeout(() => {\n            view.someProp(\"handleKeyDown\", function (f) { return f(view, keyEvent(13, \"Enter\")); });\n        }, 20);\n    }\n    let chFrom = change.start, chTo = change.endA;\n    let mkTr = (base) => {\n        let tr = base || view.state.tr.replace(chFrom, chTo, parse.doc.slice(change.start - parse.from, change.endB - parse.from));\n        if (parse.sel) {\n            let sel = resolveSelection(view, tr.doc, parse.sel);\n            // Chrome will sometimes, during composition, report the\n            // selection in the wrong place. If it looks like that is\n            // happening, don't update the selection.\n            // Edge just doesn't move the cursor forward when you start typing\n            // in an empty block or between br nodes.\n            if (sel && !(chrome && view.composing && sel.empty &&\n                (change.start != change.endB || view.input.lastChromeDelete < Date.now() - 100) &&\n                (sel.head == chFrom || sel.head == tr.mapping.map(chTo) - 1) ||\n                ie && sel.empty && sel.head == chFrom))\n                tr.setSelection(sel);\n        }\n        if (compositionID)\n            tr.setMeta(\"composition\", compositionID);\n        return tr.scrollIntoView();\n    };\n    let markChange;\n    if (inlineChange) {\n        if ($from.pos == $to.pos) { // Deletion\n            // IE11 sometimes weirdly moves the DOM selection around after\n            // backspacing out the first element in a textblock\n            if (ie && ie_version <= 11 && $from.parentOffset == 0) {\n                view.domObserver.suppressSelectionUpdates();\n                setTimeout(() => selectionToDOM(view), 20);\n            }\n            let tr = mkTr(view.state.tr.delete(chFrom, chTo));\n            let marks = doc.resolve(change.start).marksAcross(doc.resolve(change.endA));\n            if (marks)\n                tr.ensureMarks(marks);\n            view.dispatch(tr);\n        }\n        else if ( // Adding or removing a mark\n        change.endA == change.endB &&\n            (markChange = isMarkChange($from.parent.content.cut($from.parentOffset, $to.parentOffset), $fromA.parent.content.cut($fromA.parentOffset, change.endA - $fromA.start())))) {\n            let tr = mkTr(view.state.tr);\n            if (markChange.type == \"add\")\n                tr.addMark(chFrom, chTo, markChange.mark);\n            else\n                tr.removeMark(chFrom, chTo, markChange.mark);\n            view.dispatch(tr);\n        }\n        else if ($from.parent.child($from.index()).isText && $from.index() == $to.index() - ($to.textOffset ? 0 : 1)) {\n            // Both positions in the same text node -- simply insert text\n            let text = $from.parent.textBetween($from.parentOffset, $to.parentOffset);\n            let deflt = () => mkTr(view.state.tr.insertText(text, chFrom, chTo));\n            if (!view.someProp(\"handleTextInput\", f => f(view, chFrom, chTo, text, deflt)))\n                view.dispatch(deflt());\n        }\n        else {\n            view.dispatch(mkTr());\n        }\n    }\n    else {\n        view.dispatch(mkTr());\n    }\n}\nfunction resolveSelection(view, doc, parsedSel) {\n    if (Math.max(parsedSel.anchor, parsedSel.head) > doc.content.size)\n        return null;\n    return selectionBetween(view, doc.resolve(parsedSel.anchor), doc.resolve(parsedSel.head));\n}\n// Given two same-length, non-empty fragments of inline content,\n// determine whether the first could be created from the second by\n// removing or adding a single mark type.\nfunction isMarkChange(cur, prev) {\n    let curMarks = cur.firstChild.marks, prevMarks = prev.firstChild.marks;\n    let added = curMarks, removed = prevMarks, type, mark, update;\n    for (let i = 0; i < prevMarks.length; i++)\n        added = prevMarks[i].removeFromSet(added);\n    for (let i = 0; i < curMarks.length; i++)\n        removed = curMarks[i].removeFromSet(removed);\n    if (added.length == 1 && removed.length == 0) {\n        mark = added[0];\n        type = \"add\";\n        update = (node) => node.mark(mark.addToSet(node.marks));\n    }\n    else if (added.length == 0 && removed.length == 1) {\n        mark = removed[0];\n        type = \"remove\";\n        update = (node) => node.mark(mark.removeFromSet(node.marks));\n    }\n    else {\n        return null;\n    }\n    let updated = [];\n    for (let i = 0; i < prev.childCount; i++)\n        updated.push(update(prev.child(i)));\n    if (prosemirror_model__WEBPACK_IMPORTED_MODULE_0__.Fragment.from(updated).eq(cur))\n        return { mark, type };\n}\nfunction looksLikeBackspace(old, start, end, $newStart, $newEnd) {\n    if ( // The content must have shrunk\n    end - start <= $newEnd.pos - $newStart.pos ||\n        // newEnd must point directly at or after the end of the block that newStart points into\n        skipClosingAndOpening($newStart, true, false) < $newEnd.pos)\n        return false;\n    let $start = old.resolve(start);\n    // Handle the case where, rather than joining blocks, the change just removed an entire block\n    if (!$newStart.parent.isTextblock) {\n        let after = $start.nodeAfter;\n        return after != null && end == start + after.nodeSize;\n    }\n    // Start must be at the end of a block\n    if ($start.parentOffset < $start.parent.content.size || !$start.parent.isTextblock)\n        return false;\n    let $next = old.resolve(skipClosingAndOpening($start, true, true));\n    // The next textblock must start before end and end near it\n    if (!$next.parent.isTextblock || $next.pos > end ||\n        skipClosingAndOpening($next, true, false) < end)\n        return false;\n    // The fragments after the join point must match\n    return $newStart.parent.content.cut($newStart.parentOffset).eq($next.parent.content);\n}\nfunction skipClosingAndOpening($pos, fromEnd, mayOpen) {\n    let depth = $pos.depth, end = fromEnd ? $pos.end() : $pos.pos;\n    while (depth > 0 && (fromEnd || $pos.indexAfter(depth) == $pos.node(depth).childCount)) {\n        depth--;\n        end++;\n        fromEnd = false;\n    }\n    if (mayOpen) {\n        let next = $pos.node(depth).maybeChild($pos.indexAfter(depth));\n        while (next && !next.isLeaf) {\n            next = next.firstChild;\n            end++;\n        }\n    }\n    return end;\n}\nfunction findDiff(a, b, pos, preferredPos, preferredSide) {\n    let start = a.findDiffStart(b, pos);\n    if (start == null)\n        return null;\n    let { a: endA, b: endB } = a.findDiffEnd(b, pos + a.size, pos + b.size);\n    if (preferredSide == \"end\") {\n        let adjust = Math.max(0, start - Math.min(endA, endB));\n        preferredPos -= endA + adjust - start;\n    }\n    if (endA < start && a.size < b.size) {\n        let move = preferredPos <= start && preferredPos >= endA ? start - preferredPos : 0;\n        start -= move;\n        if (start && start < b.size && isSurrogatePair(b.textBetween(start - 1, start + 1)))\n            start += move ? 1 : -1;\n        endB = start + (endB - endA);\n        endA = start;\n    }\n    else if (endB < start) {\n        let move = preferredPos <= start && preferredPos >= endB ? start - preferredPos : 0;\n        start -= move;\n        if (start && start < a.size && isSurrogatePair(a.textBetween(start - 1, start + 1)))\n            start += move ? 1 : -1;\n        endA = start + (endA - endB);\n        endB = start;\n    }\n    return { start, endA, endB };\n}\nfunction isSurrogatePair(str) {\n    if (str.length != 2)\n        return false;\n    let a = str.charCodeAt(0), b = str.charCodeAt(1);\n    return a >= 0xDC00 && a <= 0xDFFF && b >= 0xD800 && b <= 0xDBFF;\n}\n\n/**\n@internal\n*/\nconst __parseFromClipboard = parseFromClipboard;\n/**\n@internal\n*/\nconst __endComposition = endComposition;\n/**\nAn editor view manages the DOM structure that represents an\neditable document. Its state and behavior are determined by its\n[props](https://prosemirror.net/docs/ref/#view.DirectEditorProps).\n*/\nclass EditorView {\n    /**\n    Create a view. `place` may be a DOM node that the editor should\n    be appended to, a function that will place it into the document,\n    or an object whose `mount` property holds the node to use as the\n    document container. If it is `null`, the editor will not be\n    added to the document.\n    */\n    constructor(place, props) {\n        this._root = null;\n        /**\n        @internal\n        */\n        this.focused = false;\n        /**\n        Kludge used to work around a Chrome bug @internal\n        */\n        this.trackWrites = null;\n        this.mounted = false;\n        /**\n        @internal\n        */\n        this.markCursor = null;\n        /**\n        @internal\n        */\n        this.cursorWrapper = null;\n        /**\n        @internal\n        */\n        this.lastSelectedViewDesc = undefined;\n        /**\n        @internal\n        */\n        this.input = new InputState;\n        this.prevDirectPlugins = [];\n        this.pluginViews = [];\n        /**\n        Holds `true` when a hack node is needed in Firefox to prevent the\n        [space is eaten issue](https://github.com/ProseMirror/prosemirror/issues/651)\n        @internal\n        */\n        this.requiresGeckoHackNode = false;\n        /**\n        When editor content is being dragged, this object contains\n        information about the dragged slice and whether it is being\n        copied or moved. At any other time, it is null.\n        */\n        this.dragging = null;\n        this._props = props;\n        this.state = props.state;\n        this.directPlugins = props.plugins || [];\n        this.directPlugins.forEach(checkStateComponent);\n        this.dispatch = this.dispatch.bind(this);\n        this.dom = (place && place.mount) || document.createElement(\"div\");\n        if (place) {\n            if (place.appendChild)\n                place.appendChild(this.dom);\n            else if (typeof place == \"function\")\n                place(this.dom);\n            else if (place.mount)\n                this.mounted = true;\n        }\n        this.editable = getEditable(this);\n        updateCursorWrapper(this);\n        this.nodeViews = buildNodeViews(this);\n        this.docView = docViewDesc(this.state.doc, computeDocDeco(this), viewDecorations(this), this.dom, this);\n        this.domObserver = new DOMObserver(this, (from, to, typeOver, added) => readDOMChange(this, from, to, typeOver, added));\n        this.domObserver.start();\n        initInput(this);\n        this.updatePluginViews();\n    }\n    /**\n    Holds `true` when a\n    [composition](https://w3c.github.io/uievents/#events-compositionevents)\n    is active.\n    */\n    get composing() { return this.input.composing; }\n    /**\n    The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).\n    */\n    get props() {\n        if (this._props.state != this.state) {\n            let prev = this._props;\n            this._props = {};\n            for (let name in prev)\n                this._props[name] = prev[name];\n            this._props.state = this.state;\n        }\n        return this._props;\n    }\n    /**\n    Update the view's props. Will immediately cause an update to\n    the DOM.\n    */\n    update(props) {\n        if (props.handleDOMEvents != this._props.handleDOMEvents)\n            ensureListeners(this);\n        let prevProps = this._props;\n        this._props = props;\n        if (props.plugins) {\n            props.plugins.forEach(checkStateComponent);\n            this.directPlugins = props.plugins;\n        }\n        this.updateStateInner(props.state, prevProps);\n    }\n    /**\n    Update the view by updating existing props object with the object\n    given as argument. Equivalent to `view.update(Object.assign({},\n    view.props, props))`.\n    */\n    setProps(props) {\n        let updated = {};\n        for (let name in this._props)\n            updated[name] = this._props[name];\n        updated.state = this.state;\n        for (let name in props)\n            updated[name] = props[name];\n        this.update(updated);\n    }\n    /**\n    Update the editor's `state` prop, without touching any of the\n    other props.\n    */\n    updateState(state) {\n        this.updateStateInner(state, this._props);\n    }\n    updateStateInner(state, prevProps) {\n        var _a;\n        let prev = this.state, redraw = false, updateSel = false;\n        // When stored marks are added, stop composition, so that they can\n        // be displayed.\n        if (state.storedMarks && this.composing) {\n            clearComposition(this);\n            updateSel = true;\n        }\n        this.state = state;\n        let pluginsChanged = prev.plugins != state.plugins || this._props.plugins != prevProps.plugins;\n        if (pluginsChanged || this._props.plugins != prevProps.plugins || this._props.nodeViews != prevProps.nodeViews) {\n            let nodeViews = buildNodeViews(this);\n            if (changedNodeViews(nodeViews, this.nodeViews)) {\n                this.nodeViews = nodeViews;\n                redraw = true;\n            }\n        }\n        if (pluginsChanged || prevProps.handleDOMEvents != this._props.handleDOMEvents) {\n            ensureListeners(this);\n        }\n        this.editable = getEditable(this);\n        updateCursorWrapper(this);\n        let innerDeco = viewDecorations(this), outerDeco = computeDocDeco(this);\n        let scroll = prev.plugins != state.plugins && !prev.doc.eq(state.doc) ? \"reset\"\n            : state.scrollToSelection > prev.scrollToSelection ? \"to selection\" : \"preserve\";\n        let updateDoc = redraw || !this.docView.matchesNode(state.doc, outerDeco, innerDeco);\n        if (updateDoc || !state.selection.eq(prev.selection))\n            updateSel = true;\n        let oldScrollPos = scroll == \"preserve\" && updateSel && this.dom.style.overflowAnchor == null && storeScrollPos(this);\n        if (updateSel) {\n            this.domObserver.stop();\n            // Work around an issue in Chrome, IE, and Edge where changing\n            // the DOM around an active selection puts it into a broken\n            // state where the thing the user sees differs from the\n            // selection reported by the Selection object (#710, #973,\n            // #1011, #1013, #1035).\n            let forceSelUpdate = updateDoc && (ie || chrome) && !this.composing &&\n                !prev.selection.empty && !state.selection.empty && selectionContextChanged(prev.selection, state.selection);\n            if (updateDoc) {\n                // If the node that the selection points into is written to,\n                // Chrome sometimes starts misreporting the selection, so this\n                // tracks that and forces a selection reset when our update\n                // did write to the node.\n                let chromeKludge = chrome ? (this.trackWrites = this.domSelectionRange().focusNode) : null;\n                if (this.composing)\n                    this.input.compositionNode = findCompositionNode(this);\n                if (redraw || !this.docView.update(state.doc, outerDeco, innerDeco, this)) {\n                    this.docView.updateOuterDeco(outerDeco);\n                    this.docView.destroy();\n                    this.docView = docViewDesc(state.doc, outerDeco, innerDeco, this.dom, this);\n                }\n                if (chromeKludge && !this.trackWrites)\n                    forceSelUpdate = true;\n            }\n            // Work around for an issue where an update arriving right between\n            // a DOM selection change and the \"selectionchange\" event for it\n            // can cause a spurious DOM selection update, disrupting mouse\n            // drag selection.\n            if (forceSelUpdate ||\n                !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) &&\n                    anchorInRightPlace(this))) {\n                selectionToDOM(this, forceSelUpdate);\n            }\n            else {\n                syncNodeSelection(this, state.selection);\n                this.domObserver.setCurSelection();\n            }\n            this.domObserver.start();\n        }\n        this.updatePluginViews(prev);\n        if (((_a = this.dragging) === null || _a === void 0 ? void 0 : _a.node) && !prev.doc.eq(state.doc))\n            this.updateDraggedNode(this.dragging, prev);\n        if (scroll == \"reset\") {\n            this.dom.scrollTop = 0;\n        }\n        else if (scroll == \"to selection\") {\n            this.scrollToSelection();\n        }\n        else if (oldScrollPos) {\n            resetScrollPos(oldScrollPos);\n        }\n    }\n    /**\n    @internal\n    */\n    scrollToSelection() {\n        let startDOM = this.domSelectionRange().focusNode;\n        if (!startDOM || !this.dom.contains(startDOM.nodeType == 1 ? startDOM : startDOM.parentNode)) ;\n        else if (this.someProp(\"handleScrollToSelection\", f => f(this))) ;\n        else if (this.state.selection instanceof prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection) {\n            let target = this.docView.domAfterPos(this.state.selection.from);\n            if (target.nodeType == 1)\n                scrollRectIntoView(this, target.getBoundingClientRect(), startDOM);\n        }\n        else {\n            scrollRectIntoView(this, this.coordsAtPos(this.state.selection.head, 1), startDOM);\n        }\n    }\n    destroyPluginViews() {\n        let view;\n        while (view = this.pluginViews.pop())\n            if (view.destroy)\n                view.destroy();\n    }\n    updatePluginViews(prevState) {\n        if (!prevState || prevState.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {\n            this.prevDirectPlugins = this.directPlugins;\n            this.destroyPluginViews();\n            for (let i = 0; i < this.directPlugins.length; i++) {\n                let plugin = this.directPlugins[i];\n                if (plugin.spec.view)\n                    this.pluginViews.push(plugin.spec.view(this));\n            }\n            for (let i = 0; i < this.state.plugins.length; i++) {\n                let plugin = this.state.plugins[i];\n                if (plugin.spec.view)\n                    this.pluginViews.push(plugin.spec.view(this));\n            }\n        }\n        else {\n            for (let i = 0; i < this.pluginViews.length; i++) {\n                let pluginView = this.pluginViews[i];\n                if (pluginView.update)\n                    pluginView.update(this, prevState);\n            }\n        }\n    }\n    updateDraggedNode(dragging, prev) {\n        let sel = dragging.node, found = -1;\n        if (this.state.doc.nodeAt(sel.from) == sel.node) {\n            found = sel.from;\n        }\n        else {\n            let movedPos = sel.from + (this.state.doc.content.size - prev.doc.content.size);\n            let moved = movedPos > 0 && this.state.doc.nodeAt(movedPos);\n            if (moved == sel.node)\n                found = movedPos;\n        }\n        this.dragging = new Dragging(dragging.slice, dragging.move, found < 0 ? undefined : prosemirror_state__WEBPACK_IMPORTED_MODULE_1__.NodeSelection.create(this.state.doc, found));\n    }\n    someProp(propName, f) {\n        let prop = this._props && this._props[propName], value;\n        if (prop != null && (value = f ? f(prop) : prop))\n            return value;\n        for (let i = 0; i < this.directPlugins.length; i++) {\n            let prop = this.directPlugins[i].props[propName];\n            if (prop != null && (value = f ? f(prop) : prop))\n                return value;\n        }\n        let plugins = this.state.plugins;\n        if (plugins)\n            for (let i = 0; i < plugins.length; i++) {\n                let prop = plugins[i].props[propName];\n                if (prop != null && (value = f ? f(prop) : prop))\n                    return value;\n            }\n    }\n    /**\n    Query whether the view has focus.\n    */\n    hasFocus() {\n        // Work around IE not handling focus correctly if resize handles are shown.\n        // If the cursor is inside an element with resize handles, activeElement\n        // will be that element instead of this.dom.\n        if (ie) {\n            // If activeElement is within this.dom, and there are no other elements\n            // setting `contenteditable` to false in between, treat it as focused.\n            let node = this.root.activeElement;\n            if (node == this.dom)\n                return true;\n            if (!node || !this.dom.contains(node))\n                return false;\n            while (node && this.dom != node && this.dom.contains(node)) {\n                if (node.contentEditable == 'false')\n                    return false;\n                node = node.parentElement;\n            }\n            return true;\n        }\n        return this.root.activeElement == this.dom;\n    }\n    /**\n    Focus the editor.\n    */\n    focus() {\n        this.domObserver.stop();\n        if (this.editable)\n            focusPreventScroll(this.dom);\n        selectionToDOM(this);\n        this.domObserver.start();\n    }\n    /**\n    Get the document root in which the editor exists. This will\n    usually be the top-level `document`, but might be a [shadow\n    DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)\n    root if the editor is inside one.\n    */\n    get root() {\n        let cached = this._root;\n        if (cached == null)\n            for (let search = this.dom.parentNode; search; search = search.parentNode) {\n                if (search.nodeType == 9 || (search.nodeType == 11 && search.host)) {\n                    if (!search.getSelection)\n                        Object.getPrototypeOf(search).getSelection = () => search.ownerDocument.getSelection();\n                    return this._root = search;\n                }\n            }\n        return cached || document;\n    }\n    /**\n    When an existing editor view is moved to a new document or\n    shadow tree, call this to make it recompute its root.\n    */\n    updateRoot() {\n        this._root = null;\n    }\n    /**\n    Given a pair of viewport coordinates, return the document\n    position that corresponds to them. May return null if the given\n    coordinates aren't inside of the editor. When an object is\n    returned, its `pos` property is the position nearest to the\n    coordinates, and its `inside` property holds the position of the\n    inner node that the position falls inside of, or -1 if it is at\n    the top level, not in any node.\n    */\n    posAtCoords(coords) {\n        return posAtCoords(this, coords);\n    }\n    /**\n    Returns the viewport rectangle at a given document position.\n    `left` and `right` will be the same number, as this returns a\n    flat cursor-ish rectangle. If the position is between two things\n    that aren't directly adjacent, `side` determines which element\n    is used. When < 0, the element before the position is used,\n    otherwise the element after.\n    */\n    coordsAtPos(pos, side = 1) {\n        return coordsAtPos(this, pos, side);\n    }\n    /**\n    Find the DOM position that corresponds to the given document\n    position. When `side` is negative, find the position as close as\n    possible to the content before the position. When positive,\n    prefer positions close to the content after the position. When\n    zero, prefer as shallow a position as possible.\n    \n    Note that you should **not** mutate the editor's internal DOM,\n    only inspect it (and even that is usually not necessary).\n    */\n    domAtPos(pos, side = 0) {\n        return this.docView.domFromPos(pos, side);\n    }\n    /**\n    Find the DOM node that represents the document node after the\n    given position. May return `null` when the position doesn't point\n    in front of a node or if the node is inside an opaque node view.\n    \n    This is intended to be able to call things like\n    `getBoundingClientRect` on that DOM node. Do **not** mutate the\n    editor DOM directly, or add styling this way, since that will be\n    immediately overriden by the editor as it redraws the node.\n    */\n    nodeDOM(pos) {\n        let desc = this.docView.descAt(pos);\n        return desc ? desc.nodeDOM : null;\n    }\n    /**\n    Find the document position that corresponds to a given DOM\n    position. (Whenever possible, it is preferable to inspect the\n    document structure directly, rather than poking around in the\n    DOM, but sometimes—for example when interpreting an event\n    target—you don't have a choice.)\n    \n    The `bias` parameter can be used to influence which side of a DOM\n    node to use when the position is inside a leaf node.\n    */\n    posAtDOM(node, offset, bias = -1) {\n        let pos = this.docView.posFromDOM(node, offset, bias);\n        if (pos == null)\n            throw new RangeError(\"DOM position not inside the editor\");\n        return pos;\n    }\n    /**\n    Find out whether the selection is at the end of a textblock when\n    moving in a given direction. When, for example, given `\"left\"`,\n    it will return true if moving left from the current cursor\n    position would leave that position's parent textblock. Will apply\n    to the view's current state by default, but it is possible to\n    pass a different state.\n    */\n    endOfTextblock(dir, state) {\n        return endOfTextblock(this, state || this.state, dir);\n    }\n    /**\n    Run the editor's paste logic with the given HTML string. The\n    `event`, if given, will be passed to the\n    [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.\n    */\n    pasteHTML(html, event) {\n        return doPaste(this, \"\", html, false, event || new ClipboardEvent(\"paste\"));\n    }\n    /**\n    Run the editor's paste logic with the given plain-text input.\n    */\n    pasteText(text, event) {\n        return doPaste(this, text, null, true, event || new ClipboardEvent(\"paste\"));\n    }\n    /**\n    Serialize the given slice as it would be if it was copied from\n    this editor. Returns a DOM element that contains a\n    representation of the slice as its children, a textual\n    representation, and the transformed slice (which can be\n    different from the given input due to hooks like\n    [`transformCopied`](https://prosemirror.net/docs/ref/#view.EditorProps.transformCopied)).\n    */\n    serializeForClipboard(slice) {\n        return serializeForClipboard(this, slice);\n    }\n    /**\n    Removes the editor from the DOM and destroys all [node\n    views](https://prosemirror.net/docs/ref/#view.NodeView).\n    */\n    destroy() {\n        if (!this.docView)\n            return;\n        destroyInput(this);\n        this.destroyPluginViews();\n        if (this.mounted) {\n            this.docView.update(this.state.doc, [], viewDecorations(this), this);\n            this.dom.textContent = \"\";\n        }\n        else if (this.dom.parentNode) {\n            this.dom.parentNode.removeChild(this.dom);\n        }\n        this.docView.destroy();\n        this.docView = null;\n        clearReusedRange();\n    }\n    /**\n    This is true when the view has been\n    [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be\n    used anymore).\n    */\n    get isDestroyed() {\n        return this.docView == null;\n    }\n    /**\n    Used for testing.\n    */\n    dispatchEvent(event) {\n        return dispatchEvent(this, event);\n    }\n    /**\n    @internal\n    */\n    domSelectionRange() {\n        let sel = this.domSelection();\n        if (!sel)\n            return { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 };\n        return safari && this.root.nodeType === 11 &&\n            deepActiveElement(this.dom.ownerDocument) == this.dom && safariShadowSelectionRange(this, sel) || sel;\n    }\n    /**\n    @internal\n    */\n    domSelection() {\n        return this.root.getSelection();\n    }\n}\nEditorView.prototype.dispatch = function (tr) {\n    let dispatchTransaction = this._props.dispatchTransaction;\n    if (dispatchTransaction)\n        dispatchTransaction.call(this, tr);\n    else\n        this.updateState(this.state.apply(tr));\n};\nfunction computeDocDeco(view) {\n    let attrs = Object.create(null);\n    attrs.class = \"ProseMirror\";\n    attrs.contenteditable = String(view.editable);\n    view.someProp(\"attributes\", value => {\n        if (typeof value == \"function\")\n            value = value(view.state);\n        if (value)\n            for (let attr in value) {\n                if (attr == \"class\")\n                    attrs.class += \" \" + value[attr];\n                else if (attr == \"style\")\n                    attrs.style = (attrs.style ? attrs.style + \";\" : \"\") + value[attr];\n                else if (!attrs[attr] && attr != \"contenteditable\" && attr != \"nodeName\")\n                    attrs[attr] = String(value[attr]);\n            }\n    });\n    if (!attrs.translate)\n        attrs.translate = \"no\";\n    return [Decoration.node(0, view.state.doc.content.size, attrs)];\n}\nfunction updateCursorWrapper(view) {\n    if (view.markCursor) {\n        let dom = document.createElement(\"img\");\n        dom.className = \"ProseMirror-separator\";\n        dom.setAttribute(\"mark-placeholder\", \"true\");\n        dom.setAttribute(\"alt\", \"\");\n        view.cursorWrapper = { dom, deco: Decoration.widget(view.state.selection.from, dom, { raw: true, marks: view.markCursor }) };\n    }\n    else {\n        view.cursorWrapper = null;\n    }\n}\nfunction getEditable(view) {\n    return !view.someProp(\"editable\", value => value(view.state) === false);\n}\nfunction selectionContextChanged(sel1, sel2) {\n    let depth = Math.min(sel1.$anchor.sharedDepth(sel1.head), sel2.$anchor.sharedDepth(sel2.head));\n    return sel1.$anchor.start(depth) != sel2.$anchor.start(depth);\n}\nfunction buildNodeViews(view) {\n    let result = Object.create(null);\n    function add(obj) {\n        for (let prop in obj)\n            if (!Object.prototype.hasOwnProperty.call(result, prop))\n                result[prop] = obj[prop];\n    }\n    view.someProp(\"nodeViews\", add);\n    view.someProp(\"markViews\", add);\n    return result;\n}\nfunction changedNodeViews(a, b) {\n    let nA = 0, nB = 0;\n    for (let prop in a) {\n        if (a[prop] != b[prop])\n            return true;\n        nA++;\n    }\n    for (let _ in b)\n        nB++;\n    return nA != nB;\n}\nfunction checkStateComponent(plugin) {\n    if (plugin.spec.state || plugin.spec.filterTransaction || plugin.spec.appendTransaction)\n        throw new RangeError(\"Plugins passed directly to the view must not have a state component\");\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcm9zZW1pcnJvci12aWV3L2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBMEY7QUFDTjtBQUNsQzs7QUFFbEQ7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsaUJBQWlCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixLQUFLO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFdBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUscUJBQXFCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsOEJBQThCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsOEJBQThCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix1QkFBdUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msb0JBQW9CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsbUJBQW1CO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGlDQUFpQztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGtCQUFrQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsNERBQWE7QUFDbEU7QUFDQTtBQUNBLDRCQUE0Qiw0REFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVCQUF1QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGVBQWU7QUFDN0IsOERBQThELDREQUFhO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGVBQWU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNERBQWE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDREQUFhO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLGlCQUFpQjtBQUMzQjtBQUNBO0FBQ0EscUJBQXFCLHdEQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDREQUFhO0FBQ3BDO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDREQUFhO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyw0REFBYTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0REFBYTtBQUM3Qix1Q0FBdUMsNERBQWE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1Qyw0REFBYTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNERBQWE7QUFDekMsK0JBQStCLDREQUFhO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsd0RBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsdUNBQXVDLDREQUFhO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsMENBQTBDO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsZ0JBQWdCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxZQUFZO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGdCQUFnQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrRUFBa0Usb0RBQUs7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLDREQUFhO0FBQzlFO0FBQ0EsZUFBZSw0REFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0REFBYTtBQUNoQztBQUNBO0FBQ0EsVUFBVSxtQkFBbUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsZ0NBQWdDO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsb0RBQUs7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGdFQUFTO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiw0REFBYTtBQUMvQjtBQUNBLDRCQUE0Qiw0REFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGVBQWU7QUFDN0I7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxnQkFBZ0I7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsNERBQWE7QUFDcEQ7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsNERBQWE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCx3Q0FBd0M7QUFDbEcsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBLFFBQVEsdURBQVE7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLG1CQUFtQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELDREQUFhO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrQkFBK0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0JBQStCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw2QkFBNkI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRGQUE0Riw0REFBYTtBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLCtCQUErQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsb0JBQW9CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxRQUFRO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLCtEQUErRCxtQ0FBbUM7QUFDakk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFeUYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3Byb3NlbWlycm9yLXZpZXcvZGlzdC9pbmRleC5qcz9iNTJlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRleHRTZWxlY3Rpb24sIE5vZGVTZWxlY3Rpb24sIEFsbFNlbGVjdGlvbiwgU2VsZWN0aW9uIH0gZnJvbSAncHJvc2VtaXJyb3Itc3RhdGUnO1xuaW1wb3J0IHsgRE9NU2VyaWFsaXplciwgRnJhZ21lbnQsIE1hcmssIFNsaWNlLCBET01QYXJzZXIgfSBmcm9tICdwcm9zZW1pcnJvci1tb2RlbCc7XG5pbXBvcnQgeyBkcm9wUG9pbnQgfSBmcm9tICdwcm9zZW1pcnJvci10cmFuc2Zvcm0nO1xuXG5jb25zdCBkb21JbmRleCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOzsgaW5kZXgrKykge1xuICAgICAgICBub2RlID0gbm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG59O1xuY29uc3QgcGFyZW50Tm9kZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgbGV0IHBhcmVudCA9IG5vZGUuYXNzaWduZWRTbG90IHx8IG5vZGUucGFyZW50Tm9kZTtcbiAgICByZXR1cm4gcGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSA9PSAxMSA/IHBhcmVudC5ob3N0IDogcGFyZW50O1xufTtcbmxldCByZXVzZWRSYW5nZSA9IG51bGw7XG4vLyBOb3RlIHRoYXQgdGhpcyB3aWxsIGFsd2F5cyByZXR1cm4gdGhlIHNhbWUgcmFuZ2UsIGJlY2F1c2UgRE9NIHJhbmdlXG4vLyBvYmplY3RzIGFyZSBldmVyeSBleHBlbnNpdmUsIGFuZCBrZWVwIHNsb3dpbmcgZG93biBzdWJzZXF1ZW50IERPTVxuLy8gdXBkYXRlcywgZm9yIHNvbWUgcmVhc29uLlxuY29uc3QgdGV4dFJhbmdlID0gZnVuY3Rpb24gKG5vZGUsIGZyb20sIHRvKSB7XG4gICAgbGV0IHJhbmdlID0gcmV1c2VkUmFuZ2UgfHwgKHJldXNlZFJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKSk7XG4gICAgcmFuZ2Uuc2V0RW5kKG5vZGUsIHRvID09IG51bGwgPyBub2RlLm5vZGVWYWx1ZS5sZW5ndGggOiB0byk7XG4gICAgcmFuZ2Uuc2V0U3RhcnQobm9kZSwgZnJvbSB8fCAwKTtcbiAgICByZXR1cm4gcmFuZ2U7XG59O1xuY29uc3QgY2xlYXJSZXVzZWRSYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXVzZWRSYW5nZSA9IG51bGw7XG59O1xuLy8gU2NhbnMgZm9yd2FyZCBhbmQgYmFja3dhcmQgdGhyb3VnaCBET00gcG9zaXRpb25zIGVxdWl2YWxlbnQgdG8gdGhlXG4vLyBnaXZlbiBvbmUgdG8gc2VlIGlmIHRoZSB0d28gYXJlIGluIHRoZSBzYW1lIHBsYWNlIChpLmUuIGFmdGVyIGFcbi8vIHRleHQgbm9kZSB2cyBhdCB0aGUgZW5kIG9mIHRoYXQgdGV4dCBub2RlKVxuY29uc3QgaXNFcXVpdmFsZW50UG9zaXRpb24gPSBmdW5jdGlvbiAobm9kZSwgb2ZmLCB0YXJnZXROb2RlLCB0YXJnZXRPZmYpIHtcbiAgICByZXR1cm4gdGFyZ2V0Tm9kZSAmJiAoc2NhbkZvcihub2RlLCBvZmYsIHRhcmdldE5vZGUsIHRhcmdldE9mZiwgLTEpIHx8XG4gICAgICAgIHNjYW5Gb3Iobm9kZSwgb2ZmLCB0YXJnZXROb2RlLCB0YXJnZXRPZmYsIDEpKTtcbn07XG5jb25zdCBhdG9tRWxlbWVudHMgPSAvXihpbWd8YnJ8aW5wdXR8dGV4dGFyZWF8aHIpJC9pO1xuZnVuY3Rpb24gc2NhbkZvcihub2RlLCBvZmYsIHRhcmdldE5vZGUsIHRhcmdldE9mZiwgZGlyKSB7XG4gICAgdmFyIF9hO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKG5vZGUgPT0gdGFyZ2V0Tm9kZSAmJiBvZmYgPT0gdGFyZ2V0T2ZmKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmIChvZmYgPT0gKGRpciA8IDAgPyAwIDogbm9kZVNpemUobm9kZSkpKSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgaWYgKCFwYXJlbnQgfHwgcGFyZW50Lm5vZGVUeXBlICE9IDEgfHwgaGFzQmxvY2tEZXNjKG5vZGUpIHx8IGF0b21FbGVtZW50cy50ZXN0KG5vZGUubm9kZU5hbWUpIHx8XG4gICAgICAgICAgICAgICAgbm9kZS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIG9mZiA9IGRvbUluZGV4KG5vZGUpICsgKGRpciA8IDAgPyAwIDogMSk7XG4gICAgICAgICAgICBub2RlID0gcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gbm9kZS5jaGlsZE5vZGVzW29mZiArIChkaXIgPCAwID8gLTEgOiAwKV07XG4gICAgICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT0gMSAmJiBjaGlsZC5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKChfYSA9IGNoaWxkLnBtVmlld0Rlc2MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pZ25vcmVGb3JTZWxlY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgIG9mZiArPSBkaXI7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub2RlID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgb2ZmID0gZGlyIDwgMCA/IG5vZGVTaXplKG5vZGUpIDogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIG5vZGVTaXplKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS5ub2RlVHlwZSA9PSAzID8gbm9kZS5ub2RlVmFsdWUubGVuZ3RoIDogbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIHRleHROb2RlQmVmb3JlJDEobm9kZSwgb2Zmc2V0KSB7XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzICYmIG9mZnNldClcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAxICYmIG9mZnNldCA+IDApIHtcbiAgICAgICAgICAgIGlmIChub2RlLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICAgICAgb2Zmc2V0ID0gbm9kZVNpemUobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZS5wYXJlbnROb2RlICYmICFoYXNCbG9ja0Rlc2Mobm9kZSkpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IGRvbUluZGV4KG5vZGUpO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gdGV4dE5vZGVBZnRlciQxKG5vZGUsIG9mZnNldCkge1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMyAmJiBvZmZzZXQgPCBub2RlLm5vZGVWYWx1ZS5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMSAmJiBvZmZzZXQgPCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLnBhcmVudE5vZGUgJiYgIWhhc0Jsb2NrRGVzYyhub2RlKSkge1xuICAgICAgICAgICAgb2Zmc2V0ID0gZG9tSW5kZXgobm9kZSkgKyAxO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gaXNPbkVkZ2Uobm9kZSwgb2Zmc2V0LCBwYXJlbnQpIHtcbiAgICBmb3IgKGxldCBhdFN0YXJ0ID0gb2Zmc2V0ID09IDAsIGF0RW5kID0gb2Zmc2V0ID09IG5vZGVTaXplKG5vZGUpOyBhdFN0YXJ0IHx8IGF0RW5kOykge1xuICAgICAgICBpZiAobm9kZSA9PSBwYXJlbnQpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgbGV0IGluZGV4ID0gZG9tSW5kZXgobm9kZSk7XG4gICAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgYXRTdGFydCA9IGF0U3RhcnQgJiYgaW5kZXggPT0gMDtcbiAgICAgICAgYXRFbmQgPSBhdEVuZCAmJiBpbmRleCA9PSBub2RlU2l6ZShub2RlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBoYXNCbG9ja0Rlc2MoZG9tKSB7XG4gICAgbGV0IGRlc2M7XG4gICAgZm9yIChsZXQgY3VyID0gZG9tOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlKVxuICAgICAgICBpZiAoZGVzYyA9IGN1ci5wbVZpZXdEZXNjKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgcmV0dXJuIGRlc2MgJiYgZGVzYy5ub2RlICYmIGRlc2Mubm9kZS5pc0Jsb2NrICYmIChkZXNjLmRvbSA9PSBkb20gfHwgZGVzYy5jb250ZW50RE9NID09IGRvbSk7XG59XG4vLyBXb3JrIGFyb3VuZCBDaHJvbWUgaXNzdWUgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDQ3NTIzXG4vLyAoaXNDb2xsYXBzZWQgaW5hcHByb3ByaWF0ZWx5IHJldHVybnMgdHJ1ZSBpbiBzaGFkb3cgZG9tKVxuY29uc3Qgc2VsZWN0aW9uQ29sbGFwc2VkID0gZnVuY3Rpb24gKGRvbVNlbCkge1xuICAgIHJldHVybiBkb21TZWwuZm9jdXNOb2RlICYmIGlzRXF1aXZhbGVudFBvc2l0aW9uKGRvbVNlbC5mb2N1c05vZGUsIGRvbVNlbC5mb2N1c09mZnNldCwgZG9tU2VsLmFuY2hvck5vZGUsIGRvbVNlbC5hbmNob3JPZmZzZXQpO1xufTtcbmZ1bmN0aW9uIGtleUV2ZW50KGtleUNvZGUsIGtleSkge1xuICAgIGxldCBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiRXZlbnRcIik7XG4gICAgZXZlbnQuaW5pdEV2ZW50KFwia2V5ZG93blwiLCB0cnVlLCB0cnVlKTtcbiAgICBldmVudC5rZXlDb2RlID0ga2V5Q29kZTtcbiAgICBldmVudC5rZXkgPSBldmVudC5jb2RlID0ga2V5O1xuICAgIHJldHVybiBldmVudDtcbn1cbmZ1bmN0aW9uIGRlZXBBY3RpdmVFbGVtZW50KGRvYykge1xuICAgIGxldCBlbHQgPSBkb2MuYWN0aXZlRWxlbWVudDtcbiAgICB3aGlsZSAoZWx0ICYmIGVsdC5zaGFkb3dSb290KVxuICAgICAgICBlbHQgPSBlbHQuc2hhZG93Um9vdC5hY3RpdmVFbGVtZW50O1xuICAgIHJldHVybiBlbHQ7XG59XG5mdW5jdGlvbiBjYXJldEZyb21Qb2ludChkb2MsIHgsIHkpIHtcbiAgICBpZiAoZG9jLmNhcmV0UG9zaXRpb25Gcm9tUG9pbnQpIHtcbiAgICAgICAgdHJ5IHsgLy8gRmlyZWZveCB0aHJvd3MgZm9yIHRoaXMgY2FsbCBpbiBoYXJkLXRvLXByZWRpY3QgY2lyY3Vtc3RhbmNlcyAoIzk5NClcbiAgICAgICAgICAgIGxldCBwb3MgPSBkb2MuY2FyZXRQb3NpdGlvbkZyb21Qb2ludCh4LCB5KTtcbiAgICAgICAgICAgIC8vIENsaXAgdGhlIG9mZnNldCwgYmVjYXVzZSBDaHJvbWUgd2lsbCByZXR1cm4gYSB0ZXh0IG9mZnNldFxuICAgICAgICAgICAgLy8gaW50byA8aW5wdXQ+IG5vZGVzLCB3aGljaCBjYW4ndCBiZSB0cmVhdGVkIGFzIGEgcmVndWxhciBET01cbiAgICAgICAgICAgIC8vIG9mZnNldFxuICAgICAgICAgICAgaWYgKHBvcylcbiAgICAgICAgICAgICAgICByZXR1cm4geyBub2RlOiBwb3Mub2Zmc2V0Tm9kZSwgb2Zmc2V0OiBNYXRoLm1pbihub2RlU2l6ZShwb3Mub2Zmc2V0Tm9kZSksIHBvcy5vZmZzZXQpIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF8pIHsgfVxuICAgIH1cbiAgICBpZiAoZG9jLmNhcmV0UmFuZ2VGcm9tUG9pbnQpIHtcbiAgICAgICAgbGV0IHJhbmdlID0gZG9jLmNhcmV0UmFuZ2VGcm9tUG9pbnQoeCwgeSk7XG4gICAgICAgIGlmIChyYW5nZSlcbiAgICAgICAgICAgIHJldHVybiB7IG5vZGU6IHJhbmdlLnN0YXJ0Q29udGFpbmVyLCBvZmZzZXQ6IE1hdGgubWluKG5vZGVTaXplKHJhbmdlLnN0YXJ0Q29udGFpbmVyKSwgcmFuZ2Uuc3RhcnRPZmZzZXQpIH07XG4gICAgfVxufVxuXG5jb25zdCBuYXYgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgPyBuYXZpZ2F0b3IgOiBudWxsO1xuY29uc3QgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9IFwidW5kZWZpbmVkXCIgPyBkb2N1bWVudCA6IG51bGw7XG5jb25zdCBhZ2VudCA9IChuYXYgJiYgbmF2LnVzZXJBZ2VudCkgfHwgXCJcIjtcbmNvbnN0IGllX2VkZ2UgPSAvRWRnZVxcLyhcXGQrKS8uZXhlYyhhZ2VudCk7XG5jb25zdCBpZV91cHRvMTAgPSAvTVNJRSBcXGQvLmV4ZWMoYWdlbnQpO1xuY29uc3QgaWVfMTF1cCA9IC9UcmlkZW50XFwvKD86WzctOV18XFxkezIsfSlcXC4uKnJ2OihcXGQrKS8uZXhlYyhhZ2VudCk7XG5jb25zdCBpZSA9ICEhKGllX3VwdG8xMCB8fCBpZV8xMXVwIHx8IGllX2VkZ2UpO1xuY29uc3QgaWVfdmVyc2lvbiA9IGllX3VwdG8xMCA/IGRvY3VtZW50LmRvY3VtZW50TW9kZSA6IGllXzExdXAgPyAraWVfMTF1cFsxXSA6IGllX2VkZ2UgPyAraWVfZWRnZVsxXSA6IDA7XG5jb25zdCBnZWNrbyA9ICFpZSAmJiAvZ2Vja29cXC8oXFxkKykvaS50ZXN0KGFnZW50KTtcbmdlY2tvICYmICsoL0ZpcmVmb3hcXC8oXFxkKykvLmV4ZWMoYWdlbnQpIHx8IFswLCAwXSlbMV07XG5jb25zdCBfY2hyb21lID0gIWllICYmIC9DaHJvbWVcXC8oXFxkKykvLmV4ZWMoYWdlbnQpO1xuY29uc3QgY2hyb21lID0gISFfY2hyb21lO1xuY29uc3QgY2hyb21lX3ZlcnNpb24gPSBfY2hyb21lID8gK19jaHJvbWVbMV0gOiAwO1xuY29uc3Qgc2FmYXJpID0gIWllICYmICEhbmF2ICYmIC9BcHBsZSBDb21wdXRlci8udGVzdChuYXYudmVuZG9yKTtcbi8vIElzIHRydWUgZm9yIGJvdGggaU9TIGFuZCBpUGFkT1MgZm9yIGNvbnZlbmllbmNlXG5jb25zdCBpb3MgPSBzYWZhcmkgJiYgKC9Nb2JpbGVcXC9cXHcrLy50ZXN0KGFnZW50KSB8fCAhIW5hdiAmJiBuYXYubWF4VG91Y2hQb2ludHMgPiAyKTtcbmNvbnN0IG1hYyA9IGlvcyB8fCAobmF2ID8gL01hYy8udGVzdChuYXYucGxhdGZvcm0pIDogZmFsc2UpO1xuY29uc3Qgd2luZG93cyA9IG5hdiA/IC9XaW4vLnRlc3QobmF2LnBsYXRmb3JtKSA6IGZhbHNlO1xuY29uc3QgYW5kcm9pZCA9IC9BbmRyb2lkIFxcZC8udGVzdChhZ2VudCk7XG5jb25zdCB3ZWJraXQgPSAhIWRvYyAmJiBcIndlYmtpdEZvbnRTbW9vdGhpbmdcIiBpbiBkb2MuZG9jdW1lbnRFbGVtZW50LnN0eWxlO1xuY29uc3Qgd2Via2l0X3ZlcnNpb24gPSB3ZWJraXQgPyArKC9cXGJBcHBsZVdlYktpdFxcLyhcXGQrKS8uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KSB8fCBbMCwgMF0pWzFdIDogMDtcblxuZnVuY3Rpb24gd2luZG93UmVjdChkb2MpIHtcbiAgICBsZXQgdnAgPSBkb2MuZGVmYXVsdFZpZXcgJiYgZG9jLmRlZmF1bHRWaWV3LnZpc3VhbFZpZXdwb3J0O1xuICAgIGlmICh2cClcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnQ6IDAsIHJpZ2h0OiB2cC53aWR0aCxcbiAgICAgICAgICAgIHRvcDogMCwgYm90dG9tOiB2cC5oZWlnaHRcbiAgICAgICAgfTtcbiAgICByZXR1cm4geyBsZWZ0OiAwLCByaWdodDogZG9jLmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCxcbiAgICAgICAgdG9wOiAwLCBib3R0b206IGRvYy5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0IH07XG59XG5mdW5jdGlvbiBnZXRTaWRlKHZhbHVlLCBzaWRlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSBcIm51bWJlclwiID8gdmFsdWUgOiB2YWx1ZVtzaWRlXTtcbn1cbmZ1bmN0aW9uIGNsaWVudFJlY3Qobm9kZSkge1xuICAgIGxldCByZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAvLyBBZGp1c3QgZm9yIGVsZW1lbnRzIHdpdGggc3R5bGUgXCJ0cmFuc2Zvcm06IHNjYWxlKClcIlxuICAgIGxldCBzY2FsZVggPSAocmVjdC53aWR0aCAvIG5vZGUub2Zmc2V0V2lkdGgpIHx8IDE7XG4gICAgbGV0IHNjYWxlWSA9IChyZWN0LmhlaWdodCAvIG5vZGUub2Zmc2V0SGVpZ2h0KSB8fCAxO1xuICAgIC8vIE1ha2Ugc3VyZSBzY3JvbGxiYXIgd2lkdGggaXNuJ3QgaW5jbHVkZWQgaW4gdGhlIHJlY3RhbmdsZVxuICAgIHJldHVybiB7IGxlZnQ6IHJlY3QubGVmdCwgcmlnaHQ6IHJlY3QubGVmdCArIG5vZGUuY2xpZW50V2lkdGggKiBzY2FsZVgsXG4gICAgICAgIHRvcDogcmVjdC50b3AsIGJvdHRvbTogcmVjdC50b3AgKyBub2RlLmNsaWVudEhlaWdodCAqIHNjYWxlWSB9O1xufVxuZnVuY3Rpb24gc2Nyb2xsUmVjdEludG9WaWV3KHZpZXcsIHJlY3QsIHN0YXJ0RE9NKSB7XG4gICAgbGV0IHNjcm9sbFRocmVzaG9sZCA9IHZpZXcuc29tZVByb3AoXCJzY3JvbGxUaHJlc2hvbGRcIikgfHwgMCwgc2Nyb2xsTWFyZ2luID0gdmlldy5zb21lUHJvcChcInNjcm9sbE1hcmdpblwiKSB8fCA1O1xuICAgIGxldCBkb2MgPSB2aWV3LmRvbS5vd25lckRvY3VtZW50O1xuICAgIGZvciAobGV0IHBhcmVudCA9IHN0YXJ0RE9NIHx8IHZpZXcuZG9tOzspIHtcbiAgICAgICAgaWYgKCFwYXJlbnQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKHBhcmVudC5ub2RlVHlwZSAhPSAxKSB7XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnROb2RlKHBhcmVudCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZWx0ID0gcGFyZW50O1xuICAgICAgICBsZXQgYXRUb3AgPSBlbHQgPT0gZG9jLmJvZHk7XG4gICAgICAgIGxldCBib3VuZGluZyA9IGF0VG9wID8gd2luZG93UmVjdChkb2MpIDogY2xpZW50UmVjdChlbHQpO1xuICAgICAgICBsZXQgbW92ZVggPSAwLCBtb3ZlWSA9IDA7XG4gICAgICAgIGlmIChyZWN0LnRvcCA8IGJvdW5kaW5nLnRvcCArIGdldFNpZGUoc2Nyb2xsVGhyZXNob2xkLCBcInRvcFwiKSlcbiAgICAgICAgICAgIG1vdmVZID0gLShib3VuZGluZy50b3AgLSByZWN0LnRvcCArIGdldFNpZGUoc2Nyb2xsTWFyZ2luLCBcInRvcFwiKSk7XG4gICAgICAgIGVsc2UgaWYgKHJlY3QuYm90dG9tID4gYm91bmRpbmcuYm90dG9tIC0gZ2V0U2lkZShzY3JvbGxUaHJlc2hvbGQsIFwiYm90dG9tXCIpKVxuICAgICAgICAgICAgbW92ZVkgPSByZWN0LmJvdHRvbSAtIHJlY3QudG9wID4gYm91bmRpbmcuYm90dG9tIC0gYm91bmRpbmcudG9wXG4gICAgICAgICAgICAgICAgPyByZWN0LnRvcCArIGdldFNpZGUoc2Nyb2xsTWFyZ2luLCBcInRvcFwiKSAtIGJvdW5kaW5nLnRvcFxuICAgICAgICAgICAgICAgIDogcmVjdC5ib3R0b20gLSBib3VuZGluZy5ib3R0b20gKyBnZXRTaWRlKHNjcm9sbE1hcmdpbiwgXCJib3R0b21cIik7XG4gICAgICAgIGlmIChyZWN0LmxlZnQgPCBib3VuZGluZy5sZWZ0ICsgZ2V0U2lkZShzY3JvbGxUaHJlc2hvbGQsIFwibGVmdFwiKSlcbiAgICAgICAgICAgIG1vdmVYID0gLShib3VuZGluZy5sZWZ0IC0gcmVjdC5sZWZ0ICsgZ2V0U2lkZShzY3JvbGxNYXJnaW4sIFwibGVmdFwiKSk7XG4gICAgICAgIGVsc2UgaWYgKHJlY3QucmlnaHQgPiBib3VuZGluZy5yaWdodCAtIGdldFNpZGUoc2Nyb2xsVGhyZXNob2xkLCBcInJpZ2h0XCIpKVxuICAgICAgICAgICAgbW92ZVggPSByZWN0LnJpZ2h0IC0gYm91bmRpbmcucmlnaHQgKyBnZXRTaWRlKHNjcm9sbE1hcmdpbiwgXCJyaWdodFwiKTtcbiAgICAgICAgaWYgKG1vdmVYIHx8IG1vdmVZKSB7XG4gICAgICAgICAgICBpZiAoYXRUb3ApIHtcbiAgICAgICAgICAgICAgICBkb2MuZGVmYXVsdFZpZXcuc2Nyb2xsQnkobW92ZVgsIG1vdmVZKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydFggPSBlbHQuc2Nyb2xsTGVmdCwgc3RhcnRZID0gZWx0LnNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICBpZiAobW92ZVkpXG4gICAgICAgICAgICAgICAgICAgIGVsdC5zY3JvbGxUb3AgKz0gbW92ZVk7XG4gICAgICAgICAgICAgICAgaWYgKG1vdmVYKVxuICAgICAgICAgICAgICAgICAgICBlbHQuc2Nyb2xsTGVmdCArPSBtb3ZlWDtcbiAgICAgICAgICAgICAgICBsZXQgZFggPSBlbHQuc2Nyb2xsTGVmdCAtIHN0YXJ0WCwgZFkgPSBlbHQuc2Nyb2xsVG9wIC0gc3RhcnRZO1xuICAgICAgICAgICAgICAgIHJlY3QgPSB7IGxlZnQ6IHJlY3QubGVmdCAtIGRYLCB0b3A6IHJlY3QudG9wIC0gZFksIHJpZ2h0OiByZWN0LnJpZ2h0IC0gZFgsIGJvdHRvbTogcmVjdC5ib3R0b20gLSBkWSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBwb3MgPSBhdFRvcCA/IFwiZml4ZWRcIiA6IGdldENvbXB1dGVkU3R5bGUocGFyZW50KS5wb3NpdGlvbjtcbiAgICAgICAgaWYgKC9eKGZpeGVkfHN0aWNreSkkLy50ZXN0KHBvcykpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgcGFyZW50ID0gcG9zID09IFwiYWJzb2x1dGVcIiA/IHBhcmVudC5vZmZzZXRQYXJlbnQgOiBwYXJlbnROb2RlKHBhcmVudCk7XG4gICAgfVxufVxuLy8gU3RvcmUgdGhlIHNjcm9sbCBwb3NpdGlvbiBvZiB0aGUgZWRpdG9yJ3MgcGFyZW50IG5vZGVzLCBhbG9uZyB3aXRoXG4vLyB0aGUgdG9wIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgbmVhciB0aGUgdG9wIG9mIHRoZSBlZGl0b3IsIHdoaWNoXG4vLyB3aWxsIGJlIHVzZWQgdG8gbWFrZSBzdXJlIHRoZSB2aXNpYmxlIHZpZXdwb3J0IHJlbWFpbnMgc3RhYmxlIGV2ZW5cbi8vIHdoZW4gdGhlIHNpemUgb2YgdGhlIGNvbnRlbnQgYWJvdmUgY2hhbmdlcy5cbmZ1bmN0aW9uIHN0b3JlU2Nyb2xsUG9zKHZpZXcpIHtcbiAgICBsZXQgcmVjdCA9IHZpZXcuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBzdGFydFkgPSBNYXRoLm1heCgwLCByZWN0LnRvcCk7XG4gICAgbGV0IHJlZkRPTSwgcmVmVG9wO1xuICAgIGZvciAobGV0IHggPSAocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgLyAyLCB5ID0gc3RhcnRZICsgMTsgeSA8IE1hdGgubWluKGlubmVySGVpZ2h0LCByZWN0LmJvdHRvbSk7IHkgKz0gNSkge1xuICAgICAgICBsZXQgZG9tID0gdmlldy5yb290LmVsZW1lbnRGcm9tUG9pbnQoeCwgeSk7XG4gICAgICAgIGlmICghZG9tIHx8IGRvbSA9PSB2aWV3LmRvbSB8fCAhdmlldy5kb20uY29udGFpbnMoZG9tKSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBsZXQgbG9jYWxSZWN0ID0gZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAobG9jYWxSZWN0LnRvcCA+PSBzdGFydFkgLSAyMCkge1xuICAgICAgICAgICAgcmVmRE9NID0gZG9tO1xuICAgICAgICAgICAgcmVmVG9wID0gbG9jYWxSZWN0LnRvcDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHJlZkRPTTogcmVmRE9NLCByZWZUb3A6IHJlZlRvcCwgc3RhY2s6IHNjcm9sbFN0YWNrKHZpZXcuZG9tKSB9O1xufVxuZnVuY3Rpb24gc2Nyb2xsU3RhY2soZG9tKSB7XG4gICAgbGV0IHN0YWNrID0gW10sIGRvYyA9IGRvbS5vd25lckRvY3VtZW50O1xuICAgIGZvciAobGV0IGN1ciA9IGRvbTsgY3VyOyBjdXIgPSBwYXJlbnROb2RlKGN1cikpIHtcbiAgICAgICAgc3RhY2sucHVzaCh7IGRvbTogY3VyLCB0b3A6IGN1ci5zY3JvbGxUb3AsIGxlZnQ6IGN1ci5zY3JvbGxMZWZ0IH0pO1xuICAgICAgICBpZiAoZG9tID09IGRvYylcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gc3RhY2s7XG59XG4vLyBSZXNldCB0aGUgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSBlZGl0b3IncyBwYXJlbnQgbm9kZXMgdG8gdGhhdCB3aGF0XG4vLyBpdCB3YXMgYmVmb3JlLCB3aGVuIHN0b3JlU2Nyb2xsUG9zIHdhcyBjYWxsZWQuXG5mdW5jdGlvbiByZXNldFNjcm9sbFBvcyh7IHJlZkRPTSwgcmVmVG9wLCBzdGFjayB9KSB7XG4gICAgbGV0IG5ld1JlZlRvcCA9IHJlZkRPTSA/IHJlZkRPTS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgOiAwO1xuICAgIHJlc3RvcmVTY3JvbGxTdGFjayhzdGFjaywgbmV3UmVmVG9wID09IDAgPyAwIDogbmV3UmVmVG9wIC0gcmVmVG9wKTtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVTY3JvbGxTdGFjayhzdGFjaywgZFRvcCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhY2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHsgZG9tLCB0b3AsIGxlZnQgfSA9IHN0YWNrW2ldO1xuICAgICAgICBpZiAoZG9tLnNjcm9sbFRvcCAhPSB0b3AgKyBkVG9wKVxuICAgICAgICAgICAgZG9tLnNjcm9sbFRvcCA9IHRvcCArIGRUb3A7XG4gICAgICAgIGlmIChkb20uc2Nyb2xsTGVmdCAhPSBsZWZ0KVxuICAgICAgICAgICAgZG9tLnNjcm9sbExlZnQgPSBsZWZ0O1xuICAgIH1cbn1cbmxldCBwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkID0gbnVsbDtcbi8vIEZlYXR1cmUtZGV0ZWN0cyBzdXBwb3J0IGZvciAuZm9jdXMoe3ByZXZlbnRTY3JvbGw6IHRydWV9KSwgYW5kIHVzZXNcbi8vIGEgZmFsbGJhY2sga2x1ZGdlIHdoZW4gbm90IHN1cHBvcnRlZC5cbmZ1bmN0aW9uIGZvY3VzUHJldmVudFNjcm9sbChkb20pIHtcbiAgICBpZiAoZG9tLnNldEFjdGl2ZSlcbiAgICAgICAgcmV0dXJuIGRvbS5zZXRBY3RpdmUoKTsgLy8gaW4gSUVcbiAgICBpZiAocHJldmVudFNjcm9sbFN1cHBvcnRlZClcbiAgICAgICAgcmV0dXJuIGRvbS5mb2N1cyhwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkKTtcbiAgICBsZXQgc3RvcmVkID0gc2Nyb2xsU3RhY2soZG9tKTtcbiAgICBkb20uZm9jdXMocHJldmVudFNjcm9sbFN1cHBvcnRlZCA9PSBudWxsID8ge1xuICAgICAgICBnZXQgcHJldmVudFNjcm9sbCgpIHtcbiAgICAgICAgICAgIHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPSB7IHByZXZlbnRTY3JvbGw6IHRydWUgfTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSA6IHVuZGVmaW5lZCk7XG4gICAgaWYgKCFwcmV2ZW50U2Nyb2xsU3VwcG9ydGVkKSB7XG4gICAgICAgIHByZXZlbnRTY3JvbGxTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgcmVzdG9yZVNjcm9sbFN0YWNrKHN0b3JlZCwgMCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZmluZE9mZnNldEluTm9kZShub2RlLCBjb29yZHMpIHtcbiAgICBsZXQgY2xvc2VzdCwgZHhDbG9zZXN0ID0gMmU4LCBjb29yZHNDbG9zZXN0LCBvZmZzZXQgPSAwO1xuICAgIGxldCByb3dCb3QgPSBjb29yZHMudG9wLCByb3dUb3AgPSBjb29yZHMudG9wO1xuICAgIGxldCBmaXJzdEJlbG93LCBjb29yZHNCZWxvdztcbiAgICBmb3IgKGxldCBjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZCwgY2hpbGRJbmRleCA9IDA7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nLCBjaGlsZEluZGV4KyspIHtcbiAgICAgICAgbGV0IHJlY3RzO1xuICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgICAgIHJlY3RzID0gY2hpbGQuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICAgICAgZWxzZSBpZiAoY2hpbGQubm9kZVR5cGUgPT0gMylcbiAgICAgICAgICAgIHJlY3RzID0gdGV4dFJhbmdlKGNoaWxkKS5nZXRDbGllbnRSZWN0cygpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJlY3QgPSByZWN0c1tpXTtcbiAgICAgICAgICAgIGlmIChyZWN0LnRvcCA8PSByb3dCb3QgJiYgcmVjdC5ib3R0b20gPj0gcm93VG9wKSB7XG4gICAgICAgICAgICAgICAgcm93Qm90ID0gTWF0aC5tYXgocmVjdC5ib3R0b20sIHJvd0JvdCk7XG4gICAgICAgICAgICAgICAgcm93VG9wID0gTWF0aC5taW4ocmVjdC50b3AsIHJvd1RvcCk7XG4gICAgICAgICAgICAgICAgbGV0IGR4ID0gcmVjdC5sZWZ0ID4gY29vcmRzLmxlZnQgPyByZWN0LmxlZnQgLSBjb29yZHMubGVmdFxuICAgICAgICAgICAgICAgICAgICA6IHJlY3QucmlnaHQgPCBjb29yZHMubGVmdCA/IGNvb3Jkcy5sZWZ0IC0gcmVjdC5yaWdodCA6IDA7XG4gICAgICAgICAgICAgICAgaWYgKGR4IDwgZHhDbG9zZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3Nlc3QgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgZHhDbG9zZXN0ID0gZHg7XG4gICAgICAgICAgICAgICAgICAgIGNvb3Jkc0Nsb3Nlc3QgPSBkeCAmJiBjbG9zZXN0Lm5vZGVUeXBlID09IDMgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiByZWN0LnJpZ2h0IDwgY29vcmRzLmxlZnQgPyByZWN0LnJpZ2h0IDogcmVjdC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBjb29yZHMudG9wXG4gICAgICAgICAgICAgICAgICAgIH0gOiBjb29yZHM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGlsZC5ub2RlVHlwZSA9PSAxICYmIGR4KVxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gY2hpbGRJbmRleCArIChjb29yZHMubGVmdCA+PSAocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgLyAyID8gMSA6IDApO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZWN0LnRvcCA+IGNvb3Jkcy50b3AgJiYgIWZpcnN0QmVsb3cgJiYgcmVjdC5sZWZ0IDw9IGNvb3Jkcy5sZWZ0ICYmIHJlY3QucmlnaHQgPj0gY29vcmRzLmxlZnQpIHtcbiAgICAgICAgICAgICAgICBmaXJzdEJlbG93ID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgY29vcmRzQmVsb3cgPSB7IGxlZnQ6IE1hdGgubWF4KHJlY3QubGVmdCwgTWF0aC5taW4ocmVjdC5yaWdodCwgY29vcmRzLmxlZnQpKSwgdG9wOiByZWN0LnRvcCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjbG9zZXN0ICYmIChjb29yZHMubGVmdCA+PSByZWN0LnJpZ2h0ICYmIGNvb3Jkcy50b3AgPj0gcmVjdC50b3AgfHxcbiAgICAgICAgICAgICAgICBjb29yZHMubGVmdCA+PSByZWN0LmxlZnQgJiYgY29vcmRzLnRvcCA+PSByZWN0LmJvdHRvbSkpXG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gY2hpbGRJbmRleCArIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFjbG9zZXN0ICYmIGZpcnN0QmVsb3cpIHtcbiAgICAgICAgY2xvc2VzdCA9IGZpcnN0QmVsb3c7XG4gICAgICAgIGNvb3Jkc0Nsb3Nlc3QgPSBjb29yZHNCZWxvdztcbiAgICAgICAgZHhDbG9zZXN0ID0gMDtcbiAgICB9XG4gICAgaWYgKGNsb3Nlc3QgJiYgY2xvc2VzdC5ub2RlVHlwZSA9PSAzKVxuICAgICAgICByZXR1cm4gZmluZE9mZnNldEluVGV4dChjbG9zZXN0LCBjb29yZHNDbG9zZXN0KTtcbiAgICBpZiAoIWNsb3Nlc3QgfHwgKGR4Q2xvc2VzdCAmJiBjbG9zZXN0Lm5vZGVUeXBlID09IDEpKVxuICAgICAgICByZXR1cm4geyBub2RlLCBvZmZzZXQgfTtcbiAgICByZXR1cm4gZmluZE9mZnNldEluTm9kZShjbG9zZXN0LCBjb29yZHNDbG9zZXN0KTtcbn1cbmZ1bmN0aW9uIGZpbmRPZmZzZXRJblRleHQobm9kZSwgY29vcmRzKSB7XG4gICAgbGV0IGxlbiA9IG5vZGUubm9kZVZhbHVlLmxlbmd0aDtcbiAgICBsZXQgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcmFuZ2Uuc2V0RW5kKG5vZGUsIGkgKyAxKTtcbiAgICAgICAgcmFuZ2Uuc2V0U3RhcnQobm9kZSwgaSk7XG4gICAgICAgIGxldCByZWN0ID0gc2luZ2xlUmVjdChyYW5nZSwgMSk7XG4gICAgICAgIGlmIChyZWN0LnRvcCA9PSByZWN0LmJvdHRvbSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAoaW5SZWN0KGNvb3JkcywgcmVjdCkpXG4gICAgICAgICAgICByZXR1cm4geyBub2RlLCBvZmZzZXQ6IGkgKyAoY29vcmRzLmxlZnQgPj0gKHJlY3QubGVmdCArIHJlY3QucmlnaHQpIC8gMiA/IDEgOiAwKSB9O1xuICAgIH1cbiAgICByZXR1cm4geyBub2RlLCBvZmZzZXQ6IDAgfTtcbn1cbmZ1bmN0aW9uIGluUmVjdChjb29yZHMsIHJlY3QpIHtcbiAgICByZXR1cm4gY29vcmRzLmxlZnQgPj0gcmVjdC5sZWZ0IC0gMSAmJiBjb29yZHMubGVmdCA8PSByZWN0LnJpZ2h0ICsgMSAmJlxuICAgICAgICBjb29yZHMudG9wID49IHJlY3QudG9wIC0gMSAmJiBjb29yZHMudG9wIDw9IHJlY3QuYm90dG9tICsgMTtcbn1cbmZ1bmN0aW9uIHRhcmdldEtsdWRnZShkb20sIGNvb3Jkcykge1xuICAgIGxldCBwYXJlbnQgPSBkb20ucGFyZW50Tm9kZTtcbiAgICBpZiAocGFyZW50ICYmIC9ebGkkL2kudGVzdChwYXJlbnQubm9kZU5hbWUpICYmIGNvb3Jkcy5sZWZ0IDwgZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQpXG4gICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgcmV0dXJuIGRvbTtcbn1cbmZ1bmN0aW9uIHBvc0Zyb21FbGVtZW50KHZpZXcsIGVsdCwgY29vcmRzKSB7XG4gICAgbGV0IHsgbm9kZSwgb2Zmc2V0IH0gPSBmaW5kT2Zmc2V0SW5Ob2RlKGVsdCwgY29vcmRzKSwgYmlhcyA9IC0xO1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09IDEgJiYgIW5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgICBsZXQgcmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGJpYXMgPSByZWN0LmxlZnQgIT0gcmVjdC5yaWdodCAmJiBjb29yZHMubGVmdCA+IChyZWN0LmxlZnQgKyByZWN0LnJpZ2h0KSAvIDIgPyAxIDogLTE7XG4gICAgfVxuICAgIHJldHVybiB2aWV3LmRvY1ZpZXcucG9zRnJvbURPTShub2RlLCBvZmZzZXQsIGJpYXMpO1xufVxuZnVuY3Rpb24gcG9zRnJvbUNhcmV0KHZpZXcsIG5vZGUsIG9mZnNldCwgY29vcmRzKSB7XG4gICAgLy8gQnJvd3NlciAoaW4gY2FyZXRQb3NpdGlvbi9SYW5nZUZyb21Qb2ludCkgd2lsbCBhZ3Jlc3NpdmVseVxuICAgIC8vIG5vcm1hbGl6ZSB0b3dhcmRzIG5lYXJieSBpbmxpbmUgbm9kZXMuIFNpbmNlIHdlIGFyZSBpbnRlcmVzdGVkIGluXG4gICAgLy8gcG9zaXRpb25zIGJldHdlZW4gYmxvY2sgbm9kZXMgdG9vLCB3ZSBmaXJzdCB3YWxrIHVwIHRoZSBoaWVyYXJjaHlcbiAgICAvLyBvZiBub2RlcyB0byBzZWUgaWYgdGhlcmUgYXJlIGJsb2NrIG5vZGVzIHRoYXQgdGhlIGNvb3JkaW5hdGVzXG4gICAgLy8gZmFsbCBvdXRzaWRlIG9mLiBJZiBzbywgd2UgdGFrZSB0aGUgcG9zaXRpb24gYmVmb3JlL2FmdGVyIHRoYXRcbiAgICAvLyBibG9jay4gSWYgbm90LCB3ZSBjYWxsIGBwb3NGcm9tRE9NYCBvbiB0aGUgcmF3IG5vZGUvb2Zmc2V0LlxuICAgIGxldCBvdXRzaWRlQmxvY2sgPSAtMTtcbiAgICBmb3IgKGxldCBjdXIgPSBub2RlLCBzYXdCbG9jayA9IGZhbHNlOzspIHtcbiAgICAgICAgaWYgKGN1ciA9PSB2aWV3LmRvbSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBsZXQgZGVzYyA9IHZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyhjdXIsIHRydWUpLCByZWN0O1xuICAgICAgICBpZiAoIWRlc2MpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKGRlc2MuZG9tLm5vZGVUeXBlID09IDEgJiYgKGRlc2Mubm9kZS5pc0Jsb2NrICYmIGRlc2MucGFyZW50IHx8ICFkZXNjLmNvbnRlbnRET00pICYmXG4gICAgICAgICAgICAvLyBJZ25vcmUgZWxlbWVudHMgd2l0aCB6ZXJvLXNpemUgYm91bmRpbmcgcmVjdGFuZ2xlc1xuICAgICAgICAgICAgKChyZWN0ID0gZGVzYy5kb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpLndpZHRoIHx8IHJlY3QuaGVpZ2h0KSkge1xuICAgICAgICAgICAgaWYgKGRlc2Mubm9kZS5pc0Jsb2NrICYmIGRlc2MucGFyZW50ICYmICEvXlQoUnxCT0RZfEhFQUR8Rk9PVCkkLy50ZXN0KGRlc2MuZG9tLm5vZGVOYW1lKSkge1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgYXBwbHkgdGhlIGhvcml6b250YWwgdGVzdCB0byB0aGUgaW5uZXJtb3N0IGJsb2NrLiBWZXJ0aWNhbCBmb3IgYW55IHBhcmVudC5cbiAgICAgICAgICAgICAgICBpZiAoIXNhd0Jsb2NrICYmIHJlY3QubGVmdCA+IGNvb3Jkcy5sZWZ0IHx8IHJlY3QudG9wID4gY29vcmRzLnRvcClcbiAgICAgICAgICAgICAgICAgICAgb3V0c2lkZUJsb2NrID0gZGVzYy5wb3NCZWZvcmU7XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIXNhd0Jsb2NrICYmIHJlY3QucmlnaHQgPCBjb29yZHMubGVmdCB8fCByZWN0LmJvdHRvbSA8IGNvb3Jkcy50b3ApXG4gICAgICAgICAgICAgICAgICAgIG91dHNpZGVCbG9jayA9IGRlc2MucG9zQWZ0ZXI7XG4gICAgICAgICAgICAgICAgc2F3QmxvY2sgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkZXNjLmNvbnRlbnRET00gJiYgb3V0c2lkZUJsb2NrIDwgMCAmJiAhZGVzYy5ub2RlLmlzVGV4dCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGFyZSBpbnNpZGUgYSBsZWFmLCByZXR1cm4gdGhlIHNpZGUgb2YgdGhlIGxlYWYgY2xvc2VyIHRvIHRoZSBjb29yZHNcbiAgICAgICAgICAgICAgICBsZXQgYmVmb3JlID0gZGVzYy5ub2RlLmlzQmxvY2sgPyBjb29yZHMudG9wIDwgKHJlY3QudG9wICsgcmVjdC5ib3R0b20pIC8gMlxuICAgICAgICAgICAgICAgICAgICA6IGNvb3Jkcy5sZWZ0IDwgKHJlY3QubGVmdCArIHJlY3QucmlnaHQpIC8gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmVmb3JlID8gZGVzYy5wb3NCZWZvcmUgOiBkZXNjLnBvc0FmdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN1ciA9IGRlc2MuZG9tLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBvdXRzaWRlQmxvY2sgPiAtMSA/IG91dHNpZGVCbG9jayA6IHZpZXcuZG9jVmlldy5wb3NGcm9tRE9NKG5vZGUsIG9mZnNldCwgLTEpO1xufVxuZnVuY3Rpb24gZWxlbWVudEZyb21Qb2ludChlbGVtZW50LCBjb29yZHMsIGJveCkge1xuICAgIGxldCBsZW4gPSBlbGVtZW50LmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgIGlmIChsZW4gJiYgYm94LnRvcCA8IGJveC5ib3R0b20pIHtcbiAgICAgICAgZm9yIChsZXQgc3RhcnRJID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obGVuIC0gMSwgTWF0aC5mbG9vcihsZW4gKiAoY29vcmRzLnRvcCAtIGJveC50b3ApIC8gKGJveC5ib3R0b20gLSBib3gudG9wKSkgLSAyKSksIGkgPSBzdGFydEk7Oykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gZWxlbWVudC5jaGlsZE5vZGVzW2ldO1xuICAgICAgICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVjdHMgPSBjaGlsZC5nZXRDbGllbnRSZWN0cygpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcmVjdHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlY3QgPSByZWN0c1tqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluUmVjdChjb29yZHMsIHJlY3QpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnRGcm9tUG9pbnQoY2hpbGQsIGNvb3JkcywgcmVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChpID0gKGkgKyAxKSAlIGxlbikgPT0gc3RhcnRJKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50O1xufVxuLy8gR2l2ZW4gYW4geCx5IHBvc2l0aW9uIG9uIHRoZSBlZGl0b3IsIGdldCB0aGUgcG9zaXRpb24gaW4gdGhlIGRvY3VtZW50LlxuZnVuY3Rpb24gcG9zQXRDb29yZHModmlldywgY29vcmRzKSB7XG4gICAgbGV0IGRvYyA9IHZpZXcuZG9tLm93bmVyRG9jdW1lbnQsIG5vZGUsIG9mZnNldCA9IDA7XG4gICAgbGV0IGNhcmV0ID0gY2FyZXRGcm9tUG9pbnQoZG9jLCBjb29yZHMubGVmdCwgY29vcmRzLnRvcCk7XG4gICAgaWYgKGNhcmV0KVxuICAgICAgICAoeyBub2RlLCBvZmZzZXQgfSA9IGNhcmV0KTtcbiAgICBsZXQgZWx0ID0gKHZpZXcucm9vdC5lbGVtZW50RnJvbVBvaW50ID8gdmlldy5yb290IDogZG9jKVxuICAgICAgICAuZWxlbWVudEZyb21Qb2ludChjb29yZHMubGVmdCwgY29vcmRzLnRvcCk7XG4gICAgbGV0IHBvcztcbiAgICBpZiAoIWVsdCB8fCAhdmlldy5kb20uY29udGFpbnMoZWx0Lm5vZGVUeXBlICE9IDEgPyBlbHQucGFyZW50Tm9kZSA6IGVsdCkpIHtcbiAgICAgICAgbGV0IGJveCA9IHZpZXcuZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAoIWluUmVjdChjb29yZHMsIGJveCkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgZWx0ID0gZWxlbWVudEZyb21Qb2ludCh2aWV3LmRvbSwgY29vcmRzLCBib3gpO1xuICAgICAgICBpZiAoIWVsdClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBTYWZhcmkncyBjYXJldFJhbmdlRnJvbVBvaW50IHJldHVybnMgbm9uc2Vuc2Ugd2hlbiBvbiBhIGRyYWdnYWJsZSBlbGVtZW50XG4gICAgaWYgKHNhZmFyaSkge1xuICAgICAgICBmb3IgKGxldCBwID0gZWx0OyBub2RlICYmIHA7IHAgPSBwYXJlbnROb2RlKHApKVxuICAgICAgICAgICAgaWYgKHAuZHJhZ2dhYmxlKVxuICAgICAgICAgICAgICAgIG5vZGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGVsdCA9IHRhcmdldEtsdWRnZShlbHQsIGNvb3Jkcyk7XG4gICAgaWYgKG5vZGUpIHtcbiAgICAgICAgaWYgKGdlY2tvICYmIG5vZGUubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgLy8gRmlyZWZveCB3aWxsIHNvbWV0aW1lcyByZXR1cm4gb2Zmc2V0cyBpbnRvIDxpbnB1dD4gbm9kZXMsIHdoaWNoXG4gICAgICAgICAgICAvLyBoYXZlIG5vIGFjdHVhbCBjaGlsZHJlbiwgZnJvbSBjYXJldFBvc2l0aW9uRnJvbVBvaW50ICgjOTUzKVxuICAgICAgICAgICAgb2Zmc2V0ID0gTWF0aC5taW4ob2Zmc2V0LCBub2RlLmNoaWxkTm9kZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIC8vIEl0J2xsIGFsc28gbW92ZSB0aGUgcmV0dXJuZWQgcG9zaXRpb24gYmVmb3JlIGltYWdlIG5vZGVzLFxuICAgICAgICAgICAgLy8gZXZlbiBpZiB0aG9zZSBhcmUgYmVoaW5kIGl0LlxuICAgICAgICAgICAgaWYgKG9mZnNldCA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdLCBib3g7XG4gICAgICAgICAgICAgICAgaWYgKG5leHQubm9kZU5hbWUgPT0gXCJJTUdcIiAmJiAoYm94ID0gbmV4dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSkucmlnaHQgPD0gY29vcmRzLmxlZnQgJiZcbiAgICAgICAgICAgICAgICAgICAgYm94LmJvdHRvbSA+IGNvb3Jkcy50b3ApXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBwcmV2O1xuICAgICAgICAvLyBXaGVuIGNsaWNraW5nIGFib3ZlIHRoZSByaWdodCBzaWRlIG9mIGFuIHVuZWRpdGFibGUgbm9kZSwgQ2hyb21lIHdpbGwgcmVwb3J0IGEgY3Vyc29yIHBvc2l0aW9uIGFmdGVyIHRoYXQgbm9kZS5cbiAgICAgICAgaWYgKHdlYmtpdCAmJiBvZmZzZXQgJiYgbm9kZS5ub2RlVHlwZSA9PSAxICYmIChwcmV2ID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdKS5ub2RlVHlwZSA9PSAxICYmXG4gICAgICAgICAgICBwcmV2LmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIgJiYgcHJldi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgPj0gY29vcmRzLnRvcClcbiAgICAgICAgICAgIG9mZnNldC0tO1xuICAgICAgICAvLyBTdXNwaWNpb3VzbHkgc3BlY2lmaWMga2x1ZGdlIHRvIHdvcmsgYXJvdW5kIGNhcmV0KkZyb21Qb2ludFxuICAgICAgICAvLyBuZXZlciByZXR1cm5pbmcgYSBwb3NpdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudFxuICAgICAgICBpZiAobm9kZSA9PSB2aWV3LmRvbSAmJiBvZmZzZXQgPT0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAtIDEgJiYgbm9kZS5sYXN0Q2hpbGQubm9kZVR5cGUgPT0gMSAmJlxuICAgICAgICAgICAgY29vcmRzLnRvcCA+IG5vZGUubGFzdENoaWxkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbSlcbiAgICAgICAgICAgIHBvcyA9IHZpZXcuc3RhdGUuZG9jLmNvbnRlbnQuc2l6ZTtcbiAgICAgICAgLy8gSWdub3JlIHBvc2l0aW9ucyBkaXJlY3RseSBhZnRlciBhIEJSLCBzaW5jZSBjYXJldCpGcm9tUG9pbnRcbiAgICAgICAgLy8gJ3JvdW5kIHVwJyBwb3NpdGlvbnMgdGhhdCB3b3VsZCBiZSBtb3JlIGFjY3VyYXRlbHkgcGxhY2VkXG4gICAgICAgIC8vIGJlZm9yZSB0aGUgQlIgbm9kZS5cbiAgICAgICAgZWxzZSBpZiAob2Zmc2V0ID09IDAgfHwgbm9kZS5ub2RlVHlwZSAhPSAxIHx8IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXS5ub2RlTmFtZSAhPSBcIkJSXCIpXG4gICAgICAgICAgICBwb3MgPSBwb3NGcm9tQ2FyZXQodmlldywgbm9kZSwgb2Zmc2V0LCBjb29yZHMpO1xuICAgIH1cbiAgICBpZiAocG9zID09IG51bGwpXG4gICAgICAgIHBvcyA9IHBvc0Zyb21FbGVtZW50KHZpZXcsIGVsdCwgY29vcmRzKTtcbiAgICBsZXQgZGVzYyA9IHZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyhlbHQsIHRydWUpO1xuICAgIHJldHVybiB7IHBvcywgaW5zaWRlOiBkZXNjID8gZGVzYy5wb3NBdFN0YXJ0IC0gZGVzYy5ib3JkZXIgOiAtMSB9O1xufVxuZnVuY3Rpb24gbm9uWmVybyhyZWN0KSB7XG4gICAgcmV0dXJuIHJlY3QudG9wIDwgcmVjdC5ib3R0b20gfHwgcmVjdC5sZWZ0IDwgcmVjdC5yaWdodDtcbn1cbmZ1bmN0aW9uIHNpbmdsZVJlY3QodGFyZ2V0LCBiaWFzKSB7XG4gICAgbGV0IHJlY3RzID0gdGFyZ2V0LmdldENsaWVudFJlY3RzKCk7XG4gICAgaWYgKHJlY3RzLmxlbmd0aCkge1xuICAgICAgICBsZXQgZmlyc3QgPSByZWN0c1tiaWFzIDwgMCA/IDAgOiByZWN0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKG5vblplcm8oZmlyc3QpKVxuICAgICAgICAgICAgcmV0dXJuIGZpcnN0O1xuICAgIH1cbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmZpbmQuY2FsbChyZWN0cywgbm9uWmVybykgfHwgdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xufVxuY29uc3QgQklESSA9IC9bXFx1MDU5MC1cXHUwNWY0XFx1MDYwMC1cXHUwNmZmXFx1MDcwMC1cXHUwOGFjXS87XG4vLyBHaXZlbiBhIHBvc2l0aW9uIGluIHRoZSBkb2N1bWVudCBtb2RlbCwgZ2V0IGEgYm91bmRpbmcgYm94IG9mIHRoZVxuLy8gY2hhcmFjdGVyIGF0IHRoYXQgcG9zaXRpb24sIHJlbGF0aXZlIHRvIHRoZSB3aW5kb3cuXG5mdW5jdGlvbiBjb29yZHNBdFBvcyh2aWV3LCBwb3MsIHNpZGUpIHtcbiAgICBsZXQgeyBub2RlLCBvZmZzZXQsIGF0b20gfSA9IHZpZXcuZG9jVmlldy5kb21Gcm9tUG9zKHBvcywgc2lkZSA8IDAgPyAtMSA6IDEpO1xuICAgIGxldCBzdXBwb3J0RW1wdHlSYW5nZSA9IHdlYmtpdCB8fCBnZWNrbztcbiAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzKSB7XG4gICAgICAgIC8vIFRoZXNlIGJyb3dzZXJzIHN1cHBvcnQgcXVlcnlpbmcgZW1wdHkgdGV4dCByYW5nZXMuIFByZWZlciB0aGF0IGluXG4gICAgICAgIC8vIGJpZGkgY29udGV4dCBvciB3aGVuIGF0IHRoZSBlbmQgb2YgYSBub2RlLlxuICAgICAgICBpZiAoc3VwcG9ydEVtcHR5UmFuZ2UgJiYgKEJJREkudGVzdChub2RlLm5vZGVWYWx1ZSkgfHwgKHNpZGUgPCAwID8gIW9mZnNldCA6IG9mZnNldCA9PSBub2RlLm5vZGVWYWx1ZS5sZW5ndGgpKSkge1xuICAgICAgICAgICAgbGV0IHJlY3QgPSBzaW5nbGVSZWN0KHRleHRSYW5nZShub2RlLCBvZmZzZXQsIG9mZnNldCksIHNpZGUpO1xuICAgICAgICAgICAgLy8gRmlyZWZveCByZXR1cm5zIGJhZCByZXN1bHRzICh0aGUgcG9zaXRpb24gYmVmb3JlIHRoZSBzcGFjZSlcbiAgICAgICAgICAgIC8vIHdoZW4gcXVlcnlpbmcgYSBwb3NpdGlvbiBkaXJlY3RseSBhZnRlciBsaW5lLWJyb2tlblxuICAgICAgICAgICAgLy8gd2hpdGVzcGFjZS4gRGV0ZWN0IHRoaXMgc2l0dWF0aW9uIGFuZCBhbmQga2x1ZGdlIGFyb3VuZCBpdFxuICAgICAgICAgICAgaWYgKGdlY2tvICYmIG9mZnNldCAmJiAvXFxzLy50ZXN0KG5vZGUubm9kZVZhbHVlW29mZnNldCAtIDFdKSAmJiBvZmZzZXQgPCBub2RlLm5vZGVWYWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgcmVjdEJlZm9yZSA9IHNpbmdsZVJlY3QodGV4dFJhbmdlKG5vZGUsIG9mZnNldCAtIDEsIG9mZnNldCAtIDEpLCAtMSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlY3RCZWZvcmUudG9wID09IHJlY3QudG9wKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByZWN0QWZ0ZXIgPSBzaW5nbGVSZWN0KHRleHRSYW5nZShub2RlLCBvZmZzZXQsIG9mZnNldCArIDEpLCAtMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWN0QWZ0ZXIudG9wICE9IHJlY3QudG9wKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZsYXR0ZW5WKHJlY3RBZnRlciwgcmVjdEFmdGVyLmxlZnQgPCByZWN0QmVmb3JlLmxlZnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZWN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGZyb20gPSBvZmZzZXQsIHRvID0gb2Zmc2V0LCB0YWtlU2lkZSA9IHNpZGUgPCAwID8gMSA6IC0xO1xuICAgICAgICAgICAgaWYgKHNpZGUgPCAwICYmICFvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICB0bysrO1xuICAgICAgICAgICAgICAgIHRha2VTaWRlID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzaWRlID49IDAgJiYgb2Zmc2V0ID09IG5vZGUubm9kZVZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZyb20tLTtcbiAgICAgICAgICAgICAgICB0YWtlU2lkZSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzaWRlIDwgMCkge1xuICAgICAgICAgICAgICAgIGZyb20tLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRvKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmxhdHRlblYoc2luZ2xlUmVjdCh0ZXh0UmFuZ2Uobm9kZSwgZnJvbSwgdG8pLCB0YWtlU2lkZSksIHRha2VTaWRlIDwgMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0ICRkb20gPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKHBvcyAtIChhdG9tIHx8IDApKTtcbiAgICAvLyBSZXR1cm4gYSBob3Jpem9udGFsIGxpbmUgaW4gYmxvY2sgY29udGV4dFxuICAgIGlmICghJGRvbS5wYXJlbnQuaW5saW5lQ29udGVudCkge1xuICAgICAgICBpZiAoYXRvbSA9PSBudWxsICYmIG9mZnNldCAmJiAoc2lkZSA8IDAgfHwgb2Zmc2V0ID09IG5vZGVTaXplKG5vZGUpKSkge1xuICAgICAgICAgICAgbGV0IGJlZm9yZSA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXTtcbiAgICAgICAgICAgIGlmIChiZWZvcmUubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmxhdHRlbkgoYmVmb3JlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGF0b20gPT0gbnVsbCAmJiBvZmZzZXQgPCBub2RlU2l6ZShub2RlKSkge1xuICAgICAgICAgICAgbGV0IGFmdGVyID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICAgICAgICBpZiAoYWZ0ZXIubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmxhdHRlbkgoYWZ0ZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmbGF0dGVuSChub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBzaWRlID49IDApO1xuICAgIH1cbiAgICAvLyBJbmxpbmUsIG5vdCBpbiB0ZXh0IG5vZGUgKHRoaXMgaXMgbm90IEJpZGktc2FmZSlcbiAgICBpZiAoYXRvbSA9PSBudWxsICYmIG9mZnNldCAmJiAoc2lkZSA8IDAgfHwgb2Zmc2V0ID09IG5vZGVTaXplKG5vZGUpKSkge1xuICAgICAgICBsZXQgYmVmb3JlID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICBsZXQgdGFyZ2V0ID0gYmVmb3JlLm5vZGVUeXBlID09IDMgPyB0ZXh0UmFuZ2UoYmVmb3JlLCBub2RlU2l6ZShiZWZvcmUpIC0gKHN1cHBvcnRFbXB0eVJhbmdlID8gMCA6IDEpKVxuICAgICAgICAgICAgLy8gQlIgbm9kZXMgdGVuZCB0byBvbmx5IHJldHVybiB0aGUgcmVjdGFuZ2xlIGJlZm9yZSB0aGVtLlxuICAgICAgICAgICAgLy8gT25seSB1c2UgdGhlbSBpZiB0aGV5IGFyZSB0aGUgbGFzdCBlbGVtZW50IGluIHRoZWlyIHBhcmVudFxuICAgICAgICAgICAgOiBiZWZvcmUubm9kZVR5cGUgPT0gMSAmJiAoYmVmb3JlLm5vZGVOYW1lICE9IFwiQlJcIiB8fCAhYmVmb3JlLm5leHRTaWJsaW5nKSA/IGJlZm9yZSA6IG51bGw7XG4gICAgICAgIGlmICh0YXJnZXQpXG4gICAgICAgICAgICByZXR1cm4gZmxhdHRlblYoc2luZ2xlUmVjdCh0YXJnZXQsIDEpLCBmYWxzZSk7XG4gICAgfVxuICAgIGlmIChhdG9tID09IG51bGwgJiYgb2Zmc2V0IDwgbm9kZVNpemUobm9kZSkpIHtcbiAgICAgICAgbGV0IGFmdGVyID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldF07XG4gICAgICAgIHdoaWxlIChhZnRlci5wbVZpZXdEZXNjICYmIGFmdGVyLnBtVmlld0Rlc2MuaWdub3JlRm9yQ29vcmRzKVxuICAgICAgICAgICAgYWZ0ZXIgPSBhZnRlci5uZXh0U2libGluZztcbiAgICAgICAgbGV0IHRhcmdldCA9ICFhZnRlciA/IG51bGwgOiBhZnRlci5ub2RlVHlwZSA9PSAzID8gdGV4dFJhbmdlKGFmdGVyLCAwLCAoc3VwcG9ydEVtcHR5UmFuZ2UgPyAwIDogMSkpXG4gICAgICAgICAgICA6IGFmdGVyLm5vZGVUeXBlID09IDEgPyBhZnRlciA6IG51bGw7XG4gICAgICAgIGlmICh0YXJnZXQpXG4gICAgICAgICAgICByZXR1cm4gZmxhdHRlblYoc2luZ2xlUmVjdCh0YXJnZXQsIC0xKSwgdHJ1ZSk7XG4gICAgfVxuICAgIC8vIEFsbCBlbHNlIGZhaWxlZCwganVzdCB0cnkgdG8gZ2V0IGEgcmVjdGFuZ2xlIGZvciB0aGUgdGFyZ2V0IG5vZGVcbiAgICByZXR1cm4gZmxhdHRlblYoc2luZ2xlUmVjdChub2RlLm5vZGVUeXBlID09IDMgPyB0ZXh0UmFuZ2Uobm9kZSkgOiBub2RlLCAtc2lkZSksIHNpZGUgPj0gMCk7XG59XG5mdW5jdGlvbiBmbGF0dGVuVihyZWN0LCBsZWZ0KSB7XG4gICAgaWYgKHJlY3Qud2lkdGggPT0gMClcbiAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgbGV0IHggPSBsZWZ0ID8gcmVjdC5sZWZ0IDogcmVjdC5yaWdodDtcbiAgICByZXR1cm4geyB0b3A6IHJlY3QudG9wLCBib3R0b206IHJlY3QuYm90dG9tLCBsZWZ0OiB4LCByaWdodDogeCB9O1xufVxuZnVuY3Rpb24gZmxhdHRlbkgocmVjdCwgdG9wKSB7XG4gICAgaWYgKHJlY3QuaGVpZ2h0ID09IDApXG4gICAgICAgIHJldHVybiByZWN0O1xuICAgIGxldCB5ID0gdG9wID8gcmVjdC50b3AgOiByZWN0LmJvdHRvbTtcbiAgICByZXR1cm4geyB0b3A6IHksIGJvdHRvbTogeSwgbGVmdDogcmVjdC5sZWZ0LCByaWdodDogcmVjdC5yaWdodCB9O1xufVxuZnVuY3Rpb24gd2l0aEZsdXNoZWRTdGF0ZSh2aWV3LCBzdGF0ZSwgZikge1xuICAgIGxldCB2aWV3U3RhdGUgPSB2aWV3LnN0YXRlLCBhY3RpdmUgPSB2aWV3LnJvb3QuYWN0aXZlRWxlbWVudDtcbiAgICBpZiAodmlld1N0YXRlICE9IHN0YXRlKVxuICAgICAgICB2aWV3LnVwZGF0ZVN0YXRlKHN0YXRlKTtcbiAgICBpZiAoYWN0aXZlICE9IHZpZXcuZG9tKVxuICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGYoKTtcbiAgICB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIGlmICh2aWV3U3RhdGUgIT0gc3RhdGUpXG4gICAgICAgICAgICB2aWV3LnVwZGF0ZVN0YXRlKHZpZXdTdGF0ZSk7XG4gICAgICAgIGlmIChhY3RpdmUgIT0gdmlldy5kb20gJiYgYWN0aXZlKVxuICAgICAgICAgICAgYWN0aXZlLmZvY3VzKCk7XG4gICAgfVxufVxuLy8gV2hldGhlciB2ZXJ0aWNhbCBwb3NpdGlvbiBtb3Rpb24gaW4gYSBnaXZlbiBkaXJlY3Rpb25cbi8vIGZyb20gYSBwb3NpdGlvbiB3b3VsZCBsZWF2ZSBhIHRleHQgYmxvY2suXG5mdW5jdGlvbiBlbmRPZlRleHRibG9ja1ZlcnRpY2FsKHZpZXcsIHN0YXRlLCBkaXIpIHtcbiAgICBsZXQgc2VsID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGxldCAkcG9zID0gZGlyID09IFwidXBcIiA/IHNlbC4kZnJvbSA6IHNlbC4kdG87XG4gICAgcmV0dXJuIHdpdGhGbHVzaGVkU3RhdGUodmlldywgc3RhdGUsICgpID0+IHtcbiAgICAgICAgbGV0IHsgbm9kZTogZG9tIH0gPSB2aWV3LmRvY1ZpZXcuZG9tRnJvbVBvcygkcG9zLnBvcywgZGlyID09IFwidXBcIiA/IC0xIDogMSk7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBuZWFyZXN0ID0gdmlldy5kb2NWaWV3Lm5lYXJlc3REZXNjKGRvbSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoIW5lYXJlc3QpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAobmVhcmVzdC5ub2RlLmlzQmxvY2spIHtcbiAgICAgICAgICAgICAgICBkb20gPSBuZWFyZXN0LmNvbnRlbnRET00gfHwgbmVhcmVzdC5kb207XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb20gPSBuZWFyZXN0LmRvbS5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb29yZHMgPSBjb29yZHNBdFBvcyh2aWV3LCAkcG9zLnBvcywgMSk7XG4gICAgICAgIGZvciAobGV0IGNoaWxkID0gZG9tLmZpcnN0Q2hpbGQ7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICBsZXQgYm94ZXM7XG4gICAgICAgICAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgICAgICAgICBib3hlcyA9IGNoaWxkLmdldENsaWVudFJlY3RzKCk7XG4gICAgICAgICAgICBlbHNlIGlmIChjaGlsZC5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgICAgIGJveGVzID0gdGV4dFJhbmdlKGNoaWxkLCAwLCBjaGlsZC5ub2RlVmFsdWUubGVuZ3RoKS5nZXRDbGllbnRSZWN0cygpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBib3hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBib3ggPSBib3hlc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoYm94LmJvdHRvbSA+IGJveC50b3AgKyAxICYmXG4gICAgICAgICAgICAgICAgICAgIChkaXIgPT0gXCJ1cFwiID8gY29vcmRzLnRvcCAtIGJveC50b3AgPiAoYm94LmJvdHRvbSAtIGNvb3Jkcy50b3ApICogMlxuICAgICAgICAgICAgICAgICAgICAgICAgOiBib3guYm90dG9tIC0gY29vcmRzLmJvdHRvbSA+IChjb29yZHMuYm90dG9tIC0gYm94LnRvcCkgKiAyKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xufVxuY29uc3QgbWF5YmVSVEwgPSAvW1xcdTA1OTAtXFx1MDhhY10vO1xuZnVuY3Rpb24gZW5kT2ZUZXh0YmxvY2tIb3Jpem9udGFsKHZpZXcsIHN0YXRlLCBkaXIpIHtcbiAgICBsZXQgeyAkaGVhZCB9ID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmICghJGhlYWQucGFyZW50LmlzVGV4dGJsb2NrKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IG9mZnNldCA9ICRoZWFkLnBhcmVudE9mZnNldCwgYXRTdGFydCA9ICFvZmZzZXQsIGF0RW5kID0gb2Zmc2V0ID09ICRoZWFkLnBhcmVudC5jb250ZW50LnNpemU7XG4gICAgbGV0IHNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uKCk7XG4gICAgaWYgKCFzZWwpXG4gICAgICAgIHJldHVybiAkaGVhZC5wb3MgPT0gJGhlYWQuc3RhcnQoKSB8fCAkaGVhZC5wb3MgPT0gJGhlYWQuZW5kKCk7XG4gICAgLy8gSWYgdGhlIHRleHRibG9jayBpcyBhbGwgTFRSLCBvciB0aGUgYnJvd3NlciBkb2Vzbid0IHN1cHBvcnRcbiAgICAvLyBTZWxlY3Rpb24ubW9kaWZ5IChFZGdlKSwgZmFsbCBiYWNrIHRvIGEgcHJpbWl0aXZlIGFwcHJvYWNoXG4gICAgaWYgKCFtYXliZVJUTC50ZXN0KCRoZWFkLnBhcmVudC50ZXh0Q29udGVudCkgfHwgIXNlbC5tb2RpZnkpXG4gICAgICAgIHJldHVybiBkaXIgPT0gXCJsZWZ0XCIgfHwgZGlyID09IFwiYmFja3dhcmRcIiA/IGF0U3RhcnQgOiBhdEVuZDtcbiAgICByZXR1cm4gd2l0aEZsdXNoZWRTdGF0ZSh2aWV3LCBzdGF0ZSwgKCkgPT4ge1xuICAgICAgICAvLyBUaGlzIGlzIGEgaHVnZSBoYWNrLCBidXQgYXBwZWFycyB0byBiZSB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gY3VycmVudGx5IGRvOiB1c2UgYFNlbGVjdGlvbi5tb2RpZnlgIHRvIG1vdmUgdGhlIHNlbGVjdGlvbiBieVxuICAgICAgICAvLyBvbmUgY2hhcmFjdGVyLCBhbmQgc2VlIGlmIHRoYXQgbW92ZXMgdGhlIGN1cnNvciBvdXQgb2YgdGhlXG4gICAgICAgIC8vIHRleHRibG9jayAob3IgZG9lc24ndCBtb3ZlIGl0IGF0IGFsbCwgd2hlbiBhdCB0aGUgc3RhcnQvZW5kIG9mXG4gICAgICAgIC8vIHRoZSBkb2N1bWVudCkuXG4gICAgICAgIGxldCB7IGZvY3VzTm9kZTogb2xkTm9kZSwgZm9jdXNPZmZzZXQ6IG9sZE9mZiwgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0IH0gPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIGxldCBvbGRCaWRpTGV2ZWwgPSBzZWwuY2FyZXRCaWRpTGV2ZWwgLy8gT25seSBmb3IgRmlyZWZveFxuICAgICAgICA7XG4gICAgICAgIHNlbC5tb2RpZnkoXCJtb3ZlXCIsIGRpciwgXCJjaGFyYWN0ZXJcIik7XG4gICAgICAgIGxldCBwYXJlbnRET00gPSAkaGVhZC5kZXB0aCA/IHZpZXcuZG9jVmlldy5kb21BZnRlclBvcygkaGVhZC5iZWZvcmUoKSkgOiB2aWV3LmRvbTtcbiAgICAgICAgbGV0IHsgZm9jdXNOb2RlOiBuZXdOb2RlLCBmb2N1c09mZnNldDogbmV3T2ZmIH0gPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgICAgIGxldCByZXN1bHQgPSBuZXdOb2RlICYmICFwYXJlbnRET00uY29udGFpbnMobmV3Tm9kZS5ub2RlVHlwZSA9PSAxID8gbmV3Tm9kZSA6IG5ld05vZGUucGFyZW50Tm9kZSkgfHxcbiAgICAgICAgICAgIChvbGROb2RlID09IG5ld05vZGUgJiYgb2xkT2ZmID09IG5ld09mZik7XG4gICAgICAgIC8vIFJlc3RvcmUgdGhlIHByZXZpb3VzIHNlbGVjdGlvblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc2VsLmNvbGxhcHNlKGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCk7XG4gICAgICAgICAgICBpZiAob2xkTm9kZSAmJiAob2xkTm9kZSAhPSBhbmNob3JOb2RlIHx8IG9sZE9mZiAhPSBhbmNob3JPZmZzZXQpICYmIHNlbC5leHRlbmQpXG4gICAgICAgICAgICAgICAgc2VsLmV4dGVuZChvbGROb2RlLCBvbGRPZmYpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfKSB7IH1cbiAgICAgICAgaWYgKG9sZEJpZGlMZXZlbCAhPSBudWxsKVxuICAgICAgICAgICAgc2VsLmNhcmV0QmlkaUxldmVsID0gb2xkQmlkaUxldmVsO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xufVxubGV0IGNhY2hlZFN0YXRlID0gbnVsbDtcbmxldCBjYWNoZWREaXIgPSBudWxsO1xubGV0IGNhY2hlZFJlc3VsdCA9IGZhbHNlO1xuZnVuY3Rpb24gZW5kT2ZUZXh0YmxvY2sodmlldywgc3RhdGUsIGRpcikge1xuICAgIGlmIChjYWNoZWRTdGF0ZSA9PSBzdGF0ZSAmJiBjYWNoZWREaXIgPT0gZGlyKVxuICAgICAgICByZXR1cm4gY2FjaGVkUmVzdWx0O1xuICAgIGNhY2hlZFN0YXRlID0gc3RhdGU7XG4gICAgY2FjaGVkRGlyID0gZGlyO1xuICAgIHJldHVybiBjYWNoZWRSZXN1bHQgPSBkaXIgPT0gXCJ1cFwiIHx8IGRpciA9PSBcImRvd25cIlxuICAgICAgICA/IGVuZE9mVGV4dGJsb2NrVmVydGljYWwodmlldywgc3RhdGUsIGRpcilcbiAgICAgICAgOiBlbmRPZlRleHRibG9ja0hvcml6b250YWwodmlldywgc3RhdGUsIGRpcik7XG59XG5cbi8vIFZpZXcgZGVzY3JpcHRpb25zIGFyZSBkYXRhIHN0cnVjdHVyZXMgdGhhdCBkZXNjcmliZSB0aGUgRE9NIHRoYXQgaXNcbi8vIHVzZWQgdG8gcmVwcmVzZW50IHRoZSBlZGl0b3IncyBjb250ZW50LiBUaGV5IGFyZSB1c2VkIGZvcjpcbi8vXG4vLyAtIEluY3JlbWVudGFsIHJlZHJhd2luZyB3aGVuIHRoZSBkb2N1bWVudCBjaGFuZ2VzXG4vL1xuLy8gLSBGaWd1cmluZyBvdXQgd2hhdCBwYXJ0IG9mIHRoZSBkb2N1bWVudCBhIGdpdmVuIERPTSBwb3NpdGlvblxuLy8gICBjb3JyZXNwb25kcyB0b1xuLy9cbi8vIC0gV2lyaW5nIGluIGN1c3RvbSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIGVkaXRpbmcgaW50ZXJmYWNlIGZvciBhXG4vLyAgIGdpdmVuIG5vZGVcbi8vXG4vLyBUaGV5IGZvcm0gYSBkb3VibHktbGlua2VkIG11dGFibGUgdHJlZSwgc3RhcnRpbmcgYXQgYHZpZXcuZG9jVmlld2AuXG5jb25zdCBOT1RfRElSVFkgPSAwLCBDSElMRF9ESVJUWSA9IDEsIENPTlRFTlRfRElSVFkgPSAyLCBOT0RFX0RJUlRZID0gMztcbi8vIFN1cGVyY2xhc3MgZm9yIHRoZSB2YXJpb3VzIGtpbmRzIG9mIGRlc2NyaXB0aW9ucy4gRGVmaW5lcyB0aGVpclxuLy8gYmFzaWMgc3RydWN0dXJlIGFuZCBzaGFyZWQgbWV0aG9kcy5cbmNsYXNzIFZpZXdEZXNjIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIGNoaWxkcmVuLCBkb20sIFxuICAgIC8vIFRoaXMgaXMgdGhlIG5vZGUgdGhhdCBob2xkcyB0aGUgY2hpbGQgdmlld3MuIEl0IG1heSBiZSBudWxsIGZvclxuICAgIC8vIGRlc2NzIHRoYXQgZG9uJ3QgaGF2ZSBjaGlsZHJlbi5cbiAgICBjb250ZW50RE9NKSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMuZG9tID0gZG9tO1xuICAgICAgICB0aGlzLmNvbnRlbnRET00gPSBjb250ZW50RE9NO1xuICAgICAgICB0aGlzLmRpcnR5ID0gTk9UX0RJUlRZO1xuICAgICAgICAvLyBBbiBleHBhbmRvIHByb3BlcnR5IG9uIHRoZSBET00gbm9kZSBwcm92aWRlcyBhIGxpbmsgYmFjayB0byBpdHNcbiAgICAgICAgLy8gZGVzY3JpcHRpb24uXG4gICAgICAgIGRvbS5wbVZpZXdEZXNjID0gdGhpcztcbiAgICB9XG4gICAgLy8gVXNlZCB0byBjaGVjayB3aGV0aGVyIGEgZ2l2ZW4gZGVzY3JpcHRpb24gY29ycmVzcG9uZHMgdG8gYVxuICAgIC8vIHdpZGdldC9tYXJrL25vZGUuXG4gICAgbWF0Y2hlc1dpZGdldCh3aWRnZXQpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgbWF0Y2hlc01hcmsobWFyaykgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBtYXRjaGVzTm9kZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbykgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBtYXRjaGVzSGFjayhub2RlTmFtZSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAvLyBXaGVuIHBhcnNpbmcgaW4tZWRpdG9yIGNvbnRlbnQgKGluIGRvbWNoYW5nZS5qcyksIHdlIGFsbG93XG4gICAgLy8gZGVzY3JpcHRpb25zIHRvIGRldGVybWluZSB0aGUgcGFyc2UgcnVsZXMgdGhhdCBzaG91bGQgYmUgdXNlZCB0b1xuICAgIC8vIHBhcnNlIHRoZW0uXG4gICAgcGFyc2VSdWxlKCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIC8vIFVzZWQgYnkgdGhlIGVkaXRvcidzIGV2ZW50IGhhbmRsZXIgdG8gaWdub3JlIGV2ZW50cyB0aGF0IGNvbWVcbiAgICAvLyBmcm9tIGNlcnRhaW4gZGVzY3MuXG4gICAgc3RvcEV2ZW50KGV2ZW50KSB7IHJldHVybiBmYWxzZTsgfVxuICAgIC8vIFRoZSBzaXplIG9mIHRoZSBjb250ZW50IHJlcHJlc2VudGVkIGJ5IHRoaXMgZGVzYy5cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgbGV0IHNpemUgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBzaXplICs9IHRoaXMuY2hpbGRyZW5baV0uc2l6ZTtcbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuICAgIC8vIEZvciBibG9jayBub2RlcywgdGhpcyByZXByZXNlbnRzIHRoZSBzcGFjZSB0YWtlbiB1cCBieSB0aGVpclxuICAgIC8vIHN0YXJ0L2VuZCB0b2tlbnMuXG4gICAgZ2V0IGJvcmRlcigpIHsgcmV0dXJuIDA7IH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHRoaXMuZG9tLnBtVmlld0Rlc2MgPT0gdGhpcylcbiAgICAgICAgICAgIHRoaXMuZG9tLnBtVmlld0Rlc2MgPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baV0uZGVzdHJveSgpO1xuICAgIH1cbiAgICBwb3NCZWZvcmVDaGlsZChjaGlsZCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gdGhpcy5wb3NBdFN0YXJ0OzsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY3VyID0gdGhpcy5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChjdXIgPT0gY2hpbGQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgICAgIHBvcyArPSBjdXIuc2l6ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgcG9zQmVmb3JlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQucG9zQmVmb3JlQ2hpbGQodGhpcyk7XG4gICAgfVxuICAgIGdldCBwb3NBdFN0YXJ0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQgPyB0aGlzLnBhcmVudC5wb3NCZWZvcmVDaGlsZCh0aGlzKSArIHRoaXMuYm9yZGVyIDogMDtcbiAgICB9XG4gICAgZ2V0IHBvc0FmdGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3NCZWZvcmUgKyB0aGlzLnNpemU7XG4gICAgfVxuICAgIGdldCBwb3NBdEVuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zQXRTdGFydCArIHRoaXMuc2l6ZSAtIDIgKiB0aGlzLmJvcmRlcjtcbiAgICB9XG4gICAgbG9jYWxQb3NGcm9tRE9NKGRvbSwgb2Zmc2V0LCBiaWFzKSB7XG4gICAgICAgIC8vIElmIHRoZSBET00gcG9zaXRpb24gaXMgaW4gdGhlIGNvbnRlbnQsIHVzZSB0aGUgY2hpbGQgZGVzYyBhZnRlclxuICAgICAgICAvLyBpdCB0byBmaWd1cmUgb3V0IGEgcG9zaXRpb24uXG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRET00gJiYgdGhpcy5jb250ZW50RE9NLmNvbnRhaW5zKGRvbS5ub2RlVHlwZSA9PSAxID8gZG9tIDogZG9tLnBhcmVudE5vZGUpKSB7XG4gICAgICAgICAgICBpZiAoYmlhcyA8IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgZG9tQmVmb3JlLCBkZXNjO1xuICAgICAgICAgICAgICAgIGlmIChkb20gPT0gdGhpcy5jb250ZW50RE9NKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvbUJlZm9yZSA9IGRvbS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGRvbS5wYXJlbnROb2RlICE9IHRoaXMuY29udGVudERPTSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbSA9IGRvbS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICBkb21CZWZvcmUgPSBkb20ucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3aGlsZSAoZG9tQmVmb3JlICYmICEoKGRlc2MgPSBkb21CZWZvcmUucG1WaWV3RGVzYykgJiYgZGVzYy5wYXJlbnQgPT0gdGhpcykpXG4gICAgICAgICAgICAgICAgICAgIGRvbUJlZm9yZSA9IGRvbUJlZm9yZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbUJlZm9yZSA/IHRoaXMucG9zQmVmb3JlQ2hpbGQoZGVzYykgKyBkZXNjLnNpemUgOiB0aGlzLnBvc0F0U3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgZG9tQWZ0ZXIsIGRlc2M7XG4gICAgICAgICAgICAgICAgaWYgKGRvbSA9PSB0aGlzLmNvbnRlbnRET00pIHtcbiAgICAgICAgICAgICAgICAgICAgZG9tQWZ0ZXIgPSBkb20uY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGRvbS5wYXJlbnROb2RlICE9IHRoaXMuY29udGVudERPTSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvbSA9IGRvbS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICBkb21BZnRlciA9IGRvbS5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKGRvbUFmdGVyICYmICEoKGRlc2MgPSBkb21BZnRlci5wbVZpZXdEZXNjKSAmJiBkZXNjLnBhcmVudCA9PSB0aGlzKSlcbiAgICAgICAgICAgICAgICAgICAgZG9tQWZ0ZXIgPSBkb21BZnRlci5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9tQWZ0ZXIgPyB0aGlzLnBvc0JlZm9yZUNoaWxkKGRlc2MpIDogdGhpcy5wb3NBdEVuZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UsIHVzZSB2YXJpb3VzIGhldXJpc3RpY3MsIGZhbGxpbmcgYmFjayBvbiB0aGUgYmlhc1xuICAgICAgICAvLyBwYXJhbWV0ZXIsIHRvIGRldGVybWluZSB3aGV0aGVyIHRvIHJldHVybiB0aGUgcG9zaXRpb24gYXQgdGhlXG4gICAgICAgIC8vIHN0YXJ0IG9yIGF0IHRoZSBlbmQgb2YgdGhpcyB2aWV3IGRlc2MuXG4gICAgICAgIGxldCBhdEVuZDtcbiAgICAgICAgaWYgKGRvbSA9PSB0aGlzLmRvbSAmJiB0aGlzLmNvbnRlbnRET00pIHtcbiAgICAgICAgICAgIGF0RW5kID0gb2Zmc2V0ID4gZG9tSW5kZXgodGhpcy5jb250ZW50RE9NKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmNvbnRlbnRET00gJiYgdGhpcy5jb250ZW50RE9NICE9IHRoaXMuZG9tICYmIHRoaXMuZG9tLmNvbnRhaW5zKHRoaXMuY29udGVudERPTSkpIHtcbiAgICAgICAgICAgIGF0RW5kID0gZG9tLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKHRoaXMuY29udGVudERPTSkgJiAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZG9tLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPT0gMClcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzZWFyY2ggPSBkb207OyBzZWFyY2ggPSBzZWFyY2gucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VhcmNoID09IHRoaXMuZG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdEVuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlYXJjaC5wcmV2aW91c1NpYmxpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXRFbmQgPT0gbnVsbCAmJiBvZmZzZXQgPT0gZG9tLmNoaWxkTm9kZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IHNlYXJjaCA9IGRvbTs7IHNlYXJjaCA9IHNlYXJjaC5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWFyY2ggPT0gdGhpcy5kb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF0RW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWFyY2gubmV4dFNpYmxpbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChhdEVuZCA9PSBudWxsID8gYmlhcyA+IDAgOiBhdEVuZCkgPyB0aGlzLnBvc0F0RW5kIDogdGhpcy5wb3NBdFN0YXJ0O1xuICAgIH1cbiAgICBuZWFyZXN0RGVzYyhkb20sIG9ubHlOb2RlcyA9IGZhbHNlKSB7XG4gICAgICAgIGZvciAobGV0IGZpcnN0ID0gdHJ1ZSwgY3VyID0gZG9tOyBjdXI7IGN1ciA9IGN1ci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBsZXQgZGVzYyA9IHRoaXMuZ2V0RGVzYyhjdXIpLCBub2RlRE9NO1xuICAgICAgICAgICAgaWYgKGRlc2MgJiYgKCFvbmx5Tm9kZXMgfHwgZGVzYy5ub2RlKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIGRvbSBpcyBvdXRzaWRlIG9mIHRoaXMgZGVzYydzIG5vZGVET00sIGRvbid0IGNvdW50IGl0LlxuICAgICAgICAgICAgICAgIGlmIChmaXJzdCAmJiAobm9kZURPTSA9IGRlc2Mubm9kZURPTSkgJiZcbiAgICAgICAgICAgICAgICAgICAgIShub2RlRE9NLm5vZGVUeXBlID09IDEgPyBub2RlRE9NLmNvbnRhaW5zKGRvbS5ub2RlVHlwZSA9PSAxID8gZG9tIDogZG9tLnBhcmVudE5vZGUpIDogbm9kZURPTSA9PSBkb20pKVxuICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlc2M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0RGVzYyhkb20pIHtcbiAgICAgICAgbGV0IGRlc2MgPSBkb20ucG1WaWV3RGVzYztcbiAgICAgICAgZm9yIChsZXQgY3VyID0gZGVzYzsgY3VyOyBjdXIgPSBjdXIucGFyZW50KVxuICAgICAgICAgICAgaWYgKGN1ciA9PSB0aGlzKVxuICAgICAgICAgICAgICAgIHJldHVybiBkZXNjO1xuICAgIH1cbiAgICBwb3NGcm9tRE9NKGRvbSwgb2Zmc2V0LCBiaWFzKSB7XG4gICAgICAgIGZvciAobGV0IHNjYW4gPSBkb207IHNjYW47IHNjYW4gPSBzY2FuLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIGxldCBkZXNjID0gdGhpcy5nZXREZXNjKHNjYW4pO1xuICAgICAgICAgICAgaWYgKGRlc2MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc2MubG9jYWxQb3NGcm9tRE9NKGRvbSwgb2Zmc2V0LCBiaWFzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIC8vIEZpbmQgdGhlIGRlc2MgZm9yIHRoZSBub2RlIGFmdGVyIHRoZSBnaXZlbiBwb3MsIGlmIGFueS4gKFdoZW4gYVxuICAgIC8vIHBhcmVudCBub2RlIG92ZXJyb2RlIHJlbmRlcmluZywgdGhlcmUgbWlnaHQgbm90IGJlIG9uZS4pXG4gICAgZGVzY0F0KHBvcykge1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgb2Zmc2V0ID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IG9mZnNldCArIGNoaWxkLnNpemU7XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID09IHBvcyAmJiBlbmQgIT0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKCFjaGlsZC5ib3JkZXIgJiYgY2hpbGQuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGQuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbm5lciA9IGNoaWxkLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlubmVyLnNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZCA9IGlubmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwb3MgPCBlbmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLmRlc2NBdChwb3MgLSBvZmZzZXQgLSBjaGlsZC5ib3JkZXIpO1xuICAgICAgICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRvbUZyb21Qb3MocG9zLCBzaWRlKSB7XG4gICAgICAgIGlmICghdGhpcy5jb250ZW50RE9NKVxuICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogdGhpcy5kb20sIG9mZnNldDogMCwgYXRvbTogcG9zICsgMSB9O1xuICAgICAgICAvLyBGaXJzdCBmaW5kIHRoZSBwb3NpdGlvbiBpbiB0aGUgY2hpbGQgYXJyYXlcbiAgICAgICAgbGV0IGkgPSAwLCBvZmZzZXQgPSAwO1xuICAgICAgICBmb3IgKGxldCBjdXJQb3MgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gY3VyUG9zICsgY2hpbGQuc2l6ZTtcbiAgICAgICAgICAgIGlmIChlbmQgPiBwb3MgfHwgY2hpbGQgaW5zdGFuY2VvZiBUcmFpbGluZ0hhY2tWaWV3RGVzYykge1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IHBvcyAtIGN1clBvcztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1clBvcyA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGlzIHBvaW50cyBpbnRvIHRoZSBtaWRkbGUgb2YgYSBjaGlsZCwgY2FsbCB0aHJvdWdoXG4gICAgICAgIGlmIChvZmZzZXQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbltpXS5kb21Gcm9tUG9zKG9mZnNldCAtIHRoaXMuY2hpbGRyZW5baV0uYm9yZGVyLCBzaWRlKTtcbiAgICAgICAgLy8gR28gYmFjayBpZiB0aGVyZSB3ZXJlIGFueSB6ZXJvLWxlbmd0aCB3aWRnZXRzIHdpdGggc2lkZSA+PSAwIGJlZm9yZSB0aGlzIHBvaW50XG4gICAgICAgIGZvciAobGV0IHByZXY7IGkgJiYgIShwcmV2ID0gdGhpcy5jaGlsZHJlbltpIC0gMV0pLnNpemUgJiYgcHJldiBpbnN0YW5jZW9mIFdpZGdldFZpZXdEZXNjICYmIHByZXYuc2lkZSA+PSAwOyBpLS0pIHsgfVxuICAgICAgICAvLyBTY2FuIHRvd2FyZHMgdGhlIGZpcnN0IHVzZWFibGUgbm9kZVxuICAgICAgICBpZiAoc2lkZSA8PSAwKSB7XG4gICAgICAgICAgICBsZXQgcHJldiwgZW50ZXIgPSB0cnVlO1xuICAgICAgICAgICAgZm9yICg7OyBpLS0sIGVudGVyID0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBwcmV2ID0gaSA/IHRoaXMuY2hpbGRyZW5baSAtIDFdIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAoIXByZXYgfHwgcHJldi5kb20ucGFyZW50Tm9kZSA9PSB0aGlzLmNvbnRlbnRET00pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByZXYgJiYgc2lkZSAmJiBlbnRlciAmJiAhcHJldi5ib3JkZXIgJiYgIXByZXYuZG9tQXRvbSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJldi5kb21Gcm9tUG9zKHByZXYuc2l6ZSwgc2lkZSk7XG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLmNvbnRlbnRET00sIG9mZnNldDogcHJldiA/IGRvbUluZGV4KHByZXYuZG9tKSArIDEgOiAwIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbmV4dCwgZW50ZXIgPSB0cnVlO1xuICAgICAgICAgICAgZm9yICg7OyBpKyssIGVudGVyID0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBuZXh0ID0gaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoID8gdGhpcy5jaGlsZHJlbltpXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKCFuZXh0IHx8IG5leHQuZG9tLnBhcmVudE5vZGUgPT0gdGhpcy5jb250ZW50RE9NKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0ICYmIGVudGVyICYmICFuZXh0LmJvcmRlciAmJiAhbmV4dC5kb21BdG9tKVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0LmRvbUZyb21Qb3MoMCwgc2lkZSk7XG4gICAgICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLmNvbnRlbnRET00sIG9mZnNldDogbmV4dCA/IGRvbUluZGV4KG5leHQuZG9tKSA6IHRoaXMuY29udGVudERPTS5jaGlsZE5vZGVzLmxlbmd0aCB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFVzZWQgdG8gZmluZCBhIERPTSByYW5nZSBpbiBhIHNpbmdsZSBwYXJlbnQgZm9yIGEgZ2l2ZW4gY2hhbmdlZFxuICAgIC8vIHJhbmdlLlxuICAgIHBhcnNlUmFuZ2UoZnJvbSwgdG8sIGJhc2UgPSAwKSB7XG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogdGhpcy5jb250ZW50RE9NLCBmcm9tLCB0bywgZnJvbU9mZnNldDogMCwgdG9PZmZzZXQ6IHRoaXMuY29udGVudERPTS5jaGlsZE5vZGVzLmxlbmd0aCB9O1xuICAgICAgICBsZXQgZnJvbU9mZnNldCA9IC0xLCB0b09mZnNldCA9IC0xO1xuICAgICAgICBmb3IgKGxldCBvZmZzZXQgPSBiYXNlLCBpID0gMDs7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgZW5kID0gb2Zmc2V0ICsgY2hpbGQuc2l6ZTtcbiAgICAgICAgICAgIGlmIChmcm9tT2Zmc2V0ID09IC0xICYmIGZyb20gPD0gZW5kKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkQmFzZSA9IG9mZnNldCArIGNoaWxkLmJvcmRlcjtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRSBtYXliZSBkZXNjZW5kIG1hcmsgdmlld3MgdG8gcGFyc2UgYSBuYXJyb3dlciByYW5nZT9cbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA+PSBjaGlsZEJhc2UgJiYgdG8gPD0gZW5kIC0gY2hpbGQuYm9yZGVyICYmIGNoaWxkLm5vZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuY29udGVudERPTSAmJiB0aGlzLmNvbnRlbnRET00uY29udGFpbnMoY2hpbGQuY29udGVudERPTSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGlsZC5wYXJzZVJhbmdlKGZyb20sIHRvLCBjaGlsZEJhc2UpO1xuICAgICAgICAgICAgICAgIGZyb20gPSBvZmZzZXQ7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IGk7IGogPiAwOyBqLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHByZXYgPSB0aGlzLmNoaWxkcmVuW2ogLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXYuc2l6ZSAmJiBwcmV2LmRvbS5wYXJlbnROb2RlID09IHRoaXMuY29udGVudERPTSAmJiAhcHJldi5lbXB0eUNoaWxkQXQoMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb21PZmZzZXQgPSBkb21JbmRleChwcmV2LmRvbSkgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZnJvbSAtPSBwcmV2LnNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChmcm9tT2Zmc2V0ID09IC0xKVxuICAgICAgICAgICAgICAgICAgICBmcm9tT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmcm9tT2Zmc2V0ID4gLTEgJiYgKGVuZCA+IHRvIHx8IGkgPT0gdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxKSkge1xuICAgICAgICAgICAgICAgIHRvID0gZW5kO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLmNoaWxkcmVuW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dC5zaXplICYmIG5leHQuZG9tLnBhcmVudE5vZGUgPT0gdGhpcy5jb250ZW50RE9NICYmICFuZXh0LmVtcHR5Q2hpbGRBdCgtMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvT2Zmc2V0ID0gZG9tSW5kZXgobmV4dC5kb20pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdG8gKz0gbmV4dC5zaXplO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodG9PZmZzZXQgPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIHRvT2Zmc2V0ID0gdGhpcy5jb250ZW50RE9NLmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IG5vZGU6IHRoaXMuY29udGVudERPTSwgZnJvbSwgdG8sIGZyb21PZmZzZXQsIHRvT2Zmc2V0IH07XG4gICAgfVxuICAgIGVtcHR5Q2hpbGRBdChzaWRlKSB7XG4gICAgICAgIGlmICh0aGlzLmJvcmRlciB8fCAhdGhpcy5jb250ZW50RE9NIHx8ICF0aGlzLmNoaWxkcmVuLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IGNoaWxkID0gdGhpcy5jaGlsZHJlbltzaWRlIDwgMCA/IDAgOiB0aGlzLmNoaWxkcmVuLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gY2hpbGQuc2l6ZSA9PSAwIHx8IGNoaWxkLmVtcHR5Q2hpbGRBdChzaWRlKTtcbiAgICB9XG4gICAgZG9tQWZ0ZXJQb3MocG9zKSB7XG4gICAgICAgIGxldCB7IG5vZGUsIG9mZnNldCB9ID0gdGhpcy5kb21Gcm9tUG9zKHBvcywgMCk7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlICE9IDEgfHwgb2Zmc2V0ID09IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIk5vIG5vZGUgYWZ0ZXIgcG9zIFwiICsgcG9zKTtcbiAgICAgICAgcmV0dXJuIG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgIH1cbiAgICAvLyBWaWV3IGRlc2NzIGFyZSByZXNwb25zaWJsZSBmb3Igc2V0dGluZyBhbnkgc2VsZWN0aW9uIHRoYXQgZmFsbHNcbiAgICAvLyBlbnRpcmVseSBpbnNpZGUgb2YgdGhlbSwgc28gdGhhdCBjdXN0b20gaW1wbGVtZW50YXRpb25zIGNhbiBkb1xuICAgIC8vIGN1c3RvbSB0aGluZ3Mgd2l0aCB0aGUgc2VsZWN0aW9uLiBOb3RlIHRoYXQgdGhpcyBmYWxscyBhcGFydCB3aGVuXG4gICAgLy8gYSBzZWxlY3Rpb24gc3RhcnRzIGluIHN1Y2ggYSBub2RlIGFuZCBlbmRzIGluIGFub3RoZXIsIGluIHdoaWNoXG4gICAgLy8gY2FzZSB3ZSBqdXN0IHVzZSB3aGF0ZXZlciBkb21Gcm9tUG9zIHByb2R1Y2VzIGFzIGEgYmVzdCBlZmZvcnQuXG4gICAgc2V0U2VsZWN0aW9uKGFuY2hvciwgaGVhZCwgdmlldywgZm9yY2UgPSBmYWxzZSkge1xuICAgICAgICAvLyBJZiB0aGUgc2VsZWN0aW9uIGZhbGxzIGVudGlyZWx5IGluIGEgY2hpbGQsIGdpdmUgaXQgdG8gdGhhdCBjaGlsZFxuICAgICAgICBsZXQgZnJvbSA9IE1hdGgubWluKGFuY2hvciwgaGVhZCksIHRvID0gTWF0aC5tYXgoYW5jaG9yLCBoZWFkKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIG9mZnNldCA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBlbmQgPSBvZmZzZXQgKyBjaGlsZC5zaXplO1xuICAgICAgICAgICAgaWYgKGZyb20gPiBvZmZzZXQgJiYgdG8gPCBlbmQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkLnNldFNlbGVjdGlvbihhbmNob3IgLSBvZmZzZXQgLSBjaGlsZC5ib3JkZXIsIGhlYWQgLSBvZmZzZXQgLSBjaGlsZC5ib3JkZXIsIHZpZXcsIGZvcmNlKTtcbiAgICAgICAgICAgIG9mZnNldCA9IGVuZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYW5jaG9yRE9NID0gdGhpcy5kb21Gcm9tUG9zKGFuY2hvciwgYW5jaG9yID8gLTEgOiAxKTtcbiAgICAgICAgbGV0IGhlYWRET00gPSBoZWFkID09IGFuY2hvciA/IGFuY2hvckRPTSA6IHRoaXMuZG9tRnJvbVBvcyhoZWFkLCBoZWFkID8gLTEgOiAxKTtcbiAgICAgICAgbGV0IGRvbVNlbCA9IHZpZXcucm9vdC5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgbGV0IHNlbFJhbmdlID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICBsZXQgYnJLbHVkZ2UgPSBmYWxzZTtcbiAgICAgICAgLy8gT24gRmlyZWZveCwgdXNpbmcgU2VsZWN0aW9uLmNvbGxhcHNlIHRvIHB1dCB0aGUgY3Vyc29yIGFmdGVyIGFcbiAgICAgICAgLy8gQlIgbm9kZSBmb3Igc29tZSByZWFzb24gZG9lc24ndCBhbHdheXMgd29yayAoIzEwNzMpLiBPbiBTYWZhcmksXG4gICAgICAgIC8vIHRoZSBjdXJzb3Igc29tZXRpbWVzIGluZXhwbGljYWJsZSB2aXN1YWxseSBsYWdzIGJlaGluZCBpdHNcbiAgICAgICAgLy8gcmVwb3J0ZWQgcG9zaXRpb24gaW4gc3VjaCBzaXR1YXRpb25zICgjMTA5MikuXG4gICAgICAgIGlmICgoZ2Vja28gfHwgc2FmYXJpKSAmJiBhbmNob3IgPT0gaGVhZCkge1xuICAgICAgICAgICAgbGV0IHsgbm9kZSwgb2Zmc2V0IH0gPSBhbmNob3JET007XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSAzKSB7XG4gICAgICAgICAgICAgICAgYnJLbHVkZ2UgPSAhIShvZmZzZXQgJiYgbm9kZS5ub2RlVmFsdWVbb2Zmc2V0IC0gMV0gPT0gXCJcXG5cIik7XG4gICAgICAgICAgICAgICAgLy8gSXNzdWUgIzExMjhcbiAgICAgICAgICAgICAgICBpZiAoYnJLbHVkZ2UgJiYgb2Zmc2V0ID09IG5vZGUubm9kZVZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBzY2FuID0gbm9kZSwgYWZ0ZXI7IHNjYW47IHNjYW4gPSBzY2FuLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhZnRlciA9IHNjYW4ubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWZ0ZXIubm9kZU5hbWUgPT0gXCJCUlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmNob3JET00gPSBoZWFkRE9NID0geyBub2RlOiBhZnRlci5wYXJlbnROb2RlLCBvZmZzZXQ6IGRvbUluZGV4KGFmdGVyKSArIDEgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkZXNjID0gc2Nhbi5wbVZpZXdEZXNjO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlc2MgJiYgZGVzYy5ub2RlICYmIGRlc2Mubm9kZS5pc0Jsb2NrKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHByZXYgPSBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0IC0gMV07XG4gICAgICAgICAgICAgICAgYnJLbHVkZ2UgPSBwcmV2ICYmIChwcmV2Lm5vZGVOYW1lID09IFwiQlJcIiB8fCBwcmV2LmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEZpcmVmb3ggY2FuIGFjdCBzdHJhbmdlbHkgd2hlbiB0aGUgc2VsZWN0aW9uIGlzIGluIGZyb250IG9mIGFuXG4gICAgICAgIC8vIHVuZWRpdGFibGUgbm9kZS4gU2VlICMxMTYzIGFuZCBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xNzA5NTM2XG4gICAgICAgIGlmIChnZWNrbyAmJiBzZWxSYW5nZS5mb2N1c05vZGUgJiYgc2VsUmFuZ2UuZm9jdXNOb2RlICE9IGhlYWRET00ubm9kZSAmJiBzZWxSYW5nZS5mb2N1c05vZGUubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgbGV0IGFmdGVyID0gc2VsUmFuZ2UuZm9jdXNOb2RlLmNoaWxkTm9kZXNbc2VsUmFuZ2UuZm9jdXNPZmZzZXRdO1xuICAgICAgICAgICAgaWYgKGFmdGVyICYmIGFmdGVyLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpXG4gICAgICAgICAgICAgICAgZm9yY2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKGZvcmNlIHx8IGJyS2x1ZGdlICYmIHNhZmFyaSkgJiZcbiAgICAgICAgICAgIGlzRXF1aXZhbGVudFBvc2l0aW9uKGFuY2hvckRPTS5ub2RlLCBhbmNob3JET00ub2Zmc2V0LCBzZWxSYW5nZS5hbmNob3JOb2RlLCBzZWxSYW5nZS5hbmNob3JPZmZzZXQpICYmXG4gICAgICAgICAgICBpc0VxdWl2YWxlbnRQb3NpdGlvbihoZWFkRE9NLm5vZGUsIGhlYWRET00ub2Zmc2V0LCBzZWxSYW5nZS5mb2N1c05vZGUsIHNlbFJhbmdlLmZvY3VzT2Zmc2V0KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gU2VsZWN0aW9uLmV4dGVuZCBjYW4gYmUgdXNlZCB0byBjcmVhdGUgYW4gJ2ludmVydGVkJyBzZWxlY3Rpb25cbiAgICAgICAgLy8gKG9uZSB3aGVyZSB0aGUgZm9jdXMgaXMgYmVmb3JlIHRoZSBhbmNob3IpLCBidXQgbm90IGFsbFxuICAgICAgICAvLyBicm93c2VycyBzdXBwb3J0IGl0IHlldC5cbiAgICAgICAgbGV0IGRvbVNlbEV4dGVuZGVkID0gZmFsc2U7XG4gICAgICAgIGlmICgoZG9tU2VsLmV4dGVuZCB8fCBhbmNob3IgPT0gaGVhZCkgJiYgIShicktsdWRnZSAmJiBnZWNrbykpIHtcbiAgICAgICAgICAgIGRvbVNlbC5jb2xsYXBzZShhbmNob3JET00ubm9kZSwgYW5jaG9yRE9NLm9mZnNldCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChhbmNob3IgIT0gaGVhZClcbiAgICAgICAgICAgICAgICAgICAgZG9tU2VsLmV4dGVuZChoZWFkRE9NLm5vZGUsIGhlYWRET00ub2Zmc2V0KTtcbiAgICAgICAgICAgICAgICBkb21TZWxFeHRlbmRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgICAgIC8vIEluIHNvbWUgY2FzZXMgd2l0aCBDaHJvbWUgdGhlIHNlbGVjdGlvbiBpcyBlbXB0eSBhZnRlciBjYWxsaW5nXG4gICAgICAgICAgICAgICAgLy8gY29sbGFwc2UsIGV2ZW4gd2hlbiBpdCBzaG91bGQgYmUgdmFsaWQuIFRoaXMgYXBwZWFycyB0byBiZSBhIGJ1ZywgYnV0XG4gICAgICAgICAgICAgICAgLy8gaXQgaXMgZGlmZmljdWx0IHRvIGlzb2xhdGUuIElmIHRoaXMgaGFwcGVucyBmYWxsYmFjayB0byB0aGUgb2xkIHBhdGhcbiAgICAgICAgICAgICAgICAvLyB3aXRob3V0IHVzaW5nIGV4dGVuZC5cbiAgICAgICAgICAgICAgICAvLyBTaW1pbGFybHksIHRoaXMgY291bGQgY3Jhc2ggb24gU2FmYXJpIGlmIHRoZSBlZGl0b3IgaXMgaGlkZGVuLCBhbmRcbiAgICAgICAgICAgICAgICAvLyB0aGVyZSB3YXMgbm8gc2VsZWN0aW9uLlxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghZG9tU2VsRXh0ZW5kZWQpIHtcbiAgICAgICAgICAgIGlmIChhbmNob3IgPiBoZWFkKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRtcCA9IGFuY2hvckRPTTtcbiAgICAgICAgICAgICAgICBhbmNob3JET00gPSBoZWFkRE9NO1xuICAgICAgICAgICAgICAgIGhlYWRET00gPSB0bXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kKGhlYWRET00ubm9kZSwgaGVhZERPTS5vZmZzZXQpO1xuICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnQoYW5jaG9yRE9NLm5vZGUsIGFuY2hvckRPTS5vZmZzZXQpO1xuICAgICAgICAgICAgZG9tU2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgICAgZG9tU2VsLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZ25vcmVNdXRhdGlvbihtdXRhdGlvbikge1xuICAgICAgICByZXR1cm4gIXRoaXMuY29udGVudERPTSAmJiBtdXRhdGlvbi50eXBlICE9IFwic2VsZWN0aW9uXCI7XG4gICAgfVxuICAgIGdldCBjb250ZW50TG9zdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudERPTSAmJiB0aGlzLmNvbnRlbnRET00gIT0gdGhpcy5kb20gJiYgIXRoaXMuZG9tLmNvbnRhaW5zKHRoaXMuY29udGVudERPTSk7XG4gICAgfVxuICAgIC8vIFJlbW92ZSBhIHN1YnRyZWUgb2YgdGhlIGVsZW1lbnQgdHJlZSB0aGF0IGhhcyBiZWVuIHRvdWNoZWRcbiAgICAvLyBieSBhIERPTSBjaGFuZ2UsIHNvIHRoYXQgdGhlIG5leHQgdXBkYXRlIHdpbGwgcmVkcmF3IGl0LlxuICAgIG1hcmtEaXJ0eShmcm9tLCB0bykge1xuICAgICAgICBmb3IgKGxldCBvZmZzZXQgPSAwLCBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIGVuZCA9IG9mZnNldCArIGNoaWxkLnNpemU7XG4gICAgICAgICAgICBpZiAob2Zmc2V0ID09IGVuZCA/IGZyb20gPD0gZW5kICYmIHRvID49IG9mZnNldCA6IGZyb20gPCBlbmQgJiYgdG8gPiBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBsZXQgc3RhcnRJbnNpZGUgPSBvZmZzZXQgKyBjaGlsZC5ib3JkZXIsIGVuZEluc2lkZSA9IGVuZCAtIGNoaWxkLmJvcmRlcjtcbiAgICAgICAgICAgICAgICBpZiAoZnJvbSA+PSBzdGFydEluc2lkZSAmJiB0byA8PSBlbmRJbnNpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXJ0eSA9IGZyb20gPT0gb2Zmc2V0IHx8IHRvID09IGVuZCA/IENPTlRFTlRfRElSVFkgOiBDSElMRF9ESVJUWTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZyb20gPT0gc3RhcnRJbnNpZGUgJiYgdG8gPT0gZW5kSW5zaWRlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoY2hpbGQuY29udGVudExvc3QgfHwgY2hpbGQuZG9tLnBhcmVudE5vZGUgIT0gdGhpcy5jb250ZW50RE9NKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLmRpcnR5ID0gTk9ERV9ESVJUWTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQubWFya0RpcnR5KGZyb20gLSBzdGFydEluc2lkZSwgdG8gLSBzdGFydEluc2lkZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmRpcnR5ID0gY2hpbGQuZG9tID09IGNoaWxkLmNvbnRlbnRET00gJiYgY2hpbGQuZG9tLnBhcmVudE5vZGUgPT0gdGhpcy5jb250ZW50RE9NICYmICFjaGlsZC5jaGlsZHJlbi5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgID8gQ09OVEVOVF9ESVJUWSA6IE5PREVfRElSVFk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ID0gZW5kO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlydHkgPSBDT05URU5UX0RJUlRZO1xuICAgIH1cbiAgICBtYXJrUGFyZW50c0RpcnR5KCkge1xuICAgICAgICBsZXQgbGV2ZWwgPSAxO1xuICAgICAgICBmb3IgKGxldCBub2RlID0gdGhpcy5wYXJlbnQ7IG5vZGU7IG5vZGUgPSBub2RlLnBhcmVudCwgbGV2ZWwrKykge1xuICAgICAgICAgICAgbGV0IGRpcnR5ID0gbGV2ZWwgPT0gMSA/IENPTlRFTlRfRElSVFkgOiBDSElMRF9ESVJUWTtcbiAgICAgICAgICAgIGlmIChub2RlLmRpcnR5IDwgZGlydHkpXG4gICAgICAgICAgICAgICAgbm9kZS5kaXJ0eSA9IGRpcnR5O1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBkb21BdG9tKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBnZXQgaWdub3JlRm9yQ29vcmRzKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBnZXQgaWdub3JlRm9yU2VsZWN0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICBpc1RleHQodGV4dCkgeyByZXR1cm4gZmFsc2U7IH1cbn1cbi8vIEEgd2lkZ2V0IGRlc2MgcmVwcmVzZW50cyBhIHdpZGdldCBkZWNvcmF0aW9uLCB3aGljaCBpcyBhIERPTSBub2RlXG4vLyBkcmF3biBiZXR3ZWVuIHRoZSBkb2N1bWVudCBub2Rlcy5cbmNsYXNzIFdpZGdldFZpZXdEZXNjIGV4dGVuZHMgVmlld0Rlc2Mge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgd2lkZ2V0LCB2aWV3LCBwb3MpIHtcbiAgICAgICAgbGV0IHNlbGYsIGRvbSA9IHdpZGdldC50eXBlLnRvRE9NO1xuICAgICAgICBpZiAodHlwZW9mIGRvbSA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICBkb20gPSBkb20odmlldywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghc2VsZilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5wYXJlbnQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLnBhcmVudC5wb3NCZWZvcmVDaGlsZChzZWxmKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBpZiAoIXdpZGdldC50eXBlLnNwZWMucmF3KSB7XG4gICAgICAgICAgICBpZiAoZG9tLm5vZGVUeXBlICE9IDEpIHtcbiAgICAgICAgICAgICAgICBsZXQgd3JhcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICAgICAgICAgIHdyYXAuYXBwZW5kQ2hpbGQoZG9tKTtcbiAgICAgICAgICAgICAgICBkb20gPSB3cmFwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9tLmNvbnRlbnRFZGl0YWJsZSA9IFwiZmFsc2VcIjtcbiAgICAgICAgICAgIGRvbS5jbGFzc0xpc3QuYWRkKFwiUHJvc2VNaXJyb3Itd2lkZ2V0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKHBhcmVudCwgW10sIGRvbSwgbnVsbCk7XG4gICAgICAgIHRoaXMud2lkZ2V0ID0gd2lkZ2V0O1xuICAgICAgICB0aGlzLndpZGdldCA9IHdpZGdldDtcbiAgICAgICAgc2VsZiA9IHRoaXM7XG4gICAgfVxuICAgIG1hdGNoZXNXaWRnZXQod2lkZ2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpcnR5ID09IE5PVF9ESVJUWSAmJiB3aWRnZXQudHlwZS5lcSh0aGlzLndpZGdldC50eXBlKTtcbiAgICB9XG4gICAgcGFyc2VSdWxlKCkgeyByZXR1cm4geyBpZ25vcmU6IHRydWUgfTsgfVxuICAgIHN0b3BFdmVudChldmVudCkge1xuICAgICAgICBsZXQgc3RvcCA9IHRoaXMud2lkZ2V0LnNwZWMuc3RvcEV2ZW50O1xuICAgICAgICByZXR1cm4gc3RvcCA/IHN0b3AoZXZlbnQpIDogZmFsc2U7XG4gICAgfVxuICAgIGlnbm9yZU11dGF0aW9uKG11dGF0aW9uKSB7XG4gICAgICAgIHJldHVybiBtdXRhdGlvbi50eXBlICE9IFwic2VsZWN0aW9uXCIgfHwgdGhpcy53aWRnZXQuc3BlYy5pZ25vcmVTZWxlY3Rpb247XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMud2lkZ2V0LnR5cGUuZGVzdHJveSh0aGlzLmRvbSk7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgZ2V0IGRvbUF0b20oKSB7IHJldHVybiB0cnVlOyB9XG4gICAgZ2V0IGlnbm9yZUZvclNlbGVjdGlvbigpIHsgcmV0dXJuICEhdGhpcy53aWRnZXQudHlwZS5zcGVjLnJlbGF4ZWRTaWRlOyB9XG4gICAgZ2V0IHNpZGUoKSB7IHJldHVybiB0aGlzLndpZGdldC50eXBlLnNpZGU7IH1cbn1cbmNsYXNzIENvbXBvc2l0aW9uVmlld0Rlc2MgZXh0ZW5kcyBWaWV3RGVzYyB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBkb20sIHRleHRET00sIHRleHQpIHtcbiAgICAgICAgc3VwZXIocGFyZW50LCBbXSwgZG9tLCBudWxsKTtcbiAgICAgICAgdGhpcy50ZXh0RE9NID0gdGV4dERPTTtcbiAgICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7IHJldHVybiB0aGlzLnRleHQubGVuZ3RoOyB9XG4gICAgbG9jYWxQb3NGcm9tRE9NKGRvbSwgb2Zmc2V0KSB7XG4gICAgICAgIGlmIChkb20gIT0gdGhpcy50ZXh0RE9NKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucG9zQXRTdGFydCArIChvZmZzZXQgPyB0aGlzLnNpemUgOiAwKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zQXRTdGFydCArIG9mZnNldDtcbiAgICB9XG4gICAgZG9tRnJvbVBvcyhwb3MpIHtcbiAgICAgICAgcmV0dXJuIHsgbm9kZTogdGhpcy50ZXh0RE9NLCBvZmZzZXQ6IHBvcyB9O1xuICAgIH1cbiAgICBpZ25vcmVNdXRhdGlvbihtdXQpIHtcbiAgICAgICAgcmV0dXJuIG11dC50eXBlID09PSAnY2hhcmFjdGVyRGF0YScgJiYgbXV0LnRhcmdldC5ub2RlVmFsdWUgPT0gbXV0Lm9sZFZhbHVlO1xuICAgIH1cbn1cbi8vIEEgbWFyayBkZXNjIHJlcHJlc2VudHMgYSBtYXJrLiBNYXkgaGF2ZSBtdWx0aXBsZSBjaGlsZHJlbixcbi8vIGRlcGVuZGluZyBvbiBob3cgdGhlIG1hcmsgaXMgc3BsaXQuIE5vdGUgdGhhdCBtYXJrcyBhcmUgZHJhd24gdXNpbmdcbi8vIGEgZml4ZWQgbmVzdGluZyBvcmRlciwgZm9yIHNpbXBsaWNpdHkgYW5kIHByZWRpY3RhYmlsaXR5LCBzbyBpblxuLy8gc29tZSBjYXNlcyB0aGV5IHdpbGwgYmUgc3BsaXQgbW9yZSBvZnRlbiB0aGFuIHdvdWxkIGFwcGVhclxuLy8gbmVjZXNzYXJ5LlxuY2xhc3MgTWFya1ZpZXdEZXNjIGV4dGVuZHMgVmlld0Rlc2Mge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgbWFyaywgZG9tLCBjb250ZW50RE9NLCBzcGVjKSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgW10sIGRvbSwgY29udGVudERPTSk7XG4gICAgICAgIHRoaXMubWFyayA9IG1hcms7XG4gICAgICAgIHRoaXMuc3BlYyA9IHNwZWM7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUocGFyZW50LCBtYXJrLCBpbmxpbmUsIHZpZXcpIHtcbiAgICAgICAgbGV0IGN1c3RvbSA9IHZpZXcubm9kZVZpZXdzW21hcmsudHlwZS5uYW1lXTtcbiAgICAgICAgbGV0IHNwZWMgPSBjdXN0b20gJiYgY3VzdG9tKG1hcmssIHZpZXcsIGlubGluZSk7XG4gICAgICAgIGlmICghc3BlYyB8fCAhc3BlYy5kb20pXG4gICAgICAgICAgICBzcGVjID0gRE9NU2VyaWFsaXplci5yZW5kZXJTcGVjKGRvY3VtZW50LCBtYXJrLnR5cGUuc3BlYy50b0RPTShtYXJrLCBpbmxpbmUpLCBudWxsLCBtYXJrLmF0dHJzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXJrVmlld0Rlc2MocGFyZW50LCBtYXJrLCBzcGVjLmRvbSwgc3BlYy5jb250ZW50RE9NIHx8IHNwZWMuZG9tLCBzcGVjKTtcbiAgICB9XG4gICAgcGFyc2VSdWxlKCkge1xuICAgICAgICBpZiAoKHRoaXMuZGlydHkgJiBOT0RFX0RJUlRZKSB8fCB0aGlzLm1hcmsudHlwZS5zcGVjLnJlcGFyc2VJblZpZXcpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIHsgbWFyazogdGhpcy5tYXJrLnR5cGUubmFtZSwgYXR0cnM6IHRoaXMubWFyay5hdHRycywgY29udGVudEVsZW1lbnQ6IHRoaXMuY29udGVudERPTSB9O1xuICAgIH1cbiAgICBtYXRjaGVzTWFyayhtYXJrKSB7IHJldHVybiB0aGlzLmRpcnR5ICE9IE5PREVfRElSVFkgJiYgdGhpcy5tYXJrLmVxKG1hcmspOyB9XG4gICAgbWFya0RpcnR5KGZyb20sIHRvKSB7XG4gICAgICAgIHN1cGVyLm1hcmtEaXJ0eShmcm9tLCB0byk7XG4gICAgICAgIC8vIE1vdmUgZGlydHkgaW5mbyB0byBuZWFyZXN0IG5vZGUgdmlld1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSAhPSBOT1RfRElSVFkpIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnQgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgICAgIHdoaWxlICghcGFyZW50Lm5vZGUpXG4gICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgICAgICAgIGlmIChwYXJlbnQuZGlydHkgPCB0aGlzLmRpcnR5KVxuICAgICAgICAgICAgICAgIHBhcmVudC5kaXJ0eSA9IHRoaXMuZGlydHk7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gTk9UX0RJUlRZO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNsaWNlKGZyb20sIHRvLCB2aWV3KSB7XG4gICAgICAgIGxldCBjb3B5ID0gTWFya1ZpZXdEZXNjLmNyZWF0ZSh0aGlzLnBhcmVudCwgdGhpcy5tYXJrLCB0cnVlLCB2aWV3KTtcbiAgICAgICAgbGV0IG5vZGVzID0gdGhpcy5jaGlsZHJlbiwgc2l6ZSA9IHRoaXMuc2l6ZTtcbiAgICAgICAgaWYgKHRvIDwgc2l6ZSlcbiAgICAgICAgICAgIG5vZGVzID0gcmVwbGFjZU5vZGVzKG5vZGVzLCB0bywgc2l6ZSwgdmlldyk7XG4gICAgICAgIGlmIChmcm9tID4gMClcbiAgICAgICAgICAgIG5vZGVzID0gcmVwbGFjZU5vZGVzKG5vZGVzLCAwLCBmcm9tLCB2aWV3KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIG5vZGVzW2ldLnBhcmVudCA9IGNvcHk7XG4gICAgICAgIGNvcHkuY2hpbGRyZW4gPSBub2RlcztcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfVxuICAgIGlnbm9yZU11dGF0aW9uKG11dGF0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNwZWMuaWdub3JlTXV0YXRpb24gPyB0aGlzLnNwZWMuaWdub3JlTXV0YXRpb24obXV0YXRpb24pIDogc3VwZXIuaWdub3JlTXV0YXRpb24obXV0YXRpb24pO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5zcGVjLmRlc3Ryb3kpXG4gICAgICAgICAgICB0aGlzLnNwZWMuZGVzdHJveSgpO1xuICAgICAgICBzdXBlci5kZXN0cm95KCk7XG4gICAgfVxufVxuLy8gTm9kZSB2aWV3IGRlc2NzIGFyZSB0aGUgbWFpbiwgbW9zdCBjb21tb24gdHlwZSBvZiB2aWV3IGRlc2MsIGFuZFxuLy8gY29ycmVzcG9uZCB0byBhbiBhY3R1YWwgbm9kZSBpbiB0aGUgZG9jdW1lbnQuIFVubGlrZSBtYXJrIGRlc2NzLFxuLy8gdGhleSBwb3B1bGF0ZSB0aGVpciBjaGlsZCBhcnJheSB0aGVtc2VsdmVzLlxuY2xhc3MgTm9kZVZpZXdEZXNjIGV4dGVuZHMgVmlld0Rlc2Mge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgY29udGVudERPTSwgbm9kZURPTSwgdmlldywgcG9zKSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgW10sIGRvbSwgY29udGVudERPTSk7XG4gICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgIHRoaXMub3V0ZXJEZWNvID0gb3V0ZXJEZWNvO1xuICAgICAgICB0aGlzLmlubmVyRGVjbyA9IGlubmVyRGVjbztcbiAgICAgICAgdGhpcy5ub2RlRE9NID0gbm9kZURPTTtcbiAgICB9XG4gICAgLy8gQnkgZGVmYXVsdCwgYSBub2RlIGlzIHJlbmRlcmVkIHVzaW5nIHRoZSBgdG9ET01gIG1ldGhvZCBmcm9tIHRoZVxuICAgIC8vIG5vZGUgdHlwZSBzcGVjLiBCdXQgY2xpZW50IGNvZGUgY2FuIHVzZSB0aGUgYG5vZGVWaWV3c2Agc3BlYyB0b1xuICAgIC8vIHN1cHBseSBhIGN1c3RvbSBub2RlIHZpZXcsIHdoaWNoIGNhbiBpbmZsdWVuY2UgdmFyaW91cyBhc3BlY3RzIG9mXG4gICAgLy8gdGhlIHdheSB0aGUgbm9kZSB3b3Jrcy5cbiAgICAvL1xuICAgIC8vIChVc2luZyBzdWJjbGFzc2luZyBmb3IgdGhpcyB3YXMgaW50ZW50aW9uYWxseSBkZWNpZGVkIGFnYWluc3QsXG4gICAgLy8gc2luY2UgaXQnZCByZXF1aXJlIGV4cG9zaW5nIGEgd2hvbGUgc2xldyBvZiBmaW5pY2t5XG4gICAgLy8gaW1wbGVtZW50YXRpb24gZGV0YWlscyB0byB0aGUgdXNlciBjb2RlIHRoYXQgdGhleSBwcm9iYWJseSB3aWxsXG4gICAgLy8gbmV2ZXIgbmVlZC4pXG4gICAgc3RhdGljIGNyZWF0ZShwYXJlbnQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBwb3MpIHtcbiAgICAgICAgbGV0IGN1c3RvbSA9IHZpZXcubm9kZVZpZXdzW25vZGUudHlwZS5uYW1lXSwgZGVzY09iajtcbiAgICAgICAgbGV0IHNwZWMgPSBjdXN0b20gJiYgY3VzdG9tKG5vZGUsIHZpZXcsICgpID0+IHtcbiAgICAgICAgICAgIC8vIChUaGlzIGlzIGEgZnVuY3Rpb24gdGhhdCBhbGxvd3MgdGhlIGN1c3RvbSB2aWV3IHRvIGZpbmQgaXRzXG4gICAgICAgICAgICAvLyBvd24gcG9zaXRpb24pXG4gICAgICAgICAgICBpZiAoIWRlc2NPYmopXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgICAgIGlmIChkZXNjT2JqLnBhcmVudClcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzY09iai5wYXJlbnQucG9zQmVmb3JlQ2hpbGQoZGVzY09iaik7XG4gICAgICAgIH0sIG91dGVyRGVjbywgaW5uZXJEZWNvKTtcbiAgICAgICAgbGV0IGRvbSA9IHNwZWMgJiYgc3BlYy5kb20sIGNvbnRlbnRET00gPSBzcGVjICYmIHNwZWMuY29udGVudERPTTtcbiAgICAgICAgaWYgKG5vZGUuaXNUZXh0KSB7XG4gICAgICAgICAgICBpZiAoIWRvbSlcbiAgICAgICAgICAgICAgICBkb20gPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShub2RlLnRleHQpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZG9tLm5vZGVUeXBlICE9IDMpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUZXh0IG11c3QgYmUgcmVuZGVyZWQgYXMgYSBET00gdGV4dCBub2RlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFkb20pIHtcbiAgICAgICAgICAgIGxldCBzcGVjID0gRE9NU2VyaWFsaXplci5yZW5kZXJTcGVjKGRvY3VtZW50LCBub2RlLnR5cGUuc3BlYy50b0RPTShub2RlKSwgbnVsbCwgbm9kZS5hdHRycyk7XG4gICAgICAgICAgICAoeyBkb20sIGNvbnRlbnRET00gfSA9IHNwZWMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29udGVudERPTSAmJiAhbm9kZS5pc1RleHQgJiYgZG9tLm5vZGVOYW1lICE9IFwiQlJcIikgeyAvLyBDaHJvbWUgZ2V0cyBjb25mdXNlZCBieSA8YnIgY29udGVudGVkaXRhYmxlPWZhbHNlPlxuICAgICAgICAgICAgaWYgKCFkb20uaGFzQXR0cmlidXRlKFwiY29udGVudGVkaXRhYmxlXCIpKVxuICAgICAgICAgICAgICAgIGRvbS5jb250ZW50RWRpdGFibGUgPSBcImZhbHNlXCI7XG4gICAgICAgICAgICBpZiAobm9kZS50eXBlLnNwZWMuZHJhZ2dhYmxlKVxuICAgICAgICAgICAgICAgIGRvbS5kcmFnZ2FibGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBub2RlRE9NID0gZG9tO1xuICAgICAgICBkb20gPSBhcHBseU91dGVyRGVjbyhkb20sIG91dGVyRGVjbywgbm9kZSk7XG4gICAgICAgIGlmIChzcGVjKVxuICAgICAgICAgICAgcmV0dXJuIGRlc2NPYmogPSBuZXcgQ3VzdG9tTm9kZVZpZXdEZXNjKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgY29udGVudERPTSB8fCBudWxsLCBub2RlRE9NLCBzcGVjLCB2aWV3LCBwb3MgKyAxKTtcbiAgICAgICAgZWxzZSBpZiAobm9kZS5pc1RleHQpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFRleHRWaWV3RGVzYyhwYXJlbnQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBkb20sIG5vZGVET00sIHZpZXcpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbmV3IE5vZGVWaWV3RGVzYyhwYXJlbnQsIG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCBkb20sIGNvbnRlbnRET00gfHwgbnVsbCwgbm9kZURPTSwgdmlldywgcG9zICsgMSk7XG4gICAgfVxuICAgIHBhcnNlUnVsZSgpIHtcbiAgICAgICAgLy8gRXhwZXJpbWVudGFsIGtsdWRnZSB0byBhbGxvdyBvcHQtaW4gcmUtcGFyc2luZyBvZiBub2Rlc1xuICAgICAgICBpZiAodGhpcy5ub2RlLnR5cGUuc3BlYy5yZXBhcnNlSW5WaWV3KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIC8vIEZJWE1FIHRoZSBhc3N1bXB0aW9uIHRoYXQgdGhpcyBjYW4gYWx3YXlzIHJldHVybiB0aGUgY3VycmVudFxuICAgICAgICAvLyBhdHRycyBtZWFucyB0aGF0IGlmIHRoZSB1c2VyIHNvbWVob3cgbWFuYWdlcyB0byBjaGFuZ2UgdGhlXG4gICAgICAgIC8vIGF0dHJzIGluIHRoZSBkb20sIHRoYXQgd29uJ3QgYmUgcGlja2VkIHVwLiBOb3QgZW50aXJlbHkgc3VyZVxuICAgICAgICAvLyB3aGV0aGVyIHRoaXMgaXMgYSBwcm9ibGVtXG4gICAgICAgIGxldCBydWxlID0geyBub2RlOiB0aGlzLm5vZGUudHlwZS5uYW1lLCBhdHRyczogdGhpcy5ub2RlLmF0dHJzIH07XG4gICAgICAgIGlmICh0aGlzLm5vZGUudHlwZS53aGl0ZXNwYWNlID09IFwicHJlXCIpXG4gICAgICAgICAgICBydWxlLnByZXNlcnZlV2hpdGVzcGFjZSA9IFwiZnVsbFwiO1xuICAgICAgICBpZiAoIXRoaXMuY29udGVudERPTSkge1xuICAgICAgICAgICAgcnVsZS5nZXRDb250ZW50ID0gKCkgPT4gdGhpcy5ub2RlLmNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuY29udGVudExvc3QpIHtcbiAgICAgICAgICAgIHJ1bGUuY29udGVudEVsZW1lbnQgPSB0aGlzLmNvbnRlbnRET007XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBDaHJvbWUgbGlrZXMgdG8gcmFuZG9tbHkgcmVjcmVhdGUgcGFyZW50IG5vZGVzIHdoZW5cbiAgICAgICAgICAgIC8vIGJhY2tzcGFjaW5nIHRoaW5ncy4gV2hlbiB0aGF0IGhhcHBlbnMsIHRoaXMgdHJpZXMgdG8gZmluZCB0aGVcbiAgICAgICAgICAgIC8vIG5ldyBwYXJlbnQuXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZG9tLmNvbnRhaW5zKGNoaWxkLmRvbS5wYXJlbnROb2RlKSkge1xuICAgICAgICAgICAgICAgICAgICBydWxlLmNvbnRlbnRFbGVtZW50ID0gY2hpbGQuZG9tLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcnVsZS5jb250ZW50RWxlbWVudClcbiAgICAgICAgICAgICAgICBydWxlLmdldENvbnRlbnQgPSAoKSA9PiBGcmFnbWVudC5lbXB0eTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnVsZTtcbiAgICB9XG4gICAgbWF0Y2hlc05vZGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlydHkgPT0gTk9UX0RJUlRZICYmIG5vZGUuZXEodGhpcy5ub2RlKSAmJlxuICAgICAgICAgICAgc2FtZU91dGVyRGVjbyhvdXRlckRlY28sIHRoaXMub3V0ZXJEZWNvKSAmJiBpbm5lckRlY28uZXEodGhpcy5pbm5lckRlY28pO1xuICAgIH1cbiAgICBnZXQgc2l6ZSgpIHsgcmV0dXJuIHRoaXMubm9kZS5ub2RlU2l6ZTsgfVxuICAgIGdldCBib3JkZXIoKSB7IHJldHVybiB0aGlzLm5vZGUuaXNMZWFmID8gMCA6IDE7IH1cbiAgICAvLyBTeW5jcyBgdGhpcy5jaGlsZHJlbmAgdG8gbWF0Y2ggYHRoaXMubm9kZS5jb250ZW50YCBhbmQgdGhlIGxvY2FsXG4gICAgLy8gZGVjb3JhdGlvbnMsIHBvc3NpYmx5IGludHJvZHVjaW5nIG5lc3RpbmcgZm9yIG1hcmtzLiBUaGVuLCBpbiBhXG4gICAgLy8gc2VwYXJhdGUgc3RlcCwgc3luY3MgdGhlIERPTSBpbnNpZGUgYHRoaXMuY29udGVudERPTWAgdG9cbiAgICAvLyBgdGhpcy5jaGlsZHJlbmAuXG4gICAgdXBkYXRlQ2hpbGRyZW4odmlldywgcG9zKSB7XG4gICAgICAgIGxldCBpbmxpbmUgPSB0aGlzLm5vZGUuaW5saW5lQ29udGVudCwgb2ZmID0gcG9zO1xuICAgICAgICBsZXQgY29tcG9zaXRpb24gPSB2aWV3LmNvbXBvc2luZyA/IHRoaXMubG9jYWxDb21wb3NpdGlvbkluZm8odmlldywgcG9zKSA6IG51bGw7XG4gICAgICAgIGxldCBsb2NhbENvbXBvc2l0aW9uID0gY29tcG9zaXRpb24gJiYgY29tcG9zaXRpb24ucG9zID4gLTEgPyBjb21wb3NpdGlvbiA6IG51bGw7XG4gICAgICAgIGxldCBjb21wb3NpdGlvbkluQ2hpbGQgPSBjb21wb3NpdGlvbiAmJiBjb21wb3NpdGlvbi5wb3MgPCAwO1xuICAgICAgICBsZXQgdXBkYXRlciA9IG5ldyBWaWV3VHJlZVVwZGF0ZXIodGhpcywgbG9jYWxDb21wb3NpdGlvbiAmJiBsb2NhbENvbXBvc2l0aW9uLm5vZGUsIHZpZXcpO1xuICAgICAgICBpdGVyRGVjbyh0aGlzLm5vZGUsIHRoaXMuaW5uZXJEZWNvLCAod2lkZ2V0LCBpLCBpbnNpZGVOb2RlKSA9PiB7XG4gICAgICAgICAgICBpZiAod2lkZ2V0LnNwZWMubWFya3MpXG4gICAgICAgICAgICAgICAgdXBkYXRlci5zeW5jVG9NYXJrcyh3aWRnZXQuc3BlYy5tYXJrcywgaW5saW5lLCB2aWV3KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHdpZGdldC50eXBlLnNpZGUgPj0gMCAmJiAhaW5zaWRlTm9kZSlcbiAgICAgICAgICAgICAgICB1cGRhdGVyLnN5bmNUb01hcmtzKGkgPT0gdGhpcy5ub2RlLmNoaWxkQ291bnQgPyBNYXJrLm5vbmUgOiB0aGlzLm5vZGUuY2hpbGQoaSkubWFya3MsIGlubGluZSwgdmlldyk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgbmV4dCBub2RlIGlzIGEgZGVzYyBtYXRjaGluZyB0aGlzIHdpZGdldCwgcmV1c2UgaXQsXG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgaW5zZXJ0IHRoZSB3aWRnZXQgYXMgYSBuZXcgdmlldyBkZXNjLlxuICAgICAgICAgICAgdXBkYXRlci5wbGFjZVdpZGdldCh3aWRnZXQsIHZpZXcsIG9mZik7XG4gICAgICAgIH0sIChjaGlsZCwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGkpID0+IHtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgd3JhcHBpbmcgbWFyayBkZXNjcyBtYXRjaCB0aGUgbm9kZSdzIG1hcmtzLlxuICAgICAgICAgICAgdXBkYXRlci5zeW5jVG9NYXJrcyhjaGlsZC5tYXJrcywgaW5saW5lLCB2aWV3KTtcbiAgICAgICAgICAgIC8vIFRyeSBzZXZlcmFsIHN0cmF0ZWdpZXMgZm9yIGRyYXdpbmcgdGhpcyBub2RlXG4gICAgICAgICAgICBsZXQgY29tcEluZGV4O1xuICAgICAgICAgICAgaWYgKHVwZGF0ZXIuZmluZE5vZGVNYXRjaChjaGlsZCwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGkpKSA7XG4gICAgICAgICAgICBlbHNlIGlmIChjb21wb3NpdGlvbkluQ2hpbGQgJiYgdmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSA+IG9mZiAmJlxuICAgICAgICAgICAgICAgIHZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvIDwgb2ZmICsgY2hpbGQubm9kZVNpemUgJiZcbiAgICAgICAgICAgICAgICAoY29tcEluZGV4ID0gdXBkYXRlci5maW5kSW5kZXhXaXRoQ2hpbGQoY29tcG9zaXRpb24ubm9kZSkpID4gLTEgJiZcbiAgICAgICAgICAgICAgICB1cGRhdGVyLnVwZGF0ZU5vZGVBdChjaGlsZCwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGNvbXBJbmRleCwgdmlldykpIDtcbiAgICAgICAgICAgIGVsc2UgaWYgKHVwZGF0ZXIudXBkYXRlTmV4dE5vZGUoY2hpbGQsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3LCBpLCBvZmYpKSA7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBBZGQgaXQgYXMgYSBuZXcgdmlld1xuICAgICAgICAgICAgICAgIHVwZGF0ZXIuYWRkTm9kZShjaGlsZCwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcsIG9mZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmYgKz0gY2hpbGQubm9kZVNpemU7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBEcm9wIGFsbCByZW1haW5pbmcgZGVzY3MgYWZ0ZXIgdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgICAgIHVwZGF0ZXIuc3luY1RvTWFya3MoW10sIGlubGluZSwgdmlldyk7XG4gICAgICAgIGlmICh0aGlzLm5vZGUuaXNUZXh0YmxvY2spXG4gICAgICAgICAgICB1cGRhdGVyLmFkZFRleHRibG9ja0hhY2tzKCk7XG4gICAgICAgIHVwZGF0ZXIuZGVzdHJveVJlc3QoKTtcbiAgICAgICAgLy8gU3luYyB0aGUgRE9NIGlmIGFueXRoaW5nIGNoYW5nZWRcbiAgICAgICAgaWYgKHVwZGF0ZXIuY2hhbmdlZCB8fCB0aGlzLmRpcnR5ID09IENPTlRFTlRfRElSVFkpIHtcbiAgICAgICAgICAgIC8vIE1heSBoYXZlIHRvIHByb3RlY3QgZm9jdXNlZCBET00gZnJvbSBiZWluZyBjaGFuZ2VkIGlmIGEgY29tcG9zaXRpb24gaXMgYWN0aXZlXG4gICAgICAgICAgICBpZiAobG9jYWxDb21wb3NpdGlvbilcbiAgICAgICAgICAgICAgICB0aGlzLnByb3RlY3RMb2NhbENvbXBvc2l0aW9uKHZpZXcsIGxvY2FsQ29tcG9zaXRpb24pO1xuICAgICAgICAgICAgcmVuZGVyRGVzY3ModGhpcy5jb250ZW50RE9NLCB0aGlzLmNoaWxkcmVuLCB2aWV3KTtcbiAgICAgICAgICAgIGlmIChpb3MpXG4gICAgICAgICAgICAgICAgaW9zSGFja3ModGhpcy5kb20pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxvY2FsQ29tcG9zaXRpb25JbmZvKHZpZXcsIHBvcykge1xuICAgICAgICAvLyBPbmx5IGRvIHNvbWV0aGluZyBpZiBib3RoIHRoZSBzZWxlY3Rpb24gYW5kIGEgZm9jdXNlZCB0ZXh0IG5vZGVcbiAgICAgICAgLy8gYXJlIGluc2lkZSBvZiB0aGlzIG5vZGVcbiAgICAgICAgbGV0IHsgZnJvbSwgdG8gfSA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICBpZiAoISh2aWV3LnN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24pIHx8IGZyb20gPCBwb3MgfHwgdG8gPiBwb3MgKyB0aGlzLm5vZGUuY29udGVudC5zaXplKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCB0ZXh0Tm9kZSA9IHZpZXcuaW5wdXQuY29tcG9zaXRpb25Ob2RlO1xuICAgICAgICBpZiAoIXRleHROb2RlIHx8ICF0aGlzLmRvbS5jb250YWlucyh0ZXh0Tm9kZS5wYXJlbnROb2RlKSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAodGhpcy5ub2RlLmlubGluZUNvbnRlbnQpIHtcbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIHRleHQgaW4gdGhlIGZvY3VzZWQgbm9kZSBpbiB0aGUgbm9kZSwgc3RvcCBpZiBpdCdzIG5vdFxuICAgICAgICAgICAgLy8gdGhlcmUgKG1heSBoYXZlIGJlZW4gbW9kaWZpZWQgdGhyb3VnaCBvdGhlciBtZWFucywgaW4gd2hpY2hcbiAgICAgICAgICAgIC8vIGNhc2UgaXQgc2hvdWxkIG92ZXJ3cml0dGVuKVxuICAgICAgICAgICAgbGV0IHRleHQgPSB0ZXh0Tm9kZS5ub2RlVmFsdWU7XG4gICAgICAgICAgICBsZXQgdGV4dFBvcyA9IGZpbmRUZXh0SW5GcmFnbWVudCh0aGlzLm5vZGUuY29udGVudCwgdGV4dCwgZnJvbSAtIHBvcywgdG8gLSBwb3MpO1xuICAgICAgICAgICAgcmV0dXJuIHRleHRQb3MgPCAwID8gbnVsbCA6IHsgbm9kZTogdGV4dE5vZGUsIHBvczogdGV4dFBvcywgdGV4dCB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHsgbm9kZTogdGV4dE5vZGUsIHBvczogLTEsIHRleHQ6IFwiXCIgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwcm90ZWN0TG9jYWxDb21wb3NpdGlvbih2aWV3LCB7IG5vZGUsIHBvcywgdGV4dCB9KSB7XG4gICAgICAgIC8vIFRoZSBub2RlIGlzIGFscmVhZHkgcGFydCBvZiBhIGxvY2FsIHZpZXcgZGVzYywgbGVhdmUgaXQgdGhlcmVcbiAgICAgICAgaWYgKHRoaXMuZ2V0RGVzYyhub2RlKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gQ3JlYXRlIGEgY29tcG9zaXRpb24gdmlldyBmb3IgdGhlIG9ycGhhbmVkIG5vZGVzXG4gICAgICAgIGxldCB0b3BOb2RlID0gbm9kZTtcbiAgICAgICAgZm9yICg7OyB0b3BOb2RlID0gdG9wTm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBpZiAodG9wTm9kZS5wYXJlbnROb2RlID09IHRoaXMuY29udGVudERPTSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHdoaWxlICh0b3BOb2RlLnByZXZpb3VzU2libGluZylcbiAgICAgICAgICAgICAgICB0b3BOb2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodG9wTm9kZS5wcmV2aW91c1NpYmxpbmcpO1xuICAgICAgICAgICAgd2hpbGUgKHRvcE5vZGUubmV4dFNpYmxpbmcpXG4gICAgICAgICAgICAgICAgdG9wTm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRvcE5vZGUubmV4dFNpYmxpbmcpO1xuICAgICAgICAgICAgaWYgKHRvcE5vZGUucG1WaWV3RGVzYylcbiAgICAgICAgICAgICAgICB0b3BOb2RlLnBtVmlld0Rlc2MgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRlc2MgPSBuZXcgQ29tcG9zaXRpb25WaWV3RGVzYyh0aGlzLCB0b3BOb2RlLCBub2RlLCB0ZXh0KTtcbiAgICAgICAgdmlldy5pbnB1dC5jb21wb3NpdGlvbk5vZGVzLnB1c2goZGVzYyk7XG4gICAgICAgIC8vIFBhdGNoIHVwIHRoaXMuY2hpbGRyZW4gdG8gY29udGFpbiB0aGUgY29tcG9zaXRpb24gdmlld1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gcmVwbGFjZU5vZGVzKHRoaXMuY2hpbGRyZW4sIHBvcywgcG9zICsgdGV4dC5sZW5ndGgsIHZpZXcsIGRlc2MpO1xuICAgIH1cbiAgICAvLyBJZiB0aGlzIGRlc2MgbXVzdCBiZSB1cGRhdGVkIHRvIG1hdGNoIHRoZSBnaXZlbiBub2RlIGRlY29yYXRpb24sXG4gICAgLy8gZG8gc28gYW5kIHJldHVybiB0cnVlLlxuICAgIHVwZGF0ZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldykge1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSA9PSBOT0RFX0RJUlRZIHx8XG4gICAgICAgICAgICAhbm9kZS5zYW1lTWFya3VwKHRoaXMubm9kZSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMudXBkYXRlSW5uZXIobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdXBkYXRlSW5uZXIobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpIHtcbiAgICAgICAgdGhpcy51cGRhdGVPdXRlckRlY28ob3V0ZXJEZWNvKTtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5pbm5lckRlY28gPSBpbm5lckRlY287XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnRET00pXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNoaWxkcmVuKHZpZXcsIHRoaXMucG9zQXRTdGFydCk7XG4gICAgICAgIHRoaXMuZGlydHkgPSBOT1RfRElSVFk7XG4gICAgfVxuICAgIHVwZGF0ZU91dGVyRGVjbyhvdXRlckRlY28pIHtcbiAgICAgICAgaWYgKHNhbWVPdXRlckRlY28ob3V0ZXJEZWNvLCB0aGlzLm91dGVyRGVjbykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBuZWVkc1dyYXAgPSB0aGlzLm5vZGVET00ubm9kZVR5cGUgIT0gMTtcbiAgICAgICAgbGV0IG9sZERPTSA9IHRoaXMuZG9tO1xuICAgICAgICB0aGlzLmRvbSA9IHBhdGNoT3V0ZXJEZWNvKHRoaXMuZG9tLCB0aGlzLm5vZGVET00sIGNvbXB1dGVPdXRlckRlY28odGhpcy5vdXRlckRlY28sIHRoaXMubm9kZSwgbmVlZHNXcmFwKSwgY29tcHV0ZU91dGVyRGVjbyhvdXRlckRlY28sIHRoaXMubm9kZSwgbmVlZHNXcmFwKSk7XG4gICAgICAgIGlmICh0aGlzLmRvbSAhPSBvbGRET00pIHtcbiAgICAgICAgICAgIG9sZERPTS5wbVZpZXdEZXNjID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5kb20ucG1WaWV3RGVzYyA9IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vdXRlckRlY28gPSBvdXRlckRlY287XG4gICAgfVxuICAgIC8vIE1hcmsgdGhpcyBub2RlIGFzIGJlaW5nIHRoZSBzZWxlY3RlZCBub2RlLlxuICAgIHNlbGVjdE5vZGUoKSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGVET00ubm9kZVR5cGUgPT0gMSkge1xuICAgICAgICAgICAgdGhpcy5ub2RlRE9NLmNsYXNzTGlzdC5hZGQoXCJQcm9zZU1pcnJvci1zZWxlY3RlZG5vZGVcIik7XG4gICAgICAgICAgICBpZiAodGhpcy5jb250ZW50RE9NIHx8ICF0aGlzLm5vZGUudHlwZS5zcGVjLmRyYWdnYWJsZSlcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVET00uZHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBSZW1vdmUgc2VsZWN0ZWQgbm9kZSBtYXJraW5nIGZyb20gdGhpcyBub2RlLlxuICAgIGRlc2VsZWN0Tm9kZSgpIHtcbiAgICAgICAgaWYgKHRoaXMubm9kZURPTS5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGVET00uY2xhc3NMaXN0LnJlbW92ZShcIlByb3NlTWlycm9yLXNlbGVjdGVkbm9kZVwiKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbnRlbnRET00gfHwgIXRoaXMubm9kZS50eXBlLnNwZWMuZHJhZ2dhYmxlKVxuICAgICAgICAgICAgICAgIHRoaXMubm9kZURPTS5yZW1vdmVBdHRyaWJ1dGUoXCJkcmFnZ2FibGVcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGRvbUF0b20oKSB7IHJldHVybiB0aGlzLm5vZGUuaXNBdG9tOyB9XG59XG4vLyBDcmVhdGUgYSB2aWV3IGRlc2MgZm9yIHRoZSB0b3AtbGV2ZWwgZG9jdW1lbnQgbm9kZSwgdG8gYmUgZXhwb3J0ZWRcbi8vIGFuZCB1c2VkIGJ5IHRoZSB2aWV3IGNsYXNzLlxuZnVuY3Rpb24gZG9jVmlld0Rlc2MoZG9jLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCB2aWV3KSB7XG4gICAgYXBwbHlPdXRlckRlY28oZG9tLCBvdXRlckRlY28sIGRvYyk7XG4gICAgbGV0IGRvY1ZpZXcgPSBuZXcgTm9kZVZpZXdEZXNjKHVuZGVmaW5lZCwgZG9jLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBkb20sIGRvbSwgdmlldywgMCk7XG4gICAgaWYgKGRvY1ZpZXcuY29udGVudERPTSlcbiAgICAgICAgZG9jVmlldy51cGRhdGVDaGlsZHJlbih2aWV3LCAwKTtcbiAgICByZXR1cm4gZG9jVmlldztcbn1cbmNsYXNzIFRleHRWaWV3RGVzYyBleHRlbmRzIE5vZGVWaWV3RGVzYyB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBub2RlRE9NLCB2aWV3KSB7XG4gICAgICAgIHN1cGVyKHBhcmVudCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIGRvbSwgbnVsbCwgbm9kZURPTSwgdmlldywgMCk7XG4gICAgfVxuICAgIHBhcnNlUnVsZSgpIHtcbiAgICAgICAgbGV0IHNraXAgPSB0aGlzLm5vZGVET00ucGFyZW50Tm9kZTtcbiAgICAgICAgd2hpbGUgKHNraXAgJiYgc2tpcCAhPSB0aGlzLmRvbSAmJiAhc2tpcC5wbUlzRGVjbylcbiAgICAgICAgICAgIHNraXAgPSBza2lwLnBhcmVudE5vZGU7XG4gICAgICAgIHJldHVybiB7IHNraXA6IChza2lwIHx8IHRydWUpIH07XG4gICAgfVxuICAgIHVwZGF0ZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldykge1xuICAgICAgICBpZiAodGhpcy5kaXJ0eSA9PSBOT0RFX0RJUlRZIHx8ICh0aGlzLmRpcnR5ICE9IE5PVF9ESVJUWSAmJiAhdGhpcy5pblBhcmVudCgpKSB8fFxuICAgICAgICAgICAgIW5vZGUuc2FtZU1hcmt1cCh0aGlzLm5vZGUpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLnVwZGF0ZU91dGVyRGVjbyhvdXRlckRlY28pO1xuICAgICAgICBpZiAoKHRoaXMuZGlydHkgIT0gTk9UX0RJUlRZIHx8IG5vZGUudGV4dCAhPSB0aGlzLm5vZGUudGV4dCkgJiYgbm9kZS50ZXh0ICE9IHRoaXMubm9kZURPTS5ub2RlVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMubm9kZURPTS5ub2RlVmFsdWUgPSBub2RlLnRleHQ7XG4gICAgICAgICAgICBpZiAodmlldy50cmFja1dyaXRlcyA9PSB0aGlzLm5vZGVET00pXG4gICAgICAgICAgICAgICAgdmlldy50cmFja1dyaXRlcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5kaXJ0eSA9IE5PVF9ESVJUWTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGluUGFyZW50KCkge1xuICAgICAgICBsZXQgcGFyZW50RE9NID0gdGhpcy5wYXJlbnQuY29udGVudERPTTtcbiAgICAgICAgZm9yIChsZXQgbiA9IHRoaXMubm9kZURPTTsgbjsgbiA9IG4ucGFyZW50Tm9kZSlcbiAgICAgICAgICAgIGlmIChuID09IHBhcmVudERPTSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBkb21Gcm9tUG9zKHBvcykge1xuICAgICAgICByZXR1cm4geyBub2RlOiB0aGlzLm5vZGVET00sIG9mZnNldDogcG9zIH07XG4gICAgfVxuICAgIGxvY2FsUG9zRnJvbURPTShkb20sIG9mZnNldCwgYmlhcykge1xuICAgICAgICBpZiAoZG9tID09IHRoaXMubm9kZURPTSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBvc0F0U3RhcnQgKyBNYXRoLm1pbihvZmZzZXQsIHRoaXMubm9kZS50ZXh0Lmxlbmd0aCk7XG4gICAgICAgIHJldHVybiBzdXBlci5sb2NhbFBvc0Zyb21ET00oZG9tLCBvZmZzZXQsIGJpYXMpO1xuICAgIH1cbiAgICBpZ25vcmVNdXRhdGlvbihtdXRhdGlvbikge1xuICAgICAgICByZXR1cm4gbXV0YXRpb24udHlwZSAhPSBcImNoYXJhY3RlckRhdGFcIiAmJiBtdXRhdGlvbi50eXBlICE9IFwic2VsZWN0aW9uXCI7XG4gICAgfVxuICAgIHNsaWNlKGZyb20sIHRvLCB2aWV3KSB7XG4gICAgICAgIGxldCBub2RlID0gdGhpcy5ub2RlLmN1dChmcm9tLCB0byksIGRvbSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG5vZGUudGV4dCk7XG4gICAgICAgIHJldHVybiBuZXcgVGV4dFZpZXdEZXNjKHRoaXMucGFyZW50LCBub2RlLCB0aGlzLm91dGVyRGVjbywgdGhpcy5pbm5lckRlY28sIGRvbSwgZG9tLCB2aWV3KTtcbiAgICB9XG4gICAgbWFya0RpcnR5KGZyb20sIHRvKSB7XG4gICAgICAgIHN1cGVyLm1hcmtEaXJ0eShmcm9tLCB0byk7XG4gICAgICAgIGlmICh0aGlzLmRvbSAhPSB0aGlzLm5vZGVET00gJiYgKGZyb20gPT0gMCB8fCB0byA9PSB0aGlzLm5vZGVET00ubm9kZVZhbHVlLmxlbmd0aCkpXG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gTk9ERV9ESVJUWTtcbiAgICB9XG4gICAgZ2V0IGRvbUF0b20oKSB7IHJldHVybiBmYWxzZTsgfVxuICAgIGlzVGV4dCh0ZXh0KSB7IHJldHVybiB0aGlzLm5vZGUudGV4dCA9PSB0ZXh0OyB9XG59XG4vLyBBIGR1bW15IGRlc2MgdXNlZCB0byB0YWcgdHJhaWxpbmcgQlIgb3IgSU1HIG5vZGVzIGNyZWF0ZWQgdG8gd29ya1xuLy8gYXJvdW5kIGNvbnRlbnRFZGl0YWJsZSB0ZXJyaWJsZW5lc3MuXG5jbGFzcyBUcmFpbGluZ0hhY2tWaWV3RGVzYyBleHRlbmRzIFZpZXdEZXNjIHtcbiAgICBwYXJzZVJ1bGUoKSB7IHJldHVybiB7IGlnbm9yZTogdHJ1ZSB9OyB9XG4gICAgbWF0Y2hlc0hhY2sobm9kZU5hbWUpIHsgcmV0dXJuIHRoaXMuZGlydHkgPT0gTk9UX0RJUlRZICYmIHRoaXMuZG9tLm5vZGVOYW1lID09IG5vZGVOYW1lOyB9XG4gICAgZ2V0IGRvbUF0b20oKSB7IHJldHVybiB0cnVlOyB9XG4gICAgZ2V0IGlnbm9yZUZvckNvb3JkcygpIHsgcmV0dXJuIHRoaXMuZG9tLm5vZGVOYW1lID09IFwiSU1HXCI7IH1cbn1cbi8vIEEgc2VwYXJhdGUgc3ViY2xhc3MgaXMgdXNlZCBmb3IgY3VzdG9taXplZCBub2RlIHZpZXdzLCBzbyB0aGF0IHRoZVxuLy8gZXh0cmEgY2hlY2tzIG9ubHkgaGF2ZSB0byBiZSBtYWRlIGZvciBub2RlcyB0aGF0IGFyZSBhY3R1YWxseVxuLy8gY3VzdG9taXplZC5cbmNsYXNzIEN1c3RvbU5vZGVWaWV3RGVzYyBleHRlbmRzIE5vZGVWaWV3RGVzYyB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBjb250ZW50RE9NLCBub2RlRE9NLCBzcGVjLCB2aWV3LCBwb3MpIHtcbiAgICAgICAgc3VwZXIocGFyZW50LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgZG9tLCBjb250ZW50RE9NLCBub2RlRE9NLCB2aWV3LCBwb3MpO1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjO1xuICAgIH1cbiAgICAvLyBBIGN1c3RvbSBgdXBkYXRlYCBtZXRob2QgZ2V0cyB0byBkZWNpZGUgd2hldGhlciB0aGUgdXBkYXRlIGdvZXNcbiAgICAvLyB0aHJvdWdoLiBJZiBpdCBkb2VzLCBhbmQgdGhlcmUncyBhIGBjb250ZW50RE9NYCBub2RlLCBvdXIgbG9naWNcbiAgICAvLyB1cGRhdGVzIHRoZSBjaGlsZHJlbi5cbiAgICB1cGRhdGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlydHkgPT0gTk9ERV9ESVJUWSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuc3BlYy51cGRhdGUgJiYgKHRoaXMubm9kZS50eXBlID09IG5vZGUudHlwZSB8fCB0aGlzLnNwZWMubXVsdGlUeXBlKSkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuc3BlYy51cGRhdGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28pO1xuICAgICAgICAgICAgaWYgKHJlc3VsdClcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUlubmVyKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuY29udGVudERPTSAmJiAhbm9kZS5pc0xlYWYpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBzdXBlci51cGRhdGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlbGVjdE5vZGUoKSB7XG4gICAgICAgIHRoaXMuc3BlYy5zZWxlY3ROb2RlID8gdGhpcy5zcGVjLnNlbGVjdE5vZGUoKSA6IHN1cGVyLnNlbGVjdE5vZGUoKTtcbiAgICB9XG4gICAgZGVzZWxlY3ROb2RlKCkge1xuICAgICAgICB0aGlzLnNwZWMuZGVzZWxlY3ROb2RlID8gdGhpcy5zcGVjLmRlc2VsZWN0Tm9kZSgpIDogc3VwZXIuZGVzZWxlY3ROb2RlKCk7XG4gICAgfVxuICAgIHNldFNlbGVjdGlvbihhbmNob3IsIGhlYWQsIHZpZXcsIGZvcmNlKSB7XG4gICAgICAgIHRoaXMuc3BlYy5zZXRTZWxlY3Rpb24gPyB0aGlzLnNwZWMuc2V0U2VsZWN0aW9uKGFuY2hvciwgaGVhZCwgdmlldy5yb290KVxuICAgICAgICAgICAgOiBzdXBlci5zZXRTZWxlY3Rpb24oYW5jaG9yLCBoZWFkLCB2aWV3LCBmb3JjZSk7XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLnNwZWMuZGVzdHJveSlcbiAgICAgICAgICAgIHRoaXMuc3BlYy5kZXN0cm95KCk7XG4gICAgICAgIHN1cGVyLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgc3RvcEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNwZWMuc3RvcEV2ZW50ID8gdGhpcy5zcGVjLnN0b3BFdmVudChldmVudCkgOiBmYWxzZTtcbiAgICB9XG4gICAgaWdub3JlTXV0YXRpb24obXV0YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BlYy5pZ25vcmVNdXRhdGlvbiA/IHRoaXMuc3BlYy5pZ25vcmVNdXRhdGlvbihtdXRhdGlvbikgOiBzdXBlci5pZ25vcmVNdXRhdGlvbihtdXRhdGlvbik7XG4gICAgfVxufVxuLy8gU3luYyB0aGUgY29udGVudCBvZiB0aGUgZ2l2ZW4gRE9NIG5vZGUgd2l0aCB0aGUgbm9kZXMgYXNzb2NpYXRlZFxuLy8gd2l0aCB0aGUgZ2l2ZW4gYXJyYXkgb2YgdmlldyBkZXNjcywgcmVjdXJzaW5nIGludG8gbWFyayBkZXNjc1xuLy8gYmVjYXVzZSB0aGlzIHNob3VsZCBzeW5jIHRoZSBzdWJ0cmVlIGZvciBhIHdob2xlIG5vZGUgYXQgYSB0aW1lLlxuZnVuY3Rpb24gcmVuZGVyRGVzY3MocGFyZW50RE9NLCBkZXNjcywgdmlldykge1xuICAgIGxldCBkb20gPSBwYXJlbnRET00uZmlyc3RDaGlsZCwgd3JpdHRlbiA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVzY3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGRlc2MgPSBkZXNjc1tpXSwgY2hpbGRET00gPSBkZXNjLmRvbTtcbiAgICAgICAgaWYgKGNoaWxkRE9NLnBhcmVudE5vZGUgPT0gcGFyZW50RE9NKSB7XG4gICAgICAgICAgICB3aGlsZSAoY2hpbGRET00gIT0gZG9tKSB7XG4gICAgICAgICAgICAgICAgZG9tID0gcm0oZG9tKTtcbiAgICAgICAgICAgICAgICB3cml0dGVuID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbSA9IGRvbS5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdyaXR0ZW4gPSB0cnVlO1xuICAgICAgICAgICAgcGFyZW50RE9NLmluc2VydEJlZm9yZShjaGlsZERPTSwgZG9tKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVzYyBpbnN0YW5jZW9mIE1hcmtWaWV3RGVzYykge1xuICAgICAgICAgICAgbGV0IHBvcyA9IGRvbSA/IGRvbS5wcmV2aW91c1NpYmxpbmcgOiBwYXJlbnRET00ubGFzdENoaWxkO1xuICAgICAgICAgICAgcmVuZGVyRGVzY3MoZGVzYy5jb250ZW50RE9NLCBkZXNjLmNoaWxkcmVuLCB2aWV3KTtcbiAgICAgICAgICAgIGRvbSA9IHBvcyA/IHBvcy5uZXh0U2libGluZyA6IHBhcmVudERPTS5maXJzdENoaWxkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdoaWxlIChkb20pIHtcbiAgICAgICAgZG9tID0gcm0oZG9tKTtcbiAgICAgICAgd3JpdHRlbiA9IHRydWU7XG4gICAgfVxuICAgIGlmICh3cml0dGVuICYmIHZpZXcudHJhY2tXcml0ZXMgPT0gcGFyZW50RE9NKVxuICAgICAgICB2aWV3LnRyYWNrV3JpdGVzID0gbnVsbDtcbn1cbmNvbnN0IE91dGVyRGVjb0xldmVsID0gZnVuY3Rpb24gKG5vZGVOYW1lKSB7XG4gICAgaWYgKG5vZGVOYW1lKVxuICAgICAgICB0aGlzLm5vZGVOYW1lID0gbm9kZU5hbWU7XG59O1xuT3V0ZXJEZWNvTGV2ZWwucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmNvbnN0IG5vRGVjbyA9IFtuZXcgT3V0ZXJEZWNvTGV2ZWxdO1xuZnVuY3Rpb24gY29tcHV0ZU91dGVyRGVjbyhvdXRlckRlY28sIG5vZGUsIG5lZWRzV3JhcCkge1xuICAgIGlmIChvdXRlckRlY28ubGVuZ3RoID09IDApXG4gICAgICAgIHJldHVybiBub0RlY287XG4gICAgbGV0IHRvcCA9IG5lZWRzV3JhcCA/IG5vRGVjb1swXSA6IG5ldyBPdXRlckRlY29MZXZlbCwgcmVzdWx0ID0gW3RvcF07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRlckRlY28ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGF0dHJzID0gb3V0ZXJEZWNvW2ldLnR5cGUuYXR0cnM7XG4gICAgICAgIGlmICghYXR0cnMpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKGF0dHJzLm5vZGVOYW1lKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2godG9wID0gbmV3IE91dGVyRGVjb0xldmVsKGF0dHJzLm5vZGVOYW1lKSk7XG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gYXR0cnMpIHtcbiAgICAgICAgICAgIGxldCB2YWwgPSBhdHRyc1tuYW1lXTtcbiAgICAgICAgICAgIGlmICh2YWwgPT0gbnVsbClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChuZWVkc1dyYXAgJiYgcmVzdWx0Lmxlbmd0aCA9PSAxKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHRvcCA9IG5ldyBPdXRlckRlY29MZXZlbChub2RlLmlzSW5saW5lID8gXCJzcGFuXCIgOiBcImRpdlwiKSk7XG4gICAgICAgICAgICBpZiAobmFtZSA9PSBcImNsYXNzXCIpXG4gICAgICAgICAgICAgICAgdG9wLmNsYXNzID0gKHRvcC5jbGFzcyA/IHRvcC5jbGFzcyArIFwiIFwiIDogXCJcIikgKyB2YWw7XG4gICAgICAgICAgICBlbHNlIGlmIChuYW1lID09IFwic3R5bGVcIilcbiAgICAgICAgICAgICAgICB0b3Auc3R5bGUgPSAodG9wLnN0eWxlID8gdG9wLnN0eWxlICsgXCI7XCIgOiBcIlwiKSArIHZhbDtcbiAgICAgICAgICAgIGVsc2UgaWYgKG5hbWUgIT0gXCJub2RlTmFtZVwiKVxuICAgICAgICAgICAgICAgIHRvcFtuYW1lXSA9IHZhbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGF0Y2hPdXRlckRlY28ob3V0ZXJET00sIG5vZGVET00sIHByZXZDb21wdXRlZCwgY3VyQ29tcHV0ZWQpIHtcbiAgICAvLyBTaG9ydGN1dCBmb3IgdHJpdmlhbCBjYXNlXG4gICAgaWYgKHByZXZDb21wdXRlZCA9PSBub0RlY28gJiYgY3VyQ29tcHV0ZWQgPT0gbm9EZWNvKVxuICAgICAgICByZXR1cm4gbm9kZURPTTtcbiAgICBsZXQgY3VyRE9NID0gbm9kZURPTTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1ckNvbXB1dGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBkZWNvID0gY3VyQ29tcHV0ZWRbaV0sIHByZXYgPSBwcmV2Q29tcHV0ZWRbaV07XG4gICAgICAgIGlmIChpKSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50O1xuICAgICAgICAgICAgaWYgKHByZXYgJiYgcHJldi5ub2RlTmFtZSA9PSBkZWNvLm5vZGVOYW1lICYmIGN1ckRPTSAhPSBvdXRlckRPTSAmJlxuICAgICAgICAgICAgICAgIChwYXJlbnQgPSBjdXJET00ucGFyZW50Tm9kZSkgJiYgcGFyZW50Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT0gZGVjby5ub2RlTmFtZSkge1xuICAgICAgICAgICAgICAgIGN1ckRPTSA9IHBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZGVjby5ub2RlTmFtZSk7XG4gICAgICAgICAgICAgICAgcGFyZW50LnBtSXNEZWNvID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoY3VyRE9NKTtcbiAgICAgICAgICAgICAgICBwcmV2ID0gbm9EZWNvWzBdO1xuICAgICAgICAgICAgICAgIGN1ckRPTSA9IHBhcmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwYXRjaEF0dHJpYnV0ZXMoY3VyRE9NLCBwcmV2IHx8IG5vRGVjb1swXSwgZGVjbyk7XG4gICAgfVxuICAgIHJldHVybiBjdXJET007XG59XG5mdW5jdGlvbiBwYXRjaEF0dHJpYnV0ZXMoZG9tLCBwcmV2LCBjdXIpIHtcbiAgICBmb3IgKGxldCBuYW1lIGluIHByZXYpXG4gICAgICAgIGlmIChuYW1lICE9IFwiY2xhc3NcIiAmJiBuYW1lICE9IFwic3R5bGVcIiAmJiBuYW1lICE9IFwibm9kZU5hbWVcIiAmJiAhKG5hbWUgaW4gY3VyKSlcbiAgICAgICAgICAgIGRvbS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgZm9yIChsZXQgbmFtZSBpbiBjdXIpXG4gICAgICAgIGlmIChuYW1lICE9IFwiY2xhc3NcIiAmJiBuYW1lICE9IFwic3R5bGVcIiAmJiBuYW1lICE9IFwibm9kZU5hbWVcIiAmJiBjdXJbbmFtZV0gIT0gcHJldltuYW1lXSlcbiAgICAgICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUobmFtZSwgY3VyW25hbWVdKTtcbiAgICBpZiAocHJldi5jbGFzcyAhPSBjdXIuY2xhc3MpIHtcbiAgICAgICAgbGV0IHByZXZMaXN0ID0gcHJldi5jbGFzcyA/IHByZXYuY2xhc3Muc3BsaXQoXCIgXCIpLmZpbHRlcihCb29sZWFuKSA6IFtdO1xuICAgICAgICBsZXQgY3VyTGlzdCA9IGN1ci5jbGFzcyA/IGN1ci5jbGFzcy5zcGxpdChcIiBcIikuZmlsdGVyKEJvb2xlYW4pIDogW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldkxpc3QubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoY3VyTGlzdC5pbmRleE9mKHByZXZMaXN0W2ldKSA9PSAtMSlcbiAgICAgICAgICAgICAgICBkb20uY2xhc3NMaXN0LnJlbW92ZShwcmV2TGlzdFtpXSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VyTGlzdC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmIChwcmV2TGlzdC5pbmRleE9mKGN1ckxpc3RbaV0pID09IC0xKVxuICAgICAgICAgICAgICAgIGRvbS5jbGFzc0xpc3QuYWRkKGN1ckxpc3RbaV0pO1xuICAgICAgICBpZiAoZG9tLmNsYXNzTGlzdC5sZW5ndGggPT0gMClcbiAgICAgICAgICAgIGRvbS5yZW1vdmVBdHRyaWJ1dGUoXCJjbGFzc1wiKTtcbiAgICB9XG4gICAgaWYgKHByZXYuc3R5bGUgIT0gY3VyLnN0eWxlKSB7XG4gICAgICAgIGlmIChwcmV2LnN0eWxlKSB7XG4gICAgICAgICAgICBsZXQgcHJvcCA9IC9cXHMqKFtcXHdcXC1cXHhhMS1cXHVmZmZmXSspXFxzKjooPzpcIig/OlxcXFwufFteXCJdKSpcInwnKD86XFxcXC58W14nXSkqJ3xcXCguKj9cXCl8W147XSkqL2csIG07XG4gICAgICAgICAgICB3aGlsZSAobSA9IHByb3AuZXhlYyhwcmV2LnN0eWxlKSlcbiAgICAgICAgICAgICAgICBkb20uc3R5bGUucmVtb3ZlUHJvcGVydHkobVsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1ci5zdHlsZSlcbiAgICAgICAgICAgIGRvbS5zdHlsZS5jc3NUZXh0ICs9IGN1ci5zdHlsZTtcbiAgICB9XG59XG5mdW5jdGlvbiBhcHBseU91dGVyRGVjbyhkb20sIGRlY28sIG5vZGUpIHtcbiAgICByZXR1cm4gcGF0Y2hPdXRlckRlY28oZG9tLCBkb20sIG5vRGVjbywgY29tcHV0ZU91dGVyRGVjbyhkZWNvLCBub2RlLCBkb20ubm9kZVR5cGUgIT0gMSkpO1xufVxuZnVuY3Rpb24gc2FtZU91dGVyRGVjbyhhLCBiKSB7XG4gICAgaWYgKGEubGVuZ3RoICE9IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgICBpZiAoIWFbaV0udHlwZS5lcShiW2ldLnR5cGUpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuLy8gUmVtb3ZlIGEgRE9NIG5vZGUgYW5kIHJldHVybiBpdHMgbmV4dCBzaWJsaW5nLlxuZnVuY3Rpb24gcm0oZG9tKSB7XG4gICAgbGV0IG5leHQgPSBkb20ubmV4dFNpYmxpbmc7XG4gICAgZG9tLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZG9tKTtcbiAgICByZXR1cm4gbmV4dDtcbn1cbi8vIEhlbHBlciBjbGFzcyBmb3IgaW5jcmVtZW50YWxseSB1cGRhdGluZyBhIHRyZWUgb2YgbWFyayBkZXNjcyBhbmRcbi8vIHRoZSB3aWRnZXQgYW5kIG5vZGUgZGVzY3MgaW5zaWRlIG9mIHRoZW0uXG5jbGFzcyBWaWV3VHJlZVVwZGF0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHRvcCwgbG9jaywgdmlldykge1xuICAgICAgICB0aGlzLmxvY2sgPSBsb2NrO1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICAvLyBJbmRleCBpbnRvIGB0aGlzLnRvcGAncyBjaGlsZCBhcnJheSwgcmVwcmVzZW50cyB0aGUgY3VycmVudFxuICAgICAgICAvLyB1cGRhdGUgcG9zaXRpb24uXG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICAvLyBXaGVuIGVudGVyaW5nIGEgbWFyaywgdGhlIGN1cnJlbnQgdG9wIGFuZCBpbmRleCBhcmUgcHVzaGVkXG4gICAgICAgIC8vIG9udG8gdGhpcy5cbiAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xuICAgICAgICAvLyBUcmFja3Mgd2hldGhlciBhbnl0aGluZyB3YXMgY2hhbmdlZFxuICAgICAgICB0aGlzLmNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy50b3AgPSB0b3A7XG4gICAgICAgIHRoaXMucHJlTWF0Y2ggPSBwcmVNYXRjaCh0b3Aubm9kZS5jb250ZW50LCB0b3ApO1xuICAgIH1cbiAgICAvLyBEZXN0cm95IGFuZCByZW1vdmUgdGhlIGNoaWxkcmVuIGJldHdlZW4gdGhlIGdpdmVuIGluZGljZXMgaW5cbiAgICAvLyBgdGhpcy50b3BgLlxuICAgIGRlc3Ryb3lCZXR3ZWVuKHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09IGVuZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspXG4gICAgICAgICAgICB0aGlzLnRvcC5jaGlsZHJlbltpXS5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMudG9wLmNoaWxkcmVuLnNwbGljZShzdGFydCwgZW5kIC0gc3RhcnQpO1xuICAgICAgICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBEZXN0cm95IGFsbCByZW1haW5pbmcgY2hpbGRyZW4gaW4gYHRoaXMudG9wYC5cbiAgICBkZXN0cm95UmVzdCgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95QmV0d2Vlbih0aGlzLmluZGV4LCB0aGlzLnRvcC5jaGlsZHJlbi5sZW5ndGgpO1xuICAgIH1cbiAgICAvLyBTeW5jIHRoZSBjdXJyZW50IHN0YWNrIG9mIG1hcmsgZGVzY3Mgd2l0aCB0aGUgZ2l2ZW4gYXJyYXkgb2ZcbiAgICAvLyBtYXJrcywgcmV1c2luZyBleGlzdGluZyBtYXJrIGRlc2NzIHdoZW4gcG9zc2libGUuXG4gICAgc3luY1RvTWFya3MobWFya3MsIGlubGluZSwgdmlldykge1xuICAgICAgICBsZXQga2VlcCA9IDAsIGRlcHRoID0gdGhpcy5zdGFjay5sZW5ndGggPj4gMTtcbiAgICAgICAgbGV0IG1heEtlZXAgPSBNYXRoLm1pbihkZXB0aCwgbWFya3MubGVuZ3RoKTtcbiAgICAgICAgd2hpbGUgKGtlZXAgPCBtYXhLZWVwICYmXG4gICAgICAgICAgICAoa2VlcCA9PSBkZXB0aCAtIDEgPyB0aGlzLnRvcCA6IHRoaXMuc3RhY2tbKGtlZXAgKyAxKSA8PCAxXSlcbiAgICAgICAgICAgICAgICAubWF0Y2hlc01hcmsobWFya3Nba2VlcF0pICYmIG1hcmtzW2tlZXBdLnR5cGUuc3BlYy5zcGFubmluZyAhPT0gZmFsc2UpXG4gICAgICAgICAgICBrZWVwKys7XG4gICAgICAgIHdoaWxlIChrZWVwIDwgZGVwdGgpIHtcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveVJlc3QoKTtcbiAgICAgICAgICAgIHRoaXMudG9wLmRpcnR5ID0gTk9UX0RJUlRZO1xuICAgICAgICAgICAgdGhpcy5pbmRleCA9IHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgICAgICB0aGlzLnRvcCA9IHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChkZXB0aCA8IG1hcmtzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHRoaXMudG9wLCB0aGlzLmluZGV4ICsgMSk7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSAtMTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmluZGV4OyBpIDwgTWF0aC5taW4odGhpcy5pbmRleCArIDMsIHRoaXMudG9wLmNoaWxkcmVuLmxlbmd0aCk7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy50b3AuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKG5leHQubWF0Y2hlc01hcmsobWFya3NbZGVwdGhdKSAmJiAhdGhpcy5pc0xvY2tlZChuZXh0LmRvbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm91bmQgPiAtMSkge1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZCA+IHRoaXMuaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95QmV0d2Vlbih0aGlzLmluZGV4LCBmb3VuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudG9wID0gdGhpcy50b3AuY2hpbGRyZW5bdGhpcy5pbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFya0Rlc2MgPSBNYXJrVmlld0Rlc2MuY3JlYXRlKHRoaXMudG9wLCBtYXJrc1tkZXB0aF0sIGlubGluZSwgdmlldyk7XG4gICAgICAgICAgICAgICAgdGhpcy50b3AuY2hpbGRyZW4uc3BsaWNlKHRoaXMuaW5kZXgsIDAsIG1hcmtEZXNjKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRvcCA9IG1hcmtEZXNjO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gMDtcbiAgICAgICAgICAgIGRlcHRoKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVHJ5IHRvIGZpbmQgYSBub2RlIGRlc2MgbWF0Y2hpbmcgdGhlIGdpdmVuIGRhdGEuIFNraXAgb3ZlciBpdCBhbmRcbiAgICAvLyByZXR1cm4gdHJ1ZSB3aGVuIHN1Y2Nlc3NmdWwuXG4gICAgZmluZE5vZGVNYXRjaChub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgaW5kZXgpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gLTEsIHRhcmdldERlc2M7XG4gICAgICAgIGlmIChpbmRleCA+PSB0aGlzLnByZU1hdGNoLmluZGV4ICYmXG4gICAgICAgICAgICAodGFyZ2V0RGVzYyA9IHRoaXMucHJlTWF0Y2gubWF0Y2hlc1tpbmRleCAtIHRoaXMucHJlTWF0Y2guaW5kZXhdKS5wYXJlbnQgPT0gdGhpcy50b3AgJiZcbiAgICAgICAgICAgIHRhcmdldERlc2MubWF0Y2hlc05vZGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28pKSB7XG4gICAgICAgICAgICBmb3VuZCA9IHRoaXMudG9wLmNoaWxkcmVuLmluZGV4T2YodGFyZ2V0RGVzYywgdGhpcy5pbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5pbmRleCwgZSA9IE1hdGgubWluKHRoaXMudG9wLmNoaWxkcmVuLmxlbmd0aCwgaSArIDUpOyBpIDwgZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkID0gdGhpcy50b3AuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLm1hdGNoZXNOb2RlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvKSAmJiAhdGhpcy5wcmVNYXRjaC5tYXRjaGVkLmhhcyhjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm91bmQgPSBpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvdW5kIDwgMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5kZXN0cm95QmV0d2Vlbih0aGlzLmluZGV4LCBmb3VuZCk7XG4gICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHVwZGF0ZU5vZGVBdChub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgaW5kZXgsIHZpZXcpIHtcbiAgICAgICAgbGV0IGNoaWxkID0gdGhpcy50b3AuY2hpbGRyZW5baW5kZXhdO1xuICAgICAgICBpZiAoY2hpbGQuZGlydHkgPT0gTk9ERV9ESVJUWSAmJiBjaGlsZC5kb20gPT0gY2hpbGQuY29udGVudERPTSlcbiAgICAgICAgICAgIGNoaWxkLmRpcnR5ID0gQ09OVEVOVF9ESVJUWTtcbiAgICAgICAgaWYgKCFjaGlsZC51cGRhdGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3lCZXR3ZWVuKHRoaXMuaW5kZXgsIGluZGV4KTtcbiAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZmluZEluZGV4V2l0aENoaWxkKGRvbU5vZGUpIHtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgbGV0IHBhcmVudCA9IGRvbU5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIGlmICghcGFyZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQgPT0gdGhpcy50b3AuY29udGVudERPTSkge1xuICAgICAgICAgICAgICAgIGxldCBkZXNjID0gZG9tTm9kZS5wbVZpZXdEZXNjO1xuICAgICAgICAgICAgICAgIGlmIChkZXNjKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5pbmRleDsgaSA8IHRoaXMudG9wLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50b3AuY2hpbGRyZW5baV0gPT0gZGVzYylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbU5vZGUgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVHJ5IHRvIHVwZGF0ZSB0aGUgbmV4dCBub2RlLCBpZiBhbnksIHRvIHRoZSBnaXZlbiBkYXRhLiBDaGVja3NcbiAgICAvLyBwcmUtbWF0Y2hlcyB0byBhdm9pZCBvdmVyd3JpdGluZyBub2RlcyB0aGF0IGNvdWxkIHN0aWxsIGJlIHVzZWQuXG4gICAgdXBkYXRlTmV4dE5vZGUobm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcsIGluZGV4LCBwb3MpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuaW5kZXg7IGkgPCB0aGlzLnRvcC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG5leHQgPSB0aGlzLnRvcC5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChuZXh0IGluc3RhbmNlb2YgTm9kZVZpZXdEZXNjKSB7XG4gICAgICAgICAgICAgICAgbGV0IHByZU1hdGNoID0gdGhpcy5wcmVNYXRjaC5tYXRjaGVkLmdldChuZXh0KTtcbiAgICAgICAgICAgICAgICBpZiAocHJlTWF0Y2ggIT0gbnVsbCAmJiBwcmVNYXRjaCAhPSBpbmRleClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGxldCBuZXh0RE9NID0gbmV4dC5kb20sIHVwZGF0ZWQ7XG4gICAgICAgICAgICAgICAgLy8gQ2FuJ3QgdXBkYXRlIGlmIG5leHRET00gaXMgb3IgY29udGFpbnMgdGhpcy5sb2NrLCBleGNlcHQgaWZcbiAgICAgICAgICAgICAgICAvLyBpdCdzIGEgdGV4dCBub2RlIHdob3NlIGNvbnRlbnQgYWxyZWFkeSBtYXRjaGVzIHRoZSBuZXcgdGV4dFxuICAgICAgICAgICAgICAgIC8vIGFuZCB3aG9zZSBkZWNvcmF0aW9ucyBtYXRjaCB0aGUgbmV3IG9uZXMuXG4gICAgICAgICAgICAgICAgbGV0IGxvY2tlZCA9IHRoaXMuaXNMb2NrZWQobmV4dERPTSkgJiZcbiAgICAgICAgICAgICAgICAgICAgIShub2RlLmlzVGV4dCAmJiBuZXh0Lm5vZGUgJiYgbmV4dC5ub2RlLmlzVGV4dCAmJiBuZXh0Lm5vZGVET00ubm9kZVZhbHVlID09IG5vZGUudGV4dCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC5kaXJ0eSAhPSBOT0RFX0RJUlRZICYmIHNhbWVPdXRlckRlY28ob3V0ZXJEZWNvLCBuZXh0Lm91dGVyRGVjbykpO1xuICAgICAgICAgICAgICAgIGlmICghbG9ja2VkICYmIG5leHQudXBkYXRlKG5vZGUsIG91dGVyRGVjbywgaW5uZXJEZWNvLCB2aWV3KSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc3Ryb3lCZXR3ZWVuKHRoaXMuaW5kZXgsIGkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dC5kb20gIT0gbmV4dERPTSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFsb2NrZWQgJiYgKHVwZGF0ZWQgPSB0aGlzLnJlY3JlYXRlV3JhcHBlcihuZXh0LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldywgcG9zKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXN0cm95QmV0d2Vlbih0aGlzLmluZGV4LCBpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b3AuY2hpbGRyZW5bdGhpcy5pbmRleF0gPSB1cGRhdGVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlZC5jb250ZW50RE9NKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkLmRpcnR5ID0gQ09OVEVOVF9ESVJUWTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWQudXBkYXRlQ2hpbGRyZW4odmlldywgcG9zICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkLmRpcnR5ID0gTk9UX0RJUlRZO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gV2hlbiBhIG5vZGUgd2l0aCBjb250ZW50IGlzIHJlcGxhY2VkIGJ5IGEgZGlmZmVyZW50IG5vZGUgd2l0aFxuICAgIC8vIGlkZW50aWNhbCBjb250ZW50LCBtb3ZlIG92ZXIgaXRzIGNoaWxkcmVuLlxuICAgIHJlY3JlYXRlV3JhcHBlcihuZXh0LCBub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldywgcG9zKSB7XG4gICAgICAgIGlmIChuZXh0LmRpcnR5IHx8IG5vZGUuaXNBdG9tIHx8ICFuZXh0LmNoaWxkcmVuLmxlbmd0aCB8fFxuICAgICAgICAgICAgIW5leHQubm9kZS5jb250ZW50LmVxKG5vZGUuY29udGVudCkgfHxcbiAgICAgICAgICAgICFzYW1lT3V0ZXJEZWNvKG91dGVyRGVjbywgbmV4dC5vdXRlckRlY28pIHx8ICFpbm5lckRlY28uZXEobmV4dC5pbm5lckRlY28pKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGxldCB3cmFwcGVyID0gTm9kZVZpZXdEZXNjLmNyZWF0ZSh0aGlzLnRvcCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcsIHBvcyk7XG4gICAgICAgIGlmICh3cmFwcGVyLmNvbnRlbnRET00pIHtcbiAgICAgICAgICAgIHdyYXBwZXIuY2hpbGRyZW4gPSBuZXh0LmNoaWxkcmVuO1xuICAgICAgICAgICAgbmV4dC5jaGlsZHJlbiA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgY2ggb2Ygd3JhcHBlci5jaGlsZHJlbilcbiAgICAgICAgICAgICAgICBjaC5wYXJlbnQgPSB3cmFwcGVyO1xuICAgICAgICB9XG4gICAgICAgIG5leHQuZGVzdHJveSgpO1xuICAgICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG4gICAgLy8gSW5zZXJ0IHRoZSBub2RlIGFzIGEgbmV3bHkgY3JlYXRlZCBub2RlIGRlc2MuXG4gICAgYWRkTm9kZShub2RlLCBvdXRlckRlY28sIGlubmVyRGVjbywgdmlldywgcG9zKSB7XG4gICAgICAgIGxldCBkZXNjID0gTm9kZVZpZXdEZXNjLmNyZWF0ZSh0aGlzLnRvcCwgbm9kZSwgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHZpZXcsIHBvcyk7XG4gICAgICAgIGlmIChkZXNjLmNvbnRlbnRET00pXG4gICAgICAgICAgICBkZXNjLnVwZGF0ZUNoaWxkcmVuKHZpZXcsIHBvcyArIDEpO1xuICAgICAgICB0aGlzLnRvcC5jaGlsZHJlbi5zcGxpY2UodGhpcy5pbmRleCsrLCAwLCBkZXNjKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgcGxhY2VXaWRnZXQod2lkZ2V0LCB2aWV3LCBwb3MpIHtcbiAgICAgICAgbGV0IG5leHQgPSB0aGlzLmluZGV4IDwgdGhpcy50b3AuY2hpbGRyZW4ubGVuZ3RoID8gdGhpcy50b3AuY2hpbGRyZW5bdGhpcy5pbmRleF0gOiBudWxsO1xuICAgICAgICBpZiAobmV4dCAmJiBuZXh0Lm1hdGNoZXNXaWRnZXQod2lkZ2V0KSAmJlxuICAgICAgICAgICAgKHdpZGdldCA9PSBuZXh0LndpZGdldCB8fCAhbmV4dC53aWRnZXQudHlwZS50b0RPTS5wYXJlbnROb2RlKSkge1xuICAgICAgICAgICAgdGhpcy5pbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGRlc2MgPSBuZXcgV2lkZ2V0Vmlld0Rlc2ModGhpcy50b3AsIHdpZGdldCwgdmlldywgcG9zKTtcbiAgICAgICAgICAgIHRoaXMudG9wLmNoaWxkcmVuLnNwbGljZSh0aGlzLmluZGV4KyssIDAsIGRlc2MpO1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBNYWtlIHN1cmUgYSB0ZXh0YmxvY2sgbG9va3MgYW5kIGJlaGF2ZXMgY29ycmVjdGx5IGluXG4gICAgLy8gY29udGVudEVkaXRhYmxlLlxuICAgIGFkZFRleHRibG9ja0hhY2tzKCkge1xuICAgICAgICBsZXQgbGFzdENoaWxkID0gdGhpcy50b3AuY2hpbGRyZW5bdGhpcy5pbmRleCAtIDFdLCBwYXJlbnQgPSB0aGlzLnRvcDtcbiAgICAgICAgd2hpbGUgKGxhc3RDaGlsZCBpbnN0YW5jZW9mIE1hcmtWaWV3RGVzYykge1xuICAgICAgICAgICAgcGFyZW50ID0gbGFzdENoaWxkO1xuICAgICAgICAgICAgbGFzdENoaWxkID0gcGFyZW50LmNoaWxkcmVuW3BhcmVudC5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWxhc3RDaGlsZCB8fCAvLyBFbXB0eSB0ZXh0YmxvY2tcbiAgICAgICAgICAgICEobGFzdENoaWxkIGluc3RhbmNlb2YgVGV4dFZpZXdEZXNjKSB8fFxuICAgICAgICAgICAgL1xcbiQvLnRlc3QobGFzdENoaWxkLm5vZGUudGV4dCkgfHxcbiAgICAgICAgICAgICh0aGlzLnZpZXcucmVxdWlyZXNHZWNrb0hhY2tOb2RlICYmIC9cXHMkLy50ZXN0KGxhc3RDaGlsZC5ub2RlLnRleHQpKSkge1xuICAgICAgICAgICAgLy8gQXZvaWQgYnVncyBpbiBTYWZhcmkncyBjdXJzb3IgZHJhd2luZyAoIzExNjUpIGFuZCBDaHJvbWUncyBtb3VzZSBzZWxlY3Rpb24gKCMxMTUyKVxuICAgICAgICAgICAgaWYgKChzYWZhcmkgfHwgY2hyb21lKSAmJiBsYXN0Q2hpbGQgJiYgbGFzdENoaWxkLmRvbS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICAgICAgICAgIHRoaXMuYWRkSGFja05vZGUoXCJJTUdcIiwgcGFyZW50KTtcbiAgICAgICAgICAgIHRoaXMuYWRkSGFja05vZGUoXCJCUlwiLCB0aGlzLnRvcCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkSGFja05vZGUobm9kZU5hbWUsIHBhcmVudCkge1xuICAgICAgICBpZiAocGFyZW50ID09IHRoaXMudG9wICYmIHRoaXMuaW5kZXggPCBwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoICYmIHBhcmVudC5jaGlsZHJlblt0aGlzLmluZGV4XS5tYXRjaGVzSGFjayhub2RlTmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5vZGVOYW1lKTtcbiAgICAgICAgICAgIGlmIChub2RlTmFtZSA9PSBcIklNR1wiKSB7XG4gICAgICAgICAgICAgICAgZG9tLmNsYXNzTmFtZSA9IFwiUHJvc2VNaXJyb3Itc2VwYXJhdG9yXCI7XG4gICAgICAgICAgICAgICAgZG9tLmFsdCA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZU5hbWUgPT0gXCJCUlwiKVxuICAgICAgICAgICAgICAgIGRvbS5jbGFzc05hbWUgPSBcIlByb3NlTWlycm9yLXRyYWlsaW5nQnJlYWtcIjtcbiAgICAgICAgICAgIGxldCBoYWNrID0gbmV3IFRyYWlsaW5nSGFja1ZpZXdEZXNjKHRoaXMudG9wLCBbXSwgZG9tLCBudWxsKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQgIT0gdGhpcy50b3ApXG4gICAgICAgICAgICAgICAgcGFyZW50LmNoaWxkcmVuLnB1c2goaGFjayk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcGFyZW50LmNoaWxkcmVuLnNwbGljZSh0aGlzLmluZGV4KyssIDAsIGhhY2spO1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc0xvY2tlZChub2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2sgJiYgKG5vZGUgPT0gdGhpcy5sb2NrIHx8IG5vZGUubm9kZVR5cGUgPT0gMSAmJiBub2RlLmNvbnRhaW5zKHRoaXMubG9jay5wYXJlbnROb2RlKSk7XG4gICAgfVxufVxuLy8gSXRlcmF0ZSBmcm9tIHRoZSBlbmQgb2YgdGhlIGZyYWdtZW50IGFuZCBhcnJheSBvZiBkZXNjcyB0byBmaW5kXG4vLyBkaXJlY3RseSBtYXRjaGluZyBvbmVzLCBpbiBvcmRlciB0byBhdm9pZCBvdmVyZWFnZXJseSByZXVzaW5nIHRob3NlXG4vLyBmb3Igb3RoZXIgbm9kZXMuIFJldHVybnMgdGhlIGZyYWdtZW50IGluZGV4IG9mIHRoZSBmaXJzdCBub2RlIHRoYXRcbi8vIGlzIHBhcnQgb2YgdGhlIHNlcXVlbmNlIG9mIG1hdGNoZWQgbm9kZXMgYXQgdGhlIGVuZCBvZiB0aGVcbi8vIGZyYWdtZW50LlxuZnVuY3Rpb24gcHJlTWF0Y2goZnJhZywgcGFyZW50RGVzYykge1xuICAgIGxldCBjdXJEZXNjID0gcGFyZW50RGVzYywgZGVzY0kgPSBjdXJEZXNjLmNoaWxkcmVuLmxlbmd0aDtcbiAgICBsZXQgZkkgPSBmcmFnLmNoaWxkQ291bnQsIG1hdGNoZWQgPSBuZXcgTWFwLCBtYXRjaGVzID0gW107XG4gICAgb3V0ZXI6IHdoaWxlIChmSSA+IDApIHtcbiAgICAgICAgbGV0IGRlc2M7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmIChkZXNjSSkge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gY3VyRGVzYy5jaGlsZHJlbltkZXNjSSAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0IGluc3RhbmNlb2YgTWFya1ZpZXdEZXNjKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1ckRlc2MgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICBkZXNjSSA9IG5leHQuY2hpbGRyZW4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzYyA9IG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIGRlc2NJLS07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGN1ckRlc2MgPT0gcGFyZW50RGVzYykge1xuICAgICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRklYTUVcbiAgICAgICAgICAgICAgICBkZXNjSSA9IGN1ckRlc2MucGFyZW50LmNoaWxkcmVuLmluZGV4T2YoY3VyRGVzYyk7XG4gICAgICAgICAgICAgICAgY3VyRGVzYyA9IGN1ckRlc2MucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBub2RlID0gZGVzYy5ub2RlO1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKG5vZGUgIT0gZnJhZy5jaGlsZChmSSAtIDEpKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC0tZkk7XG4gICAgICAgIG1hdGNoZWQuc2V0KGRlc2MsIGZJKTtcbiAgICAgICAgbWF0Y2hlcy5wdXNoKGRlc2MpO1xuICAgIH1cbiAgICByZXR1cm4geyBpbmRleDogZkksIG1hdGNoZWQsIG1hdGNoZXM6IG1hdGNoZXMucmV2ZXJzZSgpIH07XG59XG5mdW5jdGlvbiBjb21wYXJlU2lkZShhLCBiKSB7XG4gICAgcmV0dXJuIGEudHlwZS5zaWRlIC0gYi50eXBlLnNpZGU7XG59XG4vLyBUaGlzIGZ1bmN0aW9uIGFic3RyYWN0cyBpdGVyYXRpbmcgb3ZlciB0aGUgbm9kZXMgYW5kIGRlY29yYXRpb25zIGluXG4vLyBhIGZyYWdtZW50LiBDYWxscyBgb25Ob2RlYCBmb3IgZWFjaCBub2RlLCB3aXRoIGl0cyBsb2NhbCBhbmQgY2hpbGRcbi8vIGRlY29yYXRpb25zLiBTcGxpdHMgdGV4dCBub2RlcyB3aGVuIHRoZXJlIGlzIGEgZGVjb3JhdGlvbiBzdGFydGluZ1xuLy8gb3IgZW5kaW5nIGluc2lkZSBvZiB0aGVtLiBDYWxscyBgb25XaWRnZXRgIGZvciBlYWNoIHdpZGdldC5cbmZ1bmN0aW9uIGl0ZXJEZWNvKHBhcmVudCwgZGVjbywgb25XaWRnZXQsIG9uTm9kZSkge1xuICAgIGxldCBsb2NhbHMgPSBkZWNvLmxvY2FscyhwYXJlbnQpLCBvZmZzZXQgPSAwO1xuICAgIC8vIFNpbXBsZSwgY2hlYXAgdmFyaWFudCBmb3Igd2hlbiB0aGVyZSBhcmUgbm8gbG9jYWwgZGVjb3JhdGlvbnNcbiAgICBpZiAobG9jYWxzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyZW50LmNoaWxkQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gcGFyZW50LmNoaWxkKGkpO1xuICAgICAgICAgICAgb25Ob2RlKGNoaWxkLCBsb2NhbHMsIGRlY28uZm9yQ2hpbGQob2Zmc2V0LCBjaGlsZCksIGkpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IGNoaWxkLm5vZGVTaXplO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGRlY29JbmRleCA9IDAsIGFjdGl2ZSA9IFtdLCByZXN0Tm9kZSA9IG51bGw7XG4gICAgZm9yIChsZXQgcGFyZW50SW5kZXggPSAwOzspIHtcbiAgICAgICAgbGV0IHdpZGdldCwgd2lkZ2V0cztcbiAgICAgICAgd2hpbGUgKGRlY29JbmRleCA8IGxvY2Fscy5sZW5ndGggJiYgbG9jYWxzW2RlY29JbmRleF0udG8gPT0gb2Zmc2V0KSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGxvY2Fsc1tkZWNvSW5kZXgrK107XG4gICAgICAgICAgICBpZiAobmV4dC53aWRnZXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXdpZGdldClcbiAgICAgICAgICAgICAgICAgICAgd2lkZ2V0ID0gbmV4dDtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICh3aWRnZXRzIHx8ICh3aWRnZXRzID0gW3dpZGdldF0pKS5wdXNoKG5leHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh3aWRnZXQpIHtcbiAgICAgICAgICAgIGlmICh3aWRnZXRzKSB7XG4gICAgICAgICAgICAgICAgd2lkZ2V0cy5zb3J0KGNvbXBhcmVTaWRlKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdpZGdldHMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgIG9uV2lkZ2V0KHdpZGdldHNbaV0sIHBhcmVudEluZGV4LCAhIXJlc3ROb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9uV2lkZ2V0KHdpZGdldCwgcGFyZW50SW5kZXgsICEhcmVzdE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBjaGlsZCwgaW5kZXg7XG4gICAgICAgIGlmIChyZXN0Tm9kZSkge1xuICAgICAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgICAgICAgIGNoaWxkID0gcmVzdE5vZGU7XG4gICAgICAgICAgICByZXN0Tm9kZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFyZW50SW5kZXggPCBwYXJlbnQuY2hpbGRDb3VudCkge1xuICAgICAgICAgICAgaW5kZXggPSBwYXJlbnRJbmRleDtcbiAgICAgICAgICAgIGNoaWxkID0gcGFyZW50LmNoaWxkKHBhcmVudEluZGV4KyspO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhY3RpdmUubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoYWN0aXZlW2ldLnRvIDw9IG9mZnNldClcbiAgICAgICAgICAgICAgICBhY3RpdmUuc3BsaWNlKGktLSwgMSk7XG4gICAgICAgIHdoaWxlIChkZWNvSW5kZXggPCBsb2NhbHMubGVuZ3RoICYmIGxvY2Fsc1tkZWNvSW5kZXhdLmZyb20gPD0gb2Zmc2V0ICYmIGxvY2Fsc1tkZWNvSW5kZXhdLnRvID4gb2Zmc2V0KVxuICAgICAgICAgICAgYWN0aXZlLnB1c2gobG9jYWxzW2RlY29JbmRleCsrXSk7XG4gICAgICAgIGxldCBlbmQgPSBvZmZzZXQgKyBjaGlsZC5ub2RlU2l6ZTtcbiAgICAgICAgaWYgKGNoaWxkLmlzVGV4dCkge1xuICAgICAgICAgICAgbGV0IGN1dEF0ID0gZW5kO1xuICAgICAgICAgICAgaWYgKGRlY29JbmRleCA8IGxvY2Fscy5sZW5ndGggJiYgbG9jYWxzW2RlY29JbmRleF0uZnJvbSA8IGN1dEF0KVxuICAgICAgICAgICAgICAgIGN1dEF0ID0gbG9jYWxzW2RlY29JbmRleF0uZnJvbTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWN0aXZlLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIGlmIChhY3RpdmVbaV0udG8gPCBjdXRBdClcbiAgICAgICAgICAgICAgICAgICAgY3V0QXQgPSBhY3RpdmVbaV0udG87XG4gICAgICAgICAgICBpZiAoY3V0QXQgPCBlbmQpIHtcbiAgICAgICAgICAgICAgICByZXN0Tm9kZSA9IGNoaWxkLmN1dChjdXRBdCAtIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgY2hpbGQgPSBjaGlsZC5jdXQoMCwgY3V0QXQgLSBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIGVuZCA9IGN1dEF0O1xuICAgICAgICAgICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB3aGlsZSAoZGVjb0luZGV4IDwgbG9jYWxzLmxlbmd0aCAmJiBsb2NhbHNbZGVjb0luZGV4XS50byA8IGVuZClcbiAgICAgICAgICAgICAgICBkZWNvSW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3V0ZXJEZWNvID0gY2hpbGQuaXNJbmxpbmUgJiYgIWNoaWxkLmlzTGVhZiA/IGFjdGl2ZS5maWx0ZXIoZCA9PiAhZC5pbmxpbmUpIDogYWN0aXZlLnNsaWNlKCk7XG4gICAgICAgIG9uTm9kZShjaGlsZCwgb3V0ZXJEZWNvLCBkZWNvLmZvckNoaWxkKG9mZnNldCwgY2hpbGQpLCBpbmRleCk7XG4gICAgICAgIG9mZnNldCA9IGVuZDtcbiAgICB9XG59XG4vLyBMaXN0IG1hcmtlcnMgaW4gTW9iaWxlIFNhZmFyaSB3aWxsIG15c3RlcmlvdXNseSBkaXNhcHBlYXJcbi8vIHNvbWV0aW1lcy4gVGhpcyB3b3JrcyBhcm91bmQgdGhhdC5cbmZ1bmN0aW9uIGlvc0hhY2tzKGRvbSkge1xuICAgIGlmIChkb20ubm9kZU5hbWUgPT0gXCJVTFwiIHx8IGRvbS5ub2RlTmFtZSA9PSBcIk9MXCIpIHtcbiAgICAgICAgbGV0IG9sZENTUyA9IGRvbS5zdHlsZS5jc3NUZXh0O1xuICAgICAgICBkb20uc3R5bGUuY3NzVGV4dCA9IG9sZENTUyArIFwiOyBsaXN0LXN0eWxlOiBzcXVhcmUgIWltcG9ydGFudFwiO1xuICAgICAgICB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb20pLmxpc3RTdHlsZTtcbiAgICAgICAgZG9tLnN0eWxlLmNzc1RleHQgPSBvbGRDU1M7XG4gICAgfVxufVxuLy8gRmluZCBhIHBpZWNlIG9mIHRleHQgaW4gYW4gaW5saW5lIGZyYWdtZW50LCBvdmVybGFwcGluZyBmcm9tLXRvXG5mdW5jdGlvbiBmaW5kVGV4dEluRnJhZ21lbnQoZnJhZywgdGV4dCwgZnJvbSwgdG8pIHtcbiAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gMDsgaSA8IGZyYWcuY2hpbGRDb3VudCAmJiBwb3MgPD0gdG87KSB7XG4gICAgICAgIGxldCBjaGlsZCA9IGZyYWcuY2hpbGQoaSsrKSwgY2hpbGRTdGFydCA9IHBvcztcbiAgICAgICAgcG9zICs9IGNoaWxkLm5vZGVTaXplO1xuICAgICAgICBpZiAoIWNoaWxkLmlzVGV4dClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBsZXQgc3RyID0gY2hpbGQudGV4dDtcbiAgICAgICAgd2hpbGUgKGkgPCBmcmFnLmNoaWxkQ291bnQpIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gZnJhZy5jaGlsZChpKyspO1xuICAgICAgICAgICAgcG9zICs9IG5leHQubm9kZVNpemU7XG4gICAgICAgICAgICBpZiAoIW5leHQuaXNUZXh0KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgc3RyICs9IG5leHQudGV4dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zID49IGZyb20pIHtcbiAgICAgICAgICAgIGlmIChwb3MgPj0gdG8gJiYgc3RyLnNsaWNlKHRvIC0gdGV4dC5sZW5ndGggLSBjaGlsZFN0YXJ0LCB0byAtIGNoaWxkU3RhcnQpID09IHRleHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvIC0gdGV4dC5sZW5ndGg7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBjaGlsZFN0YXJ0IDwgdG8gPyBzdHIubGFzdEluZGV4T2YodGV4dCwgdG8gLSBjaGlsZFN0YXJ0IC0gMSkgOiAtMTtcbiAgICAgICAgICAgIGlmIChmb3VuZCA+PSAwICYmIGZvdW5kICsgdGV4dC5sZW5ndGggKyBjaGlsZFN0YXJ0ID49IGZyb20pXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkU3RhcnQgKyBmb3VuZDtcbiAgICAgICAgICAgIGlmIChmcm9tID09IHRvICYmIHN0ci5sZW5ndGggPj0gKHRvICsgdGV4dC5sZW5ndGgpIC0gY2hpbGRTdGFydCAmJlxuICAgICAgICAgICAgICAgIHN0ci5zbGljZSh0byAtIGNoaWxkU3RhcnQsIHRvIC0gY2hpbGRTdGFydCArIHRleHQubGVuZ3RoKSA9PSB0ZXh0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0bztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG4vLyBSZXBsYWNlIHJhbmdlIGZyb20tdG8gaW4gYW4gYXJyYXkgb2YgdmlldyBkZXNjcyB3aXRoIHJlcGxhY2VtZW50XG4vLyAobWF5IGJlIG51bGwgdG8ganVzdCBkZWxldGUpLiBUaGlzIGdvZXMgdmVyeSBtdWNoIGFnYWluc3QgdGhlIGdyYWluXG4vLyBvZiB0aGUgcmVzdCBvZiB0aGlzIGNvZGUsIHdoaWNoIHRlbmRzIHRvIGNyZWF0ZSBub2RlcyB3aXRoIHRoZVxuLy8gcmlnaHQgc2hhcGUgaW4gb25lIGdvLCByYXRoZXIgdGhhbiBtZXNzaW5nIHdpdGggdGhlbSBhZnRlclxuLy8gY3JlYXRpb24sIGJ1dCBpcyBuZWNlc3NhcnkgaW4gdGhlIGNvbXBvc2l0aW9uIGhhY2suXG5mdW5jdGlvbiByZXBsYWNlTm9kZXMobm9kZXMsIGZyb20sIHRvLCB2aWV3LCByZXBsYWNlbWVudCkge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgb2ZmID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBjaGlsZCA9IG5vZGVzW2ldLCBzdGFydCA9IG9mZiwgZW5kID0gb2ZmICs9IGNoaWxkLnNpemU7XG4gICAgICAgIGlmIChzdGFydCA+PSB0byB8fCBlbmQgPD0gZnJvbSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goY2hpbGQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHN0YXJ0IDwgZnJvbSlcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjaGlsZC5zbGljZSgwLCBmcm9tIC0gc3RhcnQsIHZpZXcpKTtcbiAgICAgICAgICAgIGlmIChyZXBsYWNlbWVudCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHJlcGxhY2VtZW50KTtcbiAgICAgICAgICAgICAgICByZXBsYWNlbWVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbmQgPiB0bylcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjaGlsZC5zbGljZSh0byAtIHN0YXJ0LCBjaGlsZC5zaXplLCB2aWV3KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gc2VsZWN0aW9uRnJvbURPTSh2aWV3LCBvcmlnaW4gPSBudWxsKSB7XG4gICAgbGV0IGRvbVNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKSwgZG9jID0gdmlldy5zdGF0ZS5kb2M7XG4gICAgaWYgKCFkb21TZWwuZm9jdXNOb2RlKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgbmVhcmVzdERlc2MgPSB2aWV3LmRvY1ZpZXcubmVhcmVzdERlc2MoZG9tU2VsLmZvY3VzTm9kZSksIGluV2lkZ2V0ID0gbmVhcmVzdERlc2MgJiYgbmVhcmVzdERlc2Muc2l6ZSA9PSAwO1xuICAgIGxldCBoZWFkID0gdmlldy5kb2NWaWV3LnBvc0Zyb21ET00oZG9tU2VsLmZvY3VzTm9kZSwgZG9tU2VsLmZvY3VzT2Zmc2V0LCAxKTtcbiAgICBpZiAoaGVhZCA8IDApXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCAkaGVhZCA9IGRvYy5yZXNvbHZlKGhlYWQpLCBhbmNob3IsIHNlbGVjdGlvbjtcbiAgICBpZiAoc2VsZWN0aW9uQ29sbGFwc2VkKGRvbVNlbCkpIHtcbiAgICAgICAgYW5jaG9yID0gaGVhZDtcbiAgICAgICAgd2hpbGUgKG5lYXJlc3REZXNjICYmICFuZWFyZXN0RGVzYy5ub2RlKVxuICAgICAgICAgICAgbmVhcmVzdERlc2MgPSBuZWFyZXN0RGVzYy5wYXJlbnQ7XG4gICAgICAgIGxldCBuZWFyZXN0RGVzY05vZGUgPSBuZWFyZXN0RGVzYy5ub2RlO1xuICAgICAgICBpZiAobmVhcmVzdERlc2MgJiYgbmVhcmVzdERlc2NOb2RlLmlzQXRvbSAmJiBOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShuZWFyZXN0RGVzY05vZGUpICYmIG5lYXJlc3REZXNjLnBhcmVudFxuICAgICAgICAgICAgJiYgIShuZWFyZXN0RGVzY05vZGUuaXNJbmxpbmUgJiYgaXNPbkVkZ2UoZG9tU2VsLmZvY3VzTm9kZSwgZG9tU2VsLmZvY3VzT2Zmc2V0LCBuZWFyZXN0RGVzYy5kb20pKSkge1xuICAgICAgICAgICAgbGV0IHBvcyA9IG5lYXJlc3REZXNjLnBvc0JlZm9yZTtcbiAgICAgICAgICAgIHNlbGVjdGlvbiA9IG5ldyBOb2RlU2VsZWN0aW9uKGhlYWQgPT0gcG9zID8gJGhlYWQgOiBkb2MucmVzb2x2ZShwb3MpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGRvbVNlbCBpbnN0YW5jZW9mIHZpZXcuZG9tLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuU2VsZWN0aW9uICYmIGRvbVNlbC5yYW5nZUNvdW50ID4gMSkge1xuICAgICAgICAgICAgbGV0IG1pbiA9IGhlYWQsIG1heCA9IGhlYWQ7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRvbVNlbC5yYW5nZUNvdW50OyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgcmFuZ2UgPSBkb21TZWwuZ2V0UmFuZ2VBdChpKTtcbiAgICAgICAgICAgICAgICBtaW4gPSBNYXRoLm1pbihtaW4sIHZpZXcuZG9jVmlldy5wb3NGcm9tRE9NKHJhbmdlLnN0YXJ0Q29udGFpbmVyLCByYW5nZS5zdGFydE9mZnNldCwgMSkpO1xuICAgICAgICAgICAgICAgIG1heCA9IE1hdGgubWF4KG1heCwgdmlldy5kb2NWaWV3LnBvc0Zyb21ET00ocmFuZ2UuZW5kQ29udGFpbmVyLCByYW5nZS5lbmRPZmZzZXQsIC0xKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWluIDwgMClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIFthbmNob3IsIGhlYWRdID0gbWF4ID09IHZpZXcuc3RhdGUuc2VsZWN0aW9uLmFuY2hvciA/IFttYXgsIG1pbl0gOiBbbWluLCBtYXhdO1xuICAgICAgICAgICAgJGhlYWQgPSBkb2MucmVzb2x2ZShoZWFkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFuY2hvciA9IHZpZXcuZG9jVmlldy5wb3NGcm9tRE9NKGRvbVNlbC5hbmNob3JOb2RlLCBkb21TZWwuYW5jaG9yT2Zmc2V0LCAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5jaG9yIDwgMClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsZXQgJGFuY2hvciA9IGRvYy5yZXNvbHZlKGFuY2hvcik7XG4gICAgaWYgKCFzZWxlY3Rpb24pIHtcbiAgICAgICAgbGV0IGJpYXMgPSBvcmlnaW4gPT0gXCJwb2ludGVyXCIgfHwgKHZpZXcuc3RhdGUuc2VsZWN0aW9uLmhlYWQgPCAkaGVhZC5wb3MgJiYgIWluV2lkZ2V0KSA/IDEgOiAtMTtcbiAgICAgICAgc2VsZWN0aW9uID0gc2VsZWN0aW9uQmV0d2Vlbih2aWV3LCAkYW5jaG9yLCAkaGVhZCwgYmlhcyk7XG4gICAgfVxuICAgIHJldHVybiBzZWxlY3Rpb247XG59XG5mdW5jdGlvbiBlZGl0b3JPd25zU2VsZWN0aW9uKHZpZXcpIHtcbiAgICByZXR1cm4gdmlldy5lZGl0YWJsZSA/IHZpZXcuaGFzRm9jdXMoKSA6XG4gICAgICAgIGhhc1NlbGVjdGlvbih2aWV3KSAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQuY29udGFpbnModmlldy5kb20pO1xufVxuZnVuY3Rpb24gc2VsZWN0aW9uVG9ET00odmlldywgZm9yY2UgPSBmYWxzZSkge1xuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICBzeW5jTm9kZVNlbGVjdGlvbih2aWV3LCBzZWwpO1xuICAgIGlmICghZWRpdG9yT3duc1NlbGVjdGlvbih2aWV3KSlcbiAgICAgICAgcmV0dXJuO1xuICAgIC8vIFRoZSBkZWxheWVkIGRyYWcgc2VsZWN0aW9uIGNhdXNlcyBpc3N1ZXMgd2l0aCBDZWxsIFNlbGVjdGlvbnNcbiAgICAvLyBpbiBTYWZhcmkuIEFuZCB0aGUgZHJhZyBzZWxlY3Rpb24gZGVsYXkgaXMgdG8gd29ya2Fyb25kIGlzc3Vlc1xuICAgIC8vIHdoaWNoIG9ubHkgcHJlc2VudCBpbiBDaHJvbWUuXG4gICAgaWYgKCFmb3JjZSAmJiB2aWV3LmlucHV0Lm1vdXNlRG93biAmJiB2aWV3LmlucHV0Lm1vdXNlRG93bi5hbGxvd0RlZmF1bHQgJiYgY2hyb21lKSB7XG4gICAgICAgIGxldCBkb21TZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCksIGN1clNlbCA9IHZpZXcuZG9tT2JzZXJ2ZXIuY3VycmVudFNlbGVjdGlvbjtcbiAgICAgICAgaWYgKGRvbVNlbC5hbmNob3JOb2RlICYmIGN1clNlbC5hbmNob3JOb2RlICYmXG4gICAgICAgICAgICBpc0VxdWl2YWxlbnRQb3NpdGlvbihkb21TZWwuYW5jaG9yTm9kZSwgZG9tU2VsLmFuY2hvck9mZnNldCwgY3VyU2VsLmFuY2hvck5vZGUsIGN1clNlbC5hbmNob3JPZmZzZXQpKSB7XG4gICAgICAgICAgICB2aWV3LmlucHV0Lm1vdXNlRG93bi5kZWxheWVkU2VsZWN0aW9uU3luYyA9IHRydWU7XG4gICAgICAgICAgICB2aWV3LmRvbU9ic2VydmVyLnNldEN1clNlbGVjdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZpZXcuZG9tT2JzZXJ2ZXIuZGlzY29ubmVjdFNlbGVjdGlvbigpO1xuICAgIGlmICh2aWV3LmN1cnNvcldyYXBwZXIpIHtcbiAgICAgICAgc2VsZWN0Q3Vyc29yV3JhcHBlcih2aWV3KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCB7IGFuY2hvciwgaGVhZCB9ID0gc2VsLCByZXNldEVkaXRhYmxlRnJvbSwgcmVzZXRFZGl0YWJsZVRvO1xuICAgICAgICBpZiAoYnJva2VuU2VsZWN0QmV0d2VlblVuZWRpdGFibGUgJiYgIShzZWwgaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgaWYgKCFzZWwuJGZyb20ucGFyZW50LmlubGluZUNvbnRlbnQpXG4gICAgICAgICAgICAgICAgcmVzZXRFZGl0YWJsZUZyb20gPSB0ZW1wb3JhcmlseUVkaXRhYmxlTmVhcih2aWV3LCBzZWwuZnJvbSk7XG4gICAgICAgICAgICBpZiAoIXNlbC5lbXB0eSAmJiAhc2VsLiRmcm9tLnBhcmVudC5pbmxpbmVDb250ZW50KVxuICAgICAgICAgICAgICAgIHJlc2V0RWRpdGFibGVUbyA9IHRlbXBvcmFyaWx5RWRpdGFibGVOZWFyKHZpZXcsIHNlbC50byk7XG4gICAgICAgIH1cbiAgICAgICAgdmlldy5kb2NWaWV3LnNldFNlbGVjdGlvbihhbmNob3IsIGhlYWQsIHZpZXcsIGZvcmNlKTtcbiAgICAgICAgaWYgKGJyb2tlblNlbGVjdEJldHdlZW5VbmVkaXRhYmxlKSB7XG4gICAgICAgICAgICBpZiAocmVzZXRFZGl0YWJsZUZyb20pXG4gICAgICAgICAgICAgICAgcmVzZXRFZGl0YWJsZShyZXNldEVkaXRhYmxlRnJvbSk7XG4gICAgICAgICAgICBpZiAocmVzZXRFZGl0YWJsZVRvKVxuICAgICAgICAgICAgICAgIHJlc2V0RWRpdGFibGUocmVzZXRFZGl0YWJsZVRvKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsLnZpc2libGUpIHtcbiAgICAgICAgICAgIHZpZXcuZG9tLmNsYXNzTGlzdC5yZW1vdmUoXCJQcm9zZU1pcnJvci1oaWRlc2VsZWN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmlldy5kb20uY2xhc3NMaXN0LmFkZChcIlByb3NlTWlycm9yLWhpZGVzZWxlY3Rpb25cIik7XG4gICAgICAgICAgICBpZiAoXCJvbnNlbGVjdGlvbmNoYW5nZVwiIGluIGRvY3VtZW50KVxuICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzT25TZWxlY3Rpb25DaGFuZ2Uodmlldyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmlldy5kb21PYnNlcnZlci5zZXRDdXJTZWxlY3Rpb24oKTtcbiAgICB2aWV3LmRvbU9ic2VydmVyLmNvbm5lY3RTZWxlY3Rpb24oKTtcbn1cbi8vIEtsdWRnZSB0byB3b3JrIGFyb3VuZCBXZWJraXQgbm90IGFsbG93aW5nIGEgc2VsZWN0aW9uIHRvIHN0YXJ0L2VuZFxuLy8gYmV0d2VlbiBub24tZWRpdGFibGUgYmxvY2sgbm9kZXMuIFdlIGJyaWVmbHkgbWFrZSBzb21ldGhpbmdcbi8vIGVkaXRhYmxlLCBzZXQgdGhlIHNlbGVjdGlvbiwgdGhlbiBzZXQgaXQgdW5lZGl0YWJsZSBhZ2Fpbi5cbmNvbnN0IGJyb2tlblNlbGVjdEJldHdlZW5VbmVkaXRhYmxlID0gc2FmYXJpIHx8IGNocm9tZSAmJiBjaHJvbWVfdmVyc2lvbiA8IDYzO1xuZnVuY3Rpb24gdGVtcG9yYXJpbHlFZGl0YWJsZU5lYXIodmlldywgcG9zKSB7XG4gICAgbGV0IHsgbm9kZSwgb2Zmc2V0IH0gPSB2aWV3LmRvY1ZpZXcuZG9tRnJvbVBvcyhwb3MsIDApO1xuICAgIGxldCBhZnRlciA9IG9mZnNldCA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPyBub2RlLmNoaWxkTm9kZXNbb2Zmc2V0XSA6IG51bGw7XG4gICAgbGV0IGJlZm9yZSA9IG9mZnNldCA/IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXSA6IG51bGw7XG4gICAgaWYgKHNhZmFyaSAmJiBhZnRlciAmJiBhZnRlci5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICByZXR1cm4gc2V0RWRpdGFibGUoYWZ0ZXIpO1xuICAgIGlmICgoIWFmdGVyIHx8IGFmdGVyLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpICYmXG4gICAgICAgICghYmVmb3JlIHx8IGJlZm9yZS5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKSkge1xuICAgICAgICBpZiAoYWZ0ZXIpXG4gICAgICAgICAgICByZXR1cm4gc2V0RWRpdGFibGUoYWZ0ZXIpO1xuICAgICAgICBlbHNlIGlmIChiZWZvcmUpXG4gICAgICAgICAgICByZXR1cm4gc2V0RWRpdGFibGUoYmVmb3JlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRFZGl0YWJsZShlbGVtZW50KSB7XG4gICAgZWxlbWVudC5jb250ZW50RWRpdGFibGUgPSBcInRydWVcIjtcbiAgICBpZiAoc2FmYXJpICYmIGVsZW1lbnQuZHJhZ2dhYmxlKSB7XG4gICAgICAgIGVsZW1lbnQuZHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgICAgIGVsZW1lbnQud2FzRHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG59XG5mdW5jdGlvbiByZXNldEVkaXRhYmxlKGVsZW1lbnQpIHtcbiAgICBlbGVtZW50LmNvbnRlbnRFZGl0YWJsZSA9IFwiZmFsc2VcIjtcbiAgICBpZiAoZWxlbWVudC53YXNEcmFnZ2FibGUpIHtcbiAgICAgICAgZWxlbWVudC5kcmFnZ2FibGUgPSB0cnVlO1xuICAgICAgICBlbGVtZW50Lndhc0RyYWdnYWJsZSA9IG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlQ2xhc3NPblNlbGVjdGlvbkNoYW5nZSh2aWV3KSB7XG4gICAgbGV0IGRvYyA9IHZpZXcuZG9tLm93bmVyRG9jdW1lbnQ7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdmlldy5pbnB1dC5oaWRlU2VsZWN0aW9uR3VhcmQpO1xuICAgIGxldCBkb21TZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgbGV0IG5vZGUgPSBkb21TZWwuYW5jaG9yTm9kZSwgb2Zmc2V0ID0gZG9tU2VsLmFuY2hvck9mZnNldDtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcihcInNlbGVjdGlvbmNoYW5nZVwiLCB2aWV3LmlucHV0LmhpZGVTZWxlY3Rpb25HdWFyZCA9ICgpID0+IHtcbiAgICAgICAgaWYgKGRvbVNlbC5hbmNob3JOb2RlICE9IG5vZGUgfHwgZG9tU2VsLmFuY2hvck9mZnNldCAhPSBvZmZzZXQpIHtcbiAgICAgICAgICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKFwic2VsZWN0aW9uY2hhbmdlXCIsIHZpZXcuaW5wdXQuaGlkZVNlbGVjdGlvbkd1YXJkKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghZWRpdG9yT3duc1NlbGVjdGlvbih2aWV3KSB8fCB2aWV3LnN0YXRlLnNlbGVjdGlvbi52aXNpYmxlKVxuICAgICAgICAgICAgICAgICAgICB2aWV3LmRvbS5jbGFzc0xpc3QucmVtb3ZlKFwiUHJvc2VNaXJyb3ItaGlkZXNlbGVjdGlvblwiKTtcbiAgICAgICAgICAgIH0sIDIwKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gc2VsZWN0Q3Vyc29yV3JhcHBlcih2aWV3KSB7XG4gICAgbGV0IGRvbVNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uKCk7XG4gICAgaWYgKCFkb21TZWwpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgbm9kZSA9IHZpZXcuY3Vyc29yV3JhcHBlci5kb20sIGltZyA9IG5vZGUubm9kZU5hbWUgPT0gXCJJTUdcIjtcbiAgICBpZiAoaW1nKVxuICAgICAgICBkb21TZWwuY29sbGFwc2Uobm9kZS5wYXJlbnROb2RlLCBkb21JbmRleChub2RlKSArIDEpO1xuICAgIGVsc2VcbiAgICAgICAgZG9tU2VsLmNvbGxhcHNlKG5vZGUsIDApO1xuICAgIC8vIEtsdWRnZSB0byBraWxsICdjb250cm9sIHNlbGVjdGlvbicgaW4gSUUxMSB3aGVuIHNlbGVjdGluZyBhblxuICAgIC8vIGludmlzaWJsZSBjdXJzb3Igd3JhcHBlciwgc2luY2UgdGhhdCB3b3VsZCByZXN1bHQgaW4gdGhvc2Ugd2VpcmRcbiAgICAvLyByZXNpemUgaGFuZGxlcyBhbmQgYSBzZWxlY3Rpb24gdGhhdCBjb25zaWRlcnMgdGhlIGFic29sdXRlbHlcbiAgICAvLyBwb3NpdGlvbmVkIHdyYXBwZXIsIHJhdGhlciB0aGFuIHRoZSByb290IGVkaXRhYmxlIG5vZGUsIHRoZVxuICAgIC8vIGZvY3VzZWQgZWxlbWVudC5cbiAgICBpZiAoIWltZyAmJiAhdmlldy5zdGF0ZS5zZWxlY3Rpb24udmlzaWJsZSAmJiBpZSAmJiBpZV92ZXJzaW9uIDw9IDExKSB7XG4gICAgICAgIG5vZGUuZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICBub2RlLmRpc2FibGVkID0gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gc3luY05vZGVTZWxlY3Rpb24odmlldywgc2VsKSB7XG4gICAgaWYgKHNlbCBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24pIHtcbiAgICAgICAgbGV0IGRlc2MgPSB2aWV3LmRvY1ZpZXcuZGVzY0F0KHNlbC5mcm9tKTtcbiAgICAgICAgaWYgKGRlc2MgIT0gdmlldy5sYXN0U2VsZWN0ZWRWaWV3RGVzYykge1xuICAgICAgICAgICAgY2xlYXJOb2RlU2VsZWN0aW9uKHZpZXcpO1xuICAgICAgICAgICAgaWYgKGRlc2MpXG4gICAgICAgICAgICAgICAgZGVzYy5zZWxlY3ROb2RlKCk7XG4gICAgICAgICAgICB2aWV3Lmxhc3RTZWxlY3RlZFZpZXdEZXNjID0gZGVzYztcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2xlYXJOb2RlU2VsZWN0aW9uKHZpZXcpO1xuICAgIH1cbn1cbi8vIENsZWFyIGFsbCBET00gc3RhdGVmdWxuZXNzIG9mIHRoZSBsYXN0IG5vZGUgc2VsZWN0aW9uLlxuZnVuY3Rpb24gY2xlYXJOb2RlU2VsZWN0aW9uKHZpZXcpIHtcbiAgICBpZiAodmlldy5sYXN0U2VsZWN0ZWRWaWV3RGVzYykge1xuICAgICAgICBpZiAodmlldy5sYXN0U2VsZWN0ZWRWaWV3RGVzYy5wYXJlbnQpXG4gICAgICAgICAgICB2aWV3Lmxhc3RTZWxlY3RlZFZpZXdEZXNjLmRlc2VsZWN0Tm9kZSgpO1xuICAgICAgICB2aWV3Lmxhc3RTZWxlY3RlZFZpZXdEZXNjID0gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNlbGVjdGlvbkJldHdlZW4odmlldywgJGFuY2hvciwgJGhlYWQsIGJpYXMpIHtcbiAgICByZXR1cm4gdmlldy5zb21lUHJvcChcImNyZWF0ZVNlbGVjdGlvbkJldHdlZW5cIiwgZiA9PiBmKHZpZXcsICRhbmNob3IsICRoZWFkKSlcbiAgICAgICAgfHwgVGV4dFNlbGVjdGlvbi5iZXR3ZWVuKCRhbmNob3IsICRoZWFkLCBiaWFzKTtcbn1cbmZ1bmN0aW9uIGhhc0ZvY3VzQW5kU2VsZWN0aW9uKHZpZXcpIHtcbiAgICBpZiAodmlldy5lZGl0YWJsZSAmJiAhdmlldy5oYXNGb2N1cygpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIGhhc1NlbGVjdGlvbih2aWV3KTtcbn1cbmZ1bmN0aW9uIGhhc1NlbGVjdGlvbih2aWV3KSB7XG4gICAgbGV0IHNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICBpZiAoIXNlbC5hbmNob3JOb2RlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gRmlyZWZveCB3aWxsIHJhaXNlICdwZXJtaXNzaW9uIGRlbmllZCcgZXJyb3JzIHdoZW4gYWNjZXNzaW5nXG4gICAgICAgIC8vIHByb3BlcnRpZXMgb2YgYHNlbC5hbmNob3JOb2RlYCB3aGVuIGl0J3MgaW4gYSBnZW5lcmF0ZWQgQ1NTXG4gICAgICAgIC8vIGVsZW1lbnQuXG4gICAgICAgIHJldHVybiB2aWV3LmRvbS5jb250YWlucyhzZWwuYW5jaG9yTm9kZS5ub2RlVHlwZSA9PSAzID8gc2VsLmFuY2hvck5vZGUucGFyZW50Tm9kZSA6IHNlbC5hbmNob3JOb2RlKSAmJlxuICAgICAgICAgICAgKHZpZXcuZWRpdGFibGUgfHwgdmlldy5kb20uY29udGFpbnMoc2VsLmZvY3VzTm9kZS5ub2RlVHlwZSA9PSAzID8gc2VsLmZvY3VzTm9kZS5wYXJlbnROb2RlIDogc2VsLmZvY3VzTm9kZSkpO1xuICAgIH1cbiAgICBjYXRjaCAoXykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gYW5jaG9ySW5SaWdodFBsYWNlKHZpZXcpIHtcbiAgICBsZXQgYW5jaG9yRE9NID0gdmlldy5kb2NWaWV3LmRvbUZyb21Qb3Modmlldy5zdGF0ZS5zZWxlY3Rpb24uYW5jaG9yLCAwKTtcbiAgICBsZXQgZG9tU2VsID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgIHJldHVybiBpc0VxdWl2YWxlbnRQb3NpdGlvbihhbmNob3JET00ubm9kZSwgYW5jaG9yRE9NLm9mZnNldCwgZG9tU2VsLmFuY2hvck5vZGUsIGRvbVNlbC5hbmNob3JPZmZzZXQpO1xufVxuXG5mdW5jdGlvbiBtb3ZlU2VsZWN0aW9uQmxvY2soc3RhdGUsIGRpcikge1xuICAgIGxldCB7ICRhbmNob3IsICRoZWFkIH0gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgbGV0ICRzaWRlID0gZGlyID4gMCA/ICRhbmNob3IubWF4KCRoZWFkKSA6ICRhbmNob3IubWluKCRoZWFkKTtcbiAgICBsZXQgJHN0YXJ0ID0gISRzaWRlLnBhcmVudC5pbmxpbmVDb250ZW50ID8gJHNpZGUgOiAkc2lkZS5kZXB0aCA/IHN0YXRlLmRvYy5yZXNvbHZlKGRpciA+IDAgPyAkc2lkZS5hZnRlcigpIDogJHNpZGUuYmVmb3JlKCkpIDogbnVsbDtcbiAgICByZXR1cm4gJHN0YXJ0ICYmIFNlbGVjdGlvbi5maW5kRnJvbSgkc3RhcnQsIGRpcik7XG59XG5mdW5jdGlvbiBhcHBseSh2aWV3LCBzZWwpIHtcbiAgICB2aWV3LmRpc3BhdGNoKHZpZXcuc3RhdGUudHIuc2V0U2VsZWN0aW9uKHNlbCkuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBzZWxlY3RIb3Jpem9udGFsbHkodmlldywgZGlyLCBtb2RzKSB7XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIGlmIChzZWwgaW5zdGFuY2VvZiBUZXh0U2VsZWN0aW9uKSB7XG4gICAgICAgIGlmIChtb2RzLmluZGV4T2YoXCJzXCIpID4gLTEpIHtcbiAgICAgICAgICAgIGxldCB7ICRoZWFkIH0gPSBzZWwsIG5vZGUgPSAkaGVhZC50ZXh0T2Zmc2V0ID8gbnVsbCA6IGRpciA8IDAgPyAkaGVhZC5ub2RlQmVmb3JlIDogJGhlYWQubm9kZUFmdGVyO1xuICAgICAgICAgICAgaWYgKCFub2RlIHx8IG5vZGUuaXNUZXh0IHx8ICFub2RlLmlzTGVhZilcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBsZXQgJG5ld0hlYWQgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKCRoZWFkLnBvcyArIG5vZGUubm9kZVNpemUgKiAoZGlyIDwgMCA/IC0xIDogMSkpO1xuICAgICAgICAgICAgcmV0dXJuIGFwcGx5KHZpZXcsIG5ldyBUZXh0U2VsZWN0aW9uKHNlbC4kYW5jaG9yLCAkbmV3SGVhZCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFzZWwuZW1wdHkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2aWV3LmVuZE9mVGV4dGJsb2NrKGRpciA+IDAgPyBcImZvcndhcmRcIiA6IFwiYmFja3dhcmRcIikpIHtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gbW92ZVNlbGVjdGlvbkJsb2NrKHZpZXcuc3RhdGUsIGRpcik7XG4gICAgICAgICAgICBpZiAobmV4dCAmJiAobmV4dCBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24pKVxuICAgICAgICAgICAgICAgIHJldHVybiBhcHBseSh2aWV3LCBuZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghKG1hYyAmJiBtb2RzLmluZGV4T2YoXCJtXCIpID4gLTEpKSB7XG4gICAgICAgICAgICBsZXQgJGhlYWQgPSBzZWwuJGhlYWQsIG5vZGUgPSAkaGVhZC50ZXh0T2Zmc2V0ID8gbnVsbCA6IGRpciA8IDAgPyAkaGVhZC5ub2RlQmVmb3JlIDogJGhlYWQubm9kZUFmdGVyLCBkZXNjO1xuICAgICAgICAgICAgaWYgKCFub2RlIHx8IG5vZGUuaXNUZXh0KVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGxldCBub2RlUG9zID0gZGlyIDwgMCA/ICRoZWFkLnBvcyAtIG5vZGUubm9kZVNpemUgOiAkaGVhZC5wb3M7XG4gICAgICAgICAgICBpZiAoIShub2RlLmlzQXRvbSB8fCAoZGVzYyA9IHZpZXcuZG9jVmlldy5kZXNjQXQobm9kZVBvcykpICYmICFkZXNjLmNvbnRlbnRET00pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChOb2RlU2VsZWN0aW9uLmlzU2VsZWN0YWJsZShub2RlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcHBseSh2aWV3LCBuZXcgTm9kZVNlbGVjdGlvbihkaXIgPCAwID8gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZSgkaGVhZC5wb3MgLSBub2RlLm5vZGVTaXplKSA6ICRoZWFkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh3ZWJraXQpIHtcbiAgICAgICAgICAgICAgICAvLyBDaHJvbWUgYW5kIFNhZmFyaSB3aWxsIGludHJvZHVjZSBleHRyYSBwb2ludGxlc3MgY3Vyc29yXG4gICAgICAgICAgICAgICAgLy8gcG9zaXRpb25zIGFyb3VuZCBpbmxpbmUgdW5lZGl0YWJsZSBub2Rlcywgc28gd2UgaGF2ZSB0b1xuICAgICAgICAgICAgICAgIC8vIHRha2Ugb3ZlciBhbmQgbW92ZSB0aGUgY3Vyc29yIHBhc3QgdGhlbSAoIzkzNylcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwbHkodmlldywgbmV3IFRleHRTZWxlY3Rpb24odmlldy5zdGF0ZS5kb2MucmVzb2x2ZShkaXIgPCAwID8gbm9kZVBvcyA6IG5vZGVQb3MgKyBub2RlLm5vZGVTaXplKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHNlbCBpbnN0YW5jZW9mIE5vZGVTZWxlY3Rpb24gJiYgc2VsLm5vZGUuaXNJbmxpbmUpIHtcbiAgICAgICAgcmV0dXJuIGFwcGx5KHZpZXcsIG5ldyBUZXh0U2VsZWN0aW9uKGRpciA+IDAgPyBzZWwuJHRvIDogc2VsLiRmcm9tKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsZXQgbmV4dCA9IG1vdmVTZWxlY3Rpb25CbG9jayh2aWV3LnN0YXRlLCBkaXIpO1xuICAgICAgICBpZiAobmV4dClcbiAgICAgICAgICAgIHJldHVybiBhcHBseSh2aWV3LCBuZXh0KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5vZGVMZW4obm9kZSkge1xuICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09IDMgPyBub2RlLm5vZGVWYWx1ZS5sZW5ndGggOiBub2RlLmNoaWxkTm9kZXMubGVuZ3RoO1xufVxuZnVuY3Rpb24gaXNJZ25vcmFibGUoZG9tLCBkaXIpIHtcbiAgICBsZXQgZGVzYyA9IGRvbS5wbVZpZXdEZXNjO1xuICAgIHJldHVybiBkZXNjICYmIGRlc2Muc2l6ZSA9PSAwICYmIChkaXIgPCAwIHx8IGRvbS5uZXh0U2libGluZyB8fCBkb20ubm9kZU5hbWUgIT0gXCJCUlwiKTtcbn1cbmZ1bmN0aW9uIHNraXBJZ25vcmVkTm9kZXModmlldywgZGlyKSB7XG4gICAgcmV0dXJuIGRpciA8IDAgPyBza2lwSWdub3JlZE5vZGVzQmVmb3JlKHZpZXcpIDogc2tpcElnbm9yZWROb2Rlc0FmdGVyKHZpZXcpO1xufVxuLy8gTWFrZSBzdXJlIHRoZSBjdXJzb3IgaXNuJ3QgZGlyZWN0bHkgYWZ0ZXIgb25lIG9yIG1vcmUgaWdub3JlZFxuLy8gbm9kZXMsIHdoaWNoIHdpbGwgY29uZnVzZSB0aGUgYnJvd3NlcidzIGN1cnNvciBtb3Rpb24gbG9naWMuXG5mdW5jdGlvbiBza2lwSWdub3JlZE5vZGVzQmVmb3JlKHZpZXcpIHtcbiAgICBsZXQgc2VsID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgIGxldCBub2RlID0gc2VsLmZvY3VzTm9kZSwgb2Zmc2V0ID0gc2VsLmZvY3VzT2Zmc2V0O1xuICAgIGlmICghbm9kZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBtb3ZlTm9kZSwgbW92ZU9mZnNldCwgZm9yY2UgPSBmYWxzZTtcbiAgICAvLyBHZWNrbyB3aWxsIGRvIG9kZCB0aGluZ3Mgd2hlbiB0aGUgc2VsZWN0aW9uIGlzIGRpcmVjdGx5IGluIGZyb250XG4gICAgLy8gb2YgYSBub24tZWRpdGFibGUgbm9kZSwgc28gaW4gdGhhdCBjYXNlLCBtb3ZlIGl0IGludG8gdGhlIG5leHRcbiAgICAvLyBub2RlIGlmIHBvc3NpYmxlLiBJc3N1ZSBwcm9zZW1pcnJvci9wcm9zZW1pcnJvciM4MzIuXG4gICAgaWYgKGdlY2tvICYmIG5vZGUubm9kZVR5cGUgPT0gMSAmJiBvZmZzZXQgPCBub2RlTGVuKG5vZGUpICYmIGlzSWdub3JhYmxlKG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdLCAtMSkpXG4gICAgICAgIGZvcmNlID0gdHJ1ZTtcbiAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChvZmZzZXQgPiAwKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSAhPSAxKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgYmVmb3JlID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChpc0lnbm9yYWJsZShiZWZvcmUsIC0xKSkge1xuICAgICAgICAgICAgICAgICAgICBtb3ZlTm9kZSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVPZmZzZXQgPSAtLW9mZnNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYmVmb3JlLm5vZGVUeXBlID09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGJlZm9yZTtcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gbm9kZS5ub2RlVmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQmxvY2tOb2RlKG5vZGUpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBwcmV2ID0gbm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICB3aGlsZSAocHJldiAmJiBpc0lnbm9yYWJsZShwcmV2LCAtMSkpIHtcbiAgICAgICAgICAgICAgICBtb3ZlTm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICBtb3ZlT2Zmc2V0ID0gZG9tSW5kZXgocHJldik7XG4gICAgICAgICAgICAgICAgcHJldiA9IHByZXYucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFwcmV2KSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSA9PSB2aWV3LmRvbSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBwcmV2O1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IG5vZGVMZW4obm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZvcmNlKVxuICAgICAgICBzZXRTZWxGb2N1cyh2aWV3LCBub2RlLCBvZmZzZXQpO1xuICAgIGVsc2UgaWYgKG1vdmVOb2RlKVxuICAgICAgICBzZXRTZWxGb2N1cyh2aWV3LCBtb3ZlTm9kZSwgbW92ZU9mZnNldCk7XG59XG4vLyBNYWtlIHN1cmUgdGhlIGN1cnNvciBpc24ndCBkaXJlY3RseSBiZWZvcmUgb25lIG9yIG1vcmUgaWdub3JlZFxuLy8gbm9kZXMuXG5mdW5jdGlvbiBza2lwSWdub3JlZE5vZGVzQWZ0ZXIodmlldykge1xuICAgIGxldCBzZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgbGV0IG5vZGUgPSBzZWwuZm9jdXNOb2RlLCBvZmZzZXQgPSBzZWwuZm9jdXNPZmZzZXQ7XG4gICAgaWYgKCFub2RlKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IGxlbiA9IG5vZGVMZW4obm9kZSk7XG4gICAgbGV0IG1vdmVOb2RlLCBtb3ZlT2Zmc2V0O1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKG9mZnNldCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgIT0gMSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCBhZnRlciA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgICAgICAgaWYgKGlzSWdub3JhYmxlKGFmdGVyLCAxKSkge1xuICAgICAgICAgICAgICAgIG1vdmVOb2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICBtb3ZlT2Zmc2V0ID0gKytvZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNCbG9ja05vZGUobm9kZSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG5leHQgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgd2hpbGUgKG5leHQgJiYgaXNJZ25vcmFibGUobmV4dCwgMSkpIHtcbiAgICAgICAgICAgICAgICBtb3ZlTm9kZSA9IG5leHQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICBtb3ZlT2Zmc2V0ID0gZG9tSW5kZXgobmV4dCkgKyAxO1xuICAgICAgICAgICAgICAgIG5leHQgPSBuZXh0Lm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFuZXh0KSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSA9PSB2aWV3LmRvbSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gbGVuID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBuZXh0O1xuICAgICAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgICAgICAgICAgbGVuID0gbm9kZUxlbihub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAobW92ZU5vZGUpXG4gICAgICAgIHNldFNlbEZvY3VzKHZpZXcsIG1vdmVOb2RlLCBtb3ZlT2Zmc2V0KTtcbn1cbmZ1bmN0aW9uIGlzQmxvY2tOb2RlKGRvbSkge1xuICAgIGxldCBkZXNjID0gZG9tLnBtVmlld0Rlc2M7XG4gICAgcmV0dXJuIGRlc2MgJiYgZGVzYy5ub2RlICYmIGRlc2Mubm9kZS5pc0Jsb2NrO1xufVxuZnVuY3Rpb24gdGV4dE5vZGVBZnRlcihub2RlLCBvZmZzZXQpIHtcbiAgICB3aGlsZSAobm9kZSAmJiBvZmZzZXQgPT0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCAmJiAhaGFzQmxvY2tEZXNjKG5vZGUpKSB7XG4gICAgICAgIG9mZnNldCA9IGRvbUluZGV4KG5vZGUpICsgMTtcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgd2hpbGUgKG5vZGUgJiYgb2Zmc2V0IDwgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgICBsZXQgbmV4dCA9IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgICBpZiAobmV4dC5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIGlmIChuZXh0Lm5vZGVUeXBlID09IDEgJiYgbmV4dC5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIG5vZGUgPSBuZXh0O1xuICAgICAgICBvZmZzZXQgPSAwO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRleHROb2RlQmVmb3JlKG5vZGUsIG9mZnNldCkge1xuICAgIHdoaWxlIChub2RlICYmICFvZmZzZXQgJiYgIWhhc0Jsb2NrRGVzYyhub2RlKSkge1xuICAgICAgICBvZmZzZXQgPSBkb21JbmRleChub2RlKTtcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgd2hpbGUgKG5vZGUgJiYgb2Zmc2V0KSB7XG4gICAgICAgIGxldCBuZXh0ID0gbm9kZS5jaGlsZE5vZGVzW29mZnNldCAtIDFdO1xuICAgICAgICBpZiAobmV4dC5ub2RlVHlwZSA9PSAzKVxuICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIGlmIChuZXh0Lm5vZGVUeXBlID09IDEgJiYgbmV4dC5jb250ZW50RWRpdGFibGUgPT0gXCJmYWxzZVwiKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIG5vZGUgPSBuZXh0O1xuICAgICAgICBvZmZzZXQgPSBub2RlLmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldFNlbEZvY3VzKHZpZXcsIG5vZGUsIG9mZnNldCkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlICE9IDMpIHtcbiAgICAgICAgbGV0IGJlZm9yZSwgYWZ0ZXI7XG4gICAgICAgIGlmIChhZnRlciA9IHRleHROb2RlQWZ0ZXIobm9kZSwgb2Zmc2V0KSkge1xuICAgICAgICAgICAgbm9kZSA9IGFmdGVyO1xuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChiZWZvcmUgPSB0ZXh0Tm9kZUJlZm9yZShub2RlLCBvZmZzZXQpKSB7XG4gICAgICAgICAgICBub2RlID0gYmVmb3JlO1xuICAgICAgICAgICAgb2Zmc2V0ID0gYmVmb3JlLm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IHNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uKCk7XG4gICAgaWYgKCFzZWwpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoc2VsZWN0aW9uQ29sbGFwc2VkKHNlbCkpIHtcbiAgICAgICAgbGV0IHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgcmFuZ2Uuc2V0RW5kKG5vZGUsIG9mZnNldCk7XG4gICAgICAgIHJhbmdlLnNldFN0YXJ0KG5vZGUsIG9mZnNldCk7XG4gICAgICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgc2VsLmFkZFJhbmdlKHJhbmdlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2VsLmV4dGVuZCkge1xuICAgICAgICBzZWwuZXh0ZW5kKG5vZGUsIG9mZnNldCk7XG4gICAgfVxuICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc2V0Q3VyU2VsZWN0aW9uKCk7XG4gICAgbGV0IHsgc3RhdGUgfSA9IHZpZXc7XG4gICAgLy8gSWYgbm8gc3RhdGUgdXBkYXRlIGVuZHMgdXAgaGFwcGVuaW5nLCByZXNldCB0aGUgc2VsZWN0aW9uLlxuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAodmlldy5zdGF0ZSA9PSBzdGF0ZSlcbiAgICAgICAgICAgIHNlbGVjdGlvblRvRE9NKHZpZXcpO1xuICAgIH0sIDUwKTtcbn1cbmZ1bmN0aW9uIGZpbmREaXJlY3Rpb24odmlldywgcG9zKSB7XG4gICAgbGV0ICRwb3MgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKHBvcyk7XG4gICAgaWYgKCEoY2hyb21lIHx8IHdpbmRvd3MpICYmICRwb3MucGFyZW50LmlubGluZUNvbnRlbnQpIHtcbiAgICAgICAgbGV0IGNvb3JkcyA9IHZpZXcuY29vcmRzQXRQb3MocG9zKTtcbiAgICAgICAgaWYgKHBvcyA+ICRwb3Muc3RhcnQoKSkge1xuICAgICAgICAgICAgbGV0IGJlZm9yZSA9IHZpZXcuY29vcmRzQXRQb3MocG9zIC0gMSk7XG4gICAgICAgICAgICBsZXQgbWlkID0gKGJlZm9yZS50b3AgKyBiZWZvcmUuYm90dG9tKSAvIDI7XG4gICAgICAgICAgICBpZiAobWlkID4gY29vcmRzLnRvcCAmJiBtaWQgPCBjb29yZHMuYm90dG9tICYmIE1hdGguYWJzKGJlZm9yZS5sZWZ0IC0gY29vcmRzLmxlZnQpID4gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gYmVmb3JlLmxlZnQgPCBjb29yZHMubGVmdCA/IFwibHRyXCIgOiBcInJ0bFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgPCAkcG9zLmVuZCgpKSB7XG4gICAgICAgICAgICBsZXQgYWZ0ZXIgPSB2aWV3LmNvb3Jkc0F0UG9zKHBvcyArIDEpO1xuICAgICAgICAgICAgbGV0IG1pZCA9IChhZnRlci50b3AgKyBhZnRlci5ib3R0b20pIC8gMjtcbiAgICAgICAgICAgIGlmIChtaWQgPiBjb29yZHMudG9wICYmIG1pZCA8IGNvb3Jkcy5ib3R0b20gJiYgTWF0aC5hYnMoYWZ0ZXIubGVmdCAtIGNvb3Jkcy5sZWZ0KSA+IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGFmdGVyLmxlZnQgPiBjb29yZHMubGVmdCA/IFwibHRyXCIgOiBcInJ0bFwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxldCBjb21wdXRlZCA9IGdldENvbXB1dGVkU3R5bGUodmlldy5kb20pLmRpcmVjdGlvbjtcbiAgICByZXR1cm4gY29tcHV0ZWQgPT0gXCJydGxcIiA/IFwicnRsXCIgOiBcImx0clwiO1xufVxuLy8gQ2hlY2sgd2hldGhlciB2ZXJ0aWNhbCBzZWxlY3Rpb24gbW90aW9uIHdvdWxkIGludm9sdmUgbm9kZVxuLy8gc2VsZWN0aW9ucy4gSWYgc28sIGFwcGx5IGl0IChpZiBub3QsIHRoZSByZXN1bHQgaXMgbGVmdCB0byB0aGVcbi8vIGJyb3dzZXIpXG5mdW5jdGlvbiBzZWxlY3RWZXJ0aWNhbGx5KHZpZXcsIGRpciwgbW9kcykge1xuICAgIGxldCBzZWwgPSB2aWV3LnN0YXRlLnNlbGVjdGlvbjtcbiAgICBpZiAoc2VsIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbiAmJiAhc2VsLmVtcHR5IHx8IG1vZHMuaW5kZXhPZihcInNcIikgPiAtMSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChtYWMgJiYgbW9kcy5pbmRleE9mKFwibVwiKSA+IC0xKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHsgJGZyb20sICR0byB9ID0gc2VsO1xuICAgIGlmICghJGZyb20ucGFyZW50LmlubGluZUNvbnRlbnQgfHwgdmlldy5lbmRPZlRleHRibG9jayhkaXIgPCAwID8gXCJ1cFwiIDogXCJkb3duXCIpKSB7XG4gICAgICAgIGxldCBuZXh0ID0gbW92ZVNlbGVjdGlvbkJsb2NrKHZpZXcuc3RhdGUsIGRpcik7XG4gICAgICAgIGlmIChuZXh0ICYmIChuZXh0IGluc3RhbmNlb2YgTm9kZVNlbGVjdGlvbikpXG4gICAgICAgICAgICByZXR1cm4gYXBwbHkodmlldywgbmV4dCk7XG4gICAgfVxuICAgIGlmICghJGZyb20ucGFyZW50LmlubGluZUNvbnRlbnQpIHtcbiAgICAgICAgbGV0IHNpZGUgPSBkaXIgPCAwID8gJGZyb20gOiAkdG87XG4gICAgICAgIGxldCBiZXlvbmQgPSBzZWwgaW5zdGFuY2VvZiBBbGxTZWxlY3Rpb24gPyBTZWxlY3Rpb24ubmVhcihzaWRlLCBkaXIpIDogU2VsZWN0aW9uLmZpbmRGcm9tKHNpZGUsIGRpcik7XG4gICAgICAgIHJldHVybiBiZXlvbmQgPyBhcHBseSh2aWV3LCBiZXlvbmQpIDogZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHN0b3BOYXRpdmVIb3Jpem9udGFsRGVsZXRlKHZpZXcsIGRpcikge1xuICAgIGlmICghKHZpZXcuc3RhdGUuc2VsZWN0aW9uIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbikpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGxldCB7ICRoZWFkLCAkYW5jaG9yLCBlbXB0eSB9ID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCEkaGVhZC5zYW1lUGFyZW50KCRhbmNob3IpKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoIWVtcHR5KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKHZpZXcuZW5kT2ZUZXh0YmxvY2soZGlyID4gMCA/IFwiZm9yd2FyZFwiIDogXCJiYWNrd2FyZFwiKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgbGV0IG5leHROb2RlID0gISRoZWFkLnRleHRPZmZzZXQgJiYgKGRpciA8IDAgPyAkaGVhZC5ub2RlQmVmb3JlIDogJGhlYWQubm9kZUFmdGVyKTtcbiAgICBpZiAobmV4dE5vZGUgJiYgIW5leHROb2RlLmlzVGV4dCkge1xuICAgICAgICBsZXQgdHIgPSB2aWV3LnN0YXRlLnRyO1xuICAgICAgICBpZiAoZGlyIDwgMClcbiAgICAgICAgICAgIHRyLmRlbGV0ZSgkaGVhZC5wb3MgLSBuZXh0Tm9kZS5ub2RlU2l6ZSwgJGhlYWQucG9zKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdHIuZGVsZXRlKCRoZWFkLnBvcywgJGhlYWQucG9zICsgbmV4dE5vZGUubm9kZVNpemUpO1xuICAgICAgICB2aWV3LmRpc3BhdGNoKHRyKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHN3aXRjaEVkaXRhYmxlKHZpZXcsIG5vZGUsIHN0YXRlKSB7XG4gICAgdmlldy5kb21PYnNlcnZlci5zdG9wKCk7XG4gICAgbm9kZS5jb250ZW50RWRpdGFibGUgPSBzdGF0ZTtcbiAgICB2aWV3LmRvbU9ic2VydmVyLnN0YXJ0KCk7XG59XG4vLyBJc3N1ZSAjODY3IC8gIzEwOTAgLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD05MDM4MjFcbi8vIEluIHdoaWNoIFNhZmFyaSAoYW5kIGF0IHNvbWUgcG9pbnQgaW4gdGhlIHBhc3QsIENocm9tZSkgZG9lcyByZWFsbHlcbi8vIHdyb25nIHRoaW5ncyB3aGVuIHRoZSBkb3duIGFycm93IGlzIHByZXNzZWQgd2hlbiB0aGUgY3Vyc29yIGlzXG4vLyBkaXJlY3RseSBhdCB0aGUgc3RhcnQgb2YgYSB0ZXh0YmxvY2sgYW5kIGhhcyBhbiB1bmVkaXRhYmxlIG5vZGVcbi8vIGFmdGVyIGl0XG5mdW5jdGlvbiBzYWZhcmlEb3duQXJyb3dCdWcodmlldykge1xuICAgIGlmICghc2FmYXJpIHx8IHZpZXcuc3RhdGUuc2VsZWN0aW9uLiRoZWFkLnBhcmVudE9mZnNldCA+IDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgeyBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0IH0gPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgaWYgKGZvY3VzTm9kZSAmJiBmb2N1c05vZGUubm9kZVR5cGUgPT0gMSAmJiBmb2N1c09mZnNldCA9PSAwICYmXG4gICAgICAgIGZvY3VzTm9kZS5maXJzdENoaWxkICYmIGZvY3VzTm9kZS5maXJzdENoaWxkLmNvbnRlbnRFZGl0YWJsZSA9PSBcImZhbHNlXCIpIHtcbiAgICAgICAgbGV0IGNoaWxkID0gZm9jdXNOb2RlLmZpcnN0Q2hpbGQ7XG4gICAgICAgIHN3aXRjaEVkaXRhYmxlKHZpZXcsIGNoaWxkLCBcInRydWVcIik7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gc3dpdGNoRWRpdGFibGUodmlldywgY2hpbGQsIFwiZmFsc2VcIiksIDIwKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8gQSBiYWNrZHJvcCBrZXkgbWFwcGluZyB1c2VkIHRvIG1ha2Ugc3VyZSB3ZSBhbHdheXMgc3VwcHJlc3Mga2V5c1xuLy8gdGhhdCBoYXZlIGEgZGFuZ2Vyb3VzIGRlZmF1bHQgZWZmZWN0LCBldmVuIGlmIHRoZSBjb21tYW5kcyB0aGV5IGFyZVxuLy8gYm91bmQgdG8gcmV0dXJuIGZhbHNlLCBhbmQgdG8gbWFrZSBzdXJlIHRoYXQgY3Vyc29yLW1vdGlvbiBrZXlzXG4vLyBmaW5kIGEgY3Vyc29yIChhcyBvcHBvc2VkIHRvIGEgbm9kZSBzZWxlY3Rpb24pIHdoZW4gcHJlc3NlZC4gRm9yXG4vLyBjdXJzb3ItbW90aW9uIGtleXMsIHRoZSBjb2RlIGluIHRoZSBoYW5kbGVycyBhbHNvIHRha2VzIGNhcmUgb2Zcbi8vIGJsb2NrIHNlbGVjdGlvbnMuXG5mdW5jdGlvbiBnZXRNb2RzKGV2ZW50KSB7XG4gICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgaWYgKGV2ZW50LmN0cmxLZXkpXG4gICAgICAgIHJlc3VsdCArPSBcImNcIjtcbiAgICBpZiAoZXZlbnQubWV0YUtleSlcbiAgICAgICAgcmVzdWx0ICs9IFwibVwiO1xuICAgIGlmIChldmVudC5hbHRLZXkpXG4gICAgICAgIHJlc3VsdCArPSBcImFcIjtcbiAgICBpZiAoZXZlbnQuc2hpZnRLZXkpXG4gICAgICAgIHJlc3VsdCArPSBcInNcIjtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY2FwdHVyZUtleURvd24odmlldywgZXZlbnQpIHtcbiAgICBsZXQgY29kZSA9IGV2ZW50LmtleUNvZGUsIG1vZHMgPSBnZXRNb2RzKGV2ZW50KTtcbiAgICBpZiAoY29kZSA9PSA4IHx8IChtYWMgJiYgY29kZSA9PSA3MiAmJiBtb2RzID09IFwiY1wiKSkgeyAvLyBCYWNrc3BhY2UsIEN0cmwtaCBvbiBNYWNcbiAgICAgICAgcmV0dXJuIHN0b3BOYXRpdmVIb3Jpem9udGFsRGVsZXRlKHZpZXcsIC0xKSB8fCBza2lwSWdub3JlZE5vZGVzKHZpZXcsIC0xKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKGNvZGUgPT0gNDYgJiYgIWV2ZW50LnNoaWZ0S2V5KSB8fCAobWFjICYmIGNvZGUgPT0gNjggJiYgbW9kcyA9PSBcImNcIikpIHsgLy8gRGVsZXRlLCBDdHJsLWQgb24gTWFjXG4gICAgICAgIHJldHVybiBzdG9wTmF0aXZlSG9yaXpvbnRhbERlbGV0ZSh2aWV3LCAxKSB8fCBza2lwSWdub3JlZE5vZGVzKHZpZXcsIDEpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlID09IDEzIHx8IGNvZGUgPT0gMjcpIHsgLy8gRW50ZXIsIEVzY1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29kZSA9PSAzNyB8fCAobWFjICYmIGNvZGUgPT0gNjYgJiYgbW9kcyA9PSBcImNcIikpIHsgLy8gTGVmdCBhcnJvdywgQ3RybC1iIG9uIE1hY1xuICAgICAgICBsZXQgZGlyID0gY29kZSA9PSAzNyA/IChmaW5kRGlyZWN0aW9uKHZpZXcsIHZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb20pID09IFwibHRyXCIgPyAtMSA6IDEpIDogLTE7XG4gICAgICAgIHJldHVybiBzZWxlY3RIb3Jpem9udGFsbHkodmlldywgZGlyLCBtb2RzKSB8fCBza2lwSWdub3JlZE5vZGVzKHZpZXcsIGRpcik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvZGUgPT0gMzkgfHwgKG1hYyAmJiBjb2RlID09IDcwICYmIG1vZHMgPT0gXCJjXCIpKSB7IC8vIFJpZ2h0IGFycm93LCBDdHJsLWYgb24gTWFjXG4gICAgICAgIGxldCBkaXIgPSBjb2RlID09IDM5ID8gKGZpbmREaXJlY3Rpb24odmlldywgdmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSkgPT0gXCJsdHJcIiA/IDEgOiAtMSkgOiAxO1xuICAgICAgICByZXR1cm4gc2VsZWN0SG9yaXpvbnRhbGx5KHZpZXcsIGRpciwgbW9kcykgfHwgc2tpcElnbm9yZWROb2Rlcyh2aWV3LCBkaXIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChjb2RlID09IDM4IHx8IChtYWMgJiYgY29kZSA9PSA4MCAmJiBtb2RzID09IFwiY1wiKSkgeyAvLyBVcCBhcnJvdywgQ3RybC1wIG9uIE1hY1xuICAgICAgICByZXR1cm4gc2VsZWN0VmVydGljYWxseSh2aWV3LCAtMSwgbW9kcykgfHwgc2tpcElnbm9yZWROb2Rlcyh2aWV3LCAtMSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNvZGUgPT0gNDAgfHwgKG1hYyAmJiBjb2RlID09IDc4ICYmIG1vZHMgPT0gXCJjXCIpKSB7IC8vIERvd24gYXJyb3csIEN0cmwtbiBvbiBNYWNcbiAgICAgICAgcmV0dXJuIHNhZmFyaURvd25BcnJvd0J1Zyh2aWV3KSB8fCBzZWxlY3RWZXJ0aWNhbGx5KHZpZXcsIDEsIG1vZHMpIHx8IHNraXBJZ25vcmVkTm9kZXModmlldywgMSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG1vZHMgPT0gKG1hYyA/IFwibVwiIDogXCJjXCIpICYmXG4gICAgICAgIChjb2RlID09IDY2IHx8IGNvZGUgPT0gNzMgfHwgY29kZSA9PSA4OSB8fCBjb2RlID09IDkwKSkgeyAvLyBNb2QtW2JpeXpdXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZUZvckNsaXBib2FyZCh2aWV3LCBzbGljZSkge1xuICAgIHZpZXcuc29tZVByb3AoXCJ0cmFuc2Zvcm1Db3BpZWRcIiwgZiA9PiB7IHNsaWNlID0gZihzbGljZSwgdmlldyk7IH0pO1xuICAgIGxldCBjb250ZXh0ID0gW10sIHsgY29udGVudCwgb3BlblN0YXJ0LCBvcGVuRW5kIH0gPSBzbGljZTtcbiAgICB3aGlsZSAob3BlblN0YXJ0ID4gMSAmJiBvcGVuRW5kID4gMSAmJiBjb250ZW50LmNoaWxkQ291bnQgPT0gMSAmJiBjb250ZW50LmZpcnN0Q2hpbGQuY2hpbGRDb3VudCA9PSAxKSB7XG4gICAgICAgIG9wZW5TdGFydC0tO1xuICAgICAgICBvcGVuRW5kLS07XG4gICAgICAgIGxldCBub2RlID0gY29udGVudC5maXJzdENoaWxkO1xuICAgICAgICBjb250ZXh0LnB1c2gobm9kZS50eXBlLm5hbWUsIG5vZGUuYXR0cnMgIT0gbm9kZS50eXBlLmRlZmF1bHRBdHRycyA/IG5vZGUuYXR0cnMgOiBudWxsKTtcbiAgICAgICAgY29udGVudCA9IG5vZGUuY29udGVudDtcbiAgICB9XG4gICAgbGV0IHNlcmlhbGl6ZXIgPSB2aWV3LnNvbWVQcm9wKFwiY2xpcGJvYXJkU2VyaWFsaXplclwiKSB8fCBET01TZXJpYWxpemVyLmZyb21TY2hlbWEodmlldy5zdGF0ZS5zY2hlbWEpO1xuICAgIGxldCBkb2MgPSBkZXRhY2hlZERvYygpLCB3cmFwID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgd3JhcC5hcHBlbmRDaGlsZChzZXJpYWxpemVyLnNlcmlhbGl6ZUZyYWdtZW50KGNvbnRlbnQsIHsgZG9jdW1lbnQ6IGRvYyB9KSk7XG4gICAgbGV0IGZpcnN0Q2hpbGQgPSB3cmFwLmZpcnN0Q2hpbGQsIG5lZWRzV3JhcCwgd3JhcHBlcnMgPSAwO1xuICAgIHdoaWxlIChmaXJzdENoaWxkICYmIGZpcnN0Q2hpbGQubm9kZVR5cGUgPT0gMSAmJiAobmVlZHNXcmFwID0gd3JhcE1hcFtmaXJzdENoaWxkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCldKSkge1xuICAgICAgICBmb3IgKGxldCBpID0gbmVlZHNXcmFwLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBsZXQgd3JhcHBlciA9IGRvYy5jcmVhdGVFbGVtZW50KG5lZWRzV3JhcFtpXSk7XG4gICAgICAgICAgICB3aGlsZSAod3JhcC5maXJzdENoaWxkKVxuICAgICAgICAgICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQod3JhcC5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIHdyYXAuYXBwZW5kQ2hpbGQod3JhcHBlcik7XG4gICAgICAgICAgICB3cmFwcGVycysrO1xuICAgICAgICB9XG4gICAgICAgIGZpcnN0Q2hpbGQgPSB3cmFwLmZpcnN0Q2hpbGQ7XG4gICAgfVxuICAgIGlmIChmaXJzdENoaWxkICYmIGZpcnN0Q2hpbGQubm9kZVR5cGUgPT0gMSlcbiAgICAgICAgZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXBtLXNsaWNlXCIsIGAke29wZW5TdGFydH0gJHtvcGVuRW5kfSR7d3JhcHBlcnMgPyBgIC0ke3dyYXBwZXJzfWAgOiBcIlwifSAke0pTT04uc3RyaW5naWZ5KGNvbnRleHQpfWApO1xuICAgIGxldCB0ZXh0ID0gdmlldy5zb21lUHJvcChcImNsaXBib2FyZFRleHRTZXJpYWxpemVyXCIsIGYgPT4gZihzbGljZSwgdmlldykpIHx8XG4gICAgICAgIHNsaWNlLmNvbnRlbnQudGV4dEJldHdlZW4oMCwgc2xpY2UuY29udGVudC5zaXplLCBcIlxcblxcblwiKTtcbiAgICByZXR1cm4geyBkb206IHdyYXAsIHRleHQsIHNsaWNlIH07XG59XG4vLyBSZWFkIGEgc2xpY2Ugb2YgY29udGVudCBmcm9tIHRoZSBjbGlwYm9hcmQgKG9yIGRyb3AgZGF0YSkuXG5mdW5jdGlvbiBwYXJzZUZyb21DbGlwYm9hcmQodmlldywgdGV4dCwgaHRtbCwgcGxhaW5UZXh0LCAkY29udGV4dCkge1xuICAgIGxldCBpbkNvZGUgPSAkY29udGV4dC5wYXJlbnQudHlwZS5zcGVjLmNvZGU7XG4gICAgbGV0IGRvbSwgc2xpY2U7XG4gICAgaWYgKCFodG1sICYmICF0ZXh0KVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgYXNUZXh0ID0gISF0ZXh0ICYmIChwbGFpblRleHQgfHwgaW5Db2RlIHx8ICFodG1sKTtcbiAgICBpZiAoYXNUZXh0KSB7XG4gICAgICAgIHZpZXcuc29tZVByb3AoXCJ0cmFuc2Zvcm1QYXN0ZWRUZXh0XCIsIGYgPT4geyB0ZXh0ID0gZih0ZXh0LCBpbkNvZGUgfHwgcGxhaW5UZXh0LCB2aWV3KTsgfSk7XG4gICAgICAgIGlmIChpbkNvZGUpIHtcbiAgICAgICAgICAgIHNsaWNlID0gbmV3IFNsaWNlKEZyYWdtZW50LmZyb20odmlldy5zdGF0ZS5zY2hlbWEudGV4dCh0ZXh0LnJlcGxhY2UoL1xcclxcbj8vZywgXCJcXG5cIikpKSwgMCwgMCk7XG4gICAgICAgICAgICB2aWV3LnNvbWVQcm9wKFwidHJhbnNmb3JtUGFzdGVkXCIsIGYgPT4geyBzbGljZSA9IGYoc2xpY2UsIHZpZXcsIHRydWUpOyB9KTtcbiAgICAgICAgICAgIHJldHVybiBzbGljZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcGFyc2VkID0gdmlldy5zb21lUHJvcChcImNsaXBib2FyZFRleHRQYXJzZXJcIiwgZiA9PiBmKHRleHQsICRjb250ZXh0LCBwbGFpblRleHQsIHZpZXcpKTtcbiAgICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICAgICAgc2xpY2UgPSBwYXJzZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbWFya3MgPSAkY29udGV4dC5tYXJrcygpO1xuICAgICAgICAgICAgbGV0IHsgc2NoZW1hIH0gPSB2aWV3LnN0YXRlLCBzZXJpYWxpemVyID0gRE9NU2VyaWFsaXplci5mcm9tU2NoZW1hKHNjaGVtYSk7XG4gICAgICAgICAgICBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgdGV4dC5zcGxpdCgvKD86XFxyXFxuP3xcXG4pKy8pLmZvckVhY2goYmxvY2sgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBwID0gZG9tLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJwXCIpKTtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2spXG4gICAgICAgICAgICAgICAgICAgIHAuYXBwZW5kQ2hpbGQoc2VyaWFsaXplci5zZXJpYWxpemVOb2RlKHNjaGVtYS50ZXh0KGJsb2NrLCBtYXJrcykpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2aWV3LnNvbWVQcm9wKFwidHJhbnNmb3JtUGFzdGVkSFRNTFwiLCBmID0+IHsgaHRtbCA9IGYoaHRtbCwgdmlldyk7IH0pO1xuICAgICAgICBkb20gPSByZWFkSFRNTChodG1sKTtcbiAgICAgICAgaWYgKHdlYmtpdClcbiAgICAgICAgICAgIHJlc3RvcmVSZXBsYWNlZFNwYWNlcyhkb20pO1xuICAgIH1cbiAgICBsZXQgY29udGV4dE5vZGUgPSBkb20gJiYgZG9tLnF1ZXJ5U2VsZWN0b3IoXCJbZGF0YS1wbS1zbGljZV1cIik7XG4gICAgbGV0IHNsaWNlRGF0YSA9IGNvbnRleHROb2RlICYmIC9eKFxcZCspIChcXGQrKSg/OiAtKFxcZCspKT8gKC4qKS8uZXhlYyhjb250ZXh0Tm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLXBtLXNsaWNlXCIpIHx8IFwiXCIpO1xuICAgIGlmIChzbGljZURhdGEgJiYgc2xpY2VEYXRhWzNdKVxuICAgICAgICBmb3IgKGxldCBpID0gK3NsaWNlRGF0YVszXTsgaSA+IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IGNoaWxkID0gZG9tLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICB3aGlsZSAoY2hpbGQgJiYgY2hpbGQubm9kZVR5cGUgIT0gMSlcbiAgICAgICAgICAgICAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgaWYgKCFjaGlsZClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRvbSA9IGNoaWxkO1xuICAgICAgICB9XG4gICAgaWYgKCFzbGljZSkge1xuICAgICAgICBsZXQgcGFyc2VyID0gdmlldy5zb21lUHJvcChcImNsaXBib2FyZFBhcnNlclwiKSB8fCB2aWV3LnNvbWVQcm9wKFwiZG9tUGFyc2VyXCIpIHx8IERPTVBhcnNlci5mcm9tU2NoZW1hKHZpZXcuc3RhdGUuc2NoZW1hKTtcbiAgICAgICAgc2xpY2UgPSBwYXJzZXIucGFyc2VTbGljZShkb20sIHtcbiAgICAgICAgICAgIHByZXNlcnZlV2hpdGVzcGFjZTogISEoYXNUZXh0IHx8IHNsaWNlRGF0YSksXG4gICAgICAgICAgICBjb250ZXh0OiAkY29udGV4dCxcbiAgICAgICAgICAgIHJ1bGVGcm9tTm9kZShkb20pIHtcbiAgICAgICAgICAgICAgICBpZiAoZG9tLm5vZGVOYW1lID09IFwiQlJcIiAmJiAhZG9tLm5leHRTaWJsaW5nICYmXG4gICAgICAgICAgICAgICAgICAgIGRvbS5wYXJlbnROb2RlICYmICFpbmxpbmVQYXJlbnRzLnRlc3QoZG9tLnBhcmVudE5vZGUubm9kZU5hbWUpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBpZ25vcmU6IHRydWUgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzbGljZURhdGEpIHtcbiAgICAgICAgc2xpY2UgPSBhZGRDb250ZXh0KGNsb3NlU2xpY2Uoc2xpY2UsICtzbGljZURhdGFbMV0sICtzbGljZURhdGFbMl0pLCBzbGljZURhdGFbNF0pO1xuICAgIH1cbiAgICBlbHNlIHsgLy8gSFRNTCB3YXNuJ3QgY3JlYXRlZCBieSBQcm9zZU1pcnJvci4gTWFrZSBzdXJlIHRvcC1sZXZlbCBzaWJsaW5ncyBhcmUgY29oZXJlbnRcbiAgICAgICAgc2xpY2UgPSBTbGljZS5tYXhPcGVuKG5vcm1hbGl6ZVNpYmxpbmdzKHNsaWNlLmNvbnRlbnQsICRjb250ZXh0KSwgdHJ1ZSk7XG4gICAgICAgIGlmIChzbGljZS5vcGVuU3RhcnQgfHwgc2xpY2Uub3BlbkVuZCkge1xuICAgICAgICAgICAgbGV0IG9wZW5TdGFydCA9IDAsIG9wZW5FbmQgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgbm9kZSA9IHNsaWNlLmNvbnRlbnQuZmlyc3RDaGlsZDsgb3BlblN0YXJ0IDwgc2xpY2Uub3BlblN0YXJ0ICYmICFub2RlLnR5cGUuc3BlYy5pc29sYXRpbmc7IG9wZW5TdGFydCsrLCBub2RlID0gbm9kZS5maXJzdENoaWxkKSB7IH1cbiAgICAgICAgICAgIGZvciAobGV0IG5vZGUgPSBzbGljZS5jb250ZW50Lmxhc3RDaGlsZDsgb3BlbkVuZCA8IHNsaWNlLm9wZW5FbmQgJiYgIW5vZGUudHlwZS5zcGVjLmlzb2xhdGluZzsgb3BlbkVuZCsrLCBub2RlID0gbm9kZS5sYXN0Q2hpbGQpIHsgfVxuICAgICAgICAgICAgc2xpY2UgPSBjbG9zZVNsaWNlKHNsaWNlLCBvcGVuU3RhcnQsIG9wZW5FbmQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZpZXcuc29tZVByb3AoXCJ0cmFuc2Zvcm1QYXN0ZWRcIiwgZiA9PiB7IHNsaWNlID0gZihzbGljZSwgdmlldywgYXNUZXh0KTsgfSk7XG4gICAgcmV0dXJuIHNsaWNlO1xufVxuY29uc3QgaW5saW5lUGFyZW50cyA9IC9eKGF8YWJicnxhY3JvbnltfGJ8Y2l0ZXxjb2RlfGRlbHxlbXxpfGluc3xrYmR8bGFiZWx8b3V0cHV0fHF8cnVieXxzfHNhbXB8c3BhbnxzdHJvbmd8c3VifHN1cHx0aW1lfHV8dHR8dmFyKSQvaTtcbi8vIFRha2VzIGEgc2xpY2UgcGFyc2VkIHdpdGggcGFyc2VTbGljZSwgd2hpY2ggbWVhbnMgdGhlcmUgaGFzbid0IGJlZW5cbi8vIGFueSBjb250ZW50LWV4cHJlc3Npb24gY2hlY2tpbmcgZG9uZSBvbiB0aGUgdG9wIG5vZGVzLCB0cmllcyB0b1xuLy8gZmluZCBhIHBhcmVudCBub2RlIGluIHRoZSBjdXJyZW50IGNvbnRleHQgdGhhdCBtaWdodCBmaXQgdGhlIG5vZGVzLFxuLy8gYW5kIGlmIHN1Y2Nlc3NmdWwsIHJlYnVpbGRzIHRoZSBzbGljZSBzbyB0aGF0IGl0IGZpdHMgaW50byB0aGF0IHBhcmVudC5cbi8vXG4vLyBUaGlzIGFkZHJlc3NlcyB0aGUgcHJvYmxlbSB0aGF0IFRyYW5zZm9ybS5yZXBsYWNlIGV4cGVjdHMgYVxuLy8gY29oZXJlbnQgc2xpY2UsIGFuZCB3aWxsIGZhaWwgdG8gcGxhY2UgYSBzZXQgb2Ygc2libGluZ3MgdGhhdCBkb24ndFxuLy8gZml0IGFueXdoZXJlIGluIHRoZSBzY2hlbWEuXG5mdW5jdGlvbiBub3JtYWxpemVTaWJsaW5ncyhmcmFnbWVudCwgJGNvbnRleHQpIHtcbiAgICBpZiAoZnJhZ21lbnQuY2hpbGRDb3VudCA8IDIpXG4gICAgICAgIHJldHVybiBmcmFnbWVudDtcbiAgICBmb3IgKGxldCBkID0gJGNvbnRleHQuZGVwdGg7IGQgPj0gMDsgZC0tKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSAkY29udGV4dC5ub2RlKGQpO1xuICAgICAgICBsZXQgbWF0Y2ggPSBwYXJlbnQuY29udGVudE1hdGNoQXQoJGNvbnRleHQuaW5kZXgoZCkpO1xuICAgICAgICBsZXQgbGFzdFdyYXAsIHJlc3VsdCA9IFtdO1xuICAgICAgICBmcmFnbWVudC5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHdyYXAgPSBtYXRjaC5maW5kV3JhcHBpbmcobm9kZS50eXBlKSwgaW5MYXN0O1xuICAgICAgICAgICAgaWYgKCF3cmFwKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGluTGFzdCA9IHJlc3VsdC5sZW5ndGggJiYgbGFzdFdyYXAubGVuZ3RoICYmIGFkZFRvU2libGluZyh3cmFwLCBsYXN0V3JhcCwgbm9kZSwgcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSwgMCkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdID0gaW5MYXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gPSBjbG9zZVJpZ2h0KHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0sIGxhc3RXcmFwLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgbGV0IHdyYXBwZWQgPSB3aXRoV3JhcHBlcnMobm9kZSwgd3JhcCk7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2god3JhcHBlZCk7XG4gICAgICAgICAgICAgICAgbWF0Y2ggPSBtYXRjaC5tYXRjaFR5cGUod3JhcHBlZC50eXBlKTtcbiAgICAgICAgICAgICAgICBsYXN0V3JhcCA9IHdyYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocmVzdWx0KVxuICAgICAgICAgICAgcmV0dXJuIEZyYWdtZW50LmZyb20ocmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIGZyYWdtZW50O1xufVxuZnVuY3Rpb24gd2l0aFdyYXBwZXJzKG5vZGUsIHdyYXAsIGZyb20gPSAwKSB7XG4gICAgZm9yIChsZXQgaSA9IHdyYXAubGVuZ3RoIC0gMTsgaSA+PSBmcm9tOyBpLS0pXG4gICAgICAgIG5vZGUgPSB3cmFwW2ldLmNyZWF0ZShudWxsLCBGcmFnbWVudC5mcm9tKG5vZGUpKTtcbiAgICByZXR1cm4gbm9kZTtcbn1cbi8vIFVzZWQgdG8gZ3JvdXAgYWRqYWNlbnQgbm9kZXMgd3JhcHBlZCBpbiBzaW1pbGFyIHBhcmVudHMgYnlcbi8vIG5vcm1hbGl6ZVNpYmxpbmdzIGludG8gdGhlIHNhbWUgcGFyZW50IG5vZGVcbmZ1bmN0aW9uIGFkZFRvU2libGluZyh3cmFwLCBsYXN0V3JhcCwgbm9kZSwgc2libGluZywgZGVwdGgpIHtcbiAgICBpZiAoZGVwdGggPCB3cmFwLmxlbmd0aCAmJiBkZXB0aCA8IGxhc3RXcmFwLmxlbmd0aCAmJiB3cmFwW2RlcHRoXSA9PSBsYXN0V3JhcFtkZXB0aF0pIHtcbiAgICAgICAgbGV0IGlubmVyID0gYWRkVG9TaWJsaW5nKHdyYXAsIGxhc3RXcmFwLCBub2RlLCBzaWJsaW5nLmxhc3RDaGlsZCwgZGVwdGggKyAxKTtcbiAgICAgICAgaWYgKGlubmVyKVxuICAgICAgICAgICAgcmV0dXJuIHNpYmxpbmcuY29weShzaWJsaW5nLmNvbnRlbnQucmVwbGFjZUNoaWxkKHNpYmxpbmcuY2hpbGRDb3VudCAtIDEsIGlubmVyKSk7XG4gICAgICAgIGxldCBtYXRjaCA9IHNpYmxpbmcuY29udGVudE1hdGNoQXQoc2libGluZy5jaGlsZENvdW50KTtcbiAgICAgICAgaWYgKG1hdGNoLm1hdGNoVHlwZShkZXB0aCA9PSB3cmFwLmxlbmd0aCAtIDEgPyBub2RlLnR5cGUgOiB3cmFwW2RlcHRoICsgMV0pKVxuICAgICAgICAgICAgcmV0dXJuIHNpYmxpbmcuY29weShzaWJsaW5nLmNvbnRlbnQuYXBwZW5kKEZyYWdtZW50LmZyb20od2l0aFdyYXBwZXJzKG5vZGUsIHdyYXAsIGRlcHRoICsgMSkpKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gY2xvc2VSaWdodChub2RlLCBkZXB0aCkge1xuICAgIGlmIChkZXB0aCA9PSAwKVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICBsZXQgZnJhZ21lbnQgPSBub2RlLmNvbnRlbnQucmVwbGFjZUNoaWxkKG5vZGUuY2hpbGRDb3VudCAtIDEsIGNsb3NlUmlnaHQobm9kZS5sYXN0Q2hpbGQsIGRlcHRoIC0gMSkpO1xuICAgIGxldCBmaWxsID0gbm9kZS5jb250ZW50TWF0Y2hBdChub2RlLmNoaWxkQ291bnQpLmZpbGxCZWZvcmUoRnJhZ21lbnQuZW1wdHksIHRydWUpO1xuICAgIHJldHVybiBub2RlLmNvcHkoZnJhZ21lbnQuYXBwZW5kKGZpbGwpKTtcbn1cbmZ1bmN0aW9uIGNsb3NlUmFuZ2UoZnJhZ21lbnQsIHNpZGUsIGZyb20sIHRvLCBkZXB0aCwgb3BlbkVuZCkge1xuICAgIGxldCBub2RlID0gc2lkZSA8IDAgPyBmcmFnbWVudC5maXJzdENoaWxkIDogZnJhZ21lbnQubGFzdENoaWxkLCBpbm5lciA9IG5vZGUuY29udGVudDtcbiAgICBpZiAoZnJhZ21lbnQuY2hpbGRDb3VudCA+IDEpXG4gICAgICAgIG9wZW5FbmQgPSAwO1xuICAgIGlmIChkZXB0aCA8IHRvIC0gMSlcbiAgICAgICAgaW5uZXIgPSBjbG9zZVJhbmdlKGlubmVyLCBzaWRlLCBmcm9tLCB0bywgZGVwdGggKyAxLCBvcGVuRW5kKTtcbiAgICBpZiAoZGVwdGggPj0gZnJvbSlcbiAgICAgICAgaW5uZXIgPSBzaWRlIDwgMCA/IG5vZGUuY29udGVudE1hdGNoQXQoMCkuZmlsbEJlZm9yZShpbm5lciwgb3BlbkVuZCA8PSBkZXB0aCkuYXBwZW5kKGlubmVyKVxuICAgICAgICAgICAgOiBpbm5lci5hcHBlbmQobm9kZS5jb250ZW50TWF0Y2hBdChub2RlLmNoaWxkQ291bnQpLmZpbGxCZWZvcmUoRnJhZ21lbnQuZW1wdHksIHRydWUpKTtcbiAgICByZXR1cm4gZnJhZ21lbnQucmVwbGFjZUNoaWxkKHNpZGUgPCAwID8gMCA6IGZyYWdtZW50LmNoaWxkQ291bnQgLSAxLCBub2RlLmNvcHkoaW5uZXIpKTtcbn1cbmZ1bmN0aW9uIGNsb3NlU2xpY2Uoc2xpY2UsIG9wZW5TdGFydCwgb3BlbkVuZCkge1xuICAgIGlmIChvcGVuU3RhcnQgPCBzbGljZS5vcGVuU3RhcnQpXG4gICAgICAgIHNsaWNlID0gbmV3IFNsaWNlKGNsb3NlUmFuZ2Uoc2xpY2UuY29udGVudCwgLTEsIG9wZW5TdGFydCwgc2xpY2Uub3BlblN0YXJ0LCAwLCBzbGljZS5vcGVuRW5kKSwgb3BlblN0YXJ0LCBzbGljZS5vcGVuRW5kKTtcbiAgICBpZiAob3BlbkVuZCA8IHNsaWNlLm9wZW5FbmQpXG4gICAgICAgIHNsaWNlID0gbmV3IFNsaWNlKGNsb3NlUmFuZ2Uoc2xpY2UuY29udGVudCwgMSwgb3BlbkVuZCwgc2xpY2Uub3BlbkVuZCwgMCwgMCksIHNsaWNlLm9wZW5TdGFydCwgb3BlbkVuZCk7XG4gICAgcmV0dXJuIHNsaWNlO1xufVxuLy8gVHJpY2sgZnJvbSBqUXVlcnkgLS0gc29tZSBlbGVtZW50cyBtdXN0IGJlIHdyYXBwZWQgaW4gb3RoZXJcbi8vIGVsZW1lbnRzIGZvciBpbm5lckhUTUwgdG8gd29yay4gSS5lLiBpZiB5b3UgZG8gYGRpdi5pbm5lckhUTUwgPVxuLy8gXCI8dGQ+Li48L3RkPlwiYCB0aGUgdGFibGUgY2VsbHMgYXJlIGlnbm9yZWQuXG5jb25zdCB3cmFwTWFwID0ge1xuICAgIHRoZWFkOiBbXCJ0YWJsZVwiXSxcbiAgICB0Ym9keTogW1widGFibGVcIl0sXG4gICAgdGZvb3Q6IFtcInRhYmxlXCJdLFxuICAgIGNhcHRpb246IFtcInRhYmxlXCJdLFxuICAgIGNvbGdyb3VwOiBbXCJ0YWJsZVwiXSxcbiAgICBjb2w6IFtcInRhYmxlXCIsIFwiY29sZ3JvdXBcIl0sXG4gICAgdHI6IFtcInRhYmxlXCIsIFwidGJvZHlcIl0sXG4gICAgdGQ6IFtcInRhYmxlXCIsIFwidGJvZHlcIiwgXCJ0clwiXSxcbiAgICB0aDogW1widGFibGVcIiwgXCJ0Ym9keVwiLCBcInRyXCJdXG59O1xubGV0IF9kZXRhY2hlZERvYyA9IG51bGw7XG5mdW5jdGlvbiBkZXRhY2hlZERvYygpIHtcbiAgICByZXR1cm4gX2RldGFjaGVkRG9jIHx8IChfZGV0YWNoZWREb2MgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoXCJ0aXRsZVwiKSk7XG59XG5sZXQgX3BvbGljeSA9IG51bGw7XG5mdW5jdGlvbiBtYXliZVdyYXBUcnVzdGVkKGh0bWwpIHtcbiAgICBsZXQgdHJ1c3RlZFR5cGVzID0gd2luZG93LnRydXN0ZWRUeXBlcztcbiAgICBpZiAoIXRydXN0ZWRUeXBlcylcbiAgICAgICAgcmV0dXJuIGh0bWw7XG4gICAgLy8gV2l0aCB0aGUgcmVxdWlyZS10cnVzdGVkLXR5cGVzLWZvciBDU1AsIENocm9tZSB3aWxsIGJsb2NrXG4gICAgLy8gaW5uZXJIVE1MLCBldmVuIG9uIGEgZGV0YWNoZWQgZG9jdW1lbnQuIFRoaXMgd3JhcHMgdGhlIHN0cmluZyBpblxuICAgIC8vIGEgd2F5IHRoYXQgbWFrZXMgdGhlIGJyb3dzZXIgYWxsb3cgdXMgdG8gdXNlIGl0cyBwYXJzZXIgYWdhaW4uXG4gICAgaWYgKCFfcG9saWN5KVxuICAgICAgICBfcG9saWN5ID0gdHJ1c3RlZFR5cGVzLmRlZmF1bHRQb2xpY3kgfHwgdHJ1c3RlZFR5cGVzLmNyZWF0ZVBvbGljeShcIlByb3NlTWlycm9yQ2xpcGJvYXJkXCIsIHsgY3JlYXRlSFRNTDogKHMpID0+IHMgfSk7XG4gICAgcmV0dXJuIF9wb2xpY3kuY3JlYXRlSFRNTChodG1sKTtcbn1cbmZ1bmN0aW9uIHJlYWRIVE1MKGh0bWwpIHtcbiAgICBsZXQgbWV0YXMgPSAvXihcXHMqPG1ldGEgW14+XSo+KSovLmV4ZWMoaHRtbCk7XG4gICAgaWYgKG1ldGFzKVxuICAgICAgICBodG1sID0gaHRtbC5zbGljZShtZXRhc1swXS5sZW5ndGgpO1xuICAgIGxldCBlbHQgPSBkZXRhY2hlZERvYygpLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgbGV0IGZpcnN0VGFnID0gLzwoW2Etel1bXj5cXHNdKykvaS5leGVjKGh0bWwpLCB3cmFwO1xuICAgIGlmICh3cmFwID0gZmlyc3RUYWcgJiYgd3JhcE1hcFtmaXJzdFRhZ1sxXS50b0xvd2VyQ2FzZSgpXSlcbiAgICAgICAgaHRtbCA9IHdyYXAubWFwKG4gPT4gXCI8XCIgKyBuICsgXCI+XCIpLmpvaW4oXCJcIikgKyBodG1sICsgd3JhcC5tYXAobiA9PiBcIjwvXCIgKyBuICsgXCI+XCIpLnJldmVyc2UoKS5qb2luKFwiXCIpO1xuICAgIGVsdC5pbm5lckhUTUwgPSBtYXliZVdyYXBUcnVzdGVkKGh0bWwpO1xuICAgIGlmICh3cmFwKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdyYXAubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBlbHQgPSBlbHQucXVlcnlTZWxlY3Rvcih3cmFwW2ldKSB8fCBlbHQ7XG4gICAgcmV0dXJuIGVsdDtcbn1cbi8vIFdlYmtpdCBicm93c2VycyBkbyBzb21lIGhhcmQtdG8tcHJlZGljdCByZXBsYWNlbWVudCBvZiByZWd1bGFyXG4vLyBzcGFjZXMgd2l0aCBub24tYnJlYWtpbmcgc3BhY2VzIHdoZW4gcHV0dGluZyBjb250ZW50IG9uIHRoZVxuLy8gY2xpcGJvYXJkLiBUaGlzIHRyaWVzIHRvIGNvbnZlcnQgc3VjaCBub24tYnJlYWtpbmcgc3BhY2VzICh3aGljaFxuLy8gd2lsbCBiZSB3cmFwcGVkIGluIGEgcGxhaW4gc3BhbiBvbiBDaHJvbWUsIGEgc3BhbiB3aXRoIGNsYXNzXG4vLyBBcHBsZS1jb252ZXJ0ZWQtc3BhY2Ugb24gU2FmYXJpKSBiYWNrIHRvIHJlZ3VsYXIgc3BhY2VzLlxuZnVuY3Rpb24gcmVzdG9yZVJlcGxhY2VkU3BhY2VzKGRvbSkge1xuICAgIGxldCBub2RlcyA9IGRvbS5xdWVyeVNlbGVjdG9yQWxsKGNocm9tZSA/IFwic3Bhbjpub3QoW2NsYXNzXSk6bm90KFtzdHlsZV0pXCIgOiBcInNwYW4uQXBwbGUtY29udmVydGVkLXNwYWNlXCIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgaWYgKG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPT0gMSAmJiBub2RlLnRleHRDb250ZW50ID09IFwiXFx1MDBhMFwiICYmIG5vZGUucGFyZW50Tm9kZSlcbiAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoZG9tLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCIgXCIpLCBub2RlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRDb250ZXh0KHNsaWNlLCBjb250ZXh0KSB7XG4gICAgaWYgKCFzbGljZS5zaXplKVxuICAgICAgICByZXR1cm4gc2xpY2U7XG4gICAgbGV0IHNjaGVtYSA9IHNsaWNlLmNvbnRlbnQuZmlyc3RDaGlsZC50eXBlLnNjaGVtYSwgYXJyYXk7XG4gICAgdHJ5IHtcbiAgICAgICAgYXJyYXkgPSBKU09OLnBhcnNlKGNvbnRleHQpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gc2xpY2U7XG4gICAgfVxuICAgIGxldCB7IGNvbnRlbnQsIG9wZW5TdGFydCwgb3BlbkVuZCB9ID0gc2xpY2U7XG4gICAgZm9yIChsZXQgaSA9IGFycmF5Lmxlbmd0aCAtIDI7IGkgPj0gMDsgaSAtPSAyKSB7XG4gICAgICAgIGxldCB0eXBlID0gc2NoZW1hLm5vZGVzW2FycmF5W2ldXTtcbiAgICAgICAgaWYgKCF0eXBlIHx8IHR5cGUuaGFzUmVxdWlyZWRBdHRycygpKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNvbnRlbnQgPSBGcmFnbWVudC5mcm9tKHR5cGUuY3JlYXRlKGFycmF5W2kgKyAxXSwgY29udGVudCkpO1xuICAgICAgICBvcGVuU3RhcnQrKztcbiAgICAgICAgb3BlbkVuZCsrO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFNsaWNlKGNvbnRlbnQsIG9wZW5TdGFydCwgb3BlbkVuZCk7XG59XG5cbi8vIEEgY29sbGVjdGlvbiBvZiBET00gZXZlbnRzIHRoYXQgb2NjdXIgd2l0aGluIHRoZSBlZGl0b3IsIGFuZCBjYWxsYmFjayBmdW5jdGlvbnNcbi8vIHRvIGludm9rZSB3aGVuIHRoZSBldmVudCBmaXJlcy5cbmNvbnN0IGhhbmRsZXJzID0ge307XG5jb25zdCBlZGl0SGFuZGxlcnMgPSB7fTtcbmNvbnN0IHBhc3NpdmVIYW5kbGVycyA9IHsgdG91Y2hzdGFydDogdHJ1ZSwgdG91Y2htb3ZlOiB0cnVlIH07XG5jbGFzcyBJbnB1dFN0YXRlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zaGlmdEtleSA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1vdXNlRG93biA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdEtleUNvZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RLZXlDb2RlVGltZSA9IDA7XG4gICAgICAgIHRoaXMubGFzdENsaWNrID0geyB0aW1lOiAwLCB4OiAwLCB5OiAwLCB0eXBlOiBcIlwiLCBidXR0b246IDAgfTtcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0aW9uT3JpZ2luID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0aW9uVGltZSA9IDA7XG4gICAgICAgIHRoaXMubGFzdElPU0VudGVyID0gMDtcbiAgICAgICAgdGhpcy5sYXN0SU9TRW50ZXJGYWxsYmFja1RpbWVvdXQgPSAtMTtcbiAgICAgICAgdGhpcy5sYXN0Rm9jdXMgPSAwO1xuICAgICAgICB0aGlzLmxhc3RUb3VjaCA9IDA7XG4gICAgICAgIHRoaXMubGFzdENocm9tZURlbGV0ZSA9IDA7XG4gICAgICAgIHRoaXMuY29tcG9zaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29tcG9zaXRpb25Ob2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5jb21wb3NpbmdUaW1lb3V0ID0gLTE7XG4gICAgICAgIHRoaXMuY29tcG9zaXRpb25Ob2RlcyA9IFtdO1xuICAgICAgICB0aGlzLmNvbXBvc2l0aW9uRW5kZWRBdCA9IC0yZTg7XG4gICAgICAgIHRoaXMuY29tcG9zaXRpb25JRCA9IDE7XG4gICAgICAgIC8vIFNldCB0byBhIGNvbXBvc2l0aW9uIElEIHdoZW4gdGhlcmUgYXJlIHBlbmRpbmcgY2hhbmdlcyBhdCBjb21wb3NpdGlvbmVuZFxuICAgICAgICB0aGlzLmNvbXBvc2l0aW9uUGVuZGluZ0NoYW5nZXMgPSAwO1xuICAgICAgICB0aGlzLmRvbUNoYW5nZUNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5oaWRlU2VsZWN0aW9uR3VhcmQgPSBudWxsO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGluaXRJbnB1dCh2aWV3KSB7XG4gICAgZm9yIChsZXQgZXZlbnQgaW4gaGFuZGxlcnMpIHtcbiAgICAgICAgbGV0IGhhbmRsZXIgPSBoYW5kbGVyc1tldmVudF07XG4gICAgICAgIHZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIHZpZXcuaW5wdXQuZXZlbnRIYW5kbGVyc1tldmVudF0gPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudEJlbG9uZ3NUb1ZpZXcodmlldywgZXZlbnQpICYmICFydW5DdXN0b21IYW5kbGVyKHZpZXcsIGV2ZW50KSAmJlxuICAgICAgICAgICAgICAgICh2aWV3LmVkaXRhYmxlIHx8ICEoZXZlbnQudHlwZSBpbiBlZGl0SGFuZGxlcnMpKSlcbiAgICAgICAgICAgICAgICBoYW5kbGVyKHZpZXcsIGV2ZW50KTtcbiAgICAgICAgfSwgcGFzc2l2ZUhhbmRsZXJzW2V2ZW50XSA/IHsgcGFzc2l2ZTogdHJ1ZSB9IDogdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgLy8gT24gU2FmYXJpLCBmb3IgcmVhc29ucyBiZXlvbmQgbXkgdW5kZXJzdGFuZGluZywgYWRkaW5nIGFuIGlucHV0XG4gICAgLy8gZXZlbnQgaGFuZGxlciBtYWtlcyBhbiBpc3N1ZSB3aGVyZSB0aGUgY29tcG9zaXRpb24gdmFuaXNoZXMgd2hlblxuICAgIC8vIHlvdSBwcmVzcyBlbnRlciBnbyBhd2F5LlxuICAgIGlmIChzYWZhcmkpXG4gICAgICAgIHZpZXcuZG9tLmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCAoKSA9PiBudWxsKTtcbiAgICBlbnN1cmVMaXN0ZW5lcnModmlldyk7XG59XG5mdW5jdGlvbiBzZXRTZWxlY3Rpb25PcmlnaW4odmlldywgb3JpZ2luKSB7XG4gICAgdmlldy5pbnB1dC5sYXN0U2VsZWN0aW9uT3JpZ2luID0gb3JpZ2luO1xuICAgIHZpZXcuaW5wdXQubGFzdFNlbGVjdGlvblRpbWUgPSBEYXRlLm5vdygpO1xufVxuZnVuY3Rpb24gZGVzdHJveUlucHV0KHZpZXcpIHtcbiAgICB2aWV3LmRvbU9ic2VydmVyLnN0b3AoKTtcbiAgICBmb3IgKGxldCB0eXBlIGluIHZpZXcuaW5wdXQuZXZlbnRIYW5kbGVycylcbiAgICAgICAgdmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCB2aWV3LmlucHV0LmV2ZW50SGFuZGxlcnNbdHlwZV0pO1xuICAgIGNsZWFyVGltZW91dCh2aWV3LmlucHV0LmNvbXBvc2luZ1RpbWVvdXQpO1xuICAgIGNsZWFyVGltZW91dCh2aWV3LmlucHV0Lmxhc3RJT1NFbnRlckZhbGxiYWNrVGltZW91dCk7XG59XG5mdW5jdGlvbiBlbnN1cmVMaXN0ZW5lcnModmlldykge1xuICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVET01FdmVudHNcIiwgY3VycmVudEhhbmRsZXJzID0+IHtcbiAgICAgICAgZm9yIChsZXQgdHlwZSBpbiBjdXJyZW50SGFuZGxlcnMpXG4gICAgICAgICAgICBpZiAoIXZpZXcuaW5wdXQuZXZlbnRIYW5kbGVyc1t0eXBlXSlcbiAgICAgICAgICAgICAgICB2aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIHZpZXcuaW5wdXQuZXZlbnRIYW5kbGVyc1t0eXBlXSA9IGV2ZW50ID0+IHJ1bkN1c3RvbUhhbmRsZXIodmlldywgZXZlbnQpKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHJ1bkN1c3RvbUhhbmRsZXIodmlldywgZXZlbnQpIHtcbiAgICByZXR1cm4gdmlldy5zb21lUHJvcChcImhhbmRsZURPTUV2ZW50c1wiLCBoYW5kbGVycyA9PiB7XG4gICAgICAgIGxldCBoYW5kbGVyID0gaGFuZGxlcnNbZXZlbnQudHlwZV07XG4gICAgICAgIHJldHVybiBoYW5kbGVyID8gaGFuZGxlcih2aWV3LCBldmVudCkgfHwgZXZlbnQuZGVmYXVsdFByZXZlbnRlZCA6IGZhbHNlO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZXZlbnRCZWxvbmdzVG9WaWV3KHZpZXcsIGV2ZW50KSB7XG4gICAgaWYgKCFldmVudC5idWJibGVzKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IG5vZGUgPSBldmVudC50YXJnZXQ7IG5vZGUgIT0gdmlldy5kb207IG5vZGUgPSBub2RlLnBhcmVudE5vZGUpXG4gICAgICAgIGlmICghbm9kZSB8fCBub2RlLm5vZGVUeXBlID09IDExIHx8XG4gICAgICAgICAgICAobm9kZS5wbVZpZXdEZXNjICYmIG5vZGUucG1WaWV3RGVzYy5zdG9wRXZlbnQoZXZlbnQpKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQodmlldywgZXZlbnQpIHtcbiAgICBpZiAoIXJ1bkN1c3RvbUhhbmRsZXIodmlldywgZXZlbnQpICYmIGhhbmRsZXJzW2V2ZW50LnR5cGVdICYmXG4gICAgICAgICh2aWV3LmVkaXRhYmxlIHx8ICEoZXZlbnQudHlwZSBpbiBlZGl0SGFuZGxlcnMpKSlcbiAgICAgICAgaGFuZGxlcnNbZXZlbnQudHlwZV0odmlldywgZXZlbnQpO1xufVxuZWRpdEhhbmRsZXJzLmtleWRvd24gPSAodmlldywgX2V2ZW50KSA9PiB7XG4gICAgbGV0IGV2ZW50ID0gX2V2ZW50O1xuICAgIHZpZXcuaW5wdXQuc2hpZnRLZXkgPSBldmVudC5rZXlDb2RlID09IDE2IHx8IGV2ZW50LnNoaWZ0S2V5O1xuICAgIGlmIChpbk9yTmVhckNvbXBvc2l0aW9uKHZpZXcsIGV2ZW50KSlcbiAgICAgICAgcmV0dXJuO1xuICAgIHZpZXcuaW5wdXQubGFzdEtleUNvZGUgPSBldmVudC5rZXlDb2RlO1xuICAgIHZpZXcuaW5wdXQubGFzdEtleUNvZGVUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAvLyBTdXBwcmVzcyBlbnRlciBrZXkgZXZlbnRzIG9uIENocm9tZSBBbmRyb2lkLCBiZWNhdXNlIHRob3NlIHRlbmRcbiAgICAvLyB0byBiZSBwYXJ0IG9mIGEgY29uZnVzZWQgc2VxdWVuY2Ugb2YgY29tcG9zaXRpb24gZXZlbnRzIGZpcmVkLFxuICAgIC8vIGFuZCBoYW5kbGluZyB0aGVtIGVhZ2VybHkgdGVuZHMgdG8gY29ycnVwdCB0aGUgaW5wdXQuXG4gICAgaWYgKGFuZHJvaWQgJiYgY2hyb21lICYmIGV2ZW50LmtleUNvZGUgPT0gMTMpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAoZXZlbnQua2V5Q29kZSAhPSAyMjkpXG4gICAgICAgIHZpZXcuZG9tT2JzZXJ2ZXIuZm9yY2VGbHVzaCgpO1xuICAgIC8vIE9uIGlPUywgaWYgd2UgcHJldmVudERlZmF1bHQgZW50ZXIga2V5IHByZXNzZXMsIHRoZSB2aXJ0dWFsXG4gICAgLy8ga2V5Ym9hcmQgZ2V0cyBjb25mdXNlZC4gU28gdGhlIGhhY2sgaGVyZSBpcyB0byBzZXQgYSBmbGFnIHRoYXRcbiAgICAvLyBtYWtlcyB0aGUgRE9NIGNoYW5nZSBjb2RlIHJlY29nbml6ZSB0aGF0IHdoYXQganVzdCBoYXBwZW5zIHNob3VsZFxuICAgIC8vIGJlIHJlcGxhY2VkIGJ5IHdoYXRldmVyIHRoZSBFbnRlciBrZXkgaGFuZGxlcnMgZG8uXG4gICAgaWYgKGlvcyAmJiBldmVudC5rZXlDb2RlID09IDEzICYmICFldmVudC5jdHJsS2V5ICYmICFldmVudC5hbHRLZXkgJiYgIWV2ZW50Lm1ldGFLZXkpIHtcbiAgICAgICAgbGV0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIHZpZXcuaW5wdXQubGFzdElPU0VudGVyID0gbm93O1xuICAgICAgICB2aWV3LmlucHV0Lmxhc3RJT1NFbnRlckZhbGxiYWNrVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHZpZXcuaW5wdXQubGFzdElPU0VudGVyID09IG5vdykge1xuICAgICAgICAgICAgICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVLZXlEb3duXCIsIGYgPT4gZih2aWV3LCBrZXlFdmVudCgxMywgXCJFbnRlclwiKSkpO1xuICAgICAgICAgICAgICAgIHZpZXcuaW5wdXQubGFzdElPU0VudGVyID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMjAwKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZiA9PiBmKHZpZXcsIGV2ZW50KSkgfHwgY2FwdHVyZUtleURvd24odmlldywgZXZlbnQpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzZXRTZWxlY3Rpb25PcmlnaW4odmlldywgXCJrZXlcIik7XG4gICAgfVxufTtcbmVkaXRIYW5kbGVycy5rZXl1cCA9ICh2aWV3LCBldmVudCkgPT4ge1xuICAgIGlmIChldmVudC5rZXlDb2RlID09IDE2KVxuICAgICAgICB2aWV3LmlucHV0LnNoaWZ0S2V5ID0gZmFsc2U7XG59O1xuZWRpdEhhbmRsZXJzLmtleXByZXNzID0gKHZpZXcsIF9ldmVudCkgPT4ge1xuICAgIGxldCBldmVudCA9IF9ldmVudDtcbiAgICBpZiAoaW5Pck5lYXJDb21wb3NpdGlvbih2aWV3LCBldmVudCkgfHwgIWV2ZW50LmNoYXJDb2RlIHx8XG4gICAgICAgIGV2ZW50LmN0cmxLZXkgJiYgIWV2ZW50LmFsdEtleSB8fCBtYWMgJiYgZXZlbnQubWV0YUtleSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICh2aWV3LnNvbWVQcm9wKFwiaGFuZGxlS2V5UHJlc3NcIiwgZiA9PiBmKHZpZXcsIGV2ZW50KSkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgc2VsID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgaWYgKCEoc2VsIGluc3RhbmNlb2YgVGV4dFNlbGVjdGlvbikgfHwgIXNlbC4kZnJvbS5zYW1lUGFyZW50KHNlbC4kdG8pKSB7XG4gICAgICAgIGxldCB0ZXh0ID0gU3RyaW5nLmZyb21DaGFyQ29kZShldmVudC5jaGFyQ29kZSk7XG4gICAgICAgIGxldCBkZWZsdCA9ICgpID0+IHZpZXcuc3RhdGUudHIuaW5zZXJ0VGV4dCh0ZXh0KS5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICBpZiAoIS9bXFxyXFxuXS8udGVzdCh0ZXh0KSAmJiAhdmlldy5zb21lUHJvcChcImhhbmRsZVRleHRJbnB1dFwiLCBmID0+IGYodmlldywgc2VsLiRmcm9tLnBvcywgc2VsLiR0by5wb3MsIHRleHQsIGRlZmx0KSkpXG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKGRlZmx0KCkpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbn07XG5mdW5jdGlvbiBldmVudENvb3JkcyhldmVudCkgeyByZXR1cm4geyBsZWZ0OiBldmVudC5jbGllbnRYLCB0b3A6IGV2ZW50LmNsaWVudFkgfTsgfVxuZnVuY3Rpb24gaXNOZWFyKGV2ZW50LCBjbGljaykge1xuICAgIGxldCBkeCA9IGNsaWNrLnggLSBldmVudC5jbGllbnRYLCBkeSA9IGNsaWNrLnkgLSBldmVudC5jbGllbnRZO1xuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeSA8IDEwMDtcbn1cbmZ1bmN0aW9uIHJ1bkhhbmRsZXJPbkNvbnRleHQodmlldywgcHJvcE5hbWUsIHBvcywgaW5zaWRlLCBldmVudCkge1xuICAgIGlmIChpbnNpZGUgPT0gLTEpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgJHBvcyA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoaW5zaWRlKTtcbiAgICBmb3IgKGxldCBpID0gJHBvcy5kZXB0aCArIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgaWYgKHZpZXcuc29tZVByb3AocHJvcE5hbWUsIGYgPT4gaSA+ICRwb3MuZGVwdGggPyBmKHZpZXcsIHBvcywgJHBvcy5ub2RlQWZ0ZXIsICRwb3MuYmVmb3JlKGkpLCBldmVudCwgdHJ1ZSlcbiAgICAgICAgICAgIDogZih2aWV3LCBwb3MsICRwb3Mubm9kZShpKSwgJHBvcy5iZWZvcmUoaSksIGV2ZW50LCBmYWxzZSkpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVNlbGVjdGlvbih2aWV3LCBzZWxlY3Rpb24sIG9yaWdpbikge1xuICAgIGlmICghdmlldy5mb2N1c2VkKVxuICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgaWYgKHZpZXcuc3RhdGUuc2VsZWN0aW9uLmVxKHNlbGVjdGlvbikpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgdHIgPSB2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihzZWxlY3Rpb24pO1xuICAgIGlmIChvcmlnaW4gPT0gXCJwb2ludGVyXCIpXG4gICAgICAgIHRyLnNldE1ldGEoXCJwb2ludGVyXCIsIHRydWUpO1xuICAgIHZpZXcuZGlzcGF0Y2godHIpO1xufVxuZnVuY3Rpb24gc2VsZWN0Q2xpY2tlZExlYWYodmlldywgaW5zaWRlKSB7XG4gICAgaWYgKGluc2lkZSA9PSAtMSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGxldCAkcG9zID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZShpbnNpZGUpLCBub2RlID0gJHBvcy5ub2RlQWZ0ZXI7XG4gICAgaWYgKG5vZGUgJiYgbm9kZS5pc0F0b20gJiYgTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobm9kZSkpIHtcbiAgICAgICAgdXBkYXRlU2VsZWN0aW9uKHZpZXcsIG5ldyBOb2RlU2VsZWN0aW9uKCRwb3MpLCBcInBvaW50ZXJcIik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBzZWxlY3RDbGlja2VkTm9kZSh2aWV3LCBpbnNpZGUpIHtcbiAgICBpZiAoaW5zaWRlID09IC0xKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLCBzZWxlY3RlZE5vZGUsIHNlbGVjdEF0O1xuICAgIGlmIChzZWwgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uKVxuICAgICAgICBzZWxlY3RlZE5vZGUgPSBzZWwubm9kZTtcbiAgICBsZXQgJHBvcyA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoaW5zaWRlKTtcbiAgICBmb3IgKGxldCBpID0gJHBvcy5kZXB0aCArIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgbGV0IG5vZGUgPSBpID4gJHBvcy5kZXB0aCA/ICRwb3Mubm9kZUFmdGVyIDogJHBvcy5ub2RlKGkpO1xuICAgICAgICBpZiAoTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUobm9kZSkpIHtcbiAgICAgICAgICAgIGlmIChzZWxlY3RlZE5vZGUgJiYgc2VsLiRmcm9tLmRlcHRoID4gMCAmJlxuICAgICAgICAgICAgICAgIGkgPj0gc2VsLiRmcm9tLmRlcHRoICYmICRwb3MuYmVmb3JlKHNlbC4kZnJvbS5kZXB0aCArIDEpID09IHNlbC4kZnJvbS5wb3MpXG4gICAgICAgICAgICAgICAgc2VsZWN0QXQgPSAkcG9zLmJlZm9yZShzZWwuJGZyb20uZGVwdGgpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHNlbGVjdEF0ID0gJHBvcy5iZWZvcmUoaSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2VsZWN0QXQgIT0gbnVsbCkge1xuICAgICAgICB1cGRhdGVTZWxlY3Rpb24odmlldywgTm9kZVNlbGVjdGlvbi5jcmVhdGUodmlldy5zdGF0ZS5kb2MsIHNlbGVjdEF0KSwgXCJwb2ludGVyXCIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBoYW5kbGVTaW5nbGVDbGljayh2aWV3LCBwb3MsIGluc2lkZSwgZXZlbnQsIHNlbGVjdE5vZGUpIHtcbiAgICByZXR1cm4gcnVuSGFuZGxlck9uQ29udGV4dCh2aWV3LCBcImhhbmRsZUNsaWNrT25cIiwgcG9zLCBpbnNpZGUsIGV2ZW50KSB8fFxuICAgICAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlQ2xpY2tcIiwgZiA9PiBmKHZpZXcsIHBvcywgZXZlbnQpKSB8fFxuICAgICAgICAoc2VsZWN0Tm9kZSA/IHNlbGVjdENsaWNrZWROb2RlKHZpZXcsIGluc2lkZSkgOiBzZWxlY3RDbGlja2VkTGVhZih2aWV3LCBpbnNpZGUpKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZURvdWJsZUNsaWNrKHZpZXcsIHBvcywgaW5zaWRlLCBldmVudCkge1xuICAgIHJldHVybiBydW5IYW5kbGVyT25Db250ZXh0KHZpZXcsIFwiaGFuZGxlRG91YmxlQ2xpY2tPblwiLCBwb3MsIGluc2lkZSwgZXZlbnQpIHx8XG4gICAgICAgIHZpZXcuc29tZVByb3AoXCJoYW5kbGVEb3VibGVDbGlja1wiLCBmID0+IGYodmlldywgcG9zLCBldmVudCkpO1xufVxuZnVuY3Rpb24gaGFuZGxlVHJpcGxlQ2xpY2sodmlldywgcG9zLCBpbnNpZGUsIGV2ZW50KSB7XG4gICAgcmV0dXJuIHJ1bkhhbmRsZXJPbkNvbnRleHQodmlldywgXCJoYW5kbGVUcmlwbGVDbGlja09uXCIsIHBvcywgaW5zaWRlLCBldmVudCkgfHxcbiAgICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZVRyaXBsZUNsaWNrXCIsIGYgPT4gZih2aWV3LCBwb3MsIGV2ZW50KSkgfHxcbiAgICAgICAgZGVmYXVsdFRyaXBsZUNsaWNrKHZpZXcsIGluc2lkZSwgZXZlbnQpO1xufVxuZnVuY3Rpb24gZGVmYXVsdFRyaXBsZUNsaWNrKHZpZXcsIGluc2lkZSwgZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuYnV0dG9uICE9IDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgZG9jID0gdmlldy5zdGF0ZS5kb2M7XG4gICAgaWYgKGluc2lkZSA9PSAtMSkge1xuICAgICAgICBpZiAoZG9jLmlubGluZUNvbnRlbnQpIHtcbiAgICAgICAgICAgIHVwZGF0ZVNlbGVjdGlvbih2aWV3LCBUZXh0U2VsZWN0aW9uLmNyZWF0ZShkb2MsIDAsIGRvYy5jb250ZW50LnNpemUpLCBcInBvaW50ZXJcIik7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCAkcG9zID0gZG9jLnJlc29sdmUoaW5zaWRlKTtcbiAgICBmb3IgKGxldCBpID0gJHBvcy5kZXB0aCArIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgbGV0IG5vZGUgPSBpID4gJHBvcy5kZXB0aCA/ICRwb3Mubm9kZUFmdGVyIDogJHBvcy5ub2RlKGkpO1xuICAgICAgICBsZXQgbm9kZVBvcyA9ICRwb3MuYmVmb3JlKGkpO1xuICAgICAgICBpZiAobm9kZS5pbmxpbmVDb250ZW50KVxuICAgICAgICAgICAgdXBkYXRlU2VsZWN0aW9uKHZpZXcsIFRleHRTZWxlY3Rpb24uY3JlYXRlKGRvYywgbm9kZVBvcyArIDEsIG5vZGVQb3MgKyAxICsgbm9kZS5jb250ZW50LnNpemUpLCBcInBvaW50ZXJcIik7XG4gICAgICAgIGVsc2UgaWYgKE5vZGVTZWxlY3Rpb24uaXNTZWxlY3RhYmxlKG5vZGUpKVxuICAgICAgICAgICAgdXBkYXRlU2VsZWN0aW9uKHZpZXcsIE5vZGVTZWxlY3Rpb24uY3JlYXRlKGRvYywgbm9kZVBvcyksIFwicG9pbnRlclwiKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZvcmNlRE9NRmx1c2godmlldykge1xuICAgIHJldHVybiBlbmRDb21wb3NpdGlvbih2aWV3KTtcbn1cbmNvbnN0IHNlbGVjdE5vZGVNb2RpZmllciA9IG1hYyA/IFwibWV0YUtleVwiIDogXCJjdHJsS2V5XCI7XG5oYW5kbGVycy5tb3VzZWRvd24gPSAodmlldywgX2V2ZW50KSA9PiB7XG4gICAgbGV0IGV2ZW50ID0gX2V2ZW50O1xuICAgIHZpZXcuaW5wdXQuc2hpZnRLZXkgPSBldmVudC5zaGlmdEtleTtcbiAgICBsZXQgZmx1c2hlZCA9IGZvcmNlRE9NRmx1c2godmlldyk7XG4gICAgbGV0IG5vdyA9IERhdGUubm93KCksIHR5cGUgPSBcInNpbmdsZUNsaWNrXCI7XG4gICAgaWYgKG5vdyAtIHZpZXcuaW5wdXQubGFzdENsaWNrLnRpbWUgPCA1MDAgJiYgaXNOZWFyKGV2ZW50LCB2aWV3LmlucHV0Lmxhc3RDbGljaykgJiYgIWV2ZW50W3NlbGVjdE5vZGVNb2RpZmllcl0gJiZcbiAgICAgICAgdmlldy5pbnB1dC5sYXN0Q2xpY2suYnV0dG9uID09IGV2ZW50LmJ1dHRvbikge1xuICAgICAgICBpZiAodmlldy5pbnB1dC5sYXN0Q2xpY2sudHlwZSA9PSBcInNpbmdsZUNsaWNrXCIpXG4gICAgICAgICAgICB0eXBlID0gXCJkb3VibGVDbGlja1wiO1xuICAgICAgICBlbHNlIGlmICh2aWV3LmlucHV0Lmxhc3RDbGljay50eXBlID09IFwiZG91YmxlQ2xpY2tcIilcbiAgICAgICAgICAgIHR5cGUgPSBcInRyaXBsZUNsaWNrXCI7XG4gICAgfVxuICAgIHZpZXcuaW5wdXQubGFzdENsaWNrID0geyB0aW1lOiBub3csIHg6IGV2ZW50LmNsaWVudFgsIHk6IGV2ZW50LmNsaWVudFksIHR5cGUsIGJ1dHRvbjogZXZlbnQuYnV0dG9uIH07XG4gICAgbGV0IHBvcyA9IHZpZXcucG9zQXRDb29yZHMoZXZlbnRDb29yZHMoZXZlbnQpKTtcbiAgICBpZiAoIXBvcylcbiAgICAgICAgcmV0dXJuO1xuICAgIGlmICh0eXBlID09IFwic2luZ2xlQ2xpY2tcIikge1xuICAgICAgICBpZiAodmlldy5pbnB1dC5tb3VzZURvd24pXG4gICAgICAgICAgICB2aWV3LmlucHV0Lm1vdXNlRG93bi5kb25lKCk7XG4gICAgICAgIHZpZXcuaW5wdXQubW91c2VEb3duID0gbmV3IE1vdXNlRG93bih2aWV3LCBwb3MsIGV2ZW50LCAhIWZsdXNoZWQpO1xuICAgIH1cbiAgICBlbHNlIGlmICgodHlwZSA9PSBcImRvdWJsZUNsaWNrXCIgPyBoYW5kbGVEb3VibGVDbGljayA6IGhhbmRsZVRyaXBsZUNsaWNrKSh2aWV3LCBwb3MucG9zLCBwb3MuaW5zaWRlLCBldmVudCkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHNldFNlbGVjdGlvbk9yaWdpbih2aWV3LCBcInBvaW50ZXJcIik7XG4gICAgfVxufTtcbmNsYXNzIE1vdXNlRG93biB7XG4gICAgY29uc3RydWN0b3IodmlldywgcG9zLCBldmVudCwgZmx1c2hlZCkge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5ldmVudCA9IGV2ZW50O1xuICAgICAgICB0aGlzLmZsdXNoZWQgPSBmbHVzaGVkO1xuICAgICAgICB0aGlzLmRlbGF5ZWRTZWxlY3Rpb25TeW5jID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWlnaHREcmFnID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGFydERvYyA9IHZpZXcuc3RhdGUuZG9jO1xuICAgICAgICB0aGlzLnNlbGVjdE5vZGUgPSAhIWV2ZW50W3NlbGVjdE5vZGVNb2RpZmllcl07XG4gICAgICAgIHRoaXMuYWxsb3dEZWZhdWx0ID0gZXZlbnQuc2hpZnRLZXk7XG4gICAgICAgIGxldCB0YXJnZXROb2RlLCB0YXJnZXRQb3M7XG4gICAgICAgIGlmIChwb3MuaW5zaWRlID4gLTEpIHtcbiAgICAgICAgICAgIHRhcmdldE5vZGUgPSB2aWV3LnN0YXRlLmRvYy5ub2RlQXQocG9zLmluc2lkZSk7XG4gICAgICAgICAgICB0YXJnZXRQb3MgPSBwb3MuaW5zaWRlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0ICRwb3MgPSB2aWV3LnN0YXRlLmRvYy5yZXNvbHZlKHBvcy5wb3MpO1xuICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9ICRwb3MucGFyZW50O1xuICAgICAgICAgICAgdGFyZ2V0UG9zID0gJHBvcy5kZXB0aCA/ICRwb3MuYmVmb3JlKCkgOiAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGZsdXNoZWQgPyBudWxsIDogZXZlbnQudGFyZ2V0O1xuICAgICAgICBjb25zdCB0YXJnZXREZXNjID0gdGFyZ2V0ID8gdmlldy5kb2NWaWV3Lm5lYXJlc3REZXNjKHRhcmdldCwgdHJ1ZSkgOiBudWxsO1xuICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldERlc2MgJiYgdGFyZ2V0RGVzYy5ub2RlRE9NLm5vZGVUeXBlID09IDEgPyB0YXJnZXREZXNjLm5vZGVET00gOiBudWxsO1xuICAgICAgICBsZXQgeyBzZWxlY3Rpb24gfSA9IHZpZXcuc3RhdGU7XG4gICAgICAgIGlmIChldmVudC5idXR0b24gPT0gMCAmJlxuICAgICAgICAgICAgdGFyZ2V0Tm9kZS50eXBlLnNwZWMuZHJhZ2dhYmxlICYmIHRhcmdldE5vZGUudHlwZS5zcGVjLnNlbGVjdGFibGUgIT09IGZhbHNlIHx8XG4gICAgICAgICAgICBzZWxlY3Rpb24gaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uICYmIHNlbGVjdGlvbi5mcm9tIDw9IHRhcmdldFBvcyAmJiBzZWxlY3Rpb24udG8gPiB0YXJnZXRQb3MpXG4gICAgICAgICAgICB0aGlzLm1pZ2h0RHJhZyA9IHtcbiAgICAgICAgICAgICAgICBub2RlOiB0YXJnZXROb2RlLFxuICAgICAgICAgICAgICAgIHBvczogdGFyZ2V0UG9zLFxuICAgICAgICAgICAgICAgIGFkZEF0dHI6ICEhKHRoaXMudGFyZ2V0ICYmICF0aGlzLnRhcmdldC5kcmFnZ2FibGUpLFxuICAgICAgICAgICAgICAgIHNldFVuZWRpdGFibGU6ICEhKHRoaXMudGFyZ2V0ICYmIGdlY2tvICYmICF0aGlzLnRhcmdldC5oYXNBdHRyaWJ1dGUoXCJjb250ZW50RWRpdGFibGVcIikpXG4gICAgICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy50YXJnZXQgJiYgdGhpcy5taWdodERyYWcgJiYgKHRoaXMubWlnaHREcmFnLmFkZEF0dHIgfHwgdGhpcy5taWdodERyYWcuc2V0VW5lZGl0YWJsZSkpIHtcbiAgICAgICAgICAgIHRoaXMudmlldy5kb21PYnNlcnZlci5zdG9wKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5taWdodERyYWcuYWRkQXR0cilcbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldC5kcmFnZ2FibGUgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMubWlnaHREcmFnLnNldFVuZWRpdGFibGUpXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnZpZXcuaW5wdXQubW91c2VEb3duID09IHRoaXMpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRhcmdldC5zZXRBdHRyaWJ1dGUoXCJjb250ZW50RWRpdGFibGVcIiwgXCJmYWxzZVwiKTtcbiAgICAgICAgICAgICAgICB9LCAyMCk7XG4gICAgICAgICAgICB0aGlzLnZpZXcuZG9tT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgICB2aWV3LnJvb3QuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy51cCA9IHRoaXMudXAuYmluZCh0aGlzKSk7XG4gICAgICAgIHZpZXcucm9vdC5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMubW92ZSA9IHRoaXMubW92ZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgc2V0U2VsZWN0aW9uT3JpZ2luKHZpZXcsIFwicG9pbnRlclwiKTtcbiAgICB9XG4gICAgZG9uZSgpIHtcbiAgICAgICAgdGhpcy52aWV3LnJvb3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy51cCk7XG4gICAgICAgIHRoaXMudmlldy5yb290LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdGhpcy5tb3ZlKTtcbiAgICAgICAgaWYgKHRoaXMubWlnaHREcmFnICYmIHRoaXMudGFyZ2V0KSB7XG4gICAgICAgICAgICB0aGlzLnZpZXcuZG9tT2JzZXJ2ZXIuc3RvcCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMubWlnaHREcmFnLmFkZEF0dHIpXG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXQucmVtb3ZlQXR0cmlidXRlKFwiZHJhZ2dhYmxlXCIpO1xuICAgICAgICAgICAgaWYgKHRoaXMubWlnaHREcmFnLnNldFVuZWRpdGFibGUpXG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXQucmVtb3ZlQXR0cmlidXRlKFwiY29udGVudEVkaXRhYmxlXCIpO1xuICAgICAgICAgICAgdGhpcy52aWV3LmRvbU9ic2VydmVyLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGVsYXllZFNlbGVjdGlvblN5bmMpXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHNlbGVjdGlvblRvRE9NKHRoaXMudmlldykpO1xuICAgICAgICB0aGlzLnZpZXcuaW5wdXQubW91c2VEb3duID0gbnVsbDtcbiAgICB9XG4gICAgdXAoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5kb25lKCk7XG4gICAgICAgIGlmICghdGhpcy52aWV3LmRvbS5jb250YWlucyhldmVudC50YXJnZXQpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5wb3M7XG4gICAgICAgIGlmICh0aGlzLnZpZXcuc3RhdGUuZG9jICE9IHRoaXMuc3RhcnREb2MpXG4gICAgICAgICAgICBwb3MgPSB0aGlzLnZpZXcucG9zQXRDb29yZHMoZXZlbnRDb29yZHMoZXZlbnQpKTtcbiAgICAgICAgdGhpcy51cGRhdGVBbGxvd0RlZmF1bHQoZXZlbnQpO1xuICAgICAgICBpZiAodGhpcy5hbGxvd0RlZmF1bHQgfHwgIXBvcykge1xuICAgICAgICAgICAgc2V0U2VsZWN0aW9uT3JpZ2luKHRoaXMudmlldywgXCJwb2ludGVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhhbmRsZVNpbmdsZUNsaWNrKHRoaXMudmlldywgcG9zLnBvcywgcG9zLmluc2lkZSwgZXZlbnQsIHRoaXMuc2VsZWN0Tm9kZSkpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXZlbnQuYnV0dG9uID09IDAgJiZcbiAgICAgICAgICAgICh0aGlzLmZsdXNoZWQgfHxcbiAgICAgICAgICAgICAgICAvLyBTYWZhcmkgaWdub3JlcyBjbGlja3Mgb24gZHJhZ2dhYmxlIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgKHNhZmFyaSAmJiB0aGlzLm1pZ2h0RHJhZyAmJiAhdGhpcy5taWdodERyYWcubm9kZS5pc0F0b20pIHx8XG4gICAgICAgICAgICAgICAgLy8gQ2hyb21lIHdpbGwgc29tZXRpbWVzIHRyZWF0IGEgbm9kZSBzZWxlY3Rpb24gYXMgYVxuICAgICAgICAgICAgICAgIC8vIGN1cnNvciwgYnV0IHN0aWxsIHJlcG9ydCB0aGF0IHRoZSBub2RlIGlzIHNlbGVjdGVkXG4gICAgICAgICAgICAgICAgLy8gd2hlbiBhc2tlZCB0aHJvdWdoIGdldFNlbGVjdGlvbi4gWW91J2xsIHRoZW4gZ2V0IGFcbiAgICAgICAgICAgICAgICAvLyBzaXR1YXRpb24gd2hlcmUgY2xpY2tpbmcgYXQgdGhlIHBvaW50IHdoZXJlIHRoYXRcbiAgICAgICAgICAgICAgICAvLyAoaGlkZGVuKSBjdXJzb3IgaXMgZG9lc24ndCBjaGFuZ2UgdGhlIHNlbGVjdGlvbiwgYW5kXG4gICAgICAgICAgICAgICAgLy8gdGh1cyBkb2Vzbid0IGdldCBhIHJlYWN0aW9uIGZyb20gUHJvc2VNaXJyb3IuIFRoaXNcbiAgICAgICAgICAgICAgICAvLyB3b3JrcyBhcm91bmQgdGhhdC5cbiAgICAgICAgICAgICAgICAoY2hyb21lICYmICF0aGlzLnZpZXcuc3RhdGUuc2VsZWN0aW9uLnZpc2libGUgJiZcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4oTWF0aC5hYnMocG9zLnBvcyAtIHRoaXMudmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSksIE1hdGguYWJzKHBvcy5wb3MgLSB0aGlzLnZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvKSkgPD0gMikpKSB7XG4gICAgICAgICAgICB1cGRhdGVTZWxlY3Rpb24odGhpcy52aWV3LCBTZWxlY3Rpb24ubmVhcih0aGlzLnZpZXcuc3RhdGUuZG9jLnJlc29sdmUocG9zLnBvcykpLCBcInBvaW50ZXJcIik7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2V0U2VsZWN0aW9uT3JpZ2luKHRoaXMudmlldywgXCJwb2ludGVyXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1vdmUoZXZlbnQpIHtcbiAgICAgICAgdGhpcy51cGRhdGVBbGxvd0RlZmF1bHQoZXZlbnQpO1xuICAgICAgICBzZXRTZWxlY3Rpb25PcmlnaW4odGhpcy52aWV3LCBcInBvaW50ZXJcIik7XG4gICAgICAgIGlmIChldmVudC5idXR0b25zID09IDApXG4gICAgICAgICAgICB0aGlzLmRvbmUoKTtcbiAgICB9XG4gICAgdXBkYXRlQWxsb3dEZWZhdWx0KGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5hbGxvd0RlZmF1bHQgJiYgKE1hdGguYWJzKHRoaXMuZXZlbnQueCAtIGV2ZW50LmNsaWVudFgpID4gNCB8fFxuICAgICAgICAgICAgTWF0aC5hYnModGhpcy5ldmVudC55IC0gZXZlbnQuY2xpZW50WSkgPiA0KSlcbiAgICAgICAgICAgIHRoaXMuYWxsb3dEZWZhdWx0ID0gdHJ1ZTtcbiAgICB9XG59XG5oYW5kbGVycy50b3VjaHN0YXJ0ID0gdmlldyA9PiB7XG4gICAgdmlldy5pbnB1dC5sYXN0VG91Y2ggPSBEYXRlLm5vdygpO1xuICAgIGZvcmNlRE9NRmx1c2godmlldyk7XG4gICAgc2V0U2VsZWN0aW9uT3JpZ2luKHZpZXcsIFwicG9pbnRlclwiKTtcbn07XG5oYW5kbGVycy50b3VjaG1vdmUgPSB2aWV3ID0+IHtcbiAgICB2aWV3LmlucHV0Lmxhc3RUb3VjaCA9IERhdGUubm93KCk7XG4gICAgc2V0U2VsZWN0aW9uT3JpZ2luKHZpZXcsIFwicG9pbnRlclwiKTtcbn07XG5oYW5kbGVycy5jb250ZXh0bWVudSA9IHZpZXcgPT4gZm9yY2VET01GbHVzaCh2aWV3KTtcbmZ1bmN0aW9uIGluT3JOZWFyQ29tcG9zaXRpb24odmlldywgZXZlbnQpIHtcbiAgICBpZiAodmlldy5jb21wb3NpbmcpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIC8vIFNlZSBodHRwczovL3d3dy5zdHVtLmRlLzIwMTYvMDYvMjQvaGFuZGxpbmctaW1lLWV2ZW50cy1pbi1qYXZhc2NyaXB0Ly5cbiAgICAvLyBPbiBKYXBhbmVzZSBpbnB1dCBtZXRob2QgZWRpdG9ycyAoSU1FcyksIHRoZSBFbnRlciBrZXkgaXMgdXNlZCB0byBjb25maXJtIGNoYXJhY3RlclxuICAgIC8vIHNlbGVjdGlvbi4gT24gU2FmYXJpLCB3aGVuIEVudGVyIGlzIHByZXNzZWQsIGNvbXBvc2l0aW9uZW5kIGFuZCBrZXlkb3duIGV2ZW50cyBhcmVcbiAgICAvLyBlbWl0dGVkLiBUaGUga2V5ZG93biBldmVudCB0cmlnZ2VycyBuZXdsaW5lIGluc2VydGlvbiwgd2hpY2ggd2UgZG9uJ3Qgd2FudC5cbiAgICAvLyBUaGlzIG1ldGhvZCByZXR1cm5zIHRydWUgaWYgdGhlIGtleWRvd24gZXZlbnQgc2hvdWxkIGJlIGlnbm9yZWQuXG4gICAgLy8gV2Ugb25seSBpZ25vcmUgaXQgb25jZSwgYXMgcHJlc3NpbmcgRW50ZXIgYSBzZWNvbmQgdGltZSAqc2hvdWxkKiBpbnNlcnQgYSBuZXdsaW5lLlxuICAgIC8vIEZ1cnRoZXJtb3JlLCB0aGUga2V5ZG93biBldmVudCB0aW1lc3RhbXAgbXVzdCBiZSBjbG9zZSB0byB0aGUgY29tcG9zaXRpb25FbmRlZEF0IHRpbWVzdGFtcC5cbiAgICAvLyBUaGlzIGd1YXJkcyBhZ2FpbnN0IHRoZSBjYXNlIHdoZXJlIGNvbXBvc2l0aW9uZW5kIGlzIHRyaWdnZXJlZCB3aXRob3V0IHRoZSBrZXlib2FyZFxuICAgIC8vIChlLmcuIGNoYXJhY3RlciBjb25maXJtYXRpb24gbWF5IGJlIGRvbmUgd2l0aCB0aGUgbW91c2UpLCBhbmQga2V5ZG93biBpcyB0cmlnZ2VyZWRcbiAgICAvLyBhZnRlcndhcmRzLSB3ZSB3b3VsZG4ndCB3YW50IHRvIGlnbm9yZSB0aGUga2V5ZG93biBldmVudCBpbiB0aGlzIGNhc2UuXG4gICAgaWYgKHNhZmFyaSAmJiBNYXRoLmFicyhldmVudC50aW1lU3RhbXAgLSB2aWV3LmlucHV0LmNvbXBvc2l0aW9uRW5kZWRBdCkgPCA1MDApIHtcbiAgICAgICAgdmlldy5pbnB1dC5jb21wb3NpdGlvbkVuZGVkQXQgPSAtMmU4O1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8gRHJvcCBhY3RpdmUgY29tcG9zaXRpb24gYWZ0ZXIgNSBzZWNvbmRzIG9mIGluYWN0aXZpdHkgb24gQW5kcm9pZFxuY29uc3QgdGltZW91dENvbXBvc2l0aW9uID0gYW5kcm9pZCA/IDUwMDAgOiAtMTtcbmVkaXRIYW5kbGVycy5jb21wb3NpdGlvbnN0YXJ0ID0gZWRpdEhhbmRsZXJzLmNvbXBvc2l0aW9udXBkYXRlID0gdmlldyA9PiB7XG4gICAgaWYgKCF2aWV3LmNvbXBvc2luZykge1xuICAgICAgICB2aWV3LmRvbU9ic2VydmVyLmZsdXNoKCk7XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSB2aWV3LCAkcG9zID0gc3RhdGUuc2VsZWN0aW9uLiR0bztcbiAgICAgICAgaWYgKHN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24gJiZcbiAgICAgICAgICAgIChzdGF0ZS5zdG9yZWRNYXJrcyB8fFxuICAgICAgICAgICAgICAgICghJHBvcy50ZXh0T2Zmc2V0ICYmICRwb3MucGFyZW50T2Zmc2V0ICYmICRwb3Mubm9kZUJlZm9yZS5tYXJrcy5zb21lKG0gPT4gbS50eXBlLnNwZWMuaW5jbHVzaXZlID09PSBmYWxzZSkpKSkge1xuICAgICAgICAgICAgLy8gTmVlZCB0byB3cmFwIHRoZSBjdXJzb3IgaW4gbWFyayBub2RlcyBkaWZmZXJlbnQgZnJvbSB0aGUgb25lcyBpbiB0aGUgRE9NIGNvbnRleHRcbiAgICAgICAgICAgIHZpZXcubWFya0N1cnNvciA9IHZpZXcuc3RhdGUuc3RvcmVkTWFya3MgfHwgJHBvcy5tYXJrcygpO1xuICAgICAgICAgICAgZW5kQ29tcG9zaXRpb24odmlldywgdHJ1ZSk7XG4gICAgICAgICAgICB2aWV3Lm1hcmtDdXJzb3IgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZW5kQ29tcG9zaXRpb24odmlldywgIXN0YXRlLnNlbGVjdGlvbi5lbXB0eSk7XG4gICAgICAgICAgICAvLyBJbiBmaXJlZm94LCBpZiB0aGUgY3Vyc29yIGlzIGFmdGVyIGJ1dCBvdXRzaWRlIGEgbWFya2VkIG5vZGUsXG4gICAgICAgICAgICAvLyB0aGUgaW5zZXJ0ZWQgdGV4dCB3b24ndCBpbmhlcml0IHRoZSBtYXJrcy4gU28gdGhpcyBtb3ZlcyBpdFxuICAgICAgICAgICAgLy8gaW5zaWRlIGlmIG5lY2Vzc2FyeS5cbiAgICAgICAgICAgIGlmIChnZWNrbyAmJiBzdGF0ZS5zZWxlY3Rpb24uZW1wdHkgJiYgJHBvcy5wYXJlbnRPZmZzZXQgJiYgISRwb3MudGV4dE9mZnNldCAmJiAkcG9zLm5vZGVCZWZvcmUubWFya3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbGV0IHNlbCA9IHZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBub2RlID0gc2VsLmZvY3VzTm9kZSwgb2Zmc2V0ID0gc2VsLmZvY3VzT2Zmc2V0OyBub2RlICYmIG5vZGUubm9kZVR5cGUgPT0gMSAmJiBvZmZzZXQgIT0gMDspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGJlZm9yZSA9IG9mZnNldCA8IDAgPyBub2RlLmxhc3RDaGlsZCA6IG5vZGUuY2hpbGROb2Rlc1tvZmZzZXQgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFiZWZvcmUpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJlZm9yZS5ub2RlVHlwZSA9PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgc2VsID0gdmlldy5kb21TZWxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsLmNvbGxhcHNlKGJlZm9yZSwgYmVmb3JlLm5vZGVWYWx1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gYmVmb3JlO1xuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmlldy5pbnB1dC5jb21wb3NpbmcgPSB0cnVlO1xuICAgIH1cbiAgICBzY2hlZHVsZUNvbXBvc2VFbmQodmlldywgdGltZW91dENvbXBvc2l0aW9uKTtcbn07XG5lZGl0SGFuZGxlcnMuY29tcG9zaXRpb25lbmQgPSAodmlldywgZXZlbnQpID0+IHtcbiAgICBpZiAodmlldy5jb21wb3NpbmcpIHtcbiAgICAgICAgdmlldy5pbnB1dC5jb21wb3NpbmcgPSBmYWxzZTtcbiAgICAgICAgdmlldy5pbnB1dC5jb21wb3NpdGlvbkVuZGVkQXQgPSBldmVudC50aW1lU3RhbXA7XG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaXRpb25QZW5kaW5nQ2hhbmdlcyA9IHZpZXcuZG9tT2JzZXJ2ZXIucGVuZGluZ1JlY29yZHMoKS5sZW5ndGggPyB2aWV3LmlucHV0LmNvbXBvc2l0aW9uSUQgOiAwO1xuICAgICAgICB2aWV3LmlucHV0LmNvbXBvc2l0aW9uTm9kZSA9IG51bGw7XG4gICAgICAgIGlmICh2aWV3LmlucHV0LmNvbXBvc2l0aW9uUGVuZGluZ0NoYW5nZXMpXG4gICAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHZpZXcuZG9tT2JzZXJ2ZXIuZmx1c2goKSk7XG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaXRpb25JRCsrO1xuICAgICAgICBzY2hlZHVsZUNvbXBvc2VFbmQodmlldywgMjApO1xuICAgIH1cbn07XG5mdW5jdGlvbiBzY2hlZHVsZUNvbXBvc2VFbmQodmlldywgZGVsYXkpIHtcbiAgICBjbGVhclRpbWVvdXQodmlldy5pbnB1dC5jb21wb3NpbmdUaW1lb3V0KTtcbiAgICBpZiAoZGVsYXkgPiAtMSlcbiAgICAgICAgdmlldy5pbnB1dC5jb21wb3NpbmdUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiBlbmRDb21wb3NpdGlvbih2aWV3KSwgZGVsYXkpO1xufVxuZnVuY3Rpb24gY2xlYXJDb21wb3NpdGlvbih2aWV3KSB7XG4gICAgaWYgKHZpZXcuY29tcG9zaW5nKSB7XG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaW5nID0gZmFsc2U7XG4gICAgICAgIHZpZXcuaW5wdXQuY29tcG9zaXRpb25FbmRlZEF0ID0gdGltZXN0YW1wRnJvbUN1c3RvbUV2ZW50KCk7XG4gICAgfVxuICAgIHdoaWxlICh2aWV3LmlucHV0LmNvbXBvc2l0aW9uTm9kZXMubGVuZ3RoID4gMClcbiAgICAgICAgdmlldy5pbnB1dC5jb21wb3NpdGlvbk5vZGVzLnBvcCgpLm1hcmtQYXJlbnRzRGlydHkoKTtcbn1cbmZ1bmN0aW9uIGZpbmRDb21wb3NpdGlvbk5vZGUodmlldykge1xuICAgIGxldCBzZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgaWYgKCFzZWwuZm9jdXNOb2RlKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgdGV4dEJlZm9yZSA9IHRleHROb2RlQmVmb3JlJDEoc2VsLmZvY3VzTm9kZSwgc2VsLmZvY3VzT2Zmc2V0KTtcbiAgICBsZXQgdGV4dEFmdGVyID0gdGV4dE5vZGVBZnRlciQxKHNlbC5mb2N1c05vZGUsIHNlbC5mb2N1c09mZnNldCk7XG4gICAgaWYgKHRleHRCZWZvcmUgJiYgdGV4dEFmdGVyICYmIHRleHRCZWZvcmUgIT0gdGV4dEFmdGVyKSB7XG4gICAgICAgIGxldCBkZXNjQWZ0ZXIgPSB0ZXh0QWZ0ZXIucG1WaWV3RGVzYywgbGFzdENoYW5nZWQgPSB2aWV3LmRvbU9ic2VydmVyLmxhc3RDaGFuZ2VkVGV4dE5vZGU7XG4gICAgICAgIGlmICh0ZXh0QmVmb3JlID09IGxhc3RDaGFuZ2VkIHx8IHRleHRBZnRlciA9PSBsYXN0Q2hhbmdlZClcbiAgICAgICAgICAgIHJldHVybiBsYXN0Q2hhbmdlZDtcbiAgICAgICAgaWYgKCFkZXNjQWZ0ZXIgfHwgIWRlc2NBZnRlci5pc1RleHQodGV4dEFmdGVyLm5vZGVWYWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0QWZ0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmlldy5pbnB1dC5jb21wb3NpdGlvbk5vZGUgPT0gdGV4dEFmdGVyKSB7XG4gICAgICAgICAgICBsZXQgZGVzY0JlZm9yZSA9IHRleHRCZWZvcmUucG1WaWV3RGVzYztcbiAgICAgICAgICAgIGlmICghKCFkZXNjQmVmb3JlIHx8ICFkZXNjQmVmb3JlLmlzVGV4dCh0ZXh0QmVmb3JlLm5vZGVWYWx1ZSkpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0QWZ0ZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRleHRCZWZvcmUgfHwgdGV4dEFmdGVyO1xufVxuZnVuY3Rpb24gdGltZXN0YW1wRnJvbUN1c3RvbUV2ZW50KCkge1xuICAgIGxldCBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiRXZlbnRcIik7XG4gICAgZXZlbnQuaW5pdEV2ZW50KFwiZXZlbnRcIiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIGV2ZW50LnRpbWVTdGFtcDtcbn1cbi8qKlxuQGludGVybmFsXG4qL1xuZnVuY3Rpb24gZW5kQ29tcG9zaXRpb24odmlldywgcmVzdGFydGluZyA9IGZhbHNlKSB7XG4gICAgaWYgKGFuZHJvaWQgJiYgdmlldy5kb21PYnNlcnZlci5mbHVzaGluZ1Nvb24gPj0gMClcbiAgICAgICAgcmV0dXJuO1xuICAgIHZpZXcuZG9tT2JzZXJ2ZXIuZm9yY2VGbHVzaCgpO1xuICAgIGNsZWFyQ29tcG9zaXRpb24odmlldyk7XG4gICAgaWYgKHJlc3RhcnRpbmcgfHwgdmlldy5kb2NWaWV3ICYmIHZpZXcuZG9jVmlldy5kaXJ0eSkge1xuICAgICAgICBsZXQgc2VsID0gc2VsZWN0aW9uRnJvbURPTSh2aWV3KSwgY3VyID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGlmIChzZWwgJiYgIXNlbC5lcShjdXIpKVxuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihzZWwpKTtcbiAgICAgICAgZWxzZSBpZiAoKHZpZXcubWFya0N1cnNvciB8fCByZXN0YXJ0aW5nKSAmJiAhY3VyLiRmcm9tLm5vZGUoY3VyLiRmcm9tLnNoYXJlZERlcHRoKGN1ci50bykpLmlubGluZUNvbnRlbnQpXG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHZpZXcuc3RhdGUudHIuZGVsZXRlU2VsZWN0aW9uKCkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB2aWV3LnVwZGF0ZVN0YXRlKHZpZXcuc3RhdGUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY2FwdHVyZUNvcHkodmlldywgZG9tKSB7XG4gICAgLy8gVGhlIGV4dHJhIHdyYXBwZXIgaXMgc29tZWhvdyBuZWNlc3Nhcnkgb24gSUUvRWRnZSB0byBwcmV2ZW50IHRoZVxuICAgIC8vIGNvbnRlbnQgZnJvbSBiZWluZyBtYW5nbGVkIHdoZW4gaXQgaXMgcHV0IG9udG8gdGhlIGNsaXBib2FyZFxuICAgIGlmICghdmlldy5kb20ucGFyZW50Tm9kZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCB3cmFwID0gdmlldy5kb20ucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTtcbiAgICB3cmFwLmFwcGVuZENoaWxkKGRvbSk7XG4gICAgd3JhcC5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjogZml4ZWQ7IGxlZnQ6IC0xMDAwMHB4OyB0b3A6IDEwcHhcIjtcbiAgICBsZXQgc2VsID0gZ2V0U2VsZWN0aW9uKCksIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICByYW5nZS5zZWxlY3ROb2RlQ29udGVudHMoZG9tKTtcbiAgICAvLyBEb25lIGJlY2F1c2UgSUUgd2lsbCBmaXJlIGEgc2VsZWN0aW9uY2hhbmdlIG1vdmluZyB0aGUgc2VsZWN0aW9uXG4gICAgLy8gdG8gaXRzIHN0YXJ0IHdoZW4gcmVtb3ZlQWxsUmFuZ2VzIGlzIGNhbGxlZCBhbmQgdGhlIGVkaXRvciBzdGlsbFxuICAgIC8vIGhhcyBmb2N1cyAod2hpY2ggd2lsbCBtZXNzIHVwIHRoZSBlZGl0b3IncyBzZWxlY3Rpb24gc3RhdGUpLlxuICAgIHZpZXcuZG9tLmJsdXIoKTtcbiAgICBzZWwucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgc2VsLmFkZFJhbmdlKHJhbmdlKTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHdyYXAucGFyZW50Tm9kZSlcbiAgICAgICAgICAgIHdyYXAucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh3cmFwKTtcbiAgICAgICAgdmlldy5mb2N1cygpO1xuICAgIH0sIDUwKTtcbn1cbi8vIFRoaXMgaXMgdmVyeSBjcnVkZSwgYnV0IHVuZm9ydHVuYXRlbHkgYm90aCB0aGVzZSBicm93c2VycyBfcHJldGVuZF9cbi8vIHRoYXQgdGhleSBoYXZlIGEgY2xpcGJvYXJkIEFQSeKAlGFsbCB0aGUgb2JqZWN0cyBhbmQgbWV0aG9kcyBhcmVcbi8vIHRoZXJlLCB0aGV5IGp1c3QgZG9uJ3Qgd29yaywgYW5kIHRoZXkgYXJlIGhhcmQgdG8gdGVzdC5cbmNvbnN0IGJyb2tlbkNsaXBib2FyZEFQSSA9IChpZSAmJiBpZV92ZXJzaW9uIDwgMTUpIHx8XG4gICAgKGlvcyAmJiB3ZWJraXRfdmVyc2lvbiA8IDYwNCk7XG5oYW5kbGVycy5jb3B5ID0gZWRpdEhhbmRsZXJzLmN1dCA9ICh2aWV3LCBfZXZlbnQpID0+IHtcbiAgICBsZXQgZXZlbnQgPSBfZXZlbnQ7XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLCBjdXQgPSBldmVudC50eXBlID09IFwiY3V0XCI7XG4gICAgaWYgKHNlbC5lbXB0eSlcbiAgICAgICAgcmV0dXJuO1xuICAgIC8vIElFIGFuZCBFZGdlJ3MgY2xpcGJvYXJkIGludGVyZmFjZSBpcyBjb21wbGV0ZWx5IGJyb2tlblxuICAgIGxldCBkYXRhID0gYnJva2VuQ2xpcGJvYXJkQVBJID8gbnVsbCA6IGV2ZW50LmNsaXBib2FyZERhdGE7XG4gICAgbGV0IHNsaWNlID0gc2VsLmNvbnRlbnQoKSwgeyBkb20sIHRleHQgfSA9IHNlcmlhbGl6ZUZvckNsaXBib2FyZCh2aWV3LCBzbGljZSk7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZGF0YS5jbGVhckRhdGEoKTtcbiAgICAgICAgZGF0YS5zZXREYXRhKFwidGV4dC9odG1sXCIsIGRvbS5pbm5lckhUTUwpO1xuICAgICAgICBkYXRhLnNldERhdGEoXCJ0ZXh0L3BsYWluXCIsIHRleHQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY2FwdHVyZUNvcHkodmlldywgZG9tKTtcbiAgICB9XG4gICAgaWYgKGN1dClcbiAgICAgICAgdmlldy5kaXNwYXRjaCh2aWV3LnN0YXRlLnRyLmRlbGV0ZVNlbGVjdGlvbigpLnNjcm9sbEludG9WaWV3KCkuc2V0TWV0YShcInVpRXZlbnRcIiwgXCJjdXRcIikpO1xufTtcbmZ1bmN0aW9uIHNsaWNlU2luZ2xlTm9kZShzbGljZSkge1xuICAgIHJldHVybiBzbGljZS5vcGVuU3RhcnQgPT0gMCAmJiBzbGljZS5vcGVuRW5kID09IDAgJiYgc2xpY2UuY29udGVudC5jaGlsZENvdW50ID09IDEgPyBzbGljZS5jb250ZW50LmZpcnN0Q2hpbGQgOiBudWxsO1xufVxuZnVuY3Rpb24gY2FwdHVyZVBhc3RlKHZpZXcsIGV2ZW50KSB7XG4gICAgaWYgKCF2aWV3LmRvbS5wYXJlbnROb2RlKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IHBsYWluVGV4dCA9IHZpZXcuaW5wdXQuc2hpZnRLZXkgfHwgdmlldy5zdGF0ZS5zZWxlY3Rpb24uJGZyb20ucGFyZW50LnR5cGUuc3BlYy5jb2RlO1xuICAgIGxldCB0YXJnZXQgPSB2aWV3LmRvbS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQocGxhaW5UZXh0ID8gXCJ0ZXh0YXJlYVwiIDogXCJkaXZcIikpO1xuICAgIGlmICghcGxhaW5UZXh0KVxuICAgICAgICB0YXJnZXQuY29udGVudEVkaXRhYmxlID0gXCJ0cnVlXCI7XG4gICAgdGFyZ2V0LnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOiBmaXhlZDsgbGVmdDogLTEwMDAwcHg7IHRvcDogMTBweFwiO1xuICAgIHRhcmdldC5mb2N1cygpO1xuICAgIGxldCBwbGFpbiA9IHZpZXcuaW5wdXQuc2hpZnRLZXkgJiYgdmlldy5pbnB1dC5sYXN0S2V5Q29kZSAhPSA0NTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdmlldy5mb2N1cygpO1xuICAgICAgICBpZiAodGFyZ2V0LnBhcmVudE5vZGUpXG4gICAgICAgICAgICB0YXJnZXQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0YXJnZXQpO1xuICAgICAgICBpZiAocGxhaW5UZXh0KVxuICAgICAgICAgICAgZG9QYXN0ZSh2aWV3LCB0YXJnZXQudmFsdWUsIG51bGwsIHBsYWluLCBldmVudCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRvUGFzdGUodmlldywgdGFyZ2V0LnRleHRDb250ZW50LCB0YXJnZXQuaW5uZXJIVE1MLCBwbGFpbiwgZXZlbnQpO1xuICAgIH0sIDUwKTtcbn1cbmZ1bmN0aW9uIGRvUGFzdGUodmlldywgdGV4dCwgaHRtbCwgcHJlZmVyUGxhaW4sIGV2ZW50KSB7XG4gICAgbGV0IHNsaWNlID0gcGFyc2VGcm9tQ2xpcGJvYXJkKHZpZXcsIHRleHQsIGh0bWwsIHByZWZlclBsYWluLCB2aWV3LnN0YXRlLnNlbGVjdGlvbi4kZnJvbSk7XG4gICAgaWYgKHZpZXcuc29tZVByb3AoXCJoYW5kbGVQYXN0ZVwiLCBmID0+IGYodmlldywgZXZlbnQsIHNsaWNlIHx8IFNsaWNlLmVtcHR5KSkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmICghc2xpY2UpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgc2luZ2xlTm9kZSA9IHNsaWNlU2luZ2xlTm9kZShzbGljZSk7XG4gICAgbGV0IHRyID0gc2luZ2xlTm9kZVxuICAgICAgICA/IHZpZXcuc3RhdGUudHIucmVwbGFjZVNlbGVjdGlvbldpdGgoc2luZ2xlTm9kZSwgcHJlZmVyUGxhaW4pXG4gICAgICAgIDogdmlldy5zdGF0ZS50ci5yZXBsYWNlU2VsZWN0aW9uKHNsaWNlKTtcbiAgICB2aWV3LmRpc3BhdGNoKHRyLnNjcm9sbEludG9WaWV3KCkuc2V0TWV0YShcInBhc3RlXCIsIHRydWUpLnNldE1ldGEoXCJ1aUV2ZW50XCIsIFwicGFzdGVcIikpO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZ2V0VGV4dChjbGlwYm9hcmREYXRhKSB7XG4gICAgbGV0IHRleHQgPSBjbGlwYm9hcmREYXRhLmdldERhdGEoXCJ0ZXh0L3BsYWluXCIpIHx8IGNsaXBib2FyZERhdGEuZ2V0RGF0YShcIlRleHRcIik7XG4gICAgaWYgKHRleHQpXG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIGxldCB1cmlzID0gY2xpcGJvYXJkRGF0YS5nZXREYXRhKFwidGV4dC91cmktbGlzdFwiKTtcbiAgICByZXR1cm4gdXJpcyA/IHVyaXMucmVwbGFjZSgvXFxyP1xcbi9nLCBcIiBcIikgOiBcIlwiO1xufVxuZWRpdEhhbmRsZXJzLnBhc3RlID0gKHZpZXcsIF9ldmVudCkgPT4ge1xuICAgIGxldCBldmVudCA9IF9ldmVudDtcbiAgICAvLyBIYW5kbGluZyBwYXN0ZSBmcm9tIEphdmFTY3JpcHQgZHVyaW5nIGNvbXBvc2l0aW9uIGlzIHZlcnkgcG9vcmx5XG4gICAgLy8gaGFuZGxlZCBieSBicm93c2Vycywgc28gYXMgYSBkb2RneSBidXQgcHJlZmVyYWJsZSBrbHVkZ2UsIHdlIGp1c3RcbiAgICAvLyBsZXQgdGhlIGJyb3dzZXIgZG8gaXRzIG5hdGl2ZSB0aGluZyB0aGVyZSwgZXhjZXB0IG9uIEFuZHJvaWQsXG4gICAgLy8gd2hlcmUgdGhlIGVkaXRvciBpcyBhbG1vc3QgYWx3YXlzIGNvbXBvc2luZy5cbiAgICBpZiAodmlldy5jb21wb3NpbmcgJiYgIWFuZHJvaWQpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgZGF0YSA9IGJyb2tlbkNsaXBib2FyZEFQSSA/IG51bGwgOiBldmVudC5jbGlwYm9hcmREYXRhO1xuICAgIGxldCBwbGFpbiA9IHZpZXcuaW5wdXQuc2hpZnRLZXkgJiYgdmlldy5pbnB1dC5sYXN0S2V5Q29kZSAhPSA0NTtcbiAgICBpZiAoZGF0YSAmJiBkb1Bhc3RlKHZpZXcsIGdldFRleHQoZGF0YSksIGRhdGEuZ2V0RGF0YShcInRleHQvaHRtbFwiKSwgcGxhaW4sIGV2ZW50KSlcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBlbHNlXG4gICAgICAgIGNhcHR1cmVQYXN0ZSh2aWV3LCBldmVudCk7XG59O1xuY2xhc3MgRHJhZ2dpbmcge1xuICAgIGNvbnN0cnVjdG9yKHNsaWNlLCBtb3ZlLCBub2RlKSB7XG4gICAgICAgIHRoaXMuc2xpY2UgPSBzbGljZTtcbiAgICAgICAgdGhpcy5tb3ZlID0gbW92ZTtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICB9XG59XG5jb25zdCBkcmFnQ29weU1vZGlmaWVyID0gbWFjID8gXCJhbHRLZXlcIiA6IFwiY3RybEtleVwiO1xuZnVuY3Rpb24gZHJhZ01vdmVzKHZpZXcsIGV2ZW50KSB7XG4gICAgbGV0IG1vdmVzID0gdmlldy5zb21lUHJvcChcImRyYWdDb3BpZXNcIiwgdGVzdCA9PiAhdGVzdChldmVudCkpO1xuICAgIHJldHVybiBtb3ZlcyAhPSBudWxsID8gbW92ZXMgOiAhZXZlbnRbZHJhZ0NvcHlNb2RpZmllcl07XG59XG5oYW5kbGVycy5kcmFnc3RhcnQgPSAodmlldywgX2V2ZW50KSA9PiB7XG4gICAgbGV0IGV2ZW50ID0gX2V2ZW50O1xuICAgIGxldCBtb3VzZURvd24gPSB2aWV3LmlucHV0Lm1vdXNlRG93bjtcbiAgICBpZiAobW91c2VEb3duKVxuICAgICAgICBtb3VzZURvd24uZG9uZSgpO1xuICAgIGlmICghZXZlbnQuZGF0YVRyYW5zZmVyKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIGxldCBwb3MgPSBzZWwuZW1wdHkgPyBudWxsIDogdmlldy5wb3NBdENvb3JkcyhldmVudENvb3JkcyhldmVudCkpO1xuICAgIGxldCBub2RlO1xuICAgIGlmIChwb3MgJiYgcG9zLnBvcyA+PSBzZWwuZnJvbSAmJiBwb3MucG9zIDw9IChzZWwgaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uID8gc2VsLnRvIC0gMSA6IHNlbC50bykpIDtcbiAgICBlbHNlIGlmIChtb3VzZURvd24gJiYgbW91c2VEb3duLm1pZ2h0RHJhZykge1xuICAgICAgICBub2RlID0gTm9kZVNlbGVjdGlvbi5jcmVhdGUodmlldy5zdGF0ZS5kb2MsIG1vdXNlRG93bi5taWdodERyYWcucG9zKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXZlbnQudGFyZ2V0ICYmIGV2ZW50LnRhcmdldC5ub2RlVHlwZSA9PSAxKSB7XG4gICAgICAgIGxldCBkZXNjID0gdmlldy5kb2NWaWV3Lm5lYXJlc3REZXNjKGV2ZW50LnRhcmdldCwgdHJ1ZSk7XG4gICAgICAgIGlmIChkZXNjICYmIGRlc2Mubm9kZS50eXBlLnNwZWMuZHJhZ2dhYmxlICYmIGRlc2MgIT0gdmlldy5kb2NWaWV3KVxuICAgICAgICAgICAgbm9kZSA9IE5vZGVTZWxlY3Rpb24uY3JlYXRlKHZpZXcuc3RhdGUuZG9jLCBkZXNjLnBvc0JlZm9yZSk7XG4gICAgfVxuICAgIGxldCBkcmFnZ2VkU2xpY2UgPSAobm9kZSB8fCB2aWV3LnN0YXRlLnNlbGVjdGlvbikuY29udGVudCgpO1xuICAgIGxldCB7IGRvbSwgdGV4dCwgc2xpY2UgfSA9IHNlcmlhbGl6ZUZvckNsaXBib2FyZCh2aWV3LCBkcmFnZ2VkU2xpY2UpO1xuICAgIC8vIFByZS0xMjAgQ2hyb21lIHZlcnNpb25zIGNsZWFyIGZpbGVzIHdoZW4gY2FsbGluZyBgY2xlYXJEYXRhYCAoIzE0NzIpXG4gICAgaWYgKCFldmVudC5kYXRhVHJhbnNmZXIuZmlsZXMubGVuZ3RoIHx8ICFjaHJvbWUgfHwgY2hyb21lX3ZlcnNpb24gPiAxMjApXG4gICAgICAgIGV2ZW50LmRhdGFUcmFuc2Zlci5jbGVhckRhdGEoKTtcbiAgICBldmVudC5kYXRhVHJhbnNmZXIuc2V0RGF0YShicm9rZW5DbGlwYm9hcmRBUEkgPyBcIlRleHRcIiA6IFwidGV4dC9odG1sXCIsIGRvbS5pbm5lckhUTUwpO1xuICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vUHJvc2VNaXJyb3IvcHJvc2VtaXJyb3IvaXNzdWVzLzExNTZcbiAgICBldmVudC5kYXRhVHJhbnNmZXIuZWZmZWN0QWxsb3dlZCA9IFwiY29weU1vdmVcIjtcbiAgICBpZiAoIWJyb2tlbkNsaXBib2FyZEFQSSlcbiAgICAgICAgZXZlbnQuZGF0YVRyYW5zZmVyLnNldERhdGEoXCJ0ZXh0L3BsYWluXCIsIHRleHQpO1xuICAgIHZpZXcuZHJhZ2dpbmcgPSBuZXcgRHJhZ2dpbmcoc2xpY2UsIGRyYWdNb3Zlcyh2aWV3LCBldmVudCksIG5vZGUpO1xufTtcbmhhbmRsZXJzLmRyYWdlbmQgPSB2aWV3ID0+IHtcbiAgICBsZXQgZHJhZ2dpbmcgPSB2aWV3LmRyYWdnaW5nO1xuICAgIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKHZpZXcuZHJhZ2dpbmcgPT0gZHJhZ2dpbmcpXG4gICAgICAgICAgICB2aWV3LmRyYWdnaW5nID0gbnVsbDtcbiAgICB9LCA1MCk7XG59O1xuZWRpdEhhbmRsZXJzLmRyYWdvdmVyID0gZWRpdEhhbmRsZXJzLmRyYWdlbnRlciA9IChfLCBlKSA9PiBlLnByZXZlbnREZWZhdWx0KCk7XG5lZGl0SGFuZGxlcnMuZHJvcCA9ICh2aWV3LCBfZXZlbnQpID0+IHtcbiAgICBsZXQgZXZlbnQgPSBfZXZlbnQ7XG4gICAgbGV0IGRyYWdnaW5nID0gdmlldy5kcmFnZ2luZztcbiAgICB2aWV3LmRyYWdnaW5nID0gbnVsbDtcbiAgICBpZiAoIWV2ZW50LmRhdGFUcmFuc2ZlcilcbiAgICAgICAgcmV0dXJuO1xuICAgIGxldCBldmVudFBvcyA9IHZpZXcucG9zQXRDb29yZHMoZXZlbnRDb29yZHMoZXZlbnQpKTtcbiAgICBpZiAoIWV2ZW50UG9zKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0ICRtb3VzZSA9IHZpZXcuc3RhdGUuZG9jLnJlc29sdmUoZXZlbnRQb3MucG9zKTtcbiAgICBsZXQgc2xpY2UgPSBkcmFnZ2luZyAmJiBkcmFnZ2luZy5zbGljZTtcbiAgICBpZiAoc2xpY2UpIHtcbiAgICAgICAgdmlldy5zb21lUHJvcChcInRyYW5zZm9ybVBhc3RlZFwiLCBmID0+IHsgc2xpY2UgPSBmKHNsaWNlLCB2aWV3LCBmYWxzZSk7IH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2xpY2UgPSBwYXJzZUZyb21DbGlwYm9hcmQodmlldywgZ2V0VGV4dChldmVudC5kYXRhVHJhbnNmZXIpLCBicm9rZW5DbGlwYm9hcmRBUEkgPyBudWxsIDogZXZlbnQuZGF0YVRyYW5zZmVyLmdldERhdGEoXCJ0ZXh0L2h0bWxcIiksIGZhbHNlLCAkbW91c2UpO1xuICAgIH1cbiAgICBsZXQgbW92ZSA9ICEhKGRyYWdnaW5nICYmIGRyYWdNb3Zlcyh2aWV3LCBldmVudCkpO1xuICAgIGlmICh2aWV3LnNvbWVQcm9wKFwiaGFuZGxlRHJvcFwiLCBmID0+IGYodmlldywgZXZlbnQsIHNsaWNlIHx8IFNsaWNlLmVtcHR5LCBtb3ZlKSkpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXNsaWNlKVxuICAgICAgICByZXR1cm47XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBsZXQgaW5zZXJ0UG9zID0gc2xpY2UgPyBkcm9wUG9pbnQodmlldy5zdGF0ZS5kb2MsICRtb3VzZS5wb3MsIHNsaWNlKSA6ICRtb3VzZS5wb3M7XG4gICAgaWYgKGluc2VydFBvcyA9PSBudWxsKVxuICAgICAgICBpbnNlcnRQb3MgPSAkbW91c2UucG9zO1xuICAgIGxldCB0ciA9IHZpZXcuc3RhdGUudHI7XG4gICAgaWYgKG1vdmUpIHtcbiAgICAgICAgbGV0IHsgbm9kZSB9ID0gZHJhZ2dpbmc7XG4gICAgICAgIGlmIChub2RlKVxuICAgICAgICAgICAgbm9kZS5yZXBsYWNlKHRyKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdHIuZGVsZXRlU2VsZWN0aW9uKCk7XG4gICAgfVxuICAgIGxldCBwb3MgPSB0ci5tYXBwaW5nLm1hcChpbnNlcnRQb3MpO1xuICAgIGxldCBpc05vZGUgPSBzbGljZS5vcGVuU3RhcnQgPT0gMCAmJiBzbGljZS5vcGVuRW5kID09IDAgJiYgc2xpY2UuY29udGVudC5jaGlsZENvdW50ID09IDE7XG4gICAgbGV0IGJlZm9yZUluc2VydCA9IHRyLmRvYztcbiAgICBpZiAoaXNOb2RlKVxuICAgICAgICB0ci5yZXBsYWNlUmFuZ2VXaXRoKHBvcywgcG9zLCBzbGljZS5jb250ZW50LmZpcnN0Q2hpbGQpO1xuICAgIGVsc2VcbiAgICAgICAgdHIucmVwbGFjZVJhbmdlKHBvcywgcG9zLCBzbGljZSk7XG4gICAgaWYgKHRyLmRvYy5lcShiZWZvcmVJbnNlcnQpKVxuICAgICAgICByZXR1cm47XG4gICAgbGV0ICRwb3MgPSB0ci5kb2MucmVzb2x2ZShwb3MpO1xuICAgIGlmIChpc05vZGUgJiYgTm9kZVNlbGVjdGlvbi5pc1NlbGVjdGFibGUoc2xpY2UuY29udGVudC5maXJzdENoaWxkKSAmJlxuICAgICAgICAkcG9zLm5vZGVBZnRlciAmJiAkcG9zLm5vZGVBZnRlci5zYW1lTWFya3VwKHNsaWNlLmNvbnRlbnQuZmlyc3RDaGlsZCkpIHtcbiAgICAgICAgdHIuc2V0U2VsZWN0aW9uKG5ldyBOb2RlU2VsZWN0aW9uKCRwb3MpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBlbmQgPSB0ci5tYXBwaW5nLm1hcChpbnNlcnRQb3MpO1xuICAgICAgICB0ci5tYXBwaW5nLm1hcHNbdHIubWFwcGluZy5tYXBzLmxlbmd0aCAtIDFdLmZvckVhY2goKF9mcm9tLCBfdG8sIF9uZXdGcm9tLCBuZXdUbykgPT4gZW5kID0gbmV3VG8pO1xuICAgICAgICB0ci5zZXRTZWxlY3Rpb24oc2VsZWN0aW9uQmV0d2Vlbih2aWV3LCAkcG9zLCB0ci5kb2MucmVzb2x2ZShlbmQpKSk7XG4gICAgfVxuICAgIHZpZXcuZm9jdXMoKTtcbiAgICB2aWV3LmRpc3BhdGNoKHRyLnNldE1ldGEoXCJ1aUV2ZW50XCIsIFwiZHJvcFwiKSk7XG59O1xuaGFuZGxlcnMuZm9jdXMgPSB2aWV3ID0+IHtcbiAgICB2aWV3LmlucHV0Lmxhc3RGb2N1cyA9IERhdGUubm93KCk7XG4gICAgaWYgKCF2aWV3LmZvY3VzZWQpIHtcbiAgICAgICAgdmlldy5kb21PYnNlcnZlci5zdG9wKCk7XG4gICAgICAgIHZpZXcuZG9tLmNsYXNzTGlzdC5hZGQoXCJQcm9zZU1pcnJvci1mb2N1c2VkXCIpO1xuICAgICAgICB2aWV3LmRvbU9ic2VydmVyLnN0YXJ0KCk7XG4gICAgICAgIHZpZXcuZm9jdXNlZCA9IHRydWU7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHZpZXcuZG9jVmlldyAmJiB2aWV3Lmhhc0ZvY3VzKCkgJiYgIXZpZXcuZG9tT2JzZXJ2ZXIuY3VycmVudFNlbGVjdGlvbi5lcSh2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCkpKVxuICAgICAgICAgICAgICAgIHNlbGVjdGlvblRvRE9NKHZpZXcpO1xuICAgICAgICB9LCAyMCk7XG4gICAgfVxufTtcbmhhbmRsZXJzLmJsdXIgPSAodmlldywgX2V2ZW50KSA9PiB7XG4gICAgbGV0IGV2ZW50ID0gX2V2ZW50O1xuICAgIGlmICh2aWV3LmZvY3VzZWQpIHtcbiAgICAgICAgdmlldy5kb21PYnNlcnZlci5zdG9wKCk7XG4gICAgICAgIHZpZXcuZG9tLmNsYXNzTGlzdC5yZW1vdmUoXCJQcm9zZU1pcnJvci1mb2N1c2VkXCIpO1xuICAgICAgICB2aWV3LmRvbU9ic2VydmVyLnN0YXJ0KCk7XG4gICAgICAgIGlmIChldmVudC5yZWxhdGVkVGFyZ2V0ICYmIHZpZXcuZG9tLmNvbnRhaW5zKGV2ZW50LnJlbGF0ZWRUYXJnZXQpKVxuICAgICAgICAgICAgdmlldy5kb21PYnNlcnZlci5jdXJyZW50U2VsZWN0aW9uLmNsZWFyKCk7XG4gICAgICAgIHZpZXcuZm9jdXNlZCA9IGZhbHNlO1xuICAgIH1cbn07XG5oYW5kbGVycy5iZWZvcmVpbnB1dCA9ICh2aWV3LCBfZXZlbnQpID0+IHtcbiAgICBsZXQgZXZlbnQgPSBfZXZlbnQ7XG4gICAgLy8gV2Ugc2hvdWxkIHByb2JhYmx5IGRvIG1vcmUgd2l0aCBiZWZvcmVpbnB1dCBldmVudHMsIGJ1dCBzdXBwb3J0XG4gICAgLy8gaXMgc28gc3BvdHR5IHRoYXQgSSdtIHN0aWxsIHdhaXRpbmcgdG8gc2VlIHdoZXJlIHRoZXkgYXJlIGdvaW5nLlxuICAgIC8vIFZlcnkgc3BlY2lmaWMgaGFjayB0byBkZWFsIHdpdGggYmFja3NwYWNlIHNvbWV0aW1lcyBmYWlsaW5nIG9uXG4gICAgLy8gQ2hyb21lIEFuZHJvaWQgd2hlbiBhZnRlciBhbiB1bmVkaXRhYmxlIG5vZGUuXG4gICAgaWYgKGNocm9tZSAmJiBhbmRyb2lkICYmIGV2ZW50LmlucHV0VHlwZSA9PSBcImRlbGV0ZUNvbnRlbnRCYWNrd2FyZFwiKSB7XG4gICAgICAgIHZpZXcuZG9tT2JzZXJ2ZXIuZmx1c2hTb29uKCk7XG4gICAgICAgIGxldCB7IGRvbUNoYW5nZUNvdW50IH0gPSB2aWV3LmlucHV0O1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh2aWV3LmlucHV0LmRvbUNoYW5nZUNvdW50ICE9IGRvbUNoYW5nZUNvdW50KVxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gRXZlbnQgYWxyZWFkeSBoYWQgc29tZSBlZmZlY3RcbiAgICAgICAgICAgIC8vIFRoaXMgYnVnIHRlbmRzIHRvIGNsb3NlIHRoZSB2aXJ0dWFsIGtleWJvYXJkLCBzbyB3ZSByZWZvY3VzXG4gICAgICAgICAgICB2aWV3LmRvbS5ibHVyKCk7XG4gICAgICAgICAgICB2aWV3LmZvY3VzKCk7XG4gICAgICAgICAgICBpZiAodmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZiA9PiBmKHZpZXcsIGtleUV2ZW50KDgsIFwiQmFja3NwYWNlXCIpKSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHsgJGN1cnNvciB9ID0gdmlldy5zdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgICAgICAvLyBDcnVkZSBhcHByb3hpbWF0aW9uIG9mIGJhY2tzcGFjZSBiZWhhdmlvciB3aGVuIG5vIGNvbW1hbmQgaGFuZGxlZCBpdFxuICAgICAgICAgICAgaWYgKCRjdXJzb3IgJiYgJGN1cnNvci5wb3MgPiAwKVxuICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS50ci5kZWxldGUoJGN1cnNvci5wb3MgLSAxLCAkY3Vyc29yLnBvcykuc2Nyb2xsSW50b1ZpZXcoKSk7XG4gICAgICAgIH0sIDUwKTtcbiAgICB9XG59O1xuLy8gTWFrZSBzdXJlIGFsbCBoYW5kbGVycyBnZXQgcmVnaXN0ZXJlZFxuZm9yIChsZXQgcHJvcCBpbiBlZGl0SGFuZGxlcnMpXG4gICAgaGFuZGxlcnNbcHJvcF0gPSBlZGl0SGFuZGxlcnNbcHJvcF07XG5cbmZ1bmN0aW9uIGNvbXBhcmVPYmpzKGEsIGIpIHtcbiAgICBpZiAoYSA9PSBiKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBmb3IgKGxldCBwIGluIGEpXG4gICAgICAgIGlmIChhW3BdICE9PSBiW3BdKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IHAgaW4gYilcbiAgICAgICAgaWYgKCEocCBpbiBhKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmNsYXNzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKHRvRE9NLCBzcGVjKSB7XG4gICAgICAgIHRoaXMudG9ET00gPSB0b0RPTTtcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYyB8fCBub1NwZWM7XG4gICAgICAgIHRoaXMuc2lkZSA9IHRoaXMuc3BlYy5zaWRlIHx8IDA7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nLCBzcGFuLCBvZmZzZXQsIG9sZE9mZnNldCkge1xuICAgICAgICBsZXQgeyBwb3MsIGRlbGV0ZWQgfSA9IG1hcHBpbmcubWFwUmVzdWx0KHNwYW4uZnJvbSArIG9sZE9mZnNldCwgdGhpcy5zaWRlIDwgMCA/IC0xIDogMSk7XG4gICAgICAgIHJldHVybiBkZWxldGVkID8gbnVsbCA6IG5ldyBEZWNvcmF0aW9uKHBvcyAtIG9mZnNldCwgcG9zIC0gb2Zmc2V0LCB0aGlzKTtcbiAgICB9XG4gICAgdmFsaWQoKSB7IHJldHVybiB0cnVlOyB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHxcbiAgICAgICAgICAgIChvdGhlciBpbnN0YW5jZW9mIFdpZGdldFR5cGUgJiZcbiAgICAgICAgICAgICAgICAodGhpcy5zcGVjLmtleSAmJiB0aGlzLnNwZWMua2V5ID09IG90aGVyLnNwZWMua2V5IHx8XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudG9ET00gPT0gb3RoZXIudG9ET00gJiYgY29tcGFyZU9ianModGhpcy5zcGVjLCBvdGhlci5zcGVjKSkpO1xuICAgIH1cbiAgICBkZXN0cm95KG5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMuc3BlYy5kZXN0cm95KVxuICAgICAgICAgICAgdGhpcy5zcGVjLmRlc3Ryb3kobm9kZSk7XG4gICAgfVxufVxuY2xhc3MgSW5saW5lVHlwZSB7XG4gICAgY29uc3RydWN0b3IoYXR0cnMsIHNwZWMpIHtcbiAgICAgICAgdGhpcy5hdHRycyA9IGF0dHJzO1xuICAgICAgICB0aGlzLnNwZWMgPSBzcGVjIHx8IG5vU3BlYztcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcsIHNwYW4sIG9mZnNldCwgb2xkT2Zmc2V0KSB7XG4gICAgICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXAoc3Bhbi5mcm9tICsgb2xkT2Zmc2V0LCB0aGlzLnNwZWMuaW5jbHVzaXZlU3RhcnQgPyAtMSA6IDEpIC0gb2Zmc2V0O1xuICAgICAgICBsZXQgdG8gPSBtYXBwaW5nLm1hcChzcGFuLnRvICsgb2xkT2Zmc2V0LCB0aGlzLnNwZWMuaW5jbHVzaXZlRW5kID8gMSA6IC0xKSAtIG9mZnNldDtcbiAgICAgICAgcmV0dXJuIGZyb20gPj0gdG8gPyBudWxsIDogbmV3IERlY29yYXRpb24oZnJvbSwgdG8sIHRoaXMpO1xuICAgIH1cbiAgICB2YWxpZChfLCBzcGFuKSB7IHJldHVybiBzcGFuLmZyb20gPCBzcGFuLnRvOyB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMgPT0gb3RoZXIgfHxcbiAgICAgICAgICAgIChvdGhlciBpbnN0YW5jZW9mIElubGluZVR5cGUgJiYgY29tcGFyZU9ianModGhpcy5hdHRycywgb3RoZXIuYXR0cnMpICYmXG4gICAgICAgICAgICAgICAgY29tcGFyZU9ianModGhpcy5zcGVjLCBvdGhlci5zcGVjKSk7XG4gICAgfVxuICAgIHN0YXRpYyBpcyhzcGFuKSB7IHJldHVybiBzcGFuLnR5cGUgaW5zdGFuY2VvZiBJbmxpbmVUeXBlOyB9XG4gICAgZGVzdHJveSgpIHsgfVxufVxuY2xhc3MgTm9kZVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKGF0dHJzLCBzcGVjKSB7XG4gICAgICAgIHRoaXMuYXR0cnMgPSBhdHRycztcbiAgICAgICAgdGhpcy5zcGVjID0gc3BlYyB8fCBub1NwZWM7XG4gICAgfVxuICAgIG1hcChtYXBwaW5nLCBzcGFuLCBvZmZzZXQsIG9sZE9mZnNldCkge1xuICAgICAgICBsZXQgZnJvbSA9IG1hcHBpbmcubWFwUmVzdWx0KHNwYW4uZnJvbSArIG9sZE9mZnNldCwgMSk7XG4gICAgICAgIGlmIChmcm9tLmRlbGV0ZWQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IHRvID0gbWFwcGluZy5tYXBSZXN1bHQoc3Bhbi50byArIG9sZE9mZnNldCwgLTEpO1xuICAgICAgICBpZiAodG8uZGVsZXRlZCB8fCB0by5wb3MgPD0gZnJvbS5wb3MpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNvcmF0aW9uKGZyb20ucG9zIC0gb2Zmc2V0LCB0by5wb3MgLSBvZmZzZXQsIHRoaXMpO1xuICAgIH1cbiAgICB2YWxpZChub2RlLCBzcGFuKSB7XG4gICAgICAgIGxldCB7IGluZGV4LCBvZmZzZXQgfSA9IG5vZGUuY29udGVudC5maW5kSW5kZXgoc3Bhbi5mcm9tKSwgY2hpbGQ7XG4gICAgICAgIHJldHVybiBvZmZzZXQgPT0gc3Bhbi5mcm9tICYmICEoY2hpbGQgPSBub2RlLmNoaWxkKGluZGV4KSkuaXNUZXh0ICYmIG9mZnNldCArIGNoaWxkLm5vZGVTaXplID09IHNwYW4udG87XG4gICAgfVxuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzID09IG90aGVyIHx8XG4gICAgICAgICAgICAob3RoZXIgaW5zdGFuY2VvZiBOb2RlVHlwZSAmJiBjb21wYXJlT2Jqcyh0aGlzLmF0dHJzLCBvdGhlci5hdHRycykgJiZcbiAgICAgICAgICAgICAgICBjb21wYXJlT2Jqcyh0aGlzLnNwZWMsIG90aGVyLnNwZWMpKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHsgfVxufVxuLyoqXG5EZWNvcmF0aW9uIG9iamVjdHMgY2FuIGJlIHByb3ZpZGVkIHRvIHRoZSB2aWV3IHRocm91Z2ggdGhlXG5bYGRlY29yYXRpb25zYCBwcm9wXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5FZGl0b3JQcm9wcy5kZWNvcmF0aW9ucykuIFRoZXkgY29tZSBpblxuc2V2ZXJhbCB2YXJpYW50c+KAlHNlZSB0aGUgc3RhdGljIG1lbWJlcnMgb2YgdGhpcyBjbGFzcyBmb3IgZGV0YWlscy5cbiovXG5jbGFzcyBEZWNvcmF0aW9uIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgZGVjb3JhdGlvbi5cbiAgICAqL1xuICAgIGZyb20sIFxuICAgIC8qKlxuICAgIFRoZSBlbmQgcG9zaXRpb24uIFdpbGwgYmUgdGhlIHNhbWUgYXMgYGZyb21gIGZvciBbd2lkZ2V0XG4gICAgZGVjb3JhdGlvbnNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3LkRlY29yYXRpb25ed2lkZ2V0KS5cbiAgICAqL1xuICAgIHRvLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHR5cGUpIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvcHkoZnJvbSwgdG8pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNvcmF0aW9uKGZyb20sIHRvLCB0aGlzLnR5cGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGVxKG90aGVyLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUuZXEob3RoZXIudHlwZSkgJiYgdGhpcy5mcm9tICsgb2Zmc2V0ID09IG90aGVyLmZyb20gJiYgdGhpcy50byArIG9mZnNldCA9PSBvdGhlci50bztcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBtYXAobWFwcGluZywgb2Zmc2V0LCBvbGRPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZS5tYXAobWFwcGluZywgdGhpcywgb2Zmc2V0LCBvbGRPZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGVzIGEgd2lkZ2V0IGRlY29yYXRpb24sIHdoaWNoIGlzIGEgRE9NIG5vZGUgdGhhdCdzIHNob3duIGluXG4gICAgdGhlIGRvY3VtZW50IGF0IHRoZSBnaXZlbiBwb3NpdGlvbi4gSXQgaXMgcmVjb21tZW5kZWQgdGhhdCB5b3VcbiAgICBkZWxheSByZW5kZXJpbmcgdGhlIHdpZGdldCBieSBwYXNzaW5nIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlXG4gICAgY2FsbGVkIHdoZW4gdGhlIHdpZGdldCBpcyBhY3R1YWxseSBkcmF3biBpbiBhIHZpZXcsIGJ1dCB5b3UgY2FuXG4gICAgYWxzbyBkaXJlY3RseSBwYXNzIGEgRE9NIG5vZGUuIGBnZXRQb3NgIGNhbiBiZSB1c2VkIHRvIGZpbmQgdGhlXG4gICAgd2lkZ2V0J3MgY3VycmVudCBkb2N1bWVudCBwb3NpdGlvbi5cbiAgICAqL1xuICAgIHN0YXRpYyB3aWRnZXQocG9zLCB0b0RPTSwgc3BlYykge1xuICAgICAgICByZXR1cm4gbmV3IERlY29yYXRpb24ocG9zLCBwb3MsIG5ldyBXaWRnZXRUeXBlKHRvRE9NLCBzcGVjKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZXMgYW4gaW5saW5lIGRlY29yYXRpb24sIHdoaWNoIGFkZHMgdGhlIGdpdmVuIGF0dHJpYnV0ZXMgdG9cbiAgICBlYWNoIGlubGluZSBub2RlIGJldHdlZW4gYGZyb21gIGFuZCBgdG9gLlxuICAgICovXG4gICAgc3RhdGljIGlubGluZShmcm9tLCB0bywgYXR0cnMsIHNwZWMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWNvcmF0aW9uKGZyb20sIHRvLCBuZXcgSW5saW5lVHlwZShhdHRycywgc3BlYykpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGVzIGEgbm9kZSBkZWNvcmF0aW9uLiBgZnJvbWAgYW5kIGB0b2Agc2hvdWxkIHBvaW50IHByZWNpc2VseVxuICAgIGJlZm9yZSBhbmQgYWZ0ZXIgYSBub2RlIGluIHRoZSBkb2N1bWVudC4gVGhhdCBub2RlLCBhbmQgb25seSB0aGF0XG4gICAgbm9kZSwgd2lsbCByZWNlaXZlIHRoZSBnaXZlbiBhdHRyaWJ1dGVzLlxuICAgICovXG4gICAgc3RhdGljIG5vZGUoZnJvbSwgdG8sIGF0dHJzLCBzcGVjKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGVjb3JhdGlvbihmcm9tLCB0bywgbmV3IE5vZGVUeXBlKGF0dHJzLCBzcGVjKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBzcGVjIHByb3ZpZGVkIHdoZW4gY3JlYXRpbmcgdGhpcyBkZWNvcmF0aW9uLiBDYW4gYmUgdXNlZnVsXG4gICAgaWYgeW91J3ZlIHN0b3JlZCBleHRyYSBpbmZvcm1hdGlvbiBpbiB0aGF0IG9iamVjdC5cbiAgICAqL1xuICAgIGdldCBzcGVjKCkgeyByZXR1cm4gdGhpcy50eXBlLnNwZWM7IH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldCBpbmxpbmUoKSB7IHJldHVybiB0aGlzLnR5cGUgaW5zdGFuY2VvZiBJbmxpbmVUeXBlOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgd2lkZ2V0KCkgeyByZXR1cm4gdGhpcy50eXBlIGluc3RhbmNlb2YgV2lkZ2V0VHlwZTsgfVxufVxuY29uc3Qgbm9uZSA9IFtdLCBub1NwZWMgPSB7fTtcbi8qKlxuQSBjb2xsZWN0aW9uIG9mIFtkZWNvcmF0aW9uc10oaHR0cHM6Ly9wcm9zZW1pcnJvci5uZXQvZG9jcy9yZWYvI3ZpZXcuRGVjb3JhdGlvbiksIG9yZ2FuaXplZCBpbiBzdWNoXG5hIHdheSB0aGF0IHRoZSBkcmF3aW5nIGFsZ29yaXRobSBjYW4gZWZmaWNpZW50bHkgdXNlIGFuZCBjb21wYXJlXG50aGVtLiBUaGlzIGlzIGEgcGVyc2lzdGVudCBkYXRhIHN0cnVjdHVyZeKAlGl0IGlzIG5vdCBtb2RpZmllZCxcbnVwZGF0ZXMgY3JlYXRlIGEgbmV3IHZhbHVlLlxuKi9cbmNsYXNzIERlY29yYXRpb25TZXQge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IobG9jYWwsIGNoaWxkcmVuKSB7XG4gICAgICAgIHRoaXMubG9jYWwgPSBsb2NhbC5sZW5ndGggPyBsb2NhbCA6IG5vbmU7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbi5sZW5ndGggPyBjaGlsZHJlbiA6IG5vbmU7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIHNldCBvZiBkZWNvcmF0aW9ucywgdXNpbmcgdGhlIHN0cnVjdHVyZSBvZiB0aGUgZ2l2ZW5cbiAgICBkb2N1bWVudC4gVGhpcyB3aWxsIGNvbnN1bWUgKG1vZGlmeSkgdGhlIGBkZWNvcmF0aW9uc2AgYXJyYXksIHNvXG4gICAgeW91IG11c3QgbWFrZSBhIGNvcHkgaWYgeW91IHdhbnQgbmVlZCB0byBwcmVzZXJ2ZSB0aGF0LlxuICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShkb2MsIGRlY29yYXRpb25zKSB7XG4gICAgICAgIHJldHVybiBkZWNvcmF0aW9ucy5sZW5ndGggPyBidWlsZFRyZWUoZGVjb3JhdGlvbnMsIGRvYywgMCwgbm9TcGVjKSA6IGVtcHR5O1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIGFsbCBkZWNvcmF0aW9ucyBpbiB0aGlzIHNldCB3aGljaCB0b3VjaCB0aGUgZ2l2ZW4gcmFuZ2VcbiAgICAoaW5jbHVkaW5nIGRlY29yYXRpb25zIHRoYXQgc3RhcnQgb3IgZW5kIGRpcmVjdGx5IGF0IHRoZVxuICAgIGJvdW5kYXJpZXMpIGFuZCBtYXRjaCB0aGUgZ2l2ZW4gcHJlZGljYXRlIG9uIHRoZWlyIHNwZWMuIFdoZW5cbiAgICBgc3RhcnRgIGFuZCBgZW5kYCBhcmUgb21pdHRlZCwgYWxsIGRlY29yYXRpb25zIGluIHRoZSBzZXQgYXJlXG4gICAgY29uc2lkZXJlZC4gV2hlbiBgcHJlZGljYXRlYCBpc24ndCBnaXZlbiwgYWxsIGRlY29yYXRpb25zIGFyZVxuICAgIGFzc3VtZWQgdG8gbWF0Y2guXG4gICAgKi9cbiAgICBmaW5kKHN0YXJ0LCBlbmQsIHByZWRpY2F0ZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIHRoaXMuZmluZElubmVyKHN0YXJ0ID09IG51bGwgPyAwIDogc3RhcnQsIGVuZCA9PSBudWxsID8gMWU5IDogZW5kLCByZXN1bHQsIDAsIHByZWRpY2F0ZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZpbmRJbm5lcihzdGFydCwgZW5kLCByZXN1bHQsIG9mZnNldCwgcHJlZGljYXRlKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sb2NhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHNwYW4gPSB0aGlzLmxvY2FsW2ldO1xuICAgICAgICAgICAgaWYgKHNwYW4uZnJvbSA8PSBlbmQgJiYgc3Bhbi50byA+PSBzdGFydCAmJiAoIXByZWRpY2F0ZSB8fCBwcmVkaWNhdGUoc3Bhbi5zcGVjKSkpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc3Bhbi5jb3B5KHNwYW4uZnJvbSArIG9mZnNldCwgc3Bhbi50byArIG9mZnNldCkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5baV0gPCBlbmQgJiYgdGhpcy5jaGlsZHJlbltpICsgMV0gPiBzdGFydCkge1xuICAgICAgICAgICAgICAgIGxldCBjaGlsZE9mZiA9IHRoaXMuY2hpbGRyZW5baV0gKyAxO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGRyZW5baSArIDJdLmZpbmRJbm5lcihzdGFydCAtIGNoaWxkT2ZmLCBlbmQgLSBjaGlsZE9mZiwgcmVzdWx0LCBvZmZzZXQgKyBjaGlsZE9mZiwgcHJlZGljYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBNYXAgdGhlIHNldCBvZiBkZWNvcmF0aW9ucyBpbiByZXNwb25zZSB0byBhIGNoYW5nZSBpbiB0aGVcbiAgICBkb2N1bWVudC5cbiAgICAqL1xuICAgIG1hcChtYXBwaW5nLCBkb2MsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMgPT0gZW1wdHkgfHwgbWFwcGluZy5tYXBzLmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcElubmVyKG1hcHBpbmcsIGRvYywgMCwgMCwgb3B0aW9ucyB8fCBub1NwZWMpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG1hcElubmVyKG1hcHBpbmcsIG5vZGUsIG9mZnNldCwgb2xkT2Zmc2V0LCBvcHRpb25zKSB7XG4gICAgICAgIGxldCBuZXdMb2NhbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxvY2FsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbWFwcGVkID0gdGhpcy5sb2NhbFtpXS5tYXAobWFwcGluZywgb2Zmc2V0LCBvbGRPZmZzZXQpO1xuICAgICAgICAgICAgaWYgKG1hcHBlZCAmJiBtYXBwZWQudHlwZS52YWxpZChub2RlLCBtYXBwZWQpKVxuICAgICAgICAgICAgICAgIChuZXdMb2NhbCB8fCAobmV3TG9jYWwgPSBbXSkpLnB1c2gobWFwcGVkKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKG9wdGlvbnMub25SZW1vdmUpXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5vblJlbW92ZSh0aGlzLmxvY2FsW2ldLnNwZWMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBtYXBDaGlsZHJlbih0aGlzLmNoaWxkcmVuLCBuZXdMb2NhbCB8fCBbXSwgbWFwcGluZywgbm9kZSwgb2Zmc2V0LCBvbGRPZmZzZXQsIG9wdGlvbnMpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gbmV3TG9jYWwgPyBuZXcgRGVjb3JhdGlvblNldChuZXdMb2NhbC5zb3J0KGJ5UG9zKSwgbm9uZSkgOiBlbXB0eTtcbiAgICB9XG4gICAgLyoqXG4gICAgQWRkIHRoZSBnaXZlbiBhcnJheSBvZiBkZWNvcmF0aW9ucyB0byB0aGUgb25lcyBpbiB0aGUgc2V0LFxuICAgIHByb2R1Y2luZyBhIG5ldyBzZXQuIENvbnN1bWVzIHRoZSBgZGVjb3JhdGlvbnNgIGFycmF5LiBOZWVkc1xuICAgIGFjY2VzcyB0byB0aGUgY3VycmVudCBkb2N1bWVudCB0byBjcmVhdGUgdGhlIGFwcHJvcHJpYXRlIHRyZWVcbiAgICBzdHJ1Y3R1cmUuXG4gICAgKi9cbiAgICBhZGQoZG9jLCBkZWNvcmF0aW9ucykge1xuICAgICAgICBpZiAoIWRlY29yYXRpb25zLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBpZiAodGhpcyA9PSBlbXB0eSlcbiAgICAgICAgICAgIHJldHVybiBEZWNvcmF0aW9uU2V0LmNyZWF0ZShkb2MsIGRlY29yYXRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkSW5uZXIoZG9jLCBkZWNvcmF0aW9ucywgMCk7XG4gICAgfVxuICAgIGFkZElubmVyKGRvYywgZGVjb3JhdGlvbnMsIG9mZnNldCkge1xuICAgICAgICBsZXQgY2hpbGRyZW4sIGNoaWxkSW5kZXggPSAwO1xuICAgICAgICBkb2MuZm9yRWFjaCgoY2hpbGROb2RlLCBjaGlsZE9mZnNldCkgPT4ge1xuICAgICAgICAgICAgbGV0IGJhc2VPZmZzZXQgPSBjaGlsZE9mZnNldCArIG9mZnNldCwgZm91bmQ7XG4gICAgICAgICAgICBpZiAoIShmb3VuZCA9IHRha2VTcGFuc0Zvck5vZGUoZGVjb3JhdGlvbnMsIGNoaWxkTm9kZSwgYmFzZU9mZnNldCkpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmICghY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuLnNsaWNlKCk7XG4gICAgICAgICAgICB3aGlsZSAoY2hpbGRJbmRleCA8IGNoaWxkcmVuLmxlbmd0aCAmJiBjaGlsZHJlbltjaGlsZEluZGV4XSA8IGNoaWxkT2Zmc2V0KVxuICAgICAgICAgICAgICAgIGNoaWxkSW5kZXggKz0gMztcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbltjaGlsZEluZGV4XSA9PSBjaGlsZE9mZnNldClcbiAgICAgICAgICAgICAgICBjaGlsZHJlbltjaGlsZEluZGV4ICsgMl0gPSBjaGlsZHJlbltjaGlsZEluZGV4ICsgMl0uYWRkSW5uZXIoY2hpbGROb2RlLCBmb3VuZCwgYmFzZU9mZnNldCArIDEpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnNwbGljZShjaGlsZEluZGV4LCAwLCBjaGlsZE9mZnNldCwgY2hpbGRPZmZzZXQgKyBjaGlsZE5vZGUubm9kZVNpemUsIGJ1aWxkVHJlZShmb3VuZCwgY2hpbGROb2RlLCBiYXNlT2Zmc2V0ICsgMSwgbm9TcGVjKSk7XG4gICAgICAgICAgICBjaGlsZEluZGV4ICs9IDM7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgbG9jYWwgPSBtb3ZlU3BhbnMoY2hpbGRJbmRleCA/IHdpdGhvdXROdWxscyhkZWNvcmF0aW9ucykgOiBkZWNvcmF0aW9ucywgLW9mZnNldCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jYWwubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIWxvY2FsW2ldLnR5cGUudmFsaWQoZG9jLCBsb2NhbFtpXSkpXG4gICAgICAgICAgICAgICAgbG9jYWwuc3BsaWNlKGktLSwgMSk7XG4gICAgICAgIHJldHVybiBuZXcgRGVjb3JhdGlvblNldChsb2NhbC5sZW5ndGggPyB0aGlzLmxvY2FsLmNvbmNhdChsb2NhbCkuc29ydChieVBvcykgOiB0aGlzLmxvY2FsLCBjaGlsZHJlbiB8fCB0aGlzLmNoaWxkcmVuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IHNldCB0aGF0IGNvbnRhaW5zIHRoZSBkZWNvcmF0aW9ucyBpbiB0aGlzIHNldCwgbWludXNcbiAgICB0aGUgb25lcyBpbiB0aGUgZ2l2ZW4gYXJyYXkuXG4gICAgKi9cbiAgICByZW1vdmUoZGVjb3JhdGlvbnMpIHtcbiAgICAgICAgaWYgKGRlY29yYXRpb25zLmxlbmd0aCA9PSAwIHx8IHRoaXMgPT0gZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlSW5uZXIoZGVjb3JhdGlvbnMsIDApO1xuICAgIH1cbiAgICByZW1vdmVJbm5lcihkZWNvcmF0aW9ucywgb2Zmc2V0KSB7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4sIGxvY2FsID0gdGhpcy5sb2NhbDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgICAgbGV0IGZvdW5kO1xuICAgICAgICAgICAgbGV0IGZyb20gPSBjaGlsZHJlbltpXSArIG9mZnNldCwgdG8gPSBjaGlsZHJlbltpICsgMV0gKyBvZmZzZXQ7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMCwgc3BhbjsgaiA8IGRlY29yYXRpb25zLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgIGlmIChzcGFuID0gZGVjb3JhdGlvbnNbal0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNwYW4uZnJvbSA+IGZyb20gJiYgc3Bhbi50byA8IHRvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvcmF0aW9uc1tqXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAoZm91bmQgfHwgKGZvdW5kID0gW10pKS5wdXNoKHNwYW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFmb3VuZClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbiA9PSB0aGlzLmNoaWxkcmVuKVxuICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbi5zbGljZSgpO1xuICAgICAgICAgICAgbGV0IHJlbW92ZWQgPSBjaGlsZHJlbltpICsgMl0ucmVtb3ZlSW5uZXIoZm91bmQsIGZyb20gKyAxKTtcbiAgICAgICAgICAgIGlmIChyZW1vdmVkICE9IGVtcHR5KSB7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW5baSArIDJdID0gcmVtb3ZlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnNwbGljZShpLCAzKTtcbiAgICAgICAgICAgICAgICBpIC09IDM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvY2FsLmxlbmd0aClcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBzcGFuOyBpIDwgZGVjb3JhdGlvbnMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKHNwYW4gPSBkZWNvcmF0aW9uc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxvY2FsLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsW2pdLmVxKHNwYW4sIG9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWwgPT0gdGhpcy5sb2NhbClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWwgPSB0aGlzLmxvY2FsLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWwuc3BsaWNlKGotLSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGRyZW4gPT0gdGhpcy5jaGlsZHJlbiAmJiBsb2NhbCA9PSB0aGlzLmxvY2FsKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIHJldHVybiBsb2NhbC5sZW5ndGggfHwgY2hpbGRyZW4ubGVuZ3RoID8gbmV3IERlY29yYXRpb25TZXQobG9jYWwsIGNoaWxkcmVuKSA6IGVtcHR5O1xuICAgIH1cbiAgICBmb3JDaGlsZChvZmZzZXQsIG5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMgPT0gZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgaWYgKG5vZGUuaXNMZWFmKVxuICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb25TZXQuZW1wdHk7XG4gICAgICAgIGxldCBjaGlsZCwgbG9jYWw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7IGkgKz0gMylcbiAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuW2ldID49IG9mZnNldCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoaWxkcmVuW2ldID09IG9mZnNldClcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2kgKyAyXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0ID0gb2Zmc2V0ICsgMSwgZW5kID0gc3RhcnQgKyBub2RlLmNvbnRlbnQuc2l6ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxvY2FsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgZGVjID0gdGhpcy5sb2NhbFtpXTtcbiAgICAgICAgICAgIGlmIChkZWMuZnJvbSA8IGVuZCAmJiBkZWMudG8gPiBzdGFydCAmJiAoZGVjLnR5cGUgaW5zdGFuY2VvZiBJbmxpbmVUeXBlKSkge1xuICAgICAgICAgICAgICAgIGxldCBmcm9tID0gTWF0aC5tYXgoc3RhcnQsIGRlYy5mcm9tKSAtIHN0YXJ0LCB0byA9IE1hdGgubWluKGVuZCwgZGVjLnRvKSAtIHN0YXJ0O1xuICAgICAgICAgICAgICAgIGlmIChmcm9tIDwgdG8pXG4gICAgICAgICAgICAgICAgICAgIChsb2NhbCB8fCAobG9jYWwgPSBbXSkpLnB1c2goZGVjLmNvcHkoZnJvbSwgdG8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobG9jYWwpIHtcbiAgICAgICAgICAgIGxldCBsb2NhbFNldCA9IG5ldyBEZWNvcmF0aW9uU2V0KGxvY2FsLnNvcnQoYnlQb3MpLCBub25lKTtcbiAgICAgICAgICAgIHJldHVybiBjaGlsZCA/IG5ldyBEZWNvcmF0aW9uR3JvdXAoW2xvY2FsU2V0LCBjaGlsZF0pIDogbG9jYWxTZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoaWxkIHx8IGVtcHR5O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGVxKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzID09IG90aGVyKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgRGVjb3JhdGlvblNldCkgfHxcbiAgICAgICAgICAgIHRoaXMubG9jYWwubGVuZ3RoICE9IG90aGVyLmxvY2FsLmxlbmd0aCB8fFxuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5sZW5ndGggIT0gb3RoZXIuY2hpbGRyZW4ubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubG9jYWwubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAoIXRoaXMubG9jYWxbaV0uZXEob3RoZXIubG9jYWxbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKVxuICAgICAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW5baV0gIT0gb3RoZXIuY2hpbGRyZW5baV0gfHxcbiAgICAgICAgICAgICAgICB0aGlzLmNoaWxkcmVuW2kgKyAxXSAhPSBvdGhlci5jaGlsZHJlbltpICsgMV0gfHxcbiAgICAgICAgICAgICAgICAhdGhpcy5jaGlsZHJlbltpICsgMl0uZXEob3RoZXIuY2hpbGRyZW5baSArIDJdKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGxvY2Fscyhub2RlKSB7XG4gICAgICAgIHJldHVybiByZW1vdmVPdmVybGFwKHRoaXMubG9jYWxzSW5uZXIobm9kZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGxvY2Fsc0lubmVyKG5vZGUpIHtcbiAgICAgICAgaWYgKHRoaXMgPT0gZW1wdHkpXG4gICAgICAgICAgICByZXR1cm4gbm9uZTtcbiAgICAgICAgaWYgKG5vZGUuaW5saW5lQ29udGVudCB8fCAhdGhpcy5sb2NhbC5zb21lKElubGluZVR5cGUuaXMpKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWw7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxvY2FsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoISh0aGlzLmxvY2FsW2ldLnR5cGUgaW5zdGFuY2VvZiBJbmxpbmVUeXBlKSlcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmxvY2FsW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBmb3JFYWNoU2V0KGYpIHsgZih0aGlzKTsgfVxufVxuLyoqXG5UaGUgZW1wdHkgc2V0IG9mIGRlY29yYXRpb25zLlxuKi9cbkRlY29yYXRpb25TZXQuZW1wdHkgPSBuZXcgRGVjb3JhdGlvblNldChbXSwgW10pO1xuLyoqXG5AaW50ZXJuYWxcbiovXG5EZWNvcmF0aW9uU2V0LnJlbW92ZU92ZXJsYXAgPSByZW1vdmVPdmVybGFwO1xuY29uc3QgZW1wdHkgPSBEZWNvcmF0aW9uU2V0LmVtcHR5O1xuLy8gQW4gYWJzdHJhY3Rpb24gdGhhdCBhbGxvd3MgdGhlIGNvZGUgZGVhbGluZyB3aXRoIGRlY29yYXRpb25zIHRvXG4vLyB0cmVhdCBtdWx0aXBsZSBEZWNvcmF0aW9uU2V0IG9iamVjdHMgYXMgaWYgaXQgd2VyZSBhIHNpbmdsZSBvYmplY3Rcbi8vIHdpdGggKGEgc3Vic2V0IG9mKSB0aGUgc2FtZSBpbnRlcmZhY2UuXG5jbGFzcyBEZWNvcmF0aW9uR3JvdXAge1xuICAgIGNvbnN0cnVjdG9yKG1lbWJlcnMpIHtcbiAgICAgICAgdGhpcy5tZW1iZXJzID0gbWVtYmVycztcbiAgICB9XG4gICAgbWFwKG1hcHBpbmcsIGRvYykge1xuICAgICAgICBjb25zdCBtYXBwZWREZWNvcyA9IHRoaXMubWVtYmVycy5tYXAobWVtYmVyID0+IG1lbWJlci5tYXAobWFwcGluZywgZG9jLCBub1NwZWMpKTtcbiAgICAgICAgcmV0dXJuIERlY29yYXRpb25Hcm91cC5mcm9tKG1hcHBlZERlY29zKTtcbiAgICB9XG4gICAgZm9yQ2hpbGQob2Zmc2V0LCBjaGlsZCkge1xuICAgICAgICBpZiAoY2hpbGQuaXNMZWFmKVxuICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb25TZXQuZW1wdHk7XG4gICAgICAgIGxldCBmb3VuZCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWVtYmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMubWVtYmVyc1tpXS5mb3JDaGlsZChvZmZzZXQsIGNoaWxkKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gZW1wdHkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgRGVjb3JhdGlvbkdyb3VwKVxuICAgICAgICAgICAgICAgIGZvdW5kID0gZm91bmQuY29uY2F0KHJlc3VsdC5tZW1iZXJzKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBmb3VuZC5wdXNoKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERlY29yYXRpb25Hcm91cC5mcm9tKGZvdW5kKTtcbiAgICB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBEZWNvcmF0aW9uR3JvdXApIHx8XG4gICAgICAgICAgICBvdGhlci5tZW1iZXJzLmxlbmd0aCAhPSB0aGlzLm1lbWJlcnMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWVtYmVycy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICghdGhpcy5tZW1iZXJzW2ldLmVxKG90aGVyLm1lbWJlcnNbaV0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxvY2Fscyhub2RlKSB7XG4gICAgICAgIGxldCByZXN1bHQsIHNvcnRlZCA9IHRydWU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tZW1iZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgbG9jYWxzID0gdGhpcy5tZW1iZXJzW2ldLmxvY2Fsc0lubmVyKG5vZGUpO1xuICAgICAgICAgICAgaWYgKCFsb2NhbHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBsb2NhbHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoc29ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICBzb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsb2NhbHMubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGxvY2Fsc1tqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdCA/IHJlbW92ZU92ZXJsYXAoc29ydGVkID8gcmVzdWx0IDogcmVzdWx0LnNvcnQoYnlQb3MpKSA6IG5vbmU7XG4gICAgfVxuICAgIC8vIENyZWF0ZSBhIGdyb3VwIGZvciB0aGUgZ2l2ZW4gYXJyYXkgb2YgZGVjb3JhdGlvbiBzZXRzLCBvciByZXR1cm5cbiAgICAvLyBhIHNpbmdsZSBzZXQgd2hlbiBwb3NzaWJsZS5cbiAgICBzdGF0aWMgZnJvbShtZW1iZXJzKSB7XG4gICAgICAgIHN3aXRjaCAobWVtYmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIGVtcHR5O1xuICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gbWVtYmVyc1swXTtcbiAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBuZXcgRGVjb3JhdGlvbkdyb3VwKG1lbWJlcnMuZXZlcnkobSA9PiBtIGluc3RhbmNlb2YgRGVjb3JhdGlvblNldCkgPyBtZW1iZXJzIDpcbiAgICAgICAgICAgICAgICBtZW1iZXJzLnJlZHVjZSgociwgbSkgPT4gci5jb25jYXQobSBpbnN0YW5jZW9mIERlY29yYXRpb25TZXQgPyBtIDogbS5tZW1iZXJzKSwgW10pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3JFYWNoU2V0KGYpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1lbWJlcnMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICB0aGlzLm1lbWJlcnNbaV0uZm9yRWFjaFNldChmKTtcbiAgICB9XG59XG5mdW5jdGlvbiBtYXBDaGlsZHJlbihvbGRDaGlsZHJlbiwgbmV3TG9jYWwsIG1hcHBpbmcsIG5vZGUsIG9mZnNldCwgb2xkT2Zmc2V0LCBvcHRpb25zKSB7XG4gICAgbGV0IGNoaWxkcmVuID0gb2xkQ2hpbGRyZW4uc2xpY2UoKTtcbiAgICAvLyBNYXJrIHRoZSBjaGlsZHJlbiB0aGF0IGFyZSBkaXJlY3RseSB0b3VjaGVkIGJ5IGNoYW5nZXMsIGFuZFxuICAgIC8vIG1vdmUgdGhvc2UgdGhhdCBhcmUgYWZ0ZXIgdGhlIGNoYW5nZXMuXG4gICAgZm9yIChsZXQgaSA9IDAsIGJhc2VPZmZzZXQgPSBvbGRPZmZzZXQ7IGkgPCBtYXBwaW5nLm1hcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG1vdmVkID0gMDtcbiAgICAgICAgbWFwcGluZy5tYXBzW2ldLmZvckVhY2goKG9sZFN0YXJ0LCBvbGRFbmQsIG5ld1N0YXJ0LCBuZXdFbmQpID0+IHtcbiAgICAgICAgICAgIGxldCBkU2l6ZSA9IChuZXdFbmQgLSBuZXdTdGFydCkgLSAob2xkRW5kIC0gb2xkU3RhcnQpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgICAgICAgIGxldCBlbmQgPSBjaGlsZHJlbltpICsgMV07XG4gICAgICAgICAgICAgICAgaWYgKGVuZCA8IDAgfHwgb2xkU3RhcnQgPiBlbmQgKyBiYXNlT2Zmc2V0IC0gbW92ZWQpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGxldCBzdGFydCA9IGNoaWxkcmVuW2ldICsgYmFzZU9mZnNldCAtIG1vdmVkO1xuICAgICAgICAgICAgICAgIGlmIChvbGRFbmQgPj0gc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW5baSArIDFdID0gb2xkU3RhcnQgPD0gc3RhcnQgPyAtMiA6IC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvbGRTdGFydCA+PSBiYXNlT2Zmc2V0ICYmIGRTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuW2ldICs9IGRTaXplO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbltpICsgMV0gKz0gZFNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbW92ZWQgKz0gZFNpemU7XG4gICAgICAgIH0pO1xuICAgICAgICBiYXNlT2Zmc2V0ID0gbWFwcGluZy5tYXBzW2ldLm1hcChiYXNlT2Zmc2V0LCAtMSk7XG4gICAgfVxuICAgIC8vIEZpbmQgdGhlIGNoaWxkIG5vZGVzIHRoYXQgc3RpbGwgY29ycmVzcG9uZCB0byBhIHNpbmdsZSBub2RlLFxuICAgIC8vIHJlY3Vyc2l2ZWx5IGNhbGwgbWFwSW5uZXIgb24gdGhlbSBhbmQgdXBkYXRlIHRoZWlyIHBvc2l0aW9ucy5cbiAgICBsZXQgbXVzdFJlYnVpbGQgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKVxuICAgICAgICBpZiAoY2hpbGRyZW5baSArIDFdIDwgMCkgeyAvLyBUb3VjaGVkIG5vZGVzXG4gICAgICAgICAgICBpZiAoY2hpbGRyZW5baSArIDFdID09IC0yKSB7XG4gICAgICAgICAgICAgICAgbXVzdFJlYnVpbGQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuW2kgKyAxXSA9IC0xO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGZyb20gPSBtYXBwaW5nLm1hcChvbGRDaGlsZHJlbltpXSArIG9sZE9mZnNldCksIGZyb21Mb2NhbCA9IGZyb20gLSBvZmZzZXQ7XG4gICAgICAgICAgICBpZiAoZnJvbUxvY2FsIDwgMCB8fCBmcm9tTG9jYWwgPj0gbm9kZS5jb250ZW50LnNpemUpIHtcbiAgICAgICAgICAgICAgICBtdXN0UmVidWlsZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNdXN0IHJlYWQgb2xkQ2hpbGRyZW4gYmVjYXVzZSBjaGlsZHJlbiB3YXMgdGFnZ2VkIHdpdGggLTFcbiAgICAgICAgICAgIGxldCB0byA9IG1hcHBpbmcubWFwKG9sZENoaWxkcmVuW2kgKyAxXSArIG9sZE9mZnNldCwgLTEpLCB0b0xvY2FsID0gdG8gLSBvZmZzZXQ7XG4gICAgICAgICAgICBsZXQgeyBpbmRleCwgb2Zmc2V0OiBjaGlsZE9mZnNldCB9ID0gbm9kZS5jb250ZW50LmZpbmRJbmRleChmcm9tTG9jYWwpO1xuICAgICAgICAgICAgbGV0IGNoaWxkTm9kZSA9IG5vZGUubWF5YmVDaGlsZChpbmRleCk7XG4gICAgICAgICAgICBpZiAoY2hpbGROb2RlICYmIGNoaWxkT2Zmc2V0ID09IGZyb21Mb2NhbCAmJiBjaGlsZE9mZnNldCArIGNoaWxkTm9kZS5ub2RlU2l6ZSA9PSB0b0xvY2FsKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1hcHBlZCA9IGNoaWxkcmVuW2kgKyAyXVxuICAgICAgICAgICAgICAgICAgICAubWFwSW5uZXIobWFwcGluZywgY2hpbGROb2RlLCBmcm9tICsgMSwgb2xkQ2hpbGRyZW5baV0gKyBvbGRPZmZzZXQgKyAxLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAobWFwcGVkICE9IGVtcHR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuW2ldID0gZnJvbUxvY2FsO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbltpICsgMV0gPSB0b0xvY2FsO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbltpICsgMl0gPSBtYXBwZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbltpICsgMV0gPSAtMjtcbiAgICAgICAgICAgICAgICAgICAgbXVzdFJlYnVpbGQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG11c3RSZWJ1aWxkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIC8vIFJlbWFpbmluZyBjaGlsZHJlbiBtdXN0IGJlIGNvbGxlY3RlZCBhbmQgcmVidWlsdCBpbnRvIHRoZSBhcHByb3ByaWF0ZSBzdHJ1Y3R1cmVcbiAgICBpZiAobXVzdFJlYnVpbGQpIHtcbiAgICAgICAgbGV0IGRlY29yYXRpb25zID0gbWFwQW5kR2F0aGVyUmVtYWluaW5nRGVjb3JhdGlvbnMoY2hpbGRyZW4sIG9sZENoaWxkcmVuLCBuZXdMb2NhbCwgbWFwcGluZywgb2Zmc2V0LCBvbGRPZmZzZXQsIG9wdGlvbnMpO1xuICAgICAgICBsZXQgYnVpbHQgPSBidWlsZFRyZWUoZGVjb3JhdGlvbnMsIG5vZGUsIDAsIG9wdGlvbnMpO1xuICAgICAgICBuZXdMb2NhbCA9IGJ1aWx0LmxvY2FsO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKVxuICAgICAgICAgICAgaWYgKGNoaWxkcmVuW2kgKyAxXSA8IDApIHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5zcGxpY2UoaSwgMyk7XG4gICAgICAgICAgICAgICAgaSAtPSAzO1xuICAgICAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCBidWlsdC5jaGlsZHJlbi5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICAgICAgbGV0IGZyb20gPSBidWlsdC5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIHdoaWxlIChqIDwgY2hpbGRyZW4ubGVuZ3RoICYmIGNoaWxkcmVuW2pdIDwgZnJvbSlcbiAgICAgICAgICAgICAgICBqICs9IDM7XG4gICAgICAgICAgICBjaGlsZHJlbi5zcGxpY2UoaiwgMCwgYnVpbHQuY2hpbGRyZW5baV0sIGJ1aWx0LmNoaWxkcmVuW2kgKyAxXSwgYnVpbHQuY2hpbGRyZW5baSArIDJdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IERlY29yYXRpb25TZXQobmV3TG9jYWwuc29ydChieVBvcyksIGNoaWxkcmVuKTtcbn1cbmZ1bmN0aW9uIG1vdmVTcGFucyhzcGFucywgb2Zmc2V0KSB7XG4gICAgaWYgKCFvZmZzZXQgfHwgIXNwYW5zLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIHNwYW5zO1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBzcGFuID0gc3BhbnNbaV07XG4gICAgICAgIHJlc3VsdC5wdXNoKG5ldyBEZWNvcmF0aW9uKHNwYW4uZnJvbSArIG9mZnNldCwgc3Bhbi50byArIG9mZnNldCwgc3Bhbi50eXBlKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBtYXBBbmRHYXRoZXJSZW1haW5pbmdEZWNvcmF0aW9ucyhjaGlsZHJlbiwgb2xkQ2hpbGRyZW4sIGRlY29yYXRpb25zLCBtYXBwaW5nLCBvZmZzZXQsIG9sZE9mZnNldCwgb3B0aW9ucykge1xuICAgIC8vIEdhdGhlciBhbGwgZGVjb3JhdGlvbnMgZnJvbSB0aGUgcmVtYWluaW5nIG1hcmtlZCBjaGlsZHJlblxuICAgIGZ1bmN0aW9uIGdhdGhlcihzZXQsIG9sZE9mZnNldCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNldC5sb2NhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG1hcHBlZCA9IHNldC5sb2NhbFtpXS5tYXAobWFwcGluZywgb2Zmc2V0LCBvbGRPZmZzZXQpO1xuICAgICAgICAgICAgaWYgKG1hcHBlZClcbiAgICAgICAgICAgICAgICBkZWNvcmF0aW9ucy5wdXNoKG1hcHBlZCk7XG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLm9uUmVtb3ZlKVxuICAgICAgICAgICAgICAgIG9wdGlvbnMub25SZW1vdmUoc2V0LmxvY2FsW2ldLnNwZWMpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2V0LmNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKVxuICAgICAgICAgICAgZ2F0aGVyKHNldC5jaGlsZHJlbltpICsgMl0sIHNldC5jaGlsZHJlbltpXSArIG9sZE9mZnNldCArIDEpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArPSAzKVxuICAgICAgICBpZiAoY2hpbGRyZW5baSArIDFdID09IC0xKVxuICAgICAgICAgICAgZ2F0aGVyKGNoaWxkcmVuW2kgKyAyXSwgb2xkQ2hpbGRyZW5baV0gKyBvbGRPZmZzZXQgKyAxKTtcbiAgICByZXR1cm4gZGVjb3JhdGlvbnM7XG59XG5mdW5jdGlvbiB0YWtlU3BhbnNGb3JOb2RlKHNwYW5zLCBub2RlLCBvZmZzZXQpIHtcbiAgICBpZiAobm9kZS5pc0xlYWYpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBlbmQgPSBvZmZzZXQgKyBub2RlLm5vZGVTaXplLCBmb3VuZCA9IG51bGw7XG4gICAgZm9yIChsZXQgaSA9IDAsIHNwYW47IGkgPCBzcGFucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoKHNwYW4gPSBzcGFuc1tpXSkgJiYgc3Bhbi5mcm9tID4gb2Zmc2V0ICYmIHNwYW4udG8gPCBlbmQpIHtcbiAgICAgICAgICAgIChmb3VuZCB8fCAoZm91bmQgPSBbXSkpLnB1c2goc3Bhbik7XG4gICAgICAgICAgICBzcGFuc1tpXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZvdW5kO1xufVxuZnVuY3Rpb24gd2l0aG91dE51bGxzKGFycmF5KSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspXG4gICAgICAgIGlmIChhcnJheVtpXSAhPSBudWxsKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goYXJyYXlbaV0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyBCdWlsZCB1cCBhIHRyZWUgdGhhdCBjb3JyZXNwb25kcyB0byBhIHNldCBvZiBkZWNvcmF0aW9ucy4gYG9mZnNldGBcbi8vIGlzIGEgYmFzZSBvZmZzZXQgdGhhdCBzaG91bGQgYmUgc3VidHJhY3RlZCBmcm9tIHRoZSBgZnJvbWAgYW5kIGB0b2Bcbi8vIHBvc2l0aW9ucyBpbiB0aGUgc3BhbnMgKHNvIHRoYXQgd2UgZG9uJ3QgaGF2ZSB0byBhbGxvY2F0ZSBuZXcgc3BhbnNcbi8vIGZvciByZWN1cnNpdmUgY2FsbHMpLlxuZnVuY3Rpb24gYnVpbGRUcmVlKHNwYW5zLCBub2RlLCBvZmZzZXQsIG9wdGlvbnMpIHtcbiAgICBsZXQgY2hpbGRyZW4gPSBbXSwgaGFzTnVsbHMgPSBmYWxzZTtcbiAgICBub2RlLmZvckVhY2goKGNoaWxkTm9kZSwgbG9jYWxTdGFydCkgPT4ge1xuICAgICAgICBsZXQgZm91bmQgPSB0YWtlU3BhbnNGb3JOb2RlKHNwYW5zLCBjaGlsZE5vZGUsIGxvY2FsU3RhcnQgKyBvZmZzZXQpO1xuICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICAgIGhhc051bGxzID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBzdWJ0cmVlID0gYnVpbGRUcmVlKGZvdW5kLCBjaGlsZE5vZGUsIG9mZnNldCArIGxvY2FsU3RhcnQgKyAxLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChzdWJ0cmVlICE9IGVtcHR5KVxuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gobG9jYWxTdGFydCwgbG9jYWxTdGFydCArIGNoaWxkTm9kZS5ub2RlU2l6ZSwgc3VidHJlZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBsZXQgbG9jYWxzID0gbW92ZVNwYW5zKGhhc051bGxzID8gd2l0aG91dE51bGxzKHNwYW5zKSA6IHNwYW5zLCAtb2Zmc2V0KS5zb3J0KGJ5UG9zKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxvY2Fscy5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKCFsb2NhbHNbaV0udHlwZS52YWxpZChub2RlLCBsb2NhbHNbaV0pKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5vblJlbW92ZSlcbiAgICAgICAgICAgICAgICBvcHRpb25zLm9uUmVtb3ZlKGxvY2Fsc1tpXS5zcGVjKTtcbiAgICAgICAgICAgIGxvY2Fscy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgfVxuICAgIHJldHVybiBsb2NhbHMubGVuZ3RoIHx8IGNoaWxkcmVuLmxlbmd0aCA/IG5ldyBEZWNvcmF0aW9uU2V0KGxvY2FscywgY2hpbGRyZW4pIDogZW1wdHk7XG59XG4vLyBVc2VkIHRvIHNvcnQgZGVjb3JhdGlvbnMgc28gdGhhdCBvbmVzIHdpdGggYSBsb3cgc3RhcnQgcG9zaXRpb25cbi8vIGNvbWUgZmlyc3QsIGFuZCB3aXRoaW4gYSBzZXQgd2l0aCB0aGUgc2FtZSBzdGFydCBwb3NpdGlvbiwgdGhvc2Vcbi8vIHdpdGggYW4gc21hbGxlciBlbmQgcG9zaXRpb24gY29tZSBmaXJzdC5cbmZ1bmN0aW9uIGJ5UG9zKGEsIGIpIHtcbiAgICByZXR1cm4gYS5mcm9tIC0gYi5mcm9tIHx8IGEudG8gLSBiLnRvO1xufVxuLy8gU2NhbiBhIHNvcnRlZCBhcnJheSBvZiBkZWNvcmF0aW9ucyBmb3IgcGFydGlhbGx5IG92ZXJsYXBwaW5nIHNwYW5zLFxuLy8gYW5kIHNwbGl0IHRob3NlIHNvIHRoYXQgb25seSBmdWxseSBvdmVybGFwcGluZyBzcGFucyBhcmUgbGVmdCAodG9cbi8vIG1ha2Ugc3Vic2VxdWVudCByZW5kZXJpbmcgZWFzaWVyKS4gV2lsbCByZXR1cm4gdGhlIGlucHV0IGFycmF5IGlmXG4vLyBubyBwYXJ0aWFsbHkgb3ZlcmxhcHBpbmcgc3BhbnMgYXJlIGZvdW5kICh0aGUgY29tbW9uIGNhc2UpLlxuZnVuY3Rpb24gcmVtb3ZlT3ZlcmxhcChzcGFucykge1xuICAgIGxldCB3b3JraW5nID0gc3BhbnM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3b3JraW5nLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBsZXQgc3BhbiA9IHdvcmtpbmdbaV07XG4gICAgICAgIGlmIChzcGFuLmZyb20gIT0gc3Bhbi50bylcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IHdvcmtpbmcubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHdvcmtpbmdbal07XG4gICAgICAgICAgICAgICAgaWYgKG5leHQuZnJvbSA9PSBzcGFuLmZyb20pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQudG8gIT0gc3Bhbi50bykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdvcmtpbmcgPT0gc3BhbnMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd29ya2luZyA9IHNwYW5zLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGb2xsb3dlZCBieSBhIHBhcnRpYWxseSBvdmVybGFwcGluZyBsYXJnZXIgc3Bhbi4gU3BsaXQgdGhhdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3Bhbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtpbmdbal0gPSBuZXh0LmNvcHkobmV4dC5mcm9tLCBzcGFuLnRvKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydEFoZWFkKHdvcmtpbmcsIGogKyAxLCBuZXh0LmNvcHkoc3Bhbi50bywgbmV4dC50bykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQuZnJvbSA8IHNwYW4udG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3b3JraW5nID09IHNwYW5zKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtpbmcgPSBzcGFucy5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGVuZCBvZiB0aGlzIG9uZSBvdmVybGFwcyB3aXRoIGEgc3Vic2VxdWVudCBzcGFuLiBTcGxpdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBvbmUuXG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JraW5nW2ldID0gc3Bhbi5jb3B5KHNwYW4uZnJvbSwgbmV4dC5mcm9tKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydEFoZWFkKHdvcmtpbmcsIGosIHNwYW4uY29weShuZXh0LmZyb20sIHNwYW4udG8pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB3b3JraW5nO1xufVxuZnVuY3Rpb24gaW5zZXJ0QWhlYWQoYXJyYXksIGksIGRlY28pIHtcbiAgICB3aGlsZSAoaSA8IGFycmF5Lmxlbmd0aCAmJiBieVBvcyhkZWNvLCBhcnJheVtpXSkgPiAwKVxuICAgICAgICBpKys7XG4gICAgYXJyYXkuc3BsaWNlKGksIDAsIGRlY28pO1xufVxuLy8gR2V0IHRoZSBkZWNvcmF0aW9ucyBhc3NvY2lhdGVkIHdpdGggdGhlIGN1cnJlbnQgcHJvcHMgb2YgYSB2aWV3LlxuZnVuY3Rpb24gdmlld0RlY29yYXRpb25zKHZpZXcpIHtcbiAgICBsZXQgZm91bmQgPSBbXTtcbiAgICB2aWV3LnNvbWVQcm9wKFwiZGVjb3JhdGlvbnNcIiwgZiA9PiB7XG4gICAgICAgIGxldCByZXN1bHQgPSBmKHZpZXcuc3RhdGUpO1xuICAgICAgICBpZiAocmVzdWx0ICYmIHJlc3VsdCAhPSBlbXB0eSlcbiAgICAgICAgICAgIGZvdW5kLnB1c2gocmVzdWx0KTtcbiAgICB9KTtcbiAgICBpZiAodmlldy5jdXJzb3JXcmFwcGVyKVxuICAgICAgICBmb3VuZC5wdXNoKERlY29yYXRpb25TZXQuY3JlYXRlKHZpZXcuc3RhdGUuZG9jLCBbdmlldy5jdXJzb3JXcmFwcGVyLmRlY29dKSk7XG4gICAgcmV0dXJuIERlY29yYXRpb25Hcm91cC5mcm9tKGZvdW5kKTtcbn1cblxuY29uc3Qgb2JzZXJ2ZU9wdGlvbnMgPSB7XG4gICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgIGNoYXJhY3RlckRhdGE6IHRydWUsXG4gICAgY2hhcmFjdGVyRGF0YU9sZFZhbHVlOiB0cnVlLFxuICAgIGF0dHJpYnV0ZXM6IHRydWUsXG4gICAgYXR0cmlidXRlT2xkVmFsdWU6IHRydWUsXG4gICAgc3VidHJlZTogdHJ1ZVxufTtcbi8vIElFMTEgaGFzIHZlcnkgYnJva2VuIG11dGF0aW9uIG9ic2VydmVycywgc28gd2UgYWxzbyBsaXN0ZW4gdG8gRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkXG5jb25zdCB1c2VDaGFyRGF0YSA9IGllICYmIGllX3ZlcnNpb24gPD0gMTE7XG5jbGFzcyBTZWxlY3Rpb25TdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYW5jaG9yTm9kZSA9IG51bGw7XG4gICAgICAgIHRoaXMuYW5jaG9yT2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy5mb2N1c05vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmZvY3VzT2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgc2V0KHNlbCkge1xuICAgICAgICB0aGlzLmFuY2hvck5vZGUgPSBzZWwuYW5jaG9yTm9kZTtcbiAgICAgICAgdGhpcy5hbmNob3JPZmZzZXQgPSBzZWwuYW5jaG9yT2Zmc2V0O1xuICAgICAgICB0aGlzLmZvY3VzTm9kZSA9IHNlbC5mb2N1c05vZGU7XG4gICAgICAgIHRoaXMuZm9jdXNPZmZzZXQgPSBzZWwuZm9jdXNPZmZzZXQ7XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLmFuY2hvck5vZGUgPSB0aGlzLmZvY3VzTm9kZSA9IG51bGw7XG4gICAgfVxuICAgIGVxKHNlbCkge1xuICAgICAgICByZXR1cm4gc2VsLmFuY2hvck5vZGUgPT0gdGhpcy5hbmNob3JOb2RlICYmIHNlbC5hbmNob3JPZmZzZXQgPT0gdGhpcy5hbmNob3JPZmZzZXQgJiZcbiAgICAgICAgICAgIHNlbC5mb2N1c05vZGUgPT0gdGhpcy5mb2N1c05vZGUgJiYgc2VsLmZvY3VzT2Zmc2V0ID09IHRoaXMuZm9jdXNPZmZzZXQ7XG4gICAgfVxufVxuY2xhc3MgRE9NT2JzZXJ2ZXIge1xuICAgIGNvbnN0cnVjdG9yKHZpZXcsIGhhbmRsZURPTUNoYW5nZSkge1xuICAgICAgICB0aGlzLnZpZXcgPSB2aWV3O1xuICAgICAgICB0aGlzLmhhbmRsZURPTUNoYW5nZSA9IGhhbmRsZURPTUNoYW5nZTtcbiAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLmZsdXNoaW5nU29vbiA9IC0xO1xuICAgICAgICB0aGlzLm9ic2VydmVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5jdXJyZW50U2VsZWN0aW9uID0gbmV3IFNlbGVjdGlvblN0YXRlO1xuICAgICAgICB0aGlzLm9uQ2hhckRhdGEgPSBudWxsO1xuICAgICAgICB0aGlzLnN1cHByZXNzaW5nU2VsZWN0aW9uVXBkYXRlcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxhc3RDaGFuZ2VkVGV4dE5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLm9ic2VydmVyID0gd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIgJiZcbiAgICAgICAgICAgIG5ldyB3aW5kb3cuTXV0YXRpb25PYnNlcnZlcihtdXRhdGlvbnMgPT4ge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0YXRpb25zLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2gobXV0YXRpb25zW2ldKTtcbiAgICAgICAgICAgICAgICAvLyBJRTExIHdpbGwgc29tZXRpbWVzIChvbiBiYWNrc3BhY2luZyBvdXQgYSBzaW5nbGUgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgLy8gdGV4dCBub2RlIGFmdGVyIGEgQlIgbm9kZSkgY2FsbCB0aGUgb2JzZXJ2ZXIgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAvLyBiZWZvcmUgYWN0dWFsbHkgdXBkYXRpbmcgdGhlIERPTSwgd2hpY2ggd2lsbCBjYXVzZVxuICAgICAgICAgICAgICAgIC8vIFByb3NlTWlycm9yIHRvIG1pc3MgdGhlIGNoYW5nZSAoc2VlICM5MzApXG4gICAgICAgICAgICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPD0gMTEgJiYgbXV0YXRpb25zLnNvbWUobSA9PiBtLnR5cGUgPT0gXCJjaGlsZExpc3RcIiAmJiBtLnJlbW92ZWROb2Rlcy5sZW5ndGggfHxcbiAgICAgICAgICAgICAgICAgICAgbS50eXBlID09IFwiY2hhcmFjdGVyRGF0YVwiICYmIG0ub2xkVmFsdWUubGVuZ3RoID4gbS50YXJnZXQubm9kZVZhbHVlLmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hTb29uKCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKHVzZUNoYXJEYXRhKSB7XG4gICAgICAgICAgICB0aGlzLm9uQ2hhckRhdGEgPSBlID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2goeyB0YXJnZXQ6IGUudGFyZ2V0LCB0eXBlOiBcImNoYXJhY3RlckRhdGFcIiwgb2xkVmFsdWU6IGUucHJldlZhbHVlIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2hTb29uKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25TZWxlY3Rpb25DaGFuZ2UgPSB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlLmJpbmQodGhpcyk7XG4gICAgfVxuICAgIGZsdXNoU29vbigpIHtcbiAgICAgICAgaWYgKHRoaXMuZmx1c2hpbmdTb29uIDwgMClcbiAgICAgICAgICAgIHRoaXMuZmx1c2hpbmdTb29uID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4geyB0aGlzLmZsdXNoaW5nU29vbiA9IC0xOyB0aGlzLmZsdXNoKCk7IH0sIDIwKTtcbiAgICB9XG4gICAgZm9yY2VGbHVzaCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZmx1c2hpbmdTb29uID4gLTEpIHtcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5mbHVzaGluZ1Nvb24pO1xuICAgICAgICAgICAgdGhpcy5mbHVzaGluZ1Nvb24gPSAtMTtcbiAgICAgICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgaWYgKHRoaXMub2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIudGFrZVJlY29yZHMoKTtcbiAgICAgICAgICAgIHRoaXMub2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLnZpZXcuZG9tLCBvYnNlcnZlT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub25DaGFyRGF0YSlcbiAgICAgICAgICAgIHRoaXMudmlldy5kb20uYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNoYXJhY3RlckRhdGFNb2RpZmllZFwiLCB0aGlzLm9uQ2hhckRhdGEpO1xuICAgICAgICB0aGlzLmNvbm5lY3RTZWxlY3Rpb24oKTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKHRoaXMub2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIGxldCB0YWtlID0gdGhpcy5vYnNlcnZlci50YWtlUmVjb3JkcygpO1xuICAgICAgICAgICAgaWYgKHRha2UubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YWtlLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlLnB1c2godGFrZVtpXSk7XG4gICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoKCkgPT4gdGhpcy5mbHVzaCgpLCAyMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vbkNoYXJEYXRhKVxuICAgICAgICAgICAgdGhpcy52aWV3LmRvbS5yZW1vdmVFdmVudExpc3RlbmVyKFwiRE9NQ2hhcmFjdGVyRGF0YU1vZGlmaWVkXCIsIHRoaXMub25DaGFyRGF0YSk7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdFNlbGVjdGlvbigpO1xuICAgIH1cbiAgICBjb25uZWN0U2VsZWN0aW9uKCkge1xuICAgICAgICB0aGlzLnZpZXcuZG9tLm93bmVyRG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInNlbGVjdGlvbmNoYW5nZVwiLCB0aGlzLm9uU2VsZWN0aW9uQ2hhbmdlKTtcbiAgICB9XG4gICAgZGlzY29ubmVjdFNlbGVjdGlvbigpIHtcbiAgICAgICAgdGhpcy52aWV3LmRvbS5vd25lckRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJzZWxlY3Rpb25jaGFuZ2VcIiwgdGhpcy5vblNlbGVjdGlvbkNoYW5nZSk7XG4gICAgfVxuICAgIHN1cHByZXNzU2VsZWN0aW9uVXBkYXRlcygpIHtcbiAgICAgICAgdGhpcy5zdXBwcmVzc2luZ1NlbGVjdGlvblVwZGF0ZXMgPSB0cnVlO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc3VwcHJlc3NpbmdTZWxlY3Rpb25VcGRhdGVzID0gZmFsc2UsIDUwKTtcbiAgICB9XG4gICAgb25TZWxlY3Rpb25DaGFuZ2UoKSB7XG4gICAgICAgIGlmICghaGFzRm9jdXNBbmRTZWxlY3Rpb24odGhpcy52aWV3KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMuc3VwcHJlc3NpbmdTZWxlY3Rpb25VcGRhdGVzKVxuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGlvblRvRE9NKHRoaXMudmlldyk7XG4gICAgICAgIC8vIERlbGV0aW9ucyBvbiBJRTExIGZpcmUgdGhlaXIgZXZlbnRzIGluIHRoZSB3cm9uZyBvcmRlciwgZ2l2aW5nXG4gICAgICAgIC8vIHVzIGEgc2VsZWN0aW9uIGNoYW5nZSBldmVudCBiZWZvcmUgdGhlIERPTSBjaGFuZ2VzIGFyZVxuICAgICAgICAvLyByZXBvcnRlZC5cbiAgICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPD0gMTEgJiYgIXRoaXMudmlldy5zdGF0ZS5zZWxlY3Rpb24uZW1wdHkpIHtcbiAgICAgICAgICAgIGxldCBzZWwgPSB0aGlzLnZpZXcuZG9tU2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgICAgIC8vIFNlbGVjdGlvbi5pc0NvbGxhcHNlZCBpc24ndCByZWxpYWJsZSBvbiBJRVxuICAgICAgICAgICAgaWYgKHNlbC5mb2N1c05vZGUgJiYgaXNFcXVpdmFsZW50UG9zaXRpb24oc2VsLmZvY3VzTm9kZSwgc2VsLmZvY3VzT2Zmc2V0LCBzZWwuYW5jaG9yTm9kZSwgc2VsLmFuY2hvck9mZnNldCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmx1c2hTb29uKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgIH1cbiAgICBzZXRDdXJTZWxlY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFNlbGVjdGlvbi5zZXQodGhpcy52aWV3LmRvbVNlbGVjdGlvblJhbmdlKCkpO1xuICAgIH1cbiAgICBpZ25vcmVTZWxlY3Rpb25DaGFuZ2Uoc2VsKSB7XG4gICAgICAgIGlmICghc2VsLmZvY3VzTm9kZSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBsZXQgYW5jZXN0b3JzID0gbmV3IFNldCwgY29udGFpbmVyO1xuICAgICAgICBmb3IgKGxldCBzY2FuID0gc2VsLmZvY3VzTm9kZTsgc2Nhbjsgc2NhbiA9IHBhcmVudE5vZGUoc2NhbikpXG4gICAgICAgICAgICBhbmNlc3RvcnMuYWRkKHNjYW4pO1xuICAgICAgICBmb3IgKGxldCBzY2FuID0gc2VsLmFuY2hvck5vZGU7IHNjYW47IHNjYW4gPSBwYXJlbnROb2RlKHNjYW4pKVxuICAgICAgICAgICAgaWYgKGFuY2VzdG9ycy5oYXMoc2NhbikpIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIgPSBzY2FuO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICBsZXQgZGVzYyA9IGNvbnRhaW5lciAmJiB0aGlzLnZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyhjb250YWluZXIpO1xuICAgICAgICBpZiAoZGVzYyAmJiBkZXNjLmlnbm9yZU11dGF0aW9uKHtcbiAgICAgICAgICAgIHR5cGU6IFwic2VsZWN0aW9uXCIsXG4gICAgICAgICAgICB0YXJnZXQ6IGNvbnRhaW5lci5ub2RlVHlwZSA9PSAzID8gY29udGFpbmVyLnBhcmVudE5vZGUgOiBjb250YWluZXJcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3VyU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwZW5kaW5nUmVjb3JkcygpIHtcbiAgICAgICAgaWYgKHRoaXMub2JzZXJ2ZXIpXG4gICAgICAgICAgICBmb3IgKGxldCBtdXQgb2YgdGhpcy5vYnNlcnZlci50YWtlUmVjb3JkcygpKVxuICAgICAgICAgICAgICAgIHRoaXMucXVldWUucHVzaChtdXQpO1xuICAgICAgICByZXR1cm4gdGhpcy5xdWV1ZTtcbiAgICB9XG4gICAgZmx1c2goKSB7XG4gICAgICAgIGxldCB7IHZpZXcgfSA9IHRoaXM7XG4gICAgICAgIGlmICghdmlldy5kb2NWaWV3IHx8IHRoaXMuZmx1c2hpbmdTb29uID4gLTEpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBtdXRhdGlvbnMgPSB0aGlzLnBlbmRpbmdSZWNvcmRzKCk7XG4gICAgICAgIGlmIChtdXRhdGlvbnMubGVuZ3RoKVxuICAgICAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgICAgICBsZXQgc2VsID0gdmlldy5kb21TZWxlY3Rpb25SYW5nZSgpO1xuICAgICAgICBsZXQgbmV3U2VsID0gIXRoaXMuc3VwcHJlc3NpbmdTZWxlY3Rpb25VcGRhdGVzICYmICF0aGlzLmN1cnJlbnRTZWxlY3Rpb24uZXEoc2VsKSAmJiBoYXNGb2N1c0FuZFNlbGVjdGlvbih2aWV3KSAmJiAhdGhpcy5pZ25vcmVTZWxlY3Rpb25DaGFuZ2Uoc2VsKTtcbiAgICAgICAgbGV0IGZyb20gPSAtMSwgdG8gPSAtMSwgdHlwZU92ZXIgPSBmYWxzZSwgYWRkZWQgPSBbXTtcbiAgICAgICAgaWYgKHZpZXcuZWRpdGFibGUpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0YXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMucmVnaXN0ZXJNdXRhdGlvbihtdXRhdGlvbnNbaV0sIGFkZGVkKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGZyb20gPSBmcm9tIDwgMCA/IHJlc3VsdC5mcm9tIDogTWF0aC5taW4ocmVzdWx0LmZyb20sIGZyb20pO1xuICAgICAgICAgICAgICAgICAgICB0byA9IHRvIDwgMCA/IHJlc3VsdC50byA6IE1hdGgubWF4KHJlc3VsdC50bywgdG8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnR5cGVPdmVyKVxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZU92ZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2Vja28gJiYgYWRkZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgYnJzID0gYWRkZWQuZmlsdGVyKG4gPT4gbi5ub2RlTmFtZSA9PSBcIkJSXCIpO1xuICAgICAgICAgICAgaWYgKGJycy5sZW5ndGggPT0gMikge1xuICAgICAgICAgICAgICAgIGxldCBbYSwgYl0gPSBicnM7XG4gICAgICAgICAgICAgICAgaWYgKGEucGFyZW50Tm9kZSAmJiBhLnBhcmVudE5vZGUucGFyZW50Tm9kZSA9PSBiLnBhcmVudE5vZGUpXG4gICAgICAgICAgICAgICAgICAgIGIucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBhLnJlbW92ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IHsgZm9jdXNOb2RlIH0gPSB0aGlzLmN1cnJlbnRTZWxlY3Rpb247XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgYnIgb2YgYnJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwYXJlbnQgPSBici5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50ICYmIHBhcmVudC5ub2RlTmFtZSA9PSBcIkxJXCIgJiYgKCFmb2N1c05vZGUgfHwgYmxvY2tQYXJlbnQodmlldywgZm9jdXNOb2RlKSAhPSBwYXJlbnQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnIucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCByZWFkU2VsID0gbnVsbDtcbiAgICAgICAgLy8gSWYgaXQgbG9va3MgbGlrZSB0aGUgYnJvd3NlciBoYXMgcmVzZXQgdGhlIHNlbGVjdGlvbiB0byB0aGVcbiAgICAgICAgLy8gc3RhcnQgb2YgdGhlIGRvY3VtZW50IGFmdGVyIGZvY3VzLCByZXN0b3JlIHRoZSBzZWxlY3Rpb24gZnJvbVxuICAgICAgICAvLyB0aGUgc3RhdGVcbiAgICAgICAgaWYgKGZyb20gPCAwICYmIG5ld1NlbCAmJiB2aWV3LmlucHV0Lmxhc3RGb2N1cyA+IERhdGUubm93KCkgLSAyMDAgJiZcbiAgICAgICAgICAgIE1hdGgubWF4KHZpZXcuaW5wdXQubGFzdFRvdWNoLCB2aWV3LmlucHV0Lmxhc3RDbGljay50aW1lKSA8IERhdGUubm93KCkgLSAzMDAgJiZcbiAgICAgICAgICAgIHNlbGVjdGlvbkNvbGxhcHNlZChzZWwpICYmIChyZWFkU2VsID0gc2VsZWN0aW9uRnJvbURPTSh2aWV3KSkgJiZcbiAgICAgICAgICAgIHJlYWRTZWwuZXEoU2VsZWN0aW9uLm5lYXIodmlldy5zdGF0ZS5kb2MucmVzb2x2ZSgwKSwgMSkpKSB7XG4gICAgICAgICAgICB2aWV3LmlucHV0Lmxhc3RGb2N1cyA9IDA7XG4gICAgICAgICAgICBzZWxlY3Rpb25Ub0RPTSh2aWV3KTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNlbGVjdGlvbi5zZXQoc2VsKTtcbiAgICAgICAgICAgIHZpZXcuc2Nyb2xsVG9TZWxlY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmcm9tID4gLTEgfHwgbmV3U2VsKSB7XG4gICAgICAgICAgICBpZiAoZnJvbSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdmlldy5kb2NWaWV3Lm1hcmtEaXJ0eShmcm9tLCB0byk7XG4gICAgICAgICAgICAgICAgY2hlY2tDU1Modmlldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhhbmRsZURPTUNoYW5nZShmcm9tLCB0bywgdHlwZU92ZXIsIGFkZGVkKTtcbiAgICAgICAgICAgIGlmICh2aWV3LmRvY1ZpZXcgJiYgdmlldy5kb2NWaWV3LmRpcnR5KVxuICAgICAgICAgICAgICAgIHZpZXcudXBkYXRlU3RhdGUodmlldy5zdGF0ZSk7XG4gICAgICAgICAgICBlbHNlIGlmICghdGhpcy5jdXJyZW50U2VsZWN0aW9uLmVxKHNlbCkpXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uVG9ET00odmlldyk7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTZWxlY3Rpb24uc2V0KHNlbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVnaXN0ZXJNdXRhdGlvbihtdXQsIGFkZGVkKSB7XG4gICAgICAgIC8vIElnbm9yZSBtdXRhdGlvbnMgaW5zaWRlIG5vZGVzIHRoYXQgd2VyZSBhbHJlYWR5IG5vdGVkIGFzIGluc2VydGVkXG4gICAgICAgIGlmIChhZGRlZC5pbmRleE9mKG11dC50YXJnZXQpID4gLTEpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGRlc2MgPSB0aGlzLnZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyhtdXQudGFyZ2V0KTtcbiAgICAgICAgaWYgKG11dC50eXBlID09IFwiYXR0cmlidXRlc1wiICYmXG4gICAgICAgICAgICAoZGVzYyA9PSB0aGlzLnZpZXcuZG9jVmlldyB8fCBtdXQuYXR0cmlidXRlTmFtZSA9PSBcImNvbnRlbnRlZGl0YWJsZVwiIHx8XG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCBzb21ldGltZXMgZmlyZXMgc3B1cmlvdXMgZXZlbnRzIGZvciBudWxsL2VtcHR5IHN0eWxlc1xuICAgICAgICAgICAgICAgIChtdXQuYXR0cmlidXRlTmFtZSA9PSBcInN0eWxlXCIgJiYgIW11dC5vbGRWYWx1ZSAmJiAhbXV0LnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJzdHlsZVwiKSkpKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICghZGVzYyB8fCBkZXNjLmlnbm9yZU11dGF0aW9uKG11dCkpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgaWYgKG11dC50eXBlID09IFwiY2hpbGRMaXN0XCIpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0LmFkZGVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbm9kZSA9IG11dC5hZGRlZE5vZGVzW2ldO1xuICAgICAgICAgICAgICAgIGFkZGVkLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT0gMylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0Q2hhbmdlZFRleHROb2RlID0gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZXNjLmNvbnRlbnRET00gJiYgZGVzYy5jb250ZW50RE9NICE9IGRlc2MuZG9tICYmICFkZXNjLmNvbnRlbnRET00uY29udGFpbnMobXV0LnRhcmdldCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZnJvbTogZGVzYy5wb3NCZWZvcmUsIHRvOiBkZXNjLnBvc0FmdGVyIH07XG4gICAgICAgICAgICBsZXQgcHJldiA9IG11dC5wcmV2aW91c1NpYmxpbmcsIG5leHQgPSBtdXQubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8PSAxMSAmJiBtdXQuYWRkZWROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBJRTExIGdpdmVzIHVzIGluY29ycmVjdCBuZXh0L3ByZXYgc2libGluZ3MgZm9yIHNvbWVcbiAgICAgICAgICAgICAgICAvLyBpbnNlcnRpb25zLCBzbyBpZiB0aGVyZSBhcmUgYWRkZWQgbm9kZXMsIHJlY29tcHV0ZSB0aG9zZVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0LmFkZGVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHsgcHJldmlvdXNTaWJsaW5nLCBuZXh0U2libGluZyB9ID0gbXV0LmFkZGVkTm9kZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmICghcHJldmlvdXNTaWJsaW5nIHx8IEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwobXV0LmFkZGVkTm9kZXMsIHByZXZpb3VzU2libGluZykgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldiA9IHByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXh0U2libGluZyB8fCBBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKG11dC5hZGRlZE5vZGVzLCBuZXh0U2libGluZykgPCAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dCA9IG5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmcm9tT2Zmc2V0ID0gcHJldiAmJiBwcmV2LnBhcmVudE5vZGUgPT0gbXV0LnRhcmdldFxuICAgICAgICAgICAgICAgID8gZG9tSW5kZXgocHJldikgKyAxIDogMDtcbiAgICAgICAgICAgIGxldCBmcm9tID0gZGVzYy5sb2NhbFBvc0Zyb21ET00obXV0LnRhcmdldCwgZnJvbU9mZnNldCwgLTEpO1xuICAgICAgICAgICAgbGV0IHRvT2Zmc2V0ID0gbmV4dCAmJiBuZXh0LnBhcmVudE5vZGUgPT0gbXV0LnRhcmdldFxuICAgICAgICAgICAgICAgID8gZG9tSW5kZXgobmV4dCkgOiBtdXQudGFyZ2V0LmNoaWxkTm9kZXMubGVuZ3RoO1xuICAgICAgICAgICAgbGV0IHRvID0gZGVzYy5sb2NhbFBvc0Zyb21ET00obXV0LnRhcmdldCwgdG9PZmZzZXQsIDEpO1xuICAgICAgICAgICAgcmV0dXJuIHsgZnJvbSwgdG8gfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtdXQudHlwZSA9PSBcImF0dHJpYnV0ZXNcIikge1xuICAgICAgICAgICAgcmV0dXJuIHsgZnJvbTogZGVzYy5wb3NBdFN0YXJ0IC0gZGVzYy5ib3JkZXIsIHRvOiBkZXNjLnBvc0F0RW5kICsgZGVzYy5ib3JkZXIgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgLy8gXCJjaGFyYWN0ZXJEYXRhXCJcbiAgICAgICAgICAgIHRoaXMubGFzdENoYW5nZWRUZXh0Tm9kZSA9IG11dC50YXJnZXQ7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZyb206IGRlc2MucG9zQXRTdGFydCxcbiAgICAgICAgICAgICAgICB0bzogZGVzYy5wb3NBdEVuZCxcbiAgICAgICAgICAgICAgICAvLyBBbiBldmVudCB3YXMgZ2VuZXJhdGVkIGZvciBhIHRleHQgY2hhbmdlIHRoYXQgZGlkbid0IGNoYW5nZVxuICAgICAgICAgICAgICAgIC8vIGFueSB0ZXh0LiBNYXJrIHRoZSBkb20gY2hhbmdlIHRvIGZhbGwgYmFjayB0byBhc3N1bWluZyB0aGVcbiAgICAgICAgICAgICAgICAvLyBzZWxlY3Rpb24gd2FzIHR5cGVkIG92ZXIgd2l0aCBhbiBpZGVudGljYWwgdmFsdWUgaWYgaXQgY2FuJ3RcbiAgICAgICAgICAgICAgICAvLyBmaW5kIGFub3RoZXIgY2hhbmdlLlxuICAgICAgICAgICAgICAgIHR5cGVPdmVyOiBtdXQudGFyZ2V0Lm5vZGVWYWx1ZSA9PSBtdXQub2xkVmFsdWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG59XG5sZXQgY3NzQ2hlY2tlZCA9IG5ldyBXZWFrTWFwKCk7XG5sZXQgY3NzQ2hlY2tXYXJuZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGNoZWNrQ1NTKHZpZXcpIHtcbiAgICBpZiAoY3NzQ2hlY2tlZC5oYXModmlldykpXG4gICAgICAgIHJldHVybjtcbiAgICBjc3NDaGVja2VkLnNldCh2aWV3LCBudWxsKTtcbiAgICBpZiAoWydub3JtYWwnLCAnbm93cmFwJywgJ3ByZS1saW5lJ10uaW5kZXhPZihnZXRDb21wdXRlZFN0eWxlKHZpZXcuZG9tKS53aGl0ZVNwYWNlKSAhPT0gLTEpIHtcbiAgICAgICAgdmlldy5yZXF1aXJlc0dlY2tvSGFja05vZGUgPSBnZWNrbztcbiAgICAgICAgaWYgKGNzc0NoZWNrV2FybmVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zb2xlW1wid2FyblwiXShcIlByb3NlTWlycm9yIGV4cGVjdHMgdGhlIENTUyB3aGl0ZS1zcGFjZSBwcm9wZXJ0eSB0byBiZSBzZXQsIHByZWZlcmFibHkgdG8gJ3ByZS13cmFwJy4gSXQgaXMgcmVjb21tZW5kZWQgdG8gbG9hZCBzdHlsZS9wcm9zZW1pcnJvci5jc3MgZnJvbSB0aGUgcHJvc2VtaXJyb3ItdmlldyBwYWNrYWdlLlwiKTtcbiAgICAgICAgY3NzQ2hlY2tXYXJuZWQgPSB0cnVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJhbmdlVG9TZWxlY3Rpb25SYW5nZSh2aWV3LCByYW5nZSkge1xuICAgIGxldCBhbmNob3JOb2RlID0gcmFuZ2Uuc3RhcnRDb250YWluZXIsIGFuY2hvck9mZnNldCA9IHJhbmdlLnN0YXJ0T2Zmc2V0O1xuICAgIGxldCBmb2N1c05vZGUgPSByYW5nZS5lbmRDb250YWluZXIsIGZvY3VzT2Zmc2V0ID0gcmFuZ2UuZW5kT2Zmc2V0O1xuICAgIGxldCBjdXJyZW50QW5jaG9yID0gdmlldy5kb21BdFBvcyh2aWV3LnN0YXRlLnNlbGVjdGlvbi5hbmNob3IpO1xuICAgIC8vIFNpbmNlIHN1Y2ggYSByYW5nZSBkb2Vzbid0IGRpc3Rpbmd1aXNoIGJldHdlZW4gYW5jaG9yIGFuZCBoZWFkLFxuICAgIC8vIHVzZSBhIGhldXJpc3RpYyB0aGF0IGZsaXBzIGl0IGFyb3VuZCBpZiBpdHMgZW5kIG1hdGNoZXMgdGhlXG4gICAgLy8gY3VycmVudCBhbmNob3IuXG4gICAgaWYgKGlzRXF1aXZhbGVudFBvc2l0aW9uKGN1cnJlbnRBbmNob3Iubm9kZSwgY3VycmVudEFuY2hvci5vZmZzZXQsIGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpKVxuICAgICAgICBbYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0XSA9IFtmb2N1c05vZGUsIGZvY3VzT2Zmc2V0LCBhbmNob3JOb2RlLCBhbmNob3JPZmZzZXRdO1xuICAgIHJldHVybiB7IGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlLCBmb2N1c09mZnNldCB9O1xufVxuLy8gVXNlZCB0byB3b3JrIGFyb3VuZCBhIFNhZmFyaSBTZWxlY3Rpb24vc2hhZG93IERPTSBidWdcbi8vIEJhc2VkIG9uIGh0dHBzOi8vZ2l0aHViLmNvbS9jb2RlbWlycm9yL2Rldi9pc3N1ZXMvNDE0IGZpeFxuZnVuY3Rpb24gc2FmYXJpU2hhZG93U2VsZWN0aW9uUmFuZ2Uodmlldywgc2VsZWN0aW9uKSB7XG4gICAgaWYgKHNlbGVjdGlvbi5nZXRDb21wb3NlZFJhbmdlcykge1xuICAgICAgICBsZXQgcmFuZ2UgPSBzZWxlY3Rpb24uZ2V0Q29tcG9zZWRSYW5nZXModmlldy5yb290KVswXTtcbiAgICAgICAgaWYgKHJhbmdlKVxuICAgICAgICAgICAgcmV0dXJuIHJhbmdlVG9TZWxlY3Rpb25SYW5nZSh2aWV3LCByYW5nZSk7XG4gICAgfVxuICAgIGxldCBmb3VuZDtcbiAgICBmdW5jdGlvbiByZWFkKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICBmb3VuZCA9IGV2ZW50LmdldFRhcmdldFJhbmdlcygpWzBdO1xuICAgIH1cbiAgICAvLyBCZWNhdXNlIFNhZmFyaSAoYXQgbGVhc3QgaW4gMjAxOC0yMDIyKSBkb2Vzbid0IHByb3ZpZGUgcmVndWxhclxuICAgIC8vIGFjY2VzcyB0byB0aGUgc2VsZWN0aW9uIGluc2lkZSBhIHNoYWRvd1Jvb3QsIHdlIGhhdmUgdG8gcGVyZm9ybSBhXG4gICAgLy8gcmlkaWN1bG91cyBoYWNrIHRvIGdldCBhdCBpdOKAlHVzaW5nIGBleGVjQ29tbWFuZGAgdG8gdHJpZ2dlciBhXG4gICAgLy8gYGJlZm9yZUlucHV0YCBldmVudCBzbyB0aGF0IHdlIGNhbiByZWFkIHRoZSB0YXJnZXQgcmFuZ2UgZnJvbSB0aGVcbiAgICAvLyBldmVudC5cbiAgICB2aWV3LmRvbS5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JlaW5wdXRcIiwgcmVhZCwgdHJ1ZSk7XG4gICAgZG9jdW1lbnQuZXhlY0NvbW1hbmQoXCJpbmRlbnRcIik7XG4gICAgdmlldy5kb20ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJlZm9yZWlucHV0XCIsIHJlYWQsIHRydWUpO1xuICAgIHJldHVybiBmb3VuZCA/IHJhbmdlVG9TZWxlY3Rpb25SYW5nZSh2aWV3LCBmb3VuZCkgOiBudWxsO1xufVxuZnVuY3Rpb24gYmxvY2tQYXJlbnQodmlldywgbm9kZSkge1xuICAgIGZvciAobGV0IHAgPSBub2RlLnBhcmVudE5vZGU7IHAgJiYgcCAhPSB2aWV3LmRvbTsgcCA9IHAucGFyZW50Tm9kZSkge1xuICAgICAgICBsZXQgZGVzYyA9IHZpZXcuZG9jVmlldy5uZWFyZXN0RGVzYyhwLCB0cnVlKTtcbiAgICAgICAgaWYgKGRlc2MgJiYgZGVzYy5ub2RlLmlzQmxvY2spXG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbi8vIE5vdGUgdGhhdCBhbGwgcmVmZXJlbmNpbmcgYW5kIHBhcnNpbmcgaXMgZG9uZSB3aXRoIHRoZVxuLy8gc3RhcnQtb2Ytb3BlcmF0aW9uIHNlbGVjdGlvbiBhbmQgZG9jdW1lbnQsIHNpbmNlIHRoYXQncyB0aGUgb25lXG4vLyB0aGF0IHRoZSBET00gcmVwcmVzZW50cy4gSWYgYW55IGNoYW5nZXMgY2FtZSBpbiBpbiB0aGUgbWVhbnRpbWUsXG4vLyB0aGUgbW9kaWZpY2F0aW9uIGlzIG1hcHBlZCBvdmVyIHRob3NlIGJlZm9yZSBpdCBpcyBhcHBsaWVkLCBpblxuLy8gcmVhZERPTUNoYW5nZS5cbmZ1bmN0aW9uIHBhcnNlQmV0d2Vlbih2aWV3LCBmcm9tXywgdG9fKSB7XG4gICAgbGV0IHsgbm9kZTogcGFyZW50LCBmcm9tT2Zmc2V0LCB0b09mZnNldCwgZnJvbSwgdG8gfSA9IHZpZXcuZG9jVmlldy5wYXJzZVJhbmdlKGZyb21fLCB0b18pO1xuICAgIGxldCBkb21TZWwgPSB2aWV3LmRvbVNlbGVjdGlvblJhbmdlKCk7XG4gICAgbGV0IGZpbmQ7XG4gICAgbGV0IGFuY2hvciA9IGRvbVNlbC5hbmNob3JOb2RlO1xuICAgIGlmIChhbmNob3IgJiYgdmlldy5kb20uY29udGFpbnMoYW5jaG9yLm5vZGVUeXBlID09IDEgPyBhbmNob3IgOiBhbmNob3IucGFyZW50Tm9kZSkpIHtcbiAgICAgICAgZmluZCA9IFt7IG5vZGU6IGFuY2hvciwgb2Zmc2V0OiBkb21TZWwuYW5jaG9yT2Zmc2V0IH1dO1xuICAgICAgICBpZiAoIXNlbGVjdGlvbkNvbGxhcHNlZChkb21TZWwpKVxuICAgICAgICAgICAgZmluZC5wdXNoKHsgbm9kZTogZG9tU2VsLmZvY3VzTm9kZSwgb2Zmc2V0OiBkb21TZWwuZm9jdXNPZmZzZXQgfSk7XG4gICAgfVxuICAgIC8vIFdvcmsgYXJvdW5kIGlzc3VlIGluIENocm9tZSB3aGVyZSBiYWNrc3BhY2luZyBzb21ldGltZXMgcmVwbGFjZXNcbiAgICAvLyB0aGUgZGVsZXRlZCBjb250ZW50IHdpdGggYSByYW5kb20gQlIgbm9kZSAoaXNzdWVzICM3OTksICM4MzEpXG4gICAgaWYgKGNocm9tZSAmJiB2aWV3LmlucHV0Lmxhc3RLZXlDb2RlID09PSA4KSB7XG4gICAgICAgIGZvciAobGV0IG9mZiA9IHRvT2Zmc2V0OyBvZmYgPiBmcm9tT2Zmc2V0OyBvZmYtLSkge1xuICAgICAgICAgICAgbGV0IG5vZGUgPSBwYXJlbnQuY2hpbGROb2Rlc1tvZmYgLSAxXSwgZGVzYyA9IG5vZGUucG1WaWV3RGVzYztcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVOYW1lID09IFwiQlJcIiAmJiAhZGVzYykge1xuICAgICAgICAgICAgICAgIHRvT2Zmc2V0ID0gb2ZmO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFkZXNjIHx8IGRlc2Muc2l6ZSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgc3RhcnREb2MgPSB2aWV3LnN0YXRlLmRvYztcbiAgICBsZXQgcGFyc2VyID0gdmlldy5zb21lUHJvcChcImRvbVBhcnNlclwiKSB8fCBET01QYXJzZXIuZnJvbVNjaGVtYSh2aWV3LnN0YXRlLnNjaGVtYSk7XG4gICAgbGV0ICRmcm9tID0gc3RhcnREb2MucmVzb2x2ZShmcm9tKTtcbiAgICBsZXQgc2VsID0gbnVsbCwgZG9jID0gcGFyc2VyLnBhcnNlKHBhcmVudCwge1xuICAgICAgICB0b3BOb2RlOiAkZnJvbS5wYXJlbnQsXG4gICAgICAgIHRvcE1hdGNoOiAkZnJvbS5wYXJlbnQuY29udGVudE1hdGNoQXQoJGZyb20uaW5kZXgoKSksXG4gICAgICAgIHRvcE9wZW46IHRydWUsXG4gICAgICAgIGZyb206IGZyb21PZmZzZXQsXG4gICAgICAgIHRvOiB0b09mZnNldCxcbiAgICAgICAgcHJlc2VydmVXaGl0ZXNwYWNlOiAkZnJvbS5wYXJlbnQudHlwZS53aGl0ZXNwYWNlID09IFwicHJlXCIgPyBcImZ1bGxcIiA6IHRydWUsXG4gICAgICAgIGZpbmRQb3NpdGlvbnM6IGZpbmQsXG4gICAgICAgIHJ1bGVGcm9tTm9kZSxcbiAgICAgICAgY29udGV4dDogJGZyb21cbiAgICB9KTtcbiAgICBpZiAoZmluZCAmJiBmaW5kWzBdLnBvcyAhPSBudWxsKSB7XG4gICAgICAgIGxldCBhbmNob3IgPSBmaW5kWzBdLnBvcywgaGVhZCA9IGZpbmRbMV0gJiYgZmluZFsxXS5wb3M7XG4gICAgICAgIGlmIChoZWFkID09IG51bGwpXG4gICAgICAgICAgICBoZWFkID0gYW5jaG9yO1xuICAgICAgICBzZWwgPSB7IGFuY2hvcjogYW5jaG9yICsgZnJvbSwgaGVhZDogaGVhZCArIGZyb20gfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgZG9jLCBzZWwsIGZyb20sIHRvIH07XG59XG5mdW5jdGlvbiBydWxlRnJvbU5vZGUoZG9tKSB7XG4gICAgbGV0IGRlc2MgPSBkb20ucG1WaWV3RGVzYztcbiAgICBpZiAoZGVzYykge1xuICAgICAgICByZXR1cm4gZGVzYy5wYXJzZVJ1bGUoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZG9tLm5vZGVOYW1lID09IFwiQlJcIiAmJiBkb20ucGFyZW50Tm9kZSkge1xuICAgICAgICAvLyBTYWZhcmkgcmVwbGFjZXMgdGhlIGxpc3QgaXRlbSBvciB0YWJsZSBjZWxsIHdpdGggYSBCUlxuICAgICAgICAvLyBkaXJlY3RseSBpbiB0aGUgbGlzdCBub2RlICg/ISkgaWYgeW91IGRlbGV0ZSB0aGUgbGFzdFxuICAgICAgICAvLyBjaGFyYWN0ZXIgaW4gYSBsaXN0IGl0ZW0gb3IgdGFibGUgY2VsbCAoIzcwOCwgIzg2MilcbiAgICAgICAgaWYgKHNhZmFyaSAmJiAvXih1bHxvbCkkL2kudGVzdChkb20ucGFyZW50Tm9kZS5ub2RlTmFtZSkpIHtcbiAgICAgICAgICAgIGxldCBza2lwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIHNraXAuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpXCIpKTtcbiAgICAgICAgICAgIHJldHVybiB7IHNraXAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkb20ucGFyZW50Tm9kZS5sYXN0Q2hpbGQgPT0gZG9tIHx8IHNhZmFyaSAmJiAvXih0cnx0YWJsZSkkL2kudGVzdChkb20ucGFyZW50Tm9kZS5ub2RlTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IGlnbm9yZTogdHJ1ZSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGRvbS5ub2RlTmFtZSA9PSBcIklNR1wiICYmIGRvbS5nZXRBdHRyaWJ1dGUoXCJtYXJrLXBsYWNlaG9sZGVyXCIpKSB7XG4gICAgICAgIHJldHVybiB7IGlnbm9yZTogdHJ1ZSB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmNvbnN0IGlzSW5saW5lID0gL14oYXxhYmJyfGFjcm9ueW18YnxiZFtpb118YmlnfGJyfGJ1dHRvbnxjaXRlfGNvZGV8ZGF0YShsaXN0KT98ZGVsfGRmbnxlbXxpfGltZ3xpbnN8a2JkfGxhYmVsfG1hcHxtYXJrfG1ldGVyfG91dHB1dHxxfHJ1Ynl8c3xzYW1wfHNtYWxsfHNwYW58c3Ryb25nfHN1W2JwXXx0aW1lfHV8dHR8dmFyKSQvaTtcbmZ1bmN0aW9uIHJlYWRET01DaGFuZ2UodmlldywgZnJvbSwgdG8sIHR5cGVPdmVyLCBhZGRlZE5vZGVzKSB7XG4gICAgbGV0IGNvbXBvc2l0aW9uSUQgPSB2aWV3LmlucHV0LmNvbXBvc2l0aW9uUGVuZGluZ0NoYW5nZXMgfHwgKHZpZXcuY29tcG9zaW5nID8gdmlldy5pbnB1dC5jb21wb3NpdGlvbklEIDogMCk7XG4gICAgdmlldy5pbnB1dC5jb21wb3NpdGlvblBlbmRpbmdDaGFuZ2VzID0gMDtcbiAgICBpZiAoZnJvbSA8IDApIHtcbiAgICAgICAgbGV0IG9yaWdpbiA9IHZpZXcuaW5wdXQubGFzdFNlbGVjdGlvblRpbWUgPiBEYXRlLm5vdygpIC0gNTAgPyB2aWV3LmlucHV0Lmxhc3RTZWxlY3Rpb25PcmlnaW4gOiBudWxsO1xuICAgICAgICBsZXQgbmV3U2VsID0gc2VsZWN0aW9uRnJvbURPTSh2aWV3LCBvcmlnaW4pO1xuICAgICAgICBpZiAobmV3U2VsICYmICF2aWV3LnN0YXRlLnNlbGVjdGlvbi5lcShuZXdTZWwpKSB7XG4gICAgICAgICAgICBpZiAoY2hyb21lICYmIGFuZHJvaWQgJiZcbiAgICAgICAgICAgICAgICB2aWV3LmlucHV0Lmxhc3RLZXlDb2RlID09PSAxMyAmJiBEYXRlLm5vdygpIC0gMTAwIDwgdmlldy5pbnB1dC5sYXN0S2V5Q29kZVRpbWUgJiZcbiAgICAgICAgICAgICAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlS2V5RG93blwiLCBmID0+IGYodmlldywga2V5RXZlbnQoMTMsIFwiRW50ZXJcIikpKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgdHIgPSB2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihuZXdTZWwpO1xuICAgICAgICAgICAgaWYgKG9yaWdpbiA9PSBcInBvaW50ZXJcIilcbiAgICAgICAgICAgICAgICB0ci5zZXRNZXRhKFwicG9pbnRlclwiLCB0cnVlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKG9yaWdpbiA9PSBcImtleVwiKVxuICAgICAgICAgICAgICAgIHRyLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgICAgICBpZiAoY29tcG9zaXRpb25JRClcbiAgICAgICAgICAgICAgICB0ci5zZXRNZXRhKFwiY29tcG9zaXRpb25cIiwgY29tcG9zaXRpb25JRCk7XG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHRyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCAkYmVmb3JlID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZShmcm9tKTtcbiAgICBsZXQgc2hhcmVkID0gJGJlZm9yZS5zaGFyZWREZXB0aCh0byk7XG4gICAgZnJvbSA9ICRiZWZvcmUuYmVmb3JlKHNoYXJlZCArIDEpO1xuICAgIHRvID0gdmlldy5zdGF0ZS5kb2MucmVzb2x2ZSh0bykuYWZ0ZXIoc2hhcmVkICsgMSk7XG4gICAgbGV0IHNlbCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uO1xuICAgIGxldCBwYXJzZSA9IHBhcnNlQmV0d2Vlbih2aWV3LCBmcm9tLCB0byk7XG4gICAgbGV0IGRvYyA9IHZpZXcuc3RhdGUuZG9jLCBjb21wYXJlID0gZG9jLnNsaWNlKHBhcnNlLmZyb20sIHBhcnNlLnRvKTtcbiAgICBsZXQgcHJlZmVycmVkUG9zLCBwcmVmZXJyZWRTaWRlO1xuICAgIC8vIFByZWZlciBhbmNob3JpbmcgdG8gZW5kIHdoZW4gQmFja3NwYWNlIGlzIHByZXNzZWRcbiAgICBpZiAodmlldy5pbnB1dC5sYXN0S2V5Q29kZSA9PT0gOCAmJiBEYXRlLm5vdygpIC0gMTAwIDwgdmlldy5pbnB1dC5sYXN0S2V5Q29kZVRpbWUpIHtcbiAgICAgICAgcHJlZmVycmVkUG9zID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24udG87XG4gICAgICAgIHByZWZlcnJlZFNpZGUgPSBcImVuZFwiO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcHJlZmVycmVkUG9zID0gdmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbTtcbiAgICAgICAgcHJlZmVycmVkU2lkZSA9IFwic3RhcnRcIjtcbiAgICB9XG4gICAgdmlldy5pbnB1dC5sYXN0S2V5Q29kZSA9IG51bGw7XG4gICAgbGV0IGNoYW5nZSA9IGZpbmREaWZmKGNvbXBhcmUuY29udGVudCwgcGFyc2UuZG9jLmNvbnRlbnQsIHBhcnNlLmZyb20sIHByZWZlcnJlZFBvcywgcHJlZmVycmVkU2lkZSk7XG4gICAgaWYgKGNoYW5nZSlcbiAgICAgICAgdmlldy5pbnB1dC5kb21DaGFuZ2VDb3VudCsrO1xuICAgIGlmICgoaW9zICYmIHZpZXcuaW5wdXQubGFzdElPU0VudGVyID4gRGF0ZS5ub3coKSAtIDIyNSB8fCBhbmRyb2lkKSAmJlxuICAgICAgICBhZGRlZE5vZGVzLnNvbWUobiA9PiBuLm5vZGVUeXBlID09IDEgJiYgIWlzSW5saW5lLnRlc3Qobi5ub2RlTmFtZSkpICYmXG4gICAgICAgICghY2hhbmdlIHx8IGNoYW5nZS5lbmRBID49IGNoYW5nZS5lbmRCKSAmJlxuICAgICAgICB2aWV3LnNvbWVQcm9wKFwiaGFuZGxlS2V5RG93blwiLCBmID0+IGYodmlldywga2V5RXZlbnQoMTMsIFwiRW50ZXJcIikpKSkge1xuICAgICAgICB2aWV3LmlucHV0Lmxhc3RJT1NFbnRlciA9IDA7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFjaGFuZ2UpIHtcbiAgICAgICAgaWYgKHR5cGVPdmVyICYmIHNlbCBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24gJiYgIXNlbC5lbXB0eSAmJiBzZWwuJGhlYWQuc2FtZVBhcmVudChzZWwuJGFuY2hvcikgJiZcbiAgICAgICAgICAgICF2aWV3LmNvbXBvc2luZyAmJiAhKHBhcnNlLnNlbCAmJiBwYXJzZS5zZWwuYW5jaG9yICE9IHBhcnNlLnNlbC5oZWFkKSkge1xuICAgICAgICAgICAgY2hhbmdlID0geyBzdGFydDogc2VsLmZyb20sIGVuZEE6IHNlbC50bywgZW5kQjogc2VsLnRvIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAocGFyc2Uuc2VsKSB7XG4gICAgICAgICAgICAgICAgbGV0IHNlbCA9IHJlc29sdmVTZWxlY3Rpb24odmlldywgdmlldy5zdGF0ZS5kb2MsIHBhcnNlLnNlbCk7XG4gICAgICAgICAgICAgICAgaWYgKHNlbCAmJiAhc2VsLmVxKHZpZXcuc3RhdGUuc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdHIgPSB2aWV3LnN0YXRlLnRyLnNldFNlbGVjdGlvbihzZWwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcG9zaXRpb25JRClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyLnNldE1ldGEoXCJjb21wb3NpdGlvblwiLCBjb21wb3NpdGlvbklEKTtcbiAgICAgICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSBvdmVyd3JpdGluZyBhIHNlbGVjdGlvbiBieSB0eXBpbmcgbWF0Y2hlc1xuICAgIC8vIHRoZSBzdGFydCBvciBlbmQgb2YgdGhlIHNlbGVjdGVkIGNvbnRlbnQsIGNyZWF0aW5nIGEgY2hhbmdlXG4gICAgLy8gdGhhdCdzIHNtYWxsZXIgdGhhbiB3aGF0IHdhcyBhY3R1YWxseSBvdmVyd3JpdHRlbi5cbiAgICBpZiAodmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSA8IHZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvICYmXG4gICAgICAgIGNoYW5nZS5zdGFydCA9PSBjaGFuZ2UuZW5kQiAmJlxuICAgICAgICB2aWV3LnN0YXRlLnNlbGVjdGlvbiBpbnN0YW5jZW9mIFRleHRTZWxlY3Rpb24pIHtcbiAgICAgICAgaWYgKGNoYW5nZS5zdGFydCA+IHZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb20gJiYgY2hhbmdlLnN0YXJ0IDw9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb20gKyAyICYmXG4gICAgICAgICAgICB2aWV3LnN0YXRlLnNlbGVjdGlvbi5mcm9tID49IHBhcnNlLmZyb20pIHtcbiAgICAgICAgICAgIGNoYW5nZS5zdGFydCA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLmZyb207XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hhbmdlLmVuZEEgPCB2aWV3LnN0YXRlLnNlbGVjdGlvbi50byAmJiBjaGFuZ2UuZW5kQSA+PSB2aWV3LnN0YXRlLnNlbGVjdGlvbi50byAtIDIgJiZcbiAgICAgICAgICAgIHZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvIDw9IHBhcnNlLnRvKSB7XG4gICAgICAgICAgICBjaGFuZ2UuZW5kQiArPSAodmlldy5zdGF0ZS5zZWxlY3Rpb24udG8gLSBjaGFuZ2UuZW5kQSk7XG4gICAgICAgICAgICBjaGFuZ2UuZW5kQSA9IHZpZXcuc3RhdGUuc2VsZWN0aW9uLnRvO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIElFMTEgd2lsbCBpbnNlcnQgYSBub24tYnJlYWtpbmcgc3BhY2UgX2FoZWFkXyBvZiB0aGUgc3BhY2UgYWZ0ZXJcbiAgICAvLyB0aGUgY3Vyc29yIHNwYWNlIHdoZW4gYWRkaW5nIGEgc3BhY2UgYmVmb3JlIGFub3RoZXIgc3BhY2UuIFdoZW5cbiAgICAvLyB0aGF0IGhhcHBlbmVkLCBhZGp1c3QgdGhlIGNoYW5nZSB0byBjb3ZlciB0aGUgc3BhY2UgaW5zdGVhZC5cbiAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8PSAxMSAmJiBjaGFuZ2UuZW5kQiA9PSBjaGFuZ2Uuc3RhcnQgKyAxICYmXG4gICAgICAgIGNoYW5nZS5lbmRBID09IGNoYW5nZS5zdGFydCAmJiBjaGFuZ2Uuc3RhcnQgPiBwYXJzZS5mcm9tICYmXG4gICAgICAgIHBhcnNlLmRvYy50ZXh0QmV0d2VlbihjaGFuZ2Uuc3RhcnQgLSBwYXJzZS5mcm9tIC0gMSwgY2hhbmdlLnN0YXJ0IC0gcGFyc2UuZnJvbSArIDEpID09IFwiIFxcdTAwYTBcIikge1xuICAgICAgICBjaGFuZ2Uuc3RhcnQtLTtcbiAgICAgICAgY2hhbmdlLmVuZEEtLTtcbiAgICAgICAgY2hhbmdlLmVuZEItLTtcbiAgICB9XG4gICAgbGV0ICRmcm9tID0gcGFyc2UuZG9jLnJlc29sdmVOb0NhY2hlKGNoYW5nZS5zdGFydCAtIHBhcnNlLmZyb20pO1xuICAgIGxldCAkdG8gPSBwYXJzZS5kb2MucmVzb2x2ZU5vQ2FjaGUoY2hhbmdlLmVuZEIgLSBwYXJzZS5mcm9tKTtcbiAgICBsZXQgJGZyb21BID0gZG9jLnJlc29sdmUoY2hhbmdlLnN0YXJ0KTtcbiAgICBsZXQgaW5saW5lQ2hhbmdlID0gJGZyb20uc2FtZVBhcmVudCgkdG8pICYmICRmcm9tLnBhcmVudC5pbmxpbmVDb250ZW50ICYmICRmcm9tQS5lbmQoKSA+PSBjaGFuZ2UuZW5kQTtcbiAgICAvLyBJZiB0aGlzIGxvb2tzIGxpa2UgdGhlIGVmZmVjdCBvZiBwcmVzc2luZyBFbnRlciAob3Igd2FzIHJlY29yZGVkXG4gICAgLy8gYXMgYmVpbmcgYW4gaU9TIGVudGVyIHByZXNzKSwganVzdCBkaXNwYXRjaCBhbiBFbnRlciBrZXkgaW5zdGVhZC5cbiAgICBpZiAoKChpb3MgJiYgdmlldy5pbnB1dC5sYXN0SU9TRW50ZXIgPiBEYXRlLm5vdygpIC0gMjI1ICYmXG4gICAgICAgICghaW5saW5lQ2hhbmdlIHx8IGFkZGVkTm9kZXMuc29tZShuID0+IG4ubm9kZU5hbWUgPT0gXCJESVZcIiB8fCBuLm5vZGVOYW1lID09IFwiUFwiKSkpIHx8XG4gICAgICAgICghaW5saW5lQ2hhbmdlICYmICRmcm9tLnBvcyA8IHBhcnNlLmRvYy5jb250ZW50LnNpemUgJiZcbiAgICAgICAgICAgICghJGZyb20uc2FtZVBhcmVudCgkdG8pIHx8ICEkZnJvbS5wYXJlbnQuaW5saW5lQ29udGVudCkgJiZcbiAgICAgICAgICAgICRmcm9tLnBvcyA8ICR0by5wb3MgJiYgIS9cXFMvLnRlc3QocGFyc2UuZG9jLnRleHRCZXR3ZWVuKCRmcm9tLnBvcywgJHRvLnBvcywgXCJcIiwgXCJcIikpKSkgJiZcbiAgICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZiA9PiBmKHZpZXcsIGtleUV2ZW50KDEzLCBcIkVudGVyXCIpKSkpIHtcbiAgICAgICAgdmlldy5pbnB1dC5sYXN0SU9TRW50ZXIgPSAwO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFNhbWUgZm9yIGJhY2tzcGFjZVxuICAgIGlmICh2aWV3LnN0YXRlLnNlbGVjdGlvbi5hbmNob3IgPiBjaGFuZ2Uuc3RhcnQgJiZcbiAgICAgICAgbG9va3NMaWtlQmFja3NwYWNlKGRvYywgY2hhbmdlLnN0YXJ0LCBjaGFuZ2UuZW5kQSwgJGZyb20sICR0bykgJiZcbiAgICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZiA9PiBmKHZpZXcsIGtleUV2ZW50KDgsIFwiQmFja3NwYWNlXCIpKSkpIHtcbiAgICAgICAgaWYgKGFuZHJvaWQgJiYgY2hyb21lKVxuICAgICAgICAgICAgdmlldy5kb21PYnNlcnZlci5zdXBwcmVzc1NlbGVjdGlvblVwZGF0ZXMoKTsgLy8gIzgyMFxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIENocm9tZSB3aWxsIG9jY2FzaW9uYWxseSwgZHVyaW5nIGNvbXBvc2l0aW9uLCBkZWxldGUgdGhlXG4gICAgLy8gZW50aXJlIGNvbXBvc2l0aW9uIGFuZCB0aGVuIGltbWVkaWF0ZWx5IGluc2VydCBpdCBhZ2Fpbi4gVGhpcyBpc1xuICAgIC8vIHVzZWQgdG8gZGV0ZWN0IHRoYXQgc2l0dWF0aW9uLlxuICAgIGlmIChjaHJvbWUgJiYgY2hhbmdlLmVuZEIgPT0gY2hhbmdlLnN0YXJ0KVxuICAgICAgICB2aWV3LmlucHV0Lmxhc3RDaHJvbWVEZWxldGUgPSBEYXRlLm5vdygpO1xuICAgIC8vIFRoaXMgdHJpZXMgdG8gZGV0ZWN0IEFuZHJvaWQgdmlydHVhbCBrZXlib2FyZFxuICAgIC8vIGVudGVyLWFuZC1waWNrLXN1Z2dlc3Rpb24gYWN0aW9uLiBUaGF0IHNvbWV0aW1lcyAoc2VlIGlzc3VlXG4gICAgLy8gIzEwNTkpIGZpcnN0IGZpcmVzIGEgRE9NIG11dGF0aW9uLCBiZWZvcmUgbW92aW5nIHRoZSBzZWxlY3Rpb24gdG9cbiAgICAvLyB0aGUgbmV3bHkgY3JlYXRlZCBibG9jay4gQW5kIHRoZW4sIGJlY2F1c2UgUHJvc2VNaXJyb3IgY2xlYW5zIHVwXG4gICAgLy8gdGhlIERPTSBzZWxlY3Rpb24sIGl0IGdpdmVzIHVwIG1vdmluZyB0aGUgc2VsZWN0aW9uIGVudGlyZWx5LFxuICAgIC8vIGxlYXZpbmcgdGhlIGN1cnNvciBpbiB0aGUgd3JvbmcgcGxhY2UuIFdoZW4gdGhhdCBoYXBwZW5zLCB3ZSBkcm9wXG4gICAgLy8gdGhlIG5ldyBwYXJhZ3JhcGggZnJvbSB0aGUgaW5pdGlhbCBjaGFuZ2UsIGFuZCBmaXJlIGEgc2ltdWxhdGVkXG4gICAgLy8gZW50ZXIga2V5IGFmdGVyd2FyZHMuXG4gICAgaWYgKGFuZHJvaWQgJiYgIWlubGluZUNoYW5nZSAmJiAkZnJvbS5zdGFydCgpICE9ICR0by5zdGFydCgpICYmICR0by5wYXJlbnRPZmZzZXQgPT0gMCAmJiAkZnJvbS5kZXB0aCA9PSAkdG8uZGVwdGggJiZcbiAgICAgICAgcGFyc2Uuc2VsICYmIHBhcnNlLnNlbC5hbmNob3IgPT0gcGFyc2Uuc2VsLmhlYWQgJiYgcGFyc2Uuc2VsLmhlYWQgPT0gY2hhbmdlLmVuZEEpIHtcbiAgICAgICAgY2hhbmdlLmVuZEIgLT0gMjtcbiAgICAgICAgJHRvID0gcGFyc2UuZG9jLnJlc29sdmVOb0NhY2hlKGNoYW5nZS5lbmRCIC0gcGFyc2UuZnJvbSk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdmlldy5zb21lUHJvcChcImhhbmRsZUtleURvd25cIiwgZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGYodmlldywga2V5RXZlbnQoMTMsIFwiRW50ZXJcIikpOyB9KTtcbiAgICAgICAgfSwgMjApO1xuICAgIH1cbiAgICBsZXQgY2hGcm9tID0gY2hhbmdlLnN0YXJ0LCBjaFRvID0gY2hhbmdlLmVuZEE7XG4gICAgbGV0IG1rVHIgPSAoYmFzZSkgPT4ge1xuICAgICAgICBsZXQgdHIgPSBiYXNlIHx8IHZpZXcuc3RhdGUudHIucmVwbGFjZShjaEZyb20sIGNoVG8sIHBhcnNlLmRvYy5zbGljZShjaGFuZ2Uuc3RhcnQgLSBwYXJzZS5mcm9tLCBjaGFuZ2UuZW5kQiAtIHBhcnNlLmZyb20pKTtcbiAgICAgICAgaWYgKHBhcnNlLnNlbCkge1xuICAgICAgICAgICAgbGV0IHNlbCA9IHJlc29sdmVTZWxlY3Rpb24odmlldywgdHIuZG9jLCBwYXJzZS5zZWwpO1xuICAgICAgICAgICAgLy8gQ2hyb21lIHdpbGwgc29tZXRpbWVzLCBkdXJpbmcgY29tcG9zaXRpb24sIHJlcG9ydCB0aGVcbiAgICAgICAgICAgIC8vIHNlbGVjdGlvbiBpbiB0aGUgd3JvbmcgcGxhY2UuIElmIGl0IGxvb2tzIGxpa2UgdGhhdCBpc1xuICAgICAgICAgICAgLy8gaGFwcGVuaW5nLCBkb24ndCB1cGRhdGUgdGhlIHNlbGVjdGlvbi5cbiAgICAgICAgICAgIC8vIEVkZ2UganVzdCBkb2Vzbid0IG1vdmUgdGhlIGN1cnNvciBmb3J3YXJkIHdoZW4geW91IHN0YXJ0IHR5cGluZ1xuICAgICAgICAgICAgLy8gaW4gYW4gZW1wdHkgYmxvY2sgb3IgYmV0d2VlbiBiciBub2Rlcy5cbiAgICAgICAgICAgIGlmIChzZWwgJiYgIShjaHJvbWUgJiYgdmlldy5jb21wb3NpbmcgJiYgc2VsLmVtcHR5ICYmXG4gICAgICAgICAgICAgICAgKGNoYW5nZS5zdGFydCAhPSBjaGFuZ2UuZW5kQiB8fCB2aWV3LmlucHV0Lmxhc3RDaHJvbWVEZWxldGUgPCBEYXRlLm5vdygpIC0gMTAwKSAmJlxuICAgICAgICAgICAgICAgIChzZWwuaGVhZCA9PSBjaEZyb20gfHwgc2VsLmhlYWQgPT0gdHIubWFwcGluZy5tYXAoY2hUbykgLSAxKSB8fFxuICAgICAgICAgICAgICAgIGllICYmIHNlbC5lbXB0eSAmJiBzZWwuaGVhZCA9PSBjaEZyb20pKVxuICAgICAgICAgICAgICAgIHRyLnNldFNlbGVjdGlvbihzZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wb3NpdGlvbklEKVxuICAgICAgICAgICAgdHIuc2V0TWV0YShcImNvbXBvc2l0aW9uXCIsIGNvbXBvc2l0aW9uSUQpO1xuICAgICAgICByZXR1cm4gdHIuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICB9O1xuICAgIGxldCBtYXJrQ2hhbmdlO1xuICAgIGlmIChpbmxpbmVDaGFuZ2UpIHtcbiAgICAgICAgaWYgKCRmcm9tLnBvcyA9PSAkdG8ucG9zKSB7IC8vIERlbGV0aW9uXG4gICAgICAgICAgICAvLyBJRTExIHNvbWV0aW1lcyB3ZWlyZGx5IG1vdmVzIHRoZSBET00gc2VsZWN0aW9uIGFyb3VuZCBhZnRlclxuICAgICAgICAgICAgLy8gYmFja3NwYWNpbmcgb3V0IHRoZSBmaXJzdCBlbGVtZW50IGluIGEgdGV4dGJsb2NrXG4gICAgICAgICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8PSAxMSAmJiAkZnJvbS5wYXJlbnRPZmZzZXQgPT0gMCkge1xuICAgICAgICAgICAgICAgIHZpZXcuZG9tT2JzZXJ2ZXIuc3VwcHJlc3NTZWxlY3Rpb25VcGRhdGVzKCk7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBzZWxlY3Rpb25Ub0RPTSh2aWV3KSwgMjApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRyID0gbWtUcih2aWV3LnN0YXRlLnRyLmRlbGV0ZShjaEZyb20sIGNoVG8pKTtcbiAgICAgICAgICAgIGxldCBtYXJrcyA9IGRvYy5yZXNvbHZlKGNoYW5nZS5zdGFydCkubWFya3NBY3Jvc3MoZG9jLnJlc29sdmUoY2hhbmdlLmVuZEEpKTtcbiAgICAgICAgICAgIGlmIChtYXJrcylcbiAgICAgICAgICAgICAgICB0ci5lbnN1cmVNYXJrcyhtYXJrcyk7XG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHRyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICggLy8gQWRkaW5nIG9yIHJlbW92aW5nIGEgbWFya1xuICAgICAgICBjaGFuZ2UuZW5kQSA9PSBjaGFuZ2UuZW5kQiAmJlxuICAgICAgICAgICAgKG1hcmtDaGFuZ2UgPSBpc01hcmtDaGFuZ2UoJGZyb20ucGFyZW50LmNvbnRlbnQuY3V0KCRmcm9tLnBhcmVudE9mZnNldCwgJHRvLnBhcmVudE9mZnNldCksICRmcm9tQS5wYXJlbnQuY29udGVudC5jdXQoJGZyb21BLnBhcmVudE9mZnNldCwgY2hhbmdlLmVuZEEgLSAkZnJvbUEuc3RhcnQoKSkpKSkge1xuICAgICAgICAgICAgbGV0IHRyID0gbWtUcih2aWV3LnN0YXRlLnRyKTtcbiAgICAgICAgICAgIGlmIChtYXJrQ2hhbmdlLnR5cGUgPT0gXCJhZGRcIilcbiAgICAgICAgICAgICAgICB0ci5hZGRNYXJrKGNoRnJvbSwgY2hUbywgbWFya0NoYW5nZS5tYXJrKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0ci5yZW1vdmVNYXJrKGNoRnJvbSwgY2hUbywgbWFya0NoYW5nZS5tYXJrKTtcbiAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2godHIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCRmcm9tLnBhcmVudC5jaGlsZCgkZnJvbS5pbmRleCgpKS5pc1RleHQgJiYgJGZyb20uaW5kZXgoKSA9PSAkdG8uaW5kZXgoKSAtICgkdG8udGV4dE9mZnNldCA/IDAgOiAxKSkge1xuICAgICAgICAgICAgLy8gQm90aCBwb3NpdGlvbnMgaW4gdGhlIHNhbWUgdGV4dCBub2RlIC0tIHNpbXBseSBpbnNlcnQgdGV4dFxuICAgICAgICAgICAgbGV0IHRleHQgPSAkZnJvbS5wYXJlbnQudGV4dEJldHdlZW4oJGZyb20ucGFyZW50T2Zmc2V0LCAkdG8ucGFyZW50T2Zmc2V0KTtcbiAgICAgICAgICAgIGxldCBkZWZsdCA9ICgpID0+IG1rVHIodmlldy5zdGF0ZS50ci5pbnNlcnRUZXh0KHRleHQsIGNoRnJvbSwgY2hUbykpO1xuICAgICAgICAgICAgaWYgKCF2aWV3LnNvbWVQcm9wKFwiaGFuZGxlVGV4dElucHV0XCIsIGYgPT4gZih2aWV3LCBjaEZyb20sIGNoVG8sIHRleHQsIGRlZmx0KSkpXG4gICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaChkZWZsdCgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2gobWtUcigpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmlldy5kaXNwYXRjaChta1RyKCkpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmVTZWxlY3Rpb24odmlldywgZG9jLCBwYXJzZWRTZWwpIHtcbiAgICBpZiAoTWF0aC5tYXgocGFyc2VkU2VsLmFuY2hvciwgcGFyc2VkU2VsLmhlYWQpID4gZG9jLmNvbnRlbnQuc2l6ZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHNlbGVjdGlvbkJldHdlZW4odmlldywgZG9jLnJlc29sdmUocGFyc2VkU2VsLmFuY2hvciksIGRvYy5yZXNvbHZlKHBhcnNlZFNlbC5oZWFkKSk7XG59XG4vLyBHaXZlbiB0d28gc2FtZS1sZW5ndGgsIG5vbi1lbXB0eSBmcmFnbWVudHMgb2YgaW5saW5lIGNvbnRlbnQsXG4vLyBkZXRlcm1pbmUgd2hldGhlciB0aGUgZmlyc3QgY291bGQgYmUgY3JlYXRlZCBmcm9tIHRoZSBzZWNvbmQgYnlcbi8vIHJlbW92aW5nIG9yIGFkZGluZyBhIHNpbmdsZSBtYXJrIHR5cGUuXG5mdW5jdGlvbiBpc01hcmtDaGFuZ2UoY3VyLCBwcmV2KSB7XG4gICAgbGV0IGN1ck1hcmtzID0gY3VyLmZpcnN0Q2hpbGQubWFya3MsIHByZXZNYXJrcyA9IHByZXYuZmlyc3RDaGlsZC5tYXJrcztcbiAgICBsZXQgYWRkZWQgPSBjdXJNYXJrcywgcmVtb3ZlZCA9IHByZXZNYXJrcywgdHlwZSwgbWFyaywgdXBkYXRlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldk1hcmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICBhZGRlZCA9IHByZXZNYXJrc1tpXS5yZW1vdmVGcm9tU2V0KGFkZGVkKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1ck1hcmtzLmxlbmd0aDsgaSsrKVxuICAgICAgICByZW1vdmVkID0gY3VyTWFya3NbaV0ucmVtb3ZlRnJvbVNldChyZW1vdmVkKTtcbiAgICBpZiAoYWRkZWQubGVuZ3RoID09IDEgJiYgcmVtb3ZlZC5sZW5ndGggPT0gMCkge1xuICAgICAgICBtYXJrID0gYWRkZWRbMF07XG4gICAgICAgIHR5cGUgPSBcImFkZFwiO1xuICAgICAgICB1cGRhdGUgPSAobm9kZSkgPT4gbm9kZS5tYXJrKG1hcmsuYWRkVG9TZXQobm9kZS5tYXJrcykpO1xuICAgIH1cbiAgICBlbHNlIGlmIChhZGRlZC5sZW5ndGggPT0gMCAmJiByZW1vdmVkLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIG1hcmsgPSByZW1vdmVkWzBdO1xuICAgICAgICB0eXBlID0gXCJyZW1vdmVcIjtcbiAgICAgICAgdXBkYXRlID0gKG5vZGUpID0+IG5vZGUubWFyayhtYXJrLnJlbW92ZUZyb21TZXQobm9kZS5tYXJrcykpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGxldCB1cGRhdGVkID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmV2LmNoaWxkQ291bnQ7IGkrKylcbiAgICAgICAgdXBkYXRlZC5wdXNoKHVwZGF0ZShwcmV2LmNoaWxkKGkpKSk7XG4gICAgaWYgKEZyYWdtZW50LmZyb20odXBkYXRlZCkuZXEoY3VyKSlcbiAgICAgICAgcmV0dXJuIHsgbWFyaywgdHlwZSB9O1xufVxuZnVuY3Rpb24gbG9va3NMaWtlQmFja3NwYWNlKG9sZCwgc3RhcnQsIGVuZCwgJG5ld1N0YXJ0LCAkbmV3RW5kKSB7XG4gICAgaWYgKCAvLyBUaGUgY29udGVudCBtdXN0IGhhdmUgc2hydW5rXG4gICAgZW5kIC0gc3RhcnQgPD0gJG5ld0VuZC5wb3MgLSAkbmV3U3RhcnQucG9zIHx8XG4gICAgICAgIC8vIG5ld0VuZCBtdXN0IHBvaW50IGRpcmVjdGx5IGF0IG9yIGFmdGVyIHRoZSBlbmQgb2YgdGhlIGJsb2NrIHRoYXQgbmV3U3RhcnQgcG9pbnRzIGludG9cbiAgICAgICAgc2tpcENsb3NpbmdBbmRPcGVuaW5nKCRuZXdTdGFydCwgdHJ1ZSwgZmFsc2UpIDwgJG5ld0VuZC5wb3MpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgJHN0YXJ0ID0gb2xkLnJlc29sdmUoc3RhcnQpO1xuICAgIC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSwgcmF0aGVyIHRoYW4gam9pbmluZyBibG9ja3MsIHRoZSBjaGFuZ2UganVzdCByZW1vdmVkIGFuIGVudGlyZSBibG9ja1xuICAgIGlmICghJG5ld1N0YXJ0LnBhcmVudC5pc1RleHRibG9jaykge1xuICAgICAgICBsZXQgYWZ0ZXIgPSAkc3RhcnQubm9kZUFmdGVyO1xuICAgICAgICByZXR1cm4gYWZ0ZXIgIT0gbnVsbCAmJiBlbmQgPT0gc3RhcnQgKyBhZnRlci5ub2RlU2l6ZTtcbiAgICB9XG4gICAgLy8gU3RhcnQgbXVzdCBiZSBhdCB0aGUgZW5kIG9mIGEgYmxvY2tcbiAgICBpZiAoJHN0YXJ0LnBhcmVudE9mZnNldCA8ICRzdGFydC5wYXJlbnQuY29udGVudC5zaXplIHx8ICEkc3RhcnQucGFyZW50LmlzVGV4dGJsb2NrKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0ICRuZXh0ID0gb2xkLnJlc29sdmUoc2tpcENsb3NpbmdBbmRPcGVuaW5nKCRzdGFydCwgdHJ1ZSwgdHJ1ZSkpO1xuICAgIC8vIFRoZSBuZXh0IHRleHRibG9jayBtdXN0IHN0YXJ0IGJlZm9yZSBlbmQgYW5kIGVuZCBuZWFyIGl0XG4gICAgaWYgKCEkbmV4dC5wYXJlbnQuaXNUZXh0YmxvY2sgfHwgJG5leHQucG9zID4gZW5kIHx8XG4gICAgICAgIHNraXBDbG9zaW5nQW5kT3BlbmluZygkbmV4dCwgdHJ1ZSwgZmFsc2UpIDwgZW5kKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgLy8gVGhlIGZyYWdtZW50cyBhZnRlciB0aGUgam9pbiBwb2ludCBtdXN0IG1hdGNoXG4gICAgcmV0dXJuICRuZXdTdGFydC5wYXJlbnQuY29udGVudC5jdXQoJG5ld1N0YXJ0LnBhcmVudE9mZnNldCkuZXEoJG5leHQucGFyZW50LmNvbnRlbnQpO1xufVxuZnVuY3Rpb24gc2tpcENsb3NpbmdBbmRPcGVuaW5nKCRwb3MsIGZyb21FbmQsIG1heU9wZW4pIHtcbiAgICBsZXQgZGVwdGggPSAkcG9zLmRlcHRoLCBlbmQgPSBmcm9tRW5kID8gJHBvcy5lbmQoKSA6ICRwb3MucG9zO1xuICAgIHdoaWxlIChkZXB0aCA+IDAgJiYgKGZyb21FbmQgfHwgJHBvcy5pbmRleEFmdGVyKGRlcHRoKSA9PSAkcG9zLm5vZGUoZGVwdGgpLmNoaWxkQ291bnQpKSB7XG4gICAgICAgIGRlcHRoLS07XG4gICAgICAgIGVuZCsrO1xuICAgICAgICBmcm9tRW5kID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChtYXlPcGVuKSB7XG4gICAgICAgIGxldCBuZXh0ID0gJHBvcy5ub2RlKGRlcHRoKS5tYXliZUNoaWxkKCRwb3MuaW5kZXhBZnRlcihkZXB0aCkpO1xuICAgICAgICB3aGlsZSAobmV4dCAmJiAhbmV4dC5pc0xlYWYpIHtcbiAgICAgICAgICAgIG5leHQgPSBuZXh0LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICBlbmQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW5kO1xufVxuZnVuY3Rpb24gZmluZERpZmYoYSwgYiwgcG9zLCBwcmVmZXJyZWRQb3MsIHByZWZlcnJlZFNpZGUpIHtcbiAgICBsZXQgc3RhcnQgPSBhLmZpbmREaWZmU3RhcnQoYiwgcG9zKTtcbiAgICBpZiAoc3RhcnQgPT0gbnVsbClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHsgYTogZW5kQSwgYjogZW5kQiB9ID0gYS5maW5kRGlmZkVuZChiLCBwb3MgKyBhLnNpemUsIHBvcyArIGIuc2l6ZSk7XG4gICAgaWYgKHByZWZlcnJlZFNpZGUgPT0gXCJlbmRcIikge1xuICAgICAgICBsZXQgYWRqdXN0ID0gTWF0aC5tYXgoMCwgc3RhcnQgLSBNYXRoLm1pbihlbmRBLCBlbmRCKSk7XG4gICAgICAgIHByZWZlcnJlZFBvcyAtPSBlbmRBICsgYWRqdXN0IC0gc3RhcnQ7XG4gICAgfVxuICAgIGlmIChlbmRBIDwgc3RhcnQgJiYgYS5zaXplIDwgYi5zaXplKSB7XG4gICAgICAgIGxldCBtb3ZlID0gcHJlZmVycmVkUG9zIDw9IHN0YXJ0ICYmIHByZWZlcnJlZFBvcyA+PSBlbmRBID8gc3RhcnQgLSBwcmVmZXJyZWRQb3MgOiAwO1xuICAgICAgICBzdGFydCAtPSBtb3ZlO1xuICAgICAgICBpZiAoc3RhcnQgJiYgc3RhcnQgPCBiLnNpemUgJiYgaXNTdXJyb2dhdGVQYWlyKGIudGV4dEJldHdlZW4oc3RhcnQgLSAxLCBzdGFydCArIDEpKSlcbiAgICAgICAgICAgIHN0YXJ0ICs9IG1vdmUgPyAxIDogLTE7XG4gICAgICAgIGVuZEIgPSBzdGFydCArIChlbmRCIC0gZW5kQSk7XG4gICAgICAgIGVuZEEgPSBzdGFydDtcbiAgICB9XG4gICAgZWxzZSBpZiAoZW5kQiA8IHN0YXJ0KSB7XG4gICAgICAgIGxldCBtb3ZlID0gcHJlZmVycmVkUG9zIDw9IHN0YXJ0ICYmIHByZWZlcnJlZFBvcyA+PSBlbmRCID8gc3RhcnQgLSBwcmVmZXJyZWRQb3MgOiAwO1xuICAgICAgICBzdGFydCAtPSBtb3ZlO1xuICAgICAgICBpZiAoc3RhcnQgJiYgc3RhcnQgPCBhLnNpemUgJiYgaXNTdXJyb2dhdGVQYWlyKGEudGV4dEJldHdlZW4oc3RhcnQgLSAxLCBzdGFydCArIDEpKSlcbiAgICAgICAgICAgIHN0YXJ0ICs9IG1vdmUgPyAxIDogLTE7XG4gICAgICAgIGVuZEEgPSBzdGFydCArIChlbmRBIC0gZW5kQik7XG4gICAgICAgIGVuZEIgPSBzdGFydDtcbiAgICB9XG4gICAgcmV0dXJuIHsgc3RhcnQsIGVuZEEsIGVuZEIgfTtcbn1cbmZ1bmN0aW9uIGlzU3Vycm9nYXRlUGFpcihzdHIpIHtcbiAgICBpZiAoc3RyLmxlbmd0aCAhPSAyKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGEgPSBzdHIuY2hhckNvZGVBdCgwKSwgYiA9IHN0ci5jaGFyQ29kZUF0KDEpO1xuICAgIHJldHVybiBhID49IDB4REMwMCAmJiBhIDw9IDB4REZGRiAmJiBiID49IDB4RDgwMCAmJiBiIDw9IDB4REJGRjtcbn1cblxuLyoqXG5AaW50ZXJuYWxcbiovXG5jb25zdCBfX3BhcnNlRnJvbUNsaXBib2FyZCA9IHBhcnNlRnJvbUNsaXBib2FyZDtcbi8qKlxuQGludGVybmFsXG4qL1xuY29uc3QgX19lbmRDb21wb3NpdGlvbiA9IGVuZENvbXBvc2l0aW9uO1xuLyoqXG5BbiBlZGl0b3IgdmlldyBtYW5hZ2VzIHRoZSBET00gc3RydWN0dXJlIHRoYXQgcmVwcmVzZW50cyBhblxuZWRpdGFibGUgZG9jdW1lbnQuIEl0cyBzdGF0ZSBhbmQgYmVoYXZpb3IgYXJlIGRldGVybWluZWQgYnkgaXRzXG5bcHJvcHNdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3LkRpcmVjdEVkaXRvclByb3BzKS5cbiovXG5jbGFzcyBFZGl0b3JWaWV3IHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSB2aWV3LiBgcGxhY2VgIG1heSBiZSBhIERPTSBub2RlIHRoYXQgdGhlIGVkaXRvciBzaG91bGRcbiAgICBiZSBhcHBlbmRlZCB0bywgYSBmdW5jdGlvbiB0aGF0IHdpbGwgcGxhY2UgaXQgaW50byB0aGUgZG9jdW1lbnQsXG4gICAgb3IgYW4gb2JqZWN0IHdob3NlIGBtb3VudGAgcHJvcGVydHkgaG9sZHMgdGhlIG5vZGUgdG8gdXNlIGFzIHRoZVxuICAgIGRvY3VtZW50IGNvbnRhaW5lci4gSWYgaXQgaXMgYG51bGxgLCB0aGUgZWRpdG9yIHdpbGwgbm90IGJlXG4gICAgYWRkZWQgdG8gdGhlIGRvY3VtZW50LlxuICAgICovXG4gICAgY29uc3RydWN0b3IocGxhY2UsIHByb3BzKSB7XG4gICAgICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgS2x1ZGdlIHVzZWQgdG8gd29yayBhcm91bmQgYSBDaHJvbWUgYnVnIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnRyYWNrV3JpdGVzID0gbnVsbDtcbiAgICAgICAgdGhpcy5tb3VudGVkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5tYXJrQ3Vyc29yID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmN1cnNvcldyYXBwZXIgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMubGFzdFNlbGVjdGVkVmlld0Rlc2MgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbnB1dCA9IG5ldyBJbnB1dFN0YXRlO1xuICAgICAgICB0aGlzLnByZXZEaXJlY3RQbHVnaW5zID0gW107XG4gICAgICAgIHRoaXMucGx1Z2luVmlld3MgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgIEhvbGRzIGB0cnVlYCB3aGVuIGEgaGFjayBub2RlIGlzIG5lZWRlZCBpbiBGaXJlZm94IHRvIHByZXZlbnQgdGhlXG4gICAgICAgIFtzcGFjZSBpcyBlYXRlbiBpc3N1ZV0oaHR0cHM6Ly9naXRodWIuY29tL1Byb3NlTWlycm9yL3Byb3NlbWlycm9yL2lzc3Vlcy82NTEpXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlcXVpcmVzR2Vja29IYWNrTm9kZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgV2hlbiBlZGl0b3IgY29udGVudCBpcyBiZWluZyBkcmFnZ2VkLCB0aGlzIG9iamVjdCBjb250YWluc1xuICAgICAgICBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZHJhZ2dlZCBzbGljZSBhbmQgd2hldGhlciBpdCBpcyBiZWluZ1xuICAgICAgICBjb3BpZWQgb3IgbW92ZWQuIEF0IGFueSBvdGhlciB0aW1lLCBpdCBpcyBudWxsLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLmRyYWdnaW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy5fcHJvcHMgPSBwcm9wcztcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHByb3BzLnN0YXRlO1xuICAgICAgICB0aGlzLmRpcmVjdFBsdWdpbnMgPSBwcm9wcy5wbHVnaW5zIHx8IFtdO1xuICAgICAgICB0aGlzLmRpcmVjdFBsdWdpbnMuZm9yRWFjaChjaGVja1N0YXRlQ29tcG9uZW50KTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCA9IHRoaXMuZGlzcGF0Y2guYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5kb20gPSAocGxhY2UgJiYgcGxhY2UubW91bnQpIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIGlmIChwbGFjZSkge1xuICAgICAgICAgICAgaWYgKHBsYWNlLmFwcGVuZENoaWxkKVxuICAgICAgICAgICAgICAgIHBsYWNlLmFwcGVuZENoaWxkKHRoaXMuZG9tKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBwbGFjZSA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICAgICAgcGxhY2UodGhpcy5kb20pO1xuICAgICAgICAgICAgZWxzZSBpZiAocGxhY2UubW91bnQpXG4gICAgICAgICAgICAgICAgdGhpcy5tb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVkaXRhYmxlID0gZ2V0RWRpdGFibGUodGhpcyk7XG4gICAgICAgIHVwZGF0ZUN1cnNvcldyYXBwZXIodGhpcyk7XG4gICAgICAgIHRoaXMubm9kZVZpZXdzID0gYnVpbGROb2RlVmlld3ModGhpcyk7XG4gICAgICAgIHRoaXMuZG9jVmlldyA9IGRvY1ZpZXdEZXNjKHRoaXMuc3RhdGUuZG9jLCBjb21wdXRlRG9jRGVjbyh0aGlzKSwgdmlld0RlY29yYXRpb25zKHRoaXMpLCB0aGlzLmRvbSwgdGhpcyk7XG4gICAgICAgIHRoaXMuZG9tT2JzZXJ2ZXIgPSBuZXcgRE9NT2JzZXJ2ZXIodGhpcywgKGZyb20sIHRvLCB0eXBlT3ZlciwgYWRkZWQpID0+IHJlYWRET01DaGFuZ2UodGhpcywgZnJvbSwgdG8sIHR5cGVPdmVyLCBhZGRlZCkpO1xuICAgICAgICB0aGlzLmRvbU9ic2VydmVyLnN0YXJ0KCk7XG4gICAgICAgIGluaXRJbnB1dCh0aGlzKTtcbiAgICAgICAgdGhpcy51cGRhdGVQbHVnaW5WaWV3cygpO1xuICAgIH1cbiAgICAvKipcbiAgICBIb2xkcyBgdHJ1ZWAgd2hlbiBhXG4gICAgW2NvbXBvc2l0aW9uXShodHRwczovL3czYy5naXRodWIuaW8vdWlldmVudHMvI2V2ZW50cy1jb21wb3NpdGlvbmV2ZW50cylcbiAgICBpcyBhY3RpdmUuXG4gICAgKi9cbiAgICBnZXQgY29tcG9zaW5nKCkgeyByZXR1cm4gdGhpcy5pbnB1dC5jb21wb3Npbmc7IH1cbiAgICAvKipcbiAgICBUaGUgdmlldydzIGN1cnJlbnQgW3Byb3BzXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5FZGl0b3JQcm9wcykuXG4gICAgKi9cbiAgICBnZXQgcHJvcHMoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wcm9wcy5zdGF0ZSAhPSB0aGlzLnN0YXRlKSB7XG4gICAgICAgICAgICBsZXQgcHJldiA9IHRoaXMuX3Byb3BzO1xuICAgICAgICAgICAgdGhpcy5fcHJvcHMgPSB7fTtcbiAgICAgICAgICAgIGZvciAobGV0IG5hbWUgaW4gcHJldilcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9wc1tuYW1lXSA9IHByZXZbbmFtZV07XG4gICAgICAgICAgICB0aGlzLl9wcm9wcy5zdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb3BzO1xuICAgIH1cbiAgICAvKipcbiAgICBVcGRhdGUgdGhlIHZpZXcncyBwcm9wcy4gV2lsbCBpbW1lZGlhdGVseSBjYXVzZSBhbiB1cGRhdGUgdG9cbiAgICB0aGUgRE9NLlxuICAgICovXG4gICAgdXBkYXRlKHByb3BzKSB7XG4gICAgICAgIGlmIChwcm9wcy5oYW5kbGVET01FdmVudHMgIT0gdGhpcy5fcHJvcHMuaGFuZGxlRE9NRXZlbnRzKVxuICAgICAgICAgICAgZW5zdXJlTGlzdGVuZXJzKHRoaXMpO1xuICAgICAgICBsZXQgcHJldlByb3BzID0gdGhpcy5fcHJvcHM7XG4gICAgICAgIHRoaXMuX3Byb3BzID0gcHJvcHM7XG4gICAgICAgIGlmIChwcm9wcy5wbHVnaW5zKSB7XG4gICAgICAgICAgICBwcm9wcy5wbHVnaW5zLmZvckVhY2goY2hlY2tTdGF0ZUNvbXBvbmVudCk7XG4gICAgICAgICAgICB0aGlzLmRpcmVjdFBsdWdpbnMgPSBwcm9wcy5wbHVnaW5zO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGVJbm5lcihwcm9wcy5zdGF0ZSwgcHJldlByb3BzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVXBkYXRlIHRoZSB2aWV3IGJ5IHVwZGF0aW5nIGV4aXN0aW5nIHByb3BzIG9iamVjdCB3aXRoIHRoZSBvYmplY3RcbiAgICBnaXZlbiBhcyBhcmd1bWVudC4gRXF1aXZhbGVudCB0byBgdmlldy51cGRhdGUoT2JqZWN0LmFzc2lnbih7fSxcbiAgICB2aWV3LnByb3BzLCBwcm9wcykpYC5cbiAgICAqL1xuICAgIHNldFByb3BzKHByb3BzKSB7XG4gICAgICAgIGxldCB1cGRhdGVkID0ge307XG4gICAgICAgIGZvciAobGV0IG5hbWUgaW4gdGhpcy5fcHJvcHMpXG4gICAgICAgICAgICB1cGRhdGVkW25hbWVdID0gdGhpcy5fcHJvcHNbbmFtZV07XG4gICAgICAgIHVwZGF0ZWQuc3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgICBmb3IgKGxldCBuYW1lIGluIHByb3BzKVxuICAgICAgICAgICAgdXBkYXRlZFtuYW1lXSA9IHByb3BzW25hbWVdO1xuICAgICAgICB0aGlzLnVwZGF0ZSh1cGRhdGVkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVXBkYXRlIHRoZSBlZGl0b3IncyBgc3RhdGVgIHByb3AsIHdpdGhvdXQgdG91Y2hpbmcgYW55IG9mIHRoZVxuICAgIG90aGVyIHByb3BzLlxuICAgICovXG4gICAgdXBkYXRlU3RhdGUoc3RhdGUpIHtcbiAgICAgICAgdGhpcy51cGRhdGVTdGF0ZUlubmVyKHN0YXRlLCB0aGlzLl9wcm9wcyk7XG4gICAgfVxuICAgIHVwZGF0ZVN0YXRlSW5uZXIoc3RhdGUsIHByZXZQcm9wcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBwcmV2ID0gdGhpcy5zdGF0ZSwgcmVkcmF3ID0gZmFsc2UsIHVwZGF0ZVNlbCA9IGZhbHNlO1xuICAgICAgICAvLyBXaGVuIHN0b3JlZCBtYXJrcyBhcmUgYWRkZWQsIHN0b3AgY29tcG9zaXRpb24sIHNvIHRoYXQgdGhleSBjYW5cbiAgICAgICAgLy8gYmUgZGlzcGxheWVkLlxuICAgICAgICBpZiAoc3RhdGUuc3RvcmVkTWFya3MgJiYgdGhpcy5jb21wb3NpbmcpIHtcbiAgICAgICAgICAgIGNsZWFyQ29tcG9zaXRpb24odGhpcyk7XG4gICAgICAgICAgICB1cGRhdGVTZWwgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgbGV0IHBsdWdpbnNDaGFuZ2VkID0gcHJldi5wbHVnaW5zICE9IHN0YXRlLnBsdWdpbnMgfHwgdGhpcy5fcHJvcHMucGx1Z2lucyAhPSBwcmV2UHJvcHMucGx1Z2lucztcbiAgICAgICAgaWYgKHBsdWdpbnNDaGFuZ2VkIHx8IHRoaXMuX3Byb3BzLnBsdWdpbnMgIT0gcHJldlByb3BzLnBsdWdpbnMgfHwgdGhpcy5fcHJvcHMubm9kZVZpZXdzICE9IHByZXZQcm9wcy5ub2RlVmlld3MpIHtcbiAgICAgICAgICAgIGxldCBub2RlVmlld3MgPSBidWlsZE5vZGVWaWV3cyh0aGlzKTtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VkTm9kZVZpZXdzKG5vZGVWaWV3cywgdGhpcy5ub2RlVmlld3MpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlVmlld3MgPSBub2RlVmlld3M7XG4gICAgICAgICAgICAgICAgcmVkcmF3ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGx1Z2luc0NoYW5nZWQgfHwgcHJldlByb3BzLmhhbmRsZURPTUV2ZW50cyAhPSB0aGlzLl9wcm9wcy5oYW5kbGVET01FdmVudHMpIHtcbiAgICAgICAgICAgIGVuc3VyZUxpc3RlbmVycyh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVkaXRhYmxlID0gZ2V0RWRpdGFibGUodGhpcyk7XG4gICAgICAgIHVwZGF0ZUN1cnNvcldyYXBwZXIodGhpcyk7XG4gICAgICAgIGxldCBpbm5lckRlY28gPSB2aWV3RGVjb3JhdGlvbnModGhpcyksIG91dGVyRGVjbyA9IGNvbXB1dGVEb2NEZWNvKHRoaXMpO1xuICAgICAgICBsZXQgc2Nyb2xsID0gcHJldi5wbHVnaW5zICE9IHN0YXRlLnBsdWdpbnMgJiYgIXByZXYuZG9jLmVxKHN0YXRlLmRvYykgPyBcInJlc2V0XCJcbiAgICAgICAgICAgIDogc3RhdGUuc2Nyb2xsVG9TZWxlY3Rpb24gPiBwcmV2LnNjcm9sbFRvU2VsZWN0aW9uID8gXCJ0byBzZWxlY3Rpb25cIiA6IFwicHJlc2VydmVcIjtcbiAgICAgICAgbGV0IHVwZGF0ZURvYyA9IHJlZHJhdyB8fCAhdGhpcy5kb2NWaWV3Lm1hdGNoZXNOb2RlKHN0YXRlLmRvYywgb3V0ZXJEZWNvLCBpbm5lckRlY28pO1xuICAgICAgICBpZiAodXBkYXRlRG9jIHx8ICFzdGF0ZS5zZWxlY3Rpb24uZXEocHJldi5zZWxlY3Rpb24pKVxuICAgICAgICAgICAgdXBkYXRlU2VsID0gdHJ1ZTtcbiAgICAgICAgbGV0IG9sZFNjcm9sbFBvcyA9IHNjcm9sbCA9PSBcInByZXNlcnZlXCIgJiYgdXBkYXRlU2VsICYmIHRoaXMuZG9tLnN0eWxlLm92ZXJmbG93QW5jaG9yID09IG51bGwgJiYgc3RvcmVTY3JvbGxQb3ModGhpcyk7XG4gICAgICAgIGlmICh1cGRhdGVTZWwpIHtcbiAgICAgICAgICAgIHRoaXMuZG9tT2JzZXJ2ZXIuc3RvcCgpO1xuICAgICAgICAgICAgLy8gV29yayBhcm91bmQgYW4gaXNzdWUgaW4gQ2hyb21lLCBJRSwgYW5kIEVkZ2Ugd2hlcmUgY2hhbmdpbmdcbiAgICAgICAgICAgIC8vIHRoZSBET00gYXJvdW5kIGFuIGFjdGl2ZSBzZWxlY3Rpb24gcHV0cyBpdCBpbnRvIGEgYnJva2VuXG4gICAgICAgICAgICAvLyBzdGF0ZSB3aGVyZSB0aGUgdGhpbmcgdGhlIHVzZXIgc2VlcyBkaWZmZXJzIGZyb20gdGhlXG4gICAgICAgICAgICAvLyBzZWxlY3Rpb24gcmVwb3J0ZWQgYnkgdGhlIFNlbGVjdGlvbiBvYmplY3QgKCM3MTAsICM5NzMsXG4gICAgICAgICAgICAvLyAjMTAxMSwgIzEwMTMsICMxMDM1KS5cbiAgICAgICAgICAgIGxldCBmb3JjZVNlbFVwZGF0ZSA9IHVwZGF0ZURvYyAmJiAoaWUgfHwgY2hyb21lKSAmJiAhdGhpcy5jb21wb3NpbmcgJiZcbiAgICAgICAgICAgICAgICAhcHJldi5zZWxlY3Rpb24uZW1wdHkgJiYgIXN0YXRlLnNlbGVjdGlvbi5lbXB0eSAmJiBzZWxlY3Rpb25Db250ZXh0Q2hhbmdlZChwcmV2LnNlbGVjdGlvbiwgc3RhdGUuc2VsZWN0aW9uKTtcbiAgICAgICAgICAgIGlmICh1cGRhdGVEb2MpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbm9kZSB0aGF0IHRoZSBzZWxlY3Rpb24gcG9pbnRzIGludG8gaXMgd3JpdHRlbiB0byxcbiAgICAgICAgICAgICAgICAvLyBDaHJvbWUgc29tZXRpbWVzIHN0YXJ0cyBtaXNyZXBvcnRpbmcgdGhlIHNlbGVjdGlvbiwgc28gdGhpc1xuICAgICAgICAgICAgICAgIC8vIHRyYWNrcyB0aGF0IGFuZCBmb3JjZXMgYSBzZWxlY3Rpb24gcmVzZXQgd2hlbiBvdXIgdXBkYXRlXG4gICAgICAgICAgICAgICAgLy8gZGlkIHdyaXRlIHRvIHRoZSBub2RlLlxuICAgICAgICAgICAgICAgIGxldCBjaHJvbWVLbHVkZ2UgPSBjaHJvbWUgPyAodGhpcy50cmFja1dyaXRlcyA9IHRoaXMuZG9tU2VsZWN0aW9uUmFuZ2UoKS5mb2N1c05vZGUpIDogbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb21wb3NpbmcpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXQuY29tcG9zaXRpb25Ob2RlID0gZmluZENvbXBvc2l0aW9uTm9kZSh0aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAocmVkcmF3IHx8ICF0aGlzLmRvY1ZpZXcudXBkYXRlKHN0YXRlLmRvYywgb3V0ZXJEZWNvLCBpbm5lckRlY28sIHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZG9jVmlldy51cGRhdGVPdXRlckRlY28ob3V0ZXJEZWNvKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb2NWaWV3LmRlc3Ryb3koKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb2NWaWV3ID0gZG9jVmlld0Rlc2Moc3RhdGUuZG9jLCBvdXRlckRlY28sIGlubmVyRGVjbywgdGhpcy5kb20sIHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2hyb21lS2x1ZGdlICYmICF0aGlzLnRyYWNrV3JpdGVzKVxuICAgICAgICAgICAgICAgICAgICBmb3JjZVNlbFVwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXb3JrIGFyb3VuZCBmb3IgYW4gaXNzdWUgd2hlcmUgYW4gdXBkYXRlIGFycml2aW5nIHJpZ2h0IGJldHdlZW5cbiAgICAgICAgICAgIC8vIGEgRE9NIHNlbGVjdGlvbiBjaGFuZ2UgYW5kIHRoZSBcInNlbGVjdGlvbmNoYW5nZVwiIGV2ZW50IGZvciBpdFxuICAgICAgICAgICAgLy8gY2FuIGNhdXNlIGEgc3B1cmlvdXMgRE9NIHNlbGVjdGlvbiB1cGRhdGUsIGRpc3J1cHRpbmcgbW91c2VcbiAgICAgICAgICAgIC8vIGRyYWcgc2VsZWN0aW9uLlxuICAgICAgICAgICAgaWYgKGZvcmNlU2VsVXBkYXRlIHx8XG4gICAgICAgICAgICAgICAgISh0aGlzLmlucHV0Lm1vdXNlRG93biAmJiB0aGlzLmRvbU9ic2VydmVyLmN1cnJlbnRTZWxlY3Rpb24uZXEodGhpcy5kb21TZWxlY3Rpb25SYW5nZSgpKSAmJlxuICAgICAgICAgICAgICAgICAgICBhbmNob3JJblJpZ2h0UGxhY2UodGhpcykpKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uVG9ET00odGhpcywgZm9yY2VTZWxVcGRhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3luY05vZGVTZWxlY3Rpb24odGhpcywgc3RhdGUuc2VsZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRvbU9ic2VydmVyLnNldEN1clNlbGVjdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kb21PYnNlcnZlci5zdGFydCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlUGx1Z2luVmlld3MocHJldik7XG4gICAgICAgIGlmICgoKF9hID0gdGhpcy5kcmFnZ2luZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5vZGUpICYmICFwcmV2LmRvYy5lcShzdGF0ZS5kb2MpKVxuICAgICAgICAgICAgdGhpcy51cGRhdGVEcmFnZ2VkTm9kZSh0aGlzLmRyYWdnaW5nLCBwcmV2KTtcbiAgICAgICAgaWYgKHNjcm9sbCA9PSBcInJlc2V0XCIpIHtcbiAgICAgICAgICAgIHRoaXMuZG9tLnNjcm9sbFRvcCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2Nyb2xsID09IFwidG8gc2VsZWN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9TZWxlY3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvbGRTY3JvbGxQb3MpIHtcbiAgICAgICAgICAgIHJlc2V0U2Nyb2xsUG9zKG9sZFNjcm9sbFBvcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzY3JvbGxUb1NlbGVjdGlvbigpIHtcbiAgICAgICAgbGV0IHN0YXJ0RE9NID0gdGhpcy5kb21TZWxlY3Rpb25SYW5nZSgpLmZvY3VzTm9kZTtcbiAgICAgICAgaWYgKCFzdGFydERPTSB8fCAhdGhpcy5kb20uY29udGFpbnMoc3RhcnRET00ubm9kZVR5cGUgPT0gMSA/IHN0YXJ0RE9NIDogc3RhcnRET00ucGFyZW50Tm9kZSkpIDtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zb21lUHJvcChcImhhbmRsZVNjcm9sbFRvU2VsZWN0aW9uXCIsIGYgPT4gZih0aGlzKSkpIDtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZS5zZWxlY3Rpb24gaW5zdGFuY2VvZiBOb2RlU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBsZXQgdGFyZ2V0ID0gdGhpcy5kb2NWaWV3LmRvbUFmdGVyUG9zKHRoaXMuc3RhdGUuc2VsZWN0aW9uLmZyb20pO1xuICAgICAgICAgICAgaWYgKHRhcmdldC5ub2RlVHlwZSA9PSAxKVxuICAgICAgICAgICAgICAgIHNjcm9sbFJlY3RJbnRvVmlldyh0aGlzLCB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIHN0YXJ0RE9NKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNjcm9sbFJlY3RJbnRvVmlldyh0aGlzLCB0aGlzLmNvb3Jkc0F0UG9zKHRoaXMuc3RhdGUuc2VsZWN0aW9uLmhlYWQsIDEpLCBzdGFydERPTSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzdHJveVBsdWdpblZpZXdzKCkge1xuICAgICAgICBsZXQgdmlldztcbiAgICAgICAgd2hpbGUgKHZpZXcgPSB0aGlzLnBsdWdpblZpZXdzLnBvcCgpKVxuICAgICAgICAgICAgaWYgKHZpZXcuZGVzdHJveSlcbiAgICAgICAgICAgICAgICB2aWV3LmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdXBkYXRlUGx1Z2luVmlld3MocHJldlN0YXRlKSB7XG4gICAgICAgIGlmICghcHJldlN0YXRlIHx8IHByZXZTdGF0ZS5wbHVnaW5zICE9IHRoaXMuc3RhdGUucGx1Z2lucyB8fCB0aGlzLmRpcmVjdFBsdWdpbnMgIT0gdGhpcy5wcmV2RGlyZWN0UGx1Z2lucykge1xuICAgICAgICAgICAgdGhpcy5wcmV2RGlyZWN0UGx1Z2lucyA9IHRoaXMuZGlyZWN0UGx1Z2lucztcbiAgICAgICAgICAgIHRoaXMuZGVzdHJveVBsdWdpblZpZXdzKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZGlyZWN0UGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBwbHVnaW4gPSB0aGlzLmRpcmVjdFBsdWdpbnNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHBsdWdpbi5zcGVjLnZpZXcpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGx1Z2luVmlld3MucHVzaChwbHVnaW4uc3BlYy52aWV3KHRoaXMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zdGF0ZS5wbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBsdWdpbiA9IHRoaXMuc3RhdGUucGx1Z2luc1tpXTtcbiAgICAgICAgICAgICAgICBpZiAocGx1Z2luLnNwZWMudmlldylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW5WaWV3cy5wdXNoKHBsdWdpbi5zcGVjLnZpZXcodGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBsdWdpblZpZXdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHBsdWdpblZpZXcgPSB0aGlzLnBsdWdpblZpZXdzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChwbHVnaW5WaWV3LnVwZGF0ZSlcbiAgICAgICAgICAgICAgICAgICAgcGx1Z2luVmlldy51cGRhdGUodGhpcywgcHJldlN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVEcmFnZ2VkTm9kZShkcmFnZ2luZywgcHJldikge1xuICAgICAgICBsZXQgc2VsID0gZHJhZ2dpbmcubm9kZSwgZm91bmQgPSAtMTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuZG9jLm5vZGVBdChzZWwuZnJvbSkgPT0gc2VsLm5vZGUpIHtcbiAgICAgICAgICAgIGZvdW5kID0gc2VsLmZyb207XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgbW92ZWRQb3MgPSBzZWwuZnJvbSArICh0aGlzLnN0YXRlLmRvYy5jb250ZW50LnNpemUgLSBwcmV2LmRvYy5jb250ZW50LnNpemUpO1xuICAgICAgICAgICAgbGV0IG1vdmVkID0gbW92ZWRQb3MgPiAwICYmIHRoaXMuc3RhdGUuZG9jLm5vZGVBdChtb3ZlZFBvcyk7XG4gICAgICAgICAgICBpZiAobW92ZWQgPT0gc2VsLm5vZGUpXG4gICAgICAgICAgICAgICAgZm91bmQgPSBtb3ZlZFBvcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRyYWdnaW5nID0gbmV3IERyYWdnaW5nKGRyYWdnaW5nLnNsaWNlLCBkcmFnZ2luZy5tb3ZlLCBmb3VuZCA8IDAgPyB1bmRlZmluZWQgOiBOb2RlU2VsZWN0aW9uLmNyZWF0ZSh0aGlzLnN0YXRlLmRvYywgZm91bmQpKTtcbiAgICB9XG4gICAgc29tZVByb3AocHJvcE5hbWUsIGYpIHtcbiAgICAgICAgbGV0IHByb3AgPSB0aGlzLl9wcm9wcyAmJiB0aGlzLl9wcm9wc1twcm9wTmFtZV0sIHZhbHVlO1xuICAgICAgICBpZiAocHJvcCAhPSBudWxsICYmICh2YWx1ZSA9IGYgPyBmKHByb3ApIDogcHJvcCkpXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5kaXJlY3RQbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgcHJvcCA9IHRoaXMuZGlyZWN0UGx1Z2luc1tpXS5wcm9wc1twcm9wTmFtZV07XG4gICAgICAgICAgICBpZiAocHJvcCAhPSBudWxsICYmICh2YWx1ZSA9IGYgPyBmKHByb3ApIDogcHJvcCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwbHVnaW5zID0gdGhpcy5zdGF0ZS5wbHVnaW5zO1xuICAgICAgICBpZiAocGx1Z2lucylcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBwcm9wID0gcGx1Z2luc1tpXS5wcm9wc1twcm9wTmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKHByb3AgIT0gbnVsbCAmJiAodmFsdWUgPSBmID8gZihwcm9wKSA6IHByb3ApKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIFF1ZXJ5IHdoZXRoZXIgdGhlIHZpZXcgaGFzIGZvY3VzLlxuICAgICovXG4gICAgaGFzRm9jdXMoKSB7XG4gICAgICAgIC8vIFdvcmsgYXJvdW5kIElFIG5vdCBoYW5kbGluZyBmb2N1cyBjb3JyZWN0bHkgaWYgcmVzaXplIGhhbmRsZXMgYXJlIHNob3duLlxuICAgICAgICAvLyBJZiB0aGUgY3Vyc29yIGlzIGluc2lkZSBhbiBlbGVtZW50IHdpdGggcmVzaXplIGhhbmRsZXMsIGFjdGl2ZUVsZW1lbnRcbiAgICAgICAgLy8gd2lsbCBiZSB0aGF0IGVsZW1lbnQgaW5zdGVhZCBvZiB0aGlzLmRvbS5cbiAgICAgICAgaWYgKGllKSB7XG4gICAgICAgICAgICAvLyBJZiBhY3RpdmVFbGVtZW50IGlzIHdpdGhpbiB0aGlzLmRvbSwgYW5kIHRoZXJlIGFyZSBubyBvdGhlciBlbGVtZW50c1xuICAgICAgICAgICAgLy8gc2V0dGluZyBgY29udGVudGVkaXRhYmxlYCB0byBmYWxzZSBpbiBiZXR3ZWVuLCB0cmVhdCBpdCBhcyBmb2N1c2VkLlxuICAgICAgICAgICAgbGV0IG5vZGUgPSB0aGlzLnJvb3QuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIGlmIChub2RlID09IHRoaXMuZG9tKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgaWYgKCFub2RlIHx8ICF0aGlzLmRvbS5jb250YWlucyhub2RlKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB3aGlsZSAobm9kZSAmJiB0aGlzLmRvbSAhPSBub2RlICYmIHRoaXMuZG9tLmNvbnRhaW5zKG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuY29udGVudEVkaXRhYmxlID09ICdmYWxzZScpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5hY3RpdmVFbGVtZW50ID09IHRoaXMuZG9tO1xuICAgIH1cbiAgICAvKipcbiAgICBGb2N1cyB0aGUgZWRpdG9yLlxuICAgICovXG4gICAgZm9jdXMoKSB7XG4gICAgICAgIHRoaXMuZG9tT2JzZXJ2ZXIuc3RvcCgpO1xuICAgICAgICBpZiAodGhpcy5lZGl0YWJsZSlcbiAgICAgICAgICAgIGZvY3VzUHJldmVudFNjcm9sbCh0aGlzLmRvbSk7XG4gICAgICAgIHNlbGVjdGlvblRvRE9NKHRoaXMpO1xuICAgICAgICB0aGlzLmRvbU9ic2VydmVyLnN0YXJ0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgZG9jdW1lbnQgcm9vdCBpbiB3aGljaCB0aGUgZWRpdG9yIGV4aXN0cy4gVGhpcyB3aWxsXG4gICAgdXN1YWxseSBiZSB0aGUgdG9wLWxldmVsIGBkb2N1bWVudGAsIGJ1dCBtaWdodCBiZSBhIFtzaGFkb3dcbiAgICBET01dKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL1dlYl9Db21wb25lbnRzL1NoYWRvd19ET00pXG4gICAgcm9vdCBpZiB0aGUgZWRpdG9yIGlzIGluc2lkZSBvbmUuXG4gICAgKi9cbiAgICBnZXQgcm9vdCgpIHtcbiAgICAgICAgbGV0IGNhY2hlZCA9IHRoaXMuX3Jvb3Q7XG4gICAgICAgIGlmIChjYWNoZWQgPT0gbnVsbClcbiAgICAgICAgICAgIGZvciAobGV0IHNlYXJjaCA9IHRoaXMuZG9tLnBhcmVudE5vZGU7IHNlYXJjaDsgc2VhcmNoID0gc2VhcmNoLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc2VhcmNoLm5vZGVUeXBlID09IDkgfHwgKHNlYXJjaC5ub2RlVHlwZSA9PSAxMSAmJiBzZWFyY2guaG9zdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWFyY2guZ2V0U2VsZWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmdldFByb3RvdHlwZU9mKHNlYXJjaCkuZ2V0U2VsZWN0aW9uID0gKCkgPT4gc2VhcmNoLm93bmVyRG9jdW1lbnQuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9yb290ID0gc2VhcmNoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhY2hlZCB8fCBkb2N1bWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgV2hlbiBhbiBleGlzdGluZyBlZGl0b3IgdmlldyBpcyBtb3ZlZCB0byBhIG5ldyBkb2N1bWVudCBvclxuICAgIHNoYWRvdyB0cmVlLCBjYWxsIHRoaXMgdG8gbWFrZSBpdCByZWNvbXB1dGUgaXRzIHJvb3QuXG4gICAgKi9cbiAgICB1cGRhdGVSb290KCkge1xuICAgICAgICB0aGlzLl9yb290ID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgR2l2ZW4gYSBwYWlyIG9mIHZpZXdwb3J0IGNvb3JkaW5hdGVzLCByZXR1cm4gdGhlIGRvY3VtZW50XG4gICAgcG9zaXRpb24gdGhhdCBjb3JyZXNwb25kcyB0byB0aGVtLiBNYXkgcmV0dXJuIG51bGwgaWYgdGhlIGdpdmVuXG4gICAgY29vcmRpbmF0ZXMgYXJlbid0IGluc2lkZSBvZiB0aGUgZWRpdG9yLiBXaGVuIGFuIG9iamVjdCBpc1xuICAgIHJldHVybmVkLCBpdHMgYHBvc2AgcHJvcGVydHkgaXMgdGhlIHBvc2l0aW9uIG5lYXJlc3QgdG8gdGhlXG4gICAgY29vcmRpbmF0ZXMsIGFuZCBpdHMgYGluc2lkZWAgcHJvcGVydHkgaG9sZHMgdGhlIHBvc2l0aW9uIG9mIHRoZVxuICAgIGlubmVyIG5vZGUgdGhhdCB0aGUgcG9zaXRpb24gZmFsbHMgaW5zaWRlIG9mLCBvciAtMSBpZiBpdCBpcyBhdFxuICAgIHRoZSB0b3AgbGV2ZWwsIG5vdCBpbiBhbnkgbm9kZS5cbiAgICAqL1xuICAgIHBvc0F0Q29vcmRzKGNvb3Jkcykge1xuICAgICAgICByZXR1cm4gcG9zQXRDb29yZHModGhpcywgY29vcmRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0aGUgdmlld3BvcnQgcmVjdGFuZ2xlIGF0IGEgZ2l2ZW4gZG9jdW1lbnQgcG9zaXRpb24uXG4gICAgYGxlZnRgIGFuZCBgcmlnaHRgIHdpbGwgYmUgdGhlIHNhbWUgbnVtYmVyLCBhcyB0aGlzIHJldHVybnMgYVxuICAgIGZsYXQgY3Vyc29yLWlzaCByZWN0YW5nbGUuIElmIHRoZSBwb3NpdGlvbiBpcyBiZXR3ZWVuIHR3byB0aGluZ3NcbiAgICB0aGF0IGFyZW4ndCBkaXJlY3RseSBhZGphY2VudCwgYHNpZGVgIGRldGVybWluZXMgd2hpY2ggZWxlbWVudFxuICAgIGlzIHVzZWQuIFdoZW4gPCAwLCB0aGUgZWxlbWVudCBiZWZvcmUgdGhlIHBvc2l0aW9uIGlzIHVzZWQsXG4gICAgb3RoZXJ3aXNlIHRoZSBlbGVtZW50IGFmdGVyLlxuICAgICovXG4gICAgY29vcmRzQXRQb3MocG9zLCBzaWRlID0gMSkge1xuICAgICAgICByZXR1cm4gY29vcmRzQXRQb3ModGhpcywgcG9zLCBzaWRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgRE9NIHBvc2l0aW9uIHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIGdpdmVuIGRvY3VtZW50XG4gICAgcG9zaXRpb24uIFdoZW4gYHNpZGVgIGlzIG5lZ2F0aXZlLCBmaW5kIHRoZSBwb3NpdGlvbiBhcyBjbG9zZSBhc1xuICAgIHBvc3NpYmxlIHRvIHRoZSBjb250ZW50IGJlZm9yZSB0aGUgcG9zaXRpb24uIFdoZW4gcG9zaXRpdmUsXG4gICAgcHJlZmVyIHBvc2l0aW9ucyBjbG9zZSB0byB0aGUgY29udGVudCBhZnRlciB0aGUgcG9zaXRpb24uIFdoZW5cbiAgICB6ZXJvLCBwcmVmZXIgYXMgc2hhbGxvdyBhIHBvc2l0aW9uIGFzIHBvc3NpYmxlLlxuICAgIFxuICAgIE5vdGUgdGhhdCB5b3Ugc2hvdWxkICoqbm90KiogbXV0YXRlIHRoZSBlZGl0b3IncyBpbnRlcm5hbCBET00sXG4gICAgb25seSBpbnNwZWN0IGl0IChhbmQgZXZlbiB0aGF0IGlzIHVzdWFsbHkgbm90IG5lY2Vzc2FyeSkuXG4gICAgKi9cbiAgICBkb21BdFBvcyhwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRvY1ZpZXcuZG9tRnJvbVBvcyhwb3MsIHNpZGUpO1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBET00gbm9kZSB0aGF0IHJlcHJlc2VudHMgdGhlIGRvY3VtZW50IG5vZGUgYWZ0ZXIgdGhlXG4gICAgZ2l2ZW4gcG9zaXRpb24uIE1heSByZXR1cm4gYG51bGxgIHdoZW4gdGhlIHBvc2l0aW9uIGRvZXNuJ3QgcG9pbnRcbiAgICBpbiBmcm9udCBvZiBhIG5vZGUgb3IgaWYgdGhlIG5vZGUgaXMgaW5zaWRlIGFuIG9wYXF1ZSBub2RlIHZpZXcuXG4gICAgXG4gICAgVGhpcyBpcyBpbnRlbmRlZCB0byBiZSBhYmxlIHRvIGNhbGwgdGhpbmdzIGxpa2VcbiAgICBgZ2V0Qm91bmRpbmdDbGllbnRSZWN0YCBvbiB0aGF0IERPTSBub2RlLiBEbyAqKm5vdCoqIG11dGF0ZSB0aGVcbiAgICBlZGl0b3IgRE9NIGRpcmVjdGx5LCBvciBhZGQgc3R5bGluZyB0aGlzIHdheSwgc2luY2UgdGhhdCB3aWxsIGJlXG4gICAgaW1tZWRpYXRlbHkgb3ZlcnJpZGVuIGJ5IHRoZSBlZGl0b3IgYXMgaXQgcmVkcmF3cyB0aGUgbm9kZS5cbiAgICAqL1xuICAgIG5vZGVET00ocG9zKSB7XG4gICAgICAgIGxldCBkZXNjID0gdGhpcy5kb2NWaWV3LmRlc2NBdChwb3MpO1xuICAgICAgICByZXR1cm4gZGVzYyA/IGRlc2Mubm9kZURPTSA6IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGRvY3VtZW50IHBvc2l0aW9uIHRoYXQgY29ycmVzcG9uZHMgdG8gYSBnaXZlbiBET01cbiAgICBwb3NpdGlvbi4gKFdoZW5ldmVyIHBvc3NpYmxlLCBpdCBpcyBwcmVmZXJhYmxlIHRvIGluc3BlY3QgdGhlXG4gICAgZG9jdW1lbnQgc3RydWN0dXJlIGRpcmVjdGx5LCByYXRoZXIgdGhhbiBwb2tpbmcgYXJvdW5kIGluIHRoZVxuICAgIERPTSwgYnV0IHNvbWV0aW1lc+KAlGZvciBleGFtcGxlIHdoZW4gaW50ZXJwcmV0aW5nIGFuIGV2ZW50XG4gICAgdGFyZ2V04oCUeW91IGRvbid0IGhhdmUgYSBjaG9pY2UuKVxuICAgIFxuICAgIFRoZSBgYmlhc2AgcGFyYW1ldGVyIGNhbiBiZSB1c2VkIHRvIGluZmx1ZW5jZSB3aGljaCBzaWRlIG9mIGEgRE9NXG4gICAgbm9kZSB0byB1c2Ugd2hlbiB0aGUgcG9zaXRpb24gaXMgaW5zaWRlIGEgbGVhZiBub2RlLlxuICAgICovXG4gICAgcG9zQXRET00obm9kZSwgb2Zmc2V0LCBiaWFzID0gLTEpIHtcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMuZG9jVmlldy5wb3NGcm9tRE9NKG5vZGUsIG9mZnNldCwgYmlhcyk7XG4gICAgICAgIGlmIChwb3MgPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiRE9NIHBvc2l0aW9uIG5vdCBpbnNpZGUgdGhlIGVkaXRvclwiKTtcbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCBvdXQgd2hldGhlciB0aGUgc2VsZWN0aW9uIGlzIGF0IHRoZSBlbmQgb2YgYSB0ZXh0YmxvY2sgd2hlblxuICAgIG1vdmluZyBpbiBhIGdpdmVuIGRpcmVjdGlvbi4gV2hlbiwgZm9yIGV4YW1wbGUsIGdpdmVuIGBcImxlZnRcImAsXG4gICAgaXQgd2lsbCByZXR1cm4gdHJ1ZSBpZiBtb3ZpbmcgbGVmdCBmcm9tIHRoZSBjdXJyZW50IGN1cnNvclxuICAgIHBvc2l0aW9uIHdvdWxkIGxlYXZlIHRoYXQgcG9zaXRpb24ncyBwYXJlbnQgdGV4dGJsb2NrLiBXaWxsIGFwcGx5XG4gICAgdG8gdGhlIHZpZXcncyBjdXJyZW50IHN0YXRlIGJ5IGRlZmF1bHQsIGJ1dCBpdCBpcyBwb3NzaWJsZSB0b1xuICAgIHBhc3MgYSBkaWZmZXJlbnQgc3RhdGUuXG4gICAgKi9cbiAgICBlbmRPZlRleHRibG9jayhkaXIsIHN0YXRlKSB7XG4gICAgICAgIHJldHVybiBlbmRPZlRleHRibG9jayh0aGlzLCBzdGF0ZSB8fCB0aGlzLnN0YXRlLCBkaXIpO1xuICAgIH1cbiAgICAvKipcbiAgICBSdW4gdGhlIGVkaXRvcidzIHBhc3RlIGxvZ2ljIHdpdGggdGhlIGdpdmVuIEhUTUwgc3RyaW5nLiBUaGVcbiAgICBgZXZlbnRgLCBpZiBnaXZlbiwgd2lsbCBiZSBwYXNzZWQgdG8gdGhlXG4gICAgW2BoYW5kbGVQYXN0ZWBdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3LkVkaXRvclByb3BzLmhhbmRsZVBhc3RlKSBob29rLlxuICAgICovXG4gICAgcGFzdGVIVE1MKGh0bWwsIGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBkb1Bhc3RlKHRoaXMsIFwiXCIsIGh0bWwsIGZhbHNlLCBldmVudCB8fCBuZXcgQ2xpcGJvYXJkRXZlbnQoXCJwYXN0ZVwiKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJ1biB0aGUgZWRpdG9yJ3MgcGFzdGUgbG9naWMgd2l0aCB0aGUgZ2l2ZW4gcGxhaW4tdGV4dCBpbnB1dC5cbiAgICAqL1xuICAgIHBhc3RlVGV4dCh0ZXh0LCBldmVudCkge1xuICAgICAgICByZXR1cm4gZG9QYXN0ZSh0aGlzLCB0ZXh0LCBudWxsLCB0cnVlLCBldmVudCB8fCBuZXcgQ2xpcGJvYXJkRXZlbnQoXCJwYXN0ZVwiKSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFNlcmlhbGl6ZSB0aGUgZ2l2ZW4gc2xpY2UgYXMgaXQgd291bGQgYmUgaWYgaXQgd2FzIGNvcGllZCBmcm9tXG4gICAgdGhpcyBlZGl0b3IuIFJldHVybnMgYSBET00gZWxlbWVudCB0aGF0IGNvbnRhaW5zIGFcbiAgICByZXByZXNlbnRhdGlvbiBvZiB0aGUgc2xpY2UgYXMgaXRzIGNoaWxkcmVuLCBhIHRleHR1YWxcbiAgICByZXByZXNlbnRhdGlvbiwgYW5kIHRoZSB0cmFuc2Zvcm1lZCBzbGljZSAod2hpY2ggY2FuIGJlXG4gICAgZGlmZmVyZW50IGZyb20gdGhlIGdpdmVuIGlucHV0IGR1ZSB0byBob29rcyBsaWtlXG4gICAgW2B0cmFuc2Zvcm1Db3BpZWRgXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5FZGl0b3JQcm9wcy50cmFuc2Zvcm1Db3BpZWQpKS5cbiAgICAqL1xuICAgIHNlcmlhbGl6ZUZvckNsaXBib2FyZChzbGljZSkge1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplRm9yQ2xpcGJvYXJkKHRoaXMsIHNsaWNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmVtb3ZlcyB0aGUgZWRpdG9yIGZyb20gdGhlIERPTSBhbmQgZGVzdHJveXMgYWxsIFtub2RlXG4gICAgdmlld3NdKGh0dHBzOi8vcHJvc2VtaXJyb3IubmV0L2RvY3MvcmVmLyN2aWV3Lk5vZGVWaWV3KS5cbiAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICghdGhpcy5kb2NWaWV3KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBkZXN0cm95SW5wdXQodGhpcyk7XG4gICAgICAgIHRoaXMuZGVzdHJveVBsdWdpblZpZXdzKCk7XG4gICAgICAgIGlmICh0aGlzLm1vdW50ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZG9jVmlldy51cGRhdGUodGhpcy5zdGF0ZS5kb2MsIFtdLCB2aWV3RGVjb3JhdGlvbnModGhpcyksIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5kb20udGV4dENvbnRlbnQgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZG9tLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuZG9tLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5kb20pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZG9jVmlldy5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuZG9jVmlldyA9IG51bGw7XG4gICAgICAgIGNsZWFyUmV1c2VkUmFuZ2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhpcyBpcyB0cnVlIHdoZW4gdGhlIHZpZXcgaGFzIGJlZW5cbiAgICBbZGVzdHJveWVkXShodHRwczovL3Byb3NlbWlycm9yLm5ldC9kb2NzL3JlZi8jdmlldy5FZGl0b3JWaWV3LmRlc3Ryb3kpIChhbmQgdGh1cyBzaG91bGQgbm90IGJlXG4gICAgdXNlZCBhbnltb3JlKS5cbiAgICAqL1xuICAgIGdldCBpc0Rlc3Ryb3llZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG9jVmlldyA9PSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICBVc2VkIGZvciB0ZXN0aW5nLlxuICAgICovXG4gICAgZGlzcGF0Y2hFdmVudChldmVudCkge1xuICAgICAgICByZXR1cm4gZGlzcGF0Y2hFdmVudCh0aGlzLCBldmVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZG9tU2VsZWN0aW9uUmFuZ2UoKSB7XG4gICAgICAgIGxldCBzZWwgPSB0aGlzLmRvbVNlbGVjdGlvbigpO1xuICAgICAgICBpZiAoIXNlbClcbiAgICAgICAgICAgIHJldHVybiB7IGZvY3VzTm9kZTogbnVsbCwgZm9jdXNPZmZzZXQ6IDAsIGFuY2hvck5vZGU6IG51bGwsIGFuY2hvck9mZnNldDogMCB9O1xuICAgICAgICByZXR1cm4gc2FmYXJpICYmIHRoaXMucm9vdC5ub2RlVHlwZSA9PT0gMTEgJiZcbiAgICAgICAgICAgIGRlZXBBY3RpdmVFbGVtZW50KHRoaXMuZG9tLm93bmVyRG9jdW1lbnQpID09IHRoaXMuZG9tICYmIHNhZmFyaVNoYWRvd1NlbGVjdGlvblJhbmdlKHRoaXMsIHNlbCkgfHwgc2VsO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGRvbVNlbGVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5nZXRTZWxlY3Rpb24oKTtcbiAgICB9XG59XG5FZGl0b3JWaWV3LnByb3RvdHlwZS5kaXNwYXRjaCA9IGZ1bmN0aW9uICh0cikge1xuICAgIGxldCBkaXNwYXRjaFRyYW5zYWN0aW9uID0gdGhpcy5fcHJvcHMuZGlzcGF0Y2hUcmFuc2FjdGlvbjtcbiAgICBpZiAoZGlzcGF0Y2hUcmFuc2FjdGlvbilcbiAgICAgICAgZGlzcGF0Y2hUcmFuc2FjdGlvbi5jYWxsKHRoaXMsIHRyKTtcbiAgICBlbHNlXG4gICAgICAgIHRoaXMudXBkYXRlU3RhdGUodGhpcy5zdGF0ZS5hcHBseSh0cikpO1xufTtcbmZ1bmN0aW9uIGNvbXB1dGVEb2NEZWNvKHZpZXcpIHtcbiAgICBsZXQgYXR0cnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGF0dHJzLmNsYXNzID0gXCJQcm9zZU1pcnJvclwiO1xuICAgIGF0dHJzLmNvbnRlbnRlZGl0YWJsZSA9IFN0cmluZyh2aWV3LmVkaXRhYmxlKTtcbiAgICB2aWV3LnNvbWVQcm9wKFwiYXR0cmlidXRlc1wiLCB2YWx1ZSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZSh2aWV3LnN0YXRlKTtcbiAgICAgICAgaWYgKHZhbHVlKVxuICAgICAgICAgICAgZm9yIChsZXQgYXR0ciBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGlmIChhdHRyID09IFwiY2xhc3NcIilcbiAgICAgICAgICAgICAgICAgICAgYXR0cnMuY2xhc3MgKz0gXCIgXCIgKyB2YWx1ZVthdHRyXTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhdHRyID09IFwic3R5bGVcIilcbiAgICAgICAgICAgICAgICAgICAgYXR0cnMuc3R5bGUgPSAoYXR0cnMuc3R5bGUgPyBhdHRycy5zdHlsZSArIFwiO1wiIDogXCJcIikgKyB2YWx1ZVthdHRyXTtcbiAgICAgICAgICAgICAgICBlbHNlIGlmICghYXR0cnNbYXR0cl0gJiYgYXR0ciAhPSBcImNvbnRlbnRlZGl0YWJsZVwiICYmIGF0dHIgIT0gXCJub2RlTmFtZVwiKVxuICAgICAgICAgICAgICAgICAgICBhdHRyc1thdHRyXSA9IFN0cmluZyh2YWx1ZVthdHRyXSk7XG4gICAgICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFhdHRycy50cmFuc2xhdGUpXG4gICAgICAgIGF0dHJzLnRyYW5zbGF0ZSA9IFwibm9cIjtcbiAgICByZXR1cm4gW0RlY29yYXRpb24ubm9kZSgwLCB2aWV3LnN0YXRlLmRvYy5jb250ZW50LnNpemUsIGF0dHJzKV07XG59XG5mdW5jdGlvbiB1cGRhdGVDdXJzb3JXcmFwcGVyKHZpZXcpIHtcbiAgICBpZiAodmlldy5tYXJrQ3Vyc29yKSB7XG4gICAgICAgIGxldCBkb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpO1xuICAgICAgICBkb20uY2xhc3NOYW1lID0gXCJQcm9zZU1pcnJvci1zZXBhcmF0b3JcIjtcbiAgICAgICAgZG9tLnNldEF0dHJpYnV0ZShcIm1hcmstcGxhY2Vob2xkZXJcIiwgXCJ0cnVlXCIpO1xuICAgICAgICBkb20uc2V0QXR0cmlidXRlKFwiYWx0XCIsIFwiXCIpO1xuICAgICAgICB2aWV3LmN1cnNvcldyYXBwZXIgPSB7IGRvbSwgZGVjbzogRGVjb3JhdGlvbi53aWRnZXQodmlldy5zdGF0ZS5zZWxlY3Rpb24uZnJvbSwgZG9tLCB7IHJhdzogdHJ1ZSwgbWFya3M6IHZpZXcubWFya0N1cnNvciB9KSB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmlldy5jdXJzb3JXcmFwcGVyID0gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRFZGl0YWJsZSh2aWV3KSB7XG4gICAgcmV0dXJuICF2aWV3LnNvbWVQcm9wKFwiZWRpdGFibGVcIiwgdmFsdWUgPT4gdmFsdWUodmlldy5zdGF0ZSkgPT09IGZhbHNlKTtcbn1cbmZ1bmN0aW9uIHNlbGVjdGlvbkNvbnRleHRDaGFuZ2VkKHNlbDEsIHNlbDIpIHtcbiAgICBsZXQgZGVwdGggPSBNYXRoLm1pbihzZWwxLiRhbmNob3Iuc2hhcmVkRGVwdGgoc2VsMS5oZWFkKSwgc2VsMi4kYW5jaG9yLnNoYXJlZERlcHRoKHNlbDIuaGVhZCkpO1xuICAgIHJldHVybiBzZWwxLiRhbmNob3Iuc3RhcnQoZGVwdGgpICE9IHNlbDIuJGFuY2hvci5zdGFydChkZXB0aCk7XG59XG5mdW5jdGlvbiBidWlsZE5vZGVWaWV3cyh2aWV3KSB7XG4gICAgbGV0IHJlc3VsdCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZnVuY3Rpb24gYWRkKG9iaikge1xuICAgICAgICBmb3IgKGxldCBwcm9wIGluIG9iailcbiAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwgcHJvcCkpXG4gICAgICAgICAgICAgICAgcmVzdWx0W3Byb3BdID0gb2JqW3Byb3BdO1xuICAgIH1cbiAgICB2aWV3LnNvbWVQcm9wKFwibm9kZVZpZXdzXCIsIGFkZCk7XG4gICAgdmlldy5zb21lUHJvcChcIm1hcmtWaWV3c1wiLCBhZGQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjaGFuZ2VkTm9kZVZpZXdzKGEsIGIpIHtcbiAgICBsZXQgbkEgPSAwLCBuQiA9IDA7XG4gICAgZm9yIChsZXQgcHJvcCBpbiBhKSB7XG4gICAgICAgIGlmIChhW3Byb3BdICE9IGJbcHJvcF0pXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgbkErKztcbiAgICB9XG4gICAgZm9yIChsZXQgXyBpbiBiKVxuICAgICAgICBuQisrO1xuICAgIHJldHVybiBuQSAhPSBuQjtcbn1cbmZ1bmN0aW9uIGNoZWNrU3RhdGVDb21wb25lbnQocGx1Z2luKSB7XG4gICAgaWYgKHBsdWdpbi5zcGVjLnN0YXRlIHx8IHBsdWdpbi5zcGVjLmZpbHRlclRyYW5zYWN0aW9uIHx8IHBsdWdpbi5zcGVjLmFwcGVuZFRyYW5zYWN0aW9uKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlBsdWdpbnMgcGFzc2VkIGRpcmVjdGx5IHRvIHRoZSB2aWV3IG11c3Qgbm90IGhhdmUgYSBzdGF0ZSBjb21wb25lbnRcIik7XG59XG5cbmV4cG9ydCB7IERlY29yYXRpb24sIERlY29yYXRpb25TZXQsIEVkaXRvclZpZXcsIF9fZW5kQ29tcG9zaXRpb24sIF9fcGFyc2VGcm9tQ2xpcGJvYXJkIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/prosemirror-view/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/rope-sequence/dist/index.js":
/*!**************************************************!*\
  !*** ./node_modules/rope-sequence/dist/index.js ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\nvar GOOD_LEAF_SIZE = 200;\n\n// :: class<T> A rope sequence is a persistent sequence data structure\n// that supports appending, prepending, and slicing without doing a\n// full copy. It is represented as a mostly-balanced tree.\nvar RopeSequence = function RopeSequence () {};\n\nRopeSequence.prototype.append = function append (other) {\n  if (!other.length) { return this }\n  other = RopeSequence.from(other);\n\n  return (!this.length && other) ||\n    (other.length < GOOD_LEAF_SIZE && this.leafAppend(other)) ||\n    (this.length < GOOD_LEAF_SIZE && other.leafPrepend(this)) ||\n    this.appendInner(other)\n};\n\n// :: (union<[T], RopeSequence<T>>) → RopeSequence<T>\n// Prepend an array or other rope to this one, returning a new rope.\nRopeSequence.prototype.prepend = function prepend (other) {\n  if (!other.length) { return this }\n  return RopeSequence.from(other).append(this)\n};\n\nRopeSequence.prototype.appendInner = function appendInner (other) {\n  return new Append(this, other)\n};\n\n// :: (?number, ?number) → RopeSequence<T>\n// Create a rope repesenting a sub-sequence of this rope.\nRopeSequence.prototype.slice = function slice (from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  if (from >= to) { return RopeSequence.empty }\n  return this.sliceInner(Math.max(0, from), Math.min(this.length, to))\n};\n\n// :: (number) → T\n// Retrieve the element at the given position from this rope.\nRopeSequence.prototype.get = function get (i) {\n  if (i < 0 || i >= this.length) { return undefined }\n  return this.getInner(i)\n};\n\n// :: ((element: T, index: number) → ?bool, ?number, ?number)\n// Call the given function for each element between the given\n// indices. This tends to be more efficient than looping over the\n// indices and calling `get`, because it doesn't have to descend the\n// tree for every element.\nRopeSequence.prototype.forEach = function forEach (f, from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  if (from <= to)\n    { this.forEachInner(f, from, to, 0); }\n  else\n    { this.forEachInvertedInner(f, from, to, 0); }\n};\n\n// :: ((element: T, index: number) → U, ?number, ?number) → [U]\n// Map the given functions over the elements of the rope, producing\n// a flat array.\nRopeSequence.prototype.map = function map (f, from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  var result = [];\n  this.forEach(function (elt, i) { return result.push(f(elt, i)); }, from, to);\n  return result\n};\n\n// :: (?union<[T], RopeSequence<T>>) → RopeSequence<T>\n// Create a rope representing the given array, or return the rope\n// itself if a rope was given.\nRopeSequence.from = function from (values) {\n  if (values instanceof RopeSequence) { return values }\n  return values && values.length ? new Leaf(values) : RopeSequence.empty\n};\n\nvar Leaf = /*@__PURE__*/(function (RopeSequence) {\n  function Leaf(values) {\n    RopeSequence.call(this);\n    this.values = values;\n  }\n\n  if ( RopeSequence ) Leaf.__proto__ = RopeSequence;\n  Leaf.prototype = Object.create( RopeSequence && RopeSequence.prototype );\n  Leaf.prototype.constructor = Leaf;\n\n  var prototypeAccessors = { length: { configurable: true },depth: { configurable: true } };\n\n  Leaf.prototype.flatten = function flatten () {\n    return this.values\n  };\n\n  Leaf.prototype.sliceInner = function sliceInner (from, to) {\n    if (from == 0 && to == this.length) { return this }\n    return new Leaf(this.values.slice(from, to))\n  };\n\n  Leaf.prototype.getInner = function getInner (i) {\n    return this.values[i]\n  };\n\n  Leaf.prototype.forEachInner = function forEachInner (f, from, to, start) {\n    for (var i = from; i < to; i++)\n      { if (f(this.values[i], start + i) === false) { return false } }\n  };\n\n  Leaf.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {\n    for (var i = from - 1; i >= to; i--)\n      { if (f(this.values[i], start + i) === false) { return false } }\n  };\n\n  Leaf.prototype.leafAppend = function leafAppend (other) {\n    if (this.length + other.length <= GOOD_LEAF_SIZE)\n      { return new Leaf(this.values.concat(other.flatten())) }\n  };\n\n  Leaf.prototype.leafPrepend = function leafPrepend (other) {\n    if (this.length + other.length <= GOOD_LEAF_SIZE)\n      { return new Leaf(other.flatten().concat(this.values)) }\n  };\n\n  prototypeAccessors.length.get = function () { return this.values.length };\n\n  prototypeAccessors.depth.get = function () { return 0 };\n\n  Object.defineProperties( Leaf.prototype, prototypeAccessors );\n\n  return Leaf;\n}(RopeSequence));\n\n// :: RopeSequence\n// The empty rope sequence.\nRopeSequence.empty = new Leaf([]);\n\nvar Append = /*@__PURE__*/(function (RopeSequence) {\n  function Append(left, right) {\n    RopeSequence.call(this);\n    this.left = left;\n    this.right = right;\n    this.length = left.length + right.length;\n    this.depth = Math.max(left.depth, right.depth) + 1;\n  }\n\n  if ( RopeSequence ) Append.__proto__ = RopeSequence;\n  Append.prototype = Object.create( RopeSequence && RopeSequence.prototype );\n  Append.prototype.constructor = Append;\n\n  Append.prototype.flatten = function flatten () {\n    return this.left.flatten().concat(this.right.flatten())\n  };\n\n  Append.prototype.getInner = function getInner (i) {\n    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length)\n  };\n\n  Append.prototype.forEachInner = function forEachInner (f, from, to, start) {\n    var leftLen = this.left.length;\n    if (from < leftLen &&\n        this.left.forEachInner(f, from, Math.min(to, leftLen), start) === false)\n      { return false }\n    if (to > leftLen &&\n        this.right.forEachInner(f, Math.max(from - leftLen, 0), Math.min(this.length, to) - leftLen, start + leftLen) === false)\n      { return false }\n  };\n\n  Append.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {\n    var leftLen = this.left.length;\n    if (from > leftLen &&\n        this.right.forEachInvertedInner(f, from - leftLen, Math.max(to, leftLen) - leftLen, start + leftLen) === false)\n      { return false }\n    if (to < leftLen &&\n        this.left.forEachInvertedInner(f, Math.min(from, leftLen), to, start) === false)\n      { return false }\n  };\n\n  Append.prototype.sliceInner = function sliceInner (from, to) {\n    if (from == 0 && to == this.length) { return this }\n    var leftLen = this.left.length;\n    if (to <= leftLen) { return this.left.slice(from, to) }\n    if (from >= leftLen) { return this.right.slice(from - leftLen, to - leftLen) }\n    return this.left.slice(from, leftLen).append(this.right.slice(0, to - leftLen))\n  };\n\n  Append.prototype.leafAppend = function leafAppend (other) {\n    var inner = this.right.leafAppend(other);\n    if (inner) { return new Append(this.left, inner) }\n  };\n\n  Append.prototype.leafPrepend = function leafPrepend (other) {\n    var inner = this.left.leafPrepend(other);\n    if (inner) { return new Append(inner, this.right) }\n  };\n\n  Append.prototype.appendInner = function appendInner (other) {\n    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1)\n      { return new Append(this.left, new Append(this.right, other)) }\n    return new Append(this, other)\n  };\n\n  return Append;\n}(RopeSequence));\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (RopeSequence);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yb3BlLXNlcXVlbmNlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IjtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUMsZ0NBQWdDO0FBQ25FO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkIsVUFBVSxvQkFBb0IsVUFBVTs7QUFFckU7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLFFBQVE7QUFDL0IsUUFBUSw4Q0FBOEM7QUFDdEQ7O0FBRUE7QUFDQSwyQkFBMkIsU0FBUztBQUNwQyxRQUFRLDhDQUE4QztBQUN0RDs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUEsZ0RBQWdEOztBQUVoRCwrQ0FBK0M7O0FBRS9DOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSx5QkFBeUI7QUFDekIsMkJBQTJCO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQsK0RBQWUsWUFBWSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yb3BlLXNlcXVlbmNlL2Rpc3QvaW5kZXguanM/MWM2YiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgR09PRF9MRUFGX1NJWkUgPSAyMDA7XG5cbi8vIDo6IGNsYXNzPFQ+IEEgcm9wZSBzZXF1ZW5jZSBpcyBhIHBlcnNpc3RlbnQgc2VxdWVuY2UgZGF0YSBzdHJ1Y3R1cmVcbi8vIHRoYXQgc3VwcG9ydHMgYXBwZW5kaW5nLCBwcmVwZW5kaW5nLCBhbmQgc2xpY2luZyB3aXRob3V0IGRvaW5nIGFcbi8vIGZ1bGwgY29weS4gSXQgaXMgcmVwcmVzZW50ZWQgYXMgYSBtb3N0bHktYmFsYW5jZWQgdHJlZS5cbnZhciBSb3BlU2VxdWVuY2UgPSBmdW5jdGlvbiBSb3BlU2VxdWVuY2UgKCkge307XG5cblJvcGVTZXF1ZW5jZS5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gYXBwZW5kIChvdGhlcikge1xuICBpZiAoIW90aGVyLmxlbmd0aCkgeyByZXR1cm4gdGhpcyB9XG4gIG90aGVyID0gUm9wZVNlcXVlbmNlLmZyb20ob3RoZXIpO1xuXG4gIHJldHVybiAoIXRoaXMubGVuZ3RoICYmIG90aGVyKSB8fFxuICAgIChvdGhlci5sZW5ndGggPCBHT09EX0xFQUZfU0laRSAmJiB0aGlzLmxlYWZBcHBlbmQob3RoZXIpKSB8fFxuICAgICh0aGlzLmxlbmd0aCA8IEdPT0RfTEVBRl9TSVpFICYmIG90aGVyLmxlYWZQcmVwZW5kKHRoaXMpKSB8fFxuICAgIHRoaXMuYXBwZW5kSW5uZXIob3RoZXIpXG59O1xuXG4vLyA6OiAodW5pb248W1RdLCBSb3BlU2VxdWVuY2U8VD4+KSDihpIgUm9wZVNlcXVlbmNlPFQ+XG4vLyBQcmVwZW5kIGFuIGFycmF5IG9yIG90aGVyIHJvcGUgdG8gdGhpcyBvbmUsIHJldHVybmluZyBhIG5ldyByb3BlLlxuUm9wZVNlcXVlbmNlLnByb3RvdHlwZS5wcmVwZW5kID0gZnVuY3Rpb24gcHJlcGVuZCAob3RoZXIpIHtcbiAgaWYgKCFvdGhlci5sZW5ndGgpIHsgcmV0dXJuIHRoaXMgfVxuICByZXR1cm4gUm9wZVNlcXVlbmNlLmZyb20ob3RoZXIpLmFwcGVuZCh0aGlzKVxufTtcblxuUm9wZVNlcXVlbmNlLnByb3RvdHlwZS5hcHBlbmRJbm5lciA9IGZ1bmN0aW9uIGFwcGVuZElubmVyIChvdGhlcikge1xuICByZXR1cm4gbmV3IEFwcGVuZCh0aGlzLCBvdGhlcilcbn07XG5cbi8vIDo6ICg/bnVtYmVyLCA/bnVtYmVyKSDihpIgUm9wZVNlcXVlbmNlPFQ+XG4vLyBDcmVhdGUgYSByb3BlIHJlcGVzZW50aW5nIGEgc3ViLXNlcXVlbmNlIG9mIHRoaXMgcm9wZS5cblJvcGVTZXF1ZW5jZS5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoZnJvbSwgdG8pIHtcbiAgICBpZiAoIGZyb20gPT09IHZvaWQgMCApIGZyb20gPSAwO1xuICAgIGlmICggdG8gPT09IHZvaWQgMCApIHRvID0gdGhpcy5sZW5ndGg7XG5cbiAgaWYgKGZyb20gPj0gdG8pIHsgcmV0dXJuIFJvcGVTZXF1ZW5jZS5lbXB0eSB9XG4gIHJldHVybiB0aGlzLnNsaWNlSW5uZXIoTWF0aC5tYXgoMCwgZnJvbSksIE1hdGgubWluKHRoaXMubGVuZ3RoLCB0bykpXG59O1xuXG4vLyA6OiAobnVtYmVyKSDihpIgVFxuLy8gUmV0cmlldmUgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uIGZyb20gdGhpcyByb3BlLlxuUm9wZVNlcXVlbmNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQgKGkpIHtcbiAgaWYgKGkgPCAwIHx8IGkgPj0gdGhpcy5sZW5ndGgpIHsgcmV0dXJuIHVuZGVmaW5lZCB9XG4gIHJldHVybiB0aGlzLmdldElubmVyKGkpXG59O1xuXG4vLyA6OiAoKGVsZW1lbnQ6IFQsIGluZGV4OiBudW1iZXIpIOKGkiA/Ym9vbCwgP251bWJlciwgP251bWJlcilcbi8vIENhbGwgdGhlIGdpdmVuIGZ1bmN0aW9uIGZvciBlYWNoIGVsZW1lbnQgYmV0d2VlbiB0aGUgZ2l2ZW5cbi8vIGluZGljZXMuIFRoaXMgdGVuZHMgdG8gYmUgbW9yZSBlZmZpY2llbnQgdGhhbiBsb29waW5nIG92ZXIgdGhlXG4vLyBpbmRpY2VzIGFuZCBjYWxsaW5nIGBnZXRgLCBiZWNhdXNlIGl0IGRvZXNuJ3QgaGF2ZSB0byBkZXNjZW5kIHRoZVxuLy8gdHJlZSBmb3IgZXZlcnkgZWxlbWVudC5cblJvcGVTZXF1ZW5jZS5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2ggKGYsIGZyb20sIHRvKSB7XG4gICAgaWYgKCBmcm9tID09PSB2b2lkIDAgKSBmcm9tID0gMDtcbiAgICBpZiAoIHRvID09PSB2b2lkIDAgKSB0byA9IHRoaXMubGVuZ3RoO1xuXG4gIGlmIChmcm9tIDw9IHRvKVxuICAgIHsgdGhpcy5mb3JFYWNoSW5uZXIoZiwgZnJvbSwgdG8sIDApOyB9XG4gIGVsc2VcbiAgICB7IHRoaXMuZm9yRWFjaEludmVydGVkSW5uZXIoZiwgZnJvbSwgdG8sIDApOyB9XG59O1xuXG4vLyA6OiAoKGVsZW1lbnQ6IFQsIGluZGV4OiBudW1iZXIpIOKGkiBVLCA/bnVtYmVyLCA/bnVtYmVyKSDihpIgW1VdXG4vLyBNYXAgdGhlIGdpdmVuIGZ1bmN0aW9ucyBvdmVyIHRoZSBlbGVtZW50cyBvZiB0aGUgcm9wZSwgcHJvZHVjaW5nXG4vLyBhIGZsYXQgYXJyYXkuXG5Sb3BlU2VxdWVuY2UucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIG1hcCAoZiwgZnJvbSwgdG8pIHtcbiAgICBpZiAoIGZyb20gPT09IHZvaWQgMCApIGZyb20gPSAwO1xuICAgIGlmICggdG8gPT09IHZvaWQgMCApIHRvID0gdGhpcy5sZW5ndGg7XG5cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKGVsdCwgaSkgeyByZXR1cm4gcmVzdWx0LnB1c2goZihlbHQsIGkpKTsgfSwgZnJvbSwgdG8pO1xuICByZXR1cm4gcmVzdWx0XG59O1xuXG4vLyA6OiAoP3VuaW9uPFtUXSwgUm9wZVNlcXVlbmNlPFQ+Pikg4oaSIFJvcGVTZXF1ZW5jZTxUPlxuLy8gQ3JlYXRlIGEgcm9wZSByZXByZXNlbnRpbmcgdGhlIGdpdmVuIGFycmF5LCBvciByZXR1cm4gdGhlIHJvcGVcbi8vIGl0c2VsZiBpZiBhIHJvcGUgd2FzIGdpdmVuLlxuUm9wZVNlcXVlbmNlLmZyb20gPSBmdW5jdGlvbiBmcm9tICh2YWx1ZXMpIHtcbiAgaWYgKHZhbHVlcyBpbnN0YW5jZW9mIFJvcGVTZXF1ZW5jZSkgeyByZXR1cm4gdmFsdWVzIH1cbiAgcmV0dXJuIHZhbHVlcyAmJiB2YWx1ZXMubGVuZ3RoID8gbmV3IExlYWYodmFsdWVzKSA6IFJvcGVTZXF1ZW5jZS5lbXB0eVxufTtcblxudmFyIExlYWYgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChSb3BlU2VxdWVuY2UpIHtcbiAgZnVuY3Rpb24gTGVhZih2YWx1ZXMpIHtcbiAgICBSb3BlU2VxdWVuY2UuY2FsbCh0aGlzKTtcbiAgICB0aGlzLnZhbHVlcyA9IHZhbHVlcztcbiAgfVxuXG4gIGlmICggUm9wZVNlcXVlbmNlICkgTGVhZi5fX3Byb3RvX18gPSBSb3BlU2VxdWVuY2U7XG4gIExlYWYucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSggUm9wZVNlcXVlbmNlICYmIFJvcGVTZXF1ZW5jZS5wcm90b3R5cGUgKTtcbiAgTGVhZi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMZWFmO1xuXG4gIHZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IGxlbmd0aDogeyBjb25maWd1cmFibGU6IHRydWUgfSxkZXB0aDogeyBjb25maWd1cmFibGU6IHRydWUgfSB9O1xuXG4gIExlYWYucHJvdG90eXBlLmZsYXR0ZW4gPSBmdW5jdGlvbiBmbGF0dGVuICgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZXNcbiAgfTtcblxuICBMZWFmLnByb3RvdHlwZS5zbGljZUlubmVyID0gZnVuY3Rpb24gc2xpY2VJbm5lciAoZnJvbSwgdG8pIHtcbiAgICBpZiAoZnJvbSA9PSAwICYmIHRvID09IHRoaXMubGVuZ3RoKSB7IHJldHVybiB0aGlzIH1cbiAgICByZXR1cm4gbmV3IExlYWYodGhpcy52YWx1ZXMuc2xpY2UoZnJvbSwgdG8pKVxuICB9O1xuXG4gIExlYWYucHJvdG90eXBlLmdldElubmVyID0gZnVuY3Rpb24gZ2V0SW5uZXIgKGkpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZXNbaV1cbiAgfTtcblxuICBMZWFmLnByb3RvdHlwZS5mb3JFYWNoSW5uZXIgPSBmdW5jdGlvbiBmb3JFYWNoSW5uZXIgKGYsIGZyb20sIHRvLCBzdGFydCkge1xuICAgIGZvciAodmFyIGkgPSBmcm9tOyBpIDwgdG87IGkrKylcbiAgICAgIHsgaWYgKGYodGhpcy52YWx1ZXNbaV0sIHN0YXJ0ICsgaSkgPT09IGZhbHNlKSB7IHJldHVybiBmYWxzZSB9IH1cbiAgfTtcblxuICBMZWFmLnByb3RvdHlwZS5mb3JFYWNoSW52ZXJ0ZWRJbm5lciA9IGZ1bmN0aW9uIGZvckVhY2hJbnZlcnRlZElubmVyIChmLCBmcm9tLCB0bywgc3RhcnQpIHtcbiAgICBmb3IgKHZhciBpID0gZnJvbSAtIDE7IGkgPj0gdG87IGktLSlcbiAgICAgIHsgaWYgKGYodGhpcy52YWx1ZXNbaV0sIHN0YXJ0ICsgaSkgPT09IGZhbHNlKSB7IHJldHVybiBmYWxzZSB9IH1cbiAgfTtcblxuICBMZWFmLnByb3RvdHlwZS5sZWFmQXBwZW5kID0gZnVuY3Rpb24gbGVhZkFwcGVuZCAob3RoZXIpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggKyBvdGhlci5sZW5ndGggPD0gR09PRF9MRUFGX1NJWkUpXG4gICAgICB7IHJldHVybiBuZXcgTGVhZih0aGlzLnZhbHVlcy5jb25jYXQob3RoZXIuZmxhdHRlbigpKSkgfVxuICB9O1xuXG4gIExlYWYucHJvdG90eXBlLmxlYWZQcmVwZW5kID0gZnVuY3Rpb24gbGVhZlByZXBlbmQgKG90aGVyKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoICsgb3RoZXIubGVuZ3RoIDw9IEdPT0RfTEVBRl9TSVpFKVxuICAgICAgeyByZXR1cm4gbmV3IExlYWYob3RoZXIuZmxhdHRlbigpLmNvbmNhdCh0aGlzLnZhbHVlcykpIH1cbiAgfTtcblxuICBwcm90b3R5cGVBY2Nlc3NvcnMubGVuZ3RoLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudmFsdWVzLmxlbmd0aCB9O1xuXG4gIHByb3RvdHlwZUFjY2Vzc29ycy5kZXB0aC5nZXQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAwIH07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIExlYWYucHJvdG90eXBlLCBwcm90b3R5cGVBY2Nlc3NvcnMgKTtcblxuICByZXR1cm4gTGVhZjtcbn0oUm9wZVNlcXVlbmNlKSk7XG5cbi8vIDo6IFJvcGVTZXF1ZW5jZVxuLy8gVGhlIGVtcHR5IHJvcGUgc2VxdWVuY2UuXG5Sb3BlU2VxdWVuY2UuZW1wdHkgPSBuZXcgTGVhZihbXSk7XG5cbnZhciBBcHBlbmQgPSAvKkBfX1BVUkVfXyovKGZ1bmN0aW9uIChSb3BlU2VxdWVuY2UpIHtcbiAgZnVuY3Rpb24gQXBwZW5kKGxlZnQsIHJpZ2h0KSB7XG4gICAgUm9wZVNlcXVlbmNlLmNhbGwodGhpcyk7XG4gICAgdGhpcy5sZWZ0ID0gbGVmdDtcbiAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgdGhpcy5sZW5ndGggPSBsZWZ0Lmxlbmd0aCArIHJpZ2h0Lmxlbmd0aDtcbiAgICB0aGlzLmRlcHRoID0gTWF0aC5tYXgobGVmdC5kZXB0aCwgcmlnaHQuZGVwdGgpICsgMTtcbiAgfVxuXG4gIGlmICggUm9wZVNlcXVlbmNlICkgQXBwZW5kLl9fcHJvdG9fXyA9IFJvcGVTZXF1ZW5jZTtcbiAgQXBwZW5kLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoIFJvcGVTZXF1ZW5jZSAmJiBSb3BlU2VxdWVuY2UucHJvdG90eXBlICk7XG4gIEFwcGVuZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBcHBlbmQ7XG5cbiAgQXBwZW5kLnByb3RvdHlwZS5mbGF0dGVuID0gZnVuY3Rpb24gZmxhdHRlbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMubGVmdC5mbGF0dGVuKCkuY29uY2F0KHRoaXMucmlnaHQuZmxhdHRlbigpKVxuICB9O1xuXG4gIEFwcGVuZC5wcm90b3R5cGUuZ2V0SW5uZXIgPSBmdW5jdGlvbiBnZXRJbm5lciAoaSkge1xuICAgIHJldHVybiBpIDwgdGhpcy5sZWZ0Lmxlbmd0aCA/IHRoaXMubGVmdC5nZXQoaSkgOiB0aGlzLnJpZ2h0LmdldChpIC0gdGhpcy5sZWZ0Lmxlbmd0aClcbiAgfTtcblxuICBBcHBlbmQucHJvdG90eXBlLmZvckVhY2hJbm5lciA9IGZ1bmN0aW9uIGZvckVhY2hJbm5lciAoZiwgZnJvbSwgdG8sIHN0YXJ0KSB7XG4gICAgdmFyIGxlZnRMZW4gPSB0aGlzLmxlZnQubGVuZ3RoO1xuICAgIGlmIChmcm9tIDwgbGVmdExlbiAmJlxuICAgICAgICB0aGlzLmxlZnQuZm9yRWFjaElubmVyKGYsIGZyb20sIE1hdGgubWluKHRvLCBsZWZ0TGVuKSwgc3RhcnQpID09PSBmYWxzZSlcbiAgICAgIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBpZiAodG8gPiBsZWZ0TGVuICYmXG4gICAgICAgIHRoaXMucmlnaHQuZm9yRWFjaElubmVyKGYsIE1hdGgubWF4KGZyb20gLSBsZWZ0TGVuLCAwKSwgTWF0aC5taW4odGhpcy5sZW5ndGgsIHRvKSAtIGxlZnRMZW4sIHN0YXJ0ICsgbGVmdExlbikgPT09IGZhbHNlKVxuICAgICAgeyByZXR1cm4gZmFsc2UgfVxuICB9O1xuXG4gIEFwcGVuZC5wcm90b3R5cGUuZm9yRWFjaEludmVydGVkSW5uZXIgPSBmdW5jdGlvbiBmb3JFYWNoSW52ZXJ0ZWRJbm5lciAoZiwgZnJvbSwgdG8sIHN0YXJ0KSB7XG4gICAgdmFyIGxlZnRMZW4gPSB0aGlzLmxlZnQubGVuZ3RoO1xuICAgIGlmIChmcm9tID4gbGVmdExlbiAmJlxuICAgICAgICB0aGlzLnJpZ2h0LmZvckVhY2hJbnZlcnRlZElubmVyKGYsIGZyb20gLSBsZWZ0TGVuLCBNYXRoLm1heCh0bywgbGVmdExlbikgLSBsZWZ0TGVuLCBzdGFydCArIGxlZnRMZW4pID09PSBmYWxzZSlcbiAgICAgIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBpZiAodG8gPCBsZWZ0TGVuICYmXG4gICAgICAgIHRoaXMubGVmdC5mb3JFYWNoSW52ZXJ0ZWRJbm5lcihmLCBNYXRoLm1pbihmcm9tLCBsZWZ0TGVuKSwgdG8sIHN0YXJ0KSA9PT0gZmFsc2UpXG4gICAgICB7IHJldHVybiBmYWxzZSB9XG4gIH07XG5cbiAgQXBwZW5kLnByb3RvdHlwZS5zbGljZUlubmVyID0gZnVuY3Rpb24gc2xpY2VJbm5lciAoZnJvbSwgdG8pIHtcbiAgICBpZiAoZnJvbSA9PSAwICYmIHRvID09IHRoaXMubGVuZ3RoKSB7IHJldHVybiB0aGlzIH1cbiAgICB2YXIgbGVmdExlbiA9IHRoaXMubGVmdC5sZW5ndGg7XG4gICAgaWYgKHRvIDw9IGxlZnRMZW4pIHsgcmV0dXJuIHRoaXMubGVmdC5zbGljZShmcm9tLCB0bykgfVxuICAgIGlmIChmcm9tID49IGxlZnRMZW4pIHsgcmV0dXJuIHRoaXMucmlnaHQuc2xpY2UoZnJvbSAtIGxlZnRMZW4sIHRvIC0gbGVmdExlbikgfVxuICAgIHJldHVybiB0aGlzLmxlZnQuc2xpY2UoZnJvbSwgbGVmdExlbikuYXBwZW5kKHRoaXMucmlnaHQuc2xpY2UoMCwgdG8gLSBsZWZ0TGVuKSlcbiAgfTtcblxuICBBcHBlbmQucHJvdG90eXBlLmxlYWZBcHBlbmQgPSBmdW5jdGlvbiBsZWFmQXBwZW5kIChvdGhlcikge1xuICAgIHZhciBpbm5lciA9IHRoaXMucmlnaHQubGVhZkFwcGVuZChvdGhlcik7XG4gICAgaWYgKGlubmVyKSB7IHJldHVybiBuZXcgQXBwZW5kKHRoaXMubGVmdCwgaW5uZXIpIH1cbiAgfTtcblxuICBBcHBlbmQucHJvdG90eXBlLmxlYWZQcmVwZW5kID0gZnVuY3Rpb24gbGVhZlByZXBlbmQgKG90aGVyKSB7XG4gICAgdmFyIGlubmVyID0gdGhpcy5sZWZ0LmxlYWZQcmVwZW5kKG90aGVyKTtcbiAgICBpZiAoaW5uZXIpIHsgcmV0dXJuIG5ldyBBcHBlbmQoaW5uZXIsIHRoaXMucmlnaHQpIH1cbiAgfTtcblxuICBBcHBlbmQucHJvdG90eXBlLmFwcGVuZElubmVyID0gZnVuY3Rpb24gYXBwZW5kSW5uZXIgKG90aGVyKSB7XG4gICAgaWYgKHRoaXMubGVmdC5kZXB0aCA+PSBNYXRoLm1heCh0aGlzLnJpZ2h0LmRlcHRoLCBvdGhlci5kZXB0aCkgKyAxKVxuICAgICAgeyByZXR1cm4gbmV3IEFwcGVuZCh0aGlzLmxlZnQsIG5ldyBBcHBlbmQodGhpcy5yaWdodCwgb3RoZXIpKSB9XG4gICAgcmV0dXJuIG5ldyBBcHBlbmQodGhpcywgb3RoZXIpXG4gIH07XG5cbiAgcmV0dXJuIEFwcGVuZDtcbn0oUm9wZVNlcXVlbmNlKSk7XG5cbmV4cG9ydCBkZWZhdWx0IFJvcGVTZXF1ZW5jZTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/rope-sequence/dist/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/w3c-keyname/index.js":
/*!*******************************************!*\
  !*** ./node_modules/w3c-keyname/index.js ***!
  \*******************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   base: function() { return /* binding */ base; },\n/* harmony export */   keyName: function() { return /* binding */ keyName; },\n/* harmony export */   shift: function() { return /* binding */ shift; }\n/* harmony export */ });\nvar base = {\n  8: \"Backspace\",\n  9: \"Tab\",\n  10: \"Enter\",\n  12: \"NumLock\",\n  13: \"Enter\",\n  16: \"Shift\",\n  17: \"Control\",\n  18: \"Alt\",\n  20: \"CapsLock\",\n  27: \"Escape\",\n  32: \" \",\n  33: \"PageUp\",\n  34: \"PageDown\",\n  35: \"End\",\n  36: \"Home\",\n  37: \"ArrowLeft\",\n  38: \"ArrowUp\",\n  39: \"ArrowRight\",\n  40: \"ArrowDown\",\n  44: \"PrintScreen\",\n  45: \"Insert\",\n  46: \"Delete\",\n  59: \";\",\n  61: \"=\",\n  91: \"Meta\",\n  92: \"Meta\",\n  106: \"*\",\n  107: \"+\",\n  108: \",\",\n  109: \"-\",\n  110: \".\",\n  111: \"/\",\n  144: \"NumLock\",\n  145: \"ScrollLock\",\n  160: \"Shift\",\n  161: \"Shift\",\n  162: \"Control\",\n  163: \"Control\",\n  164: \"Alt\",\n  165: \"Alt\",\n  173: \"-\",\n  186: \";\",\n  187: \"=\",\n  188: \",\",\n  189: \"-\",\n  190: \".\",\n  191: \"/\",\n  192: \"`\",\n  219: \"[\",\n  220: \"\\\\\",\n  221: \"]\",\n  222: \"'\"\n}\n\nvar shift = {\n  48: \")\",\n  49: \"!\",\n  50: \"@\",\n  51: \"#\",\n  52: \"$\",\n  53: \"%\",\n  54: \"^\",\n  55: \"&\",\n  56: \"*\",\n  57: \"(\",\n  59: \":\",\n  61: \"+\",\n  173: \"_\",\n  186: \":\",\n  187: \"+\",\n  188: \"<\",\n  189: \"_\",\n  190: \">\",\n  191: \"?\",\n  192: \"~\",\n  219: \"{\",\n  220: \"|\",\n  221: \"}\",\n  222: \"\\\"\"\n}\n\nvar mac = typeof navigator != \"undefined\" && /Mac/.test(navigator.platform)\nvar ie = typeof navigator != \"undefined\" && /MSIE \\d|Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(navigator.userAgent)\n\n// Fill in the digit keys\nfor (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i)\n\n// The function keys\nfor (var i = 1; i <= 24; i++) base[i + 111] = \"F\" + i\n\n// And the alphabetic keys\nfor (var i = 65; i <= 90; i++) {\n  base[i] = String.fromCharCode(i + 32)\n  shift[i] = String.fromCharCode(i)\n}\n\n// For each code that doesn't have a shift-equivalent, copy the base name\nfor (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code]\n\nfunction keyName(event) {\n  // On macOS, keys held with Shift and Cmd don't reflect the effect of Shift in `.key`.\n  // On IE, shift effect is never included in `.key`.\n  var ignoreKey = mac && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey ||\n      ie && event.shiftKey && event.key && event.key.length == 1 ||\n      event.key == \"Unidentified\"\n  var name = (!ignoreKey && event.key) ||\n    (event.shiftKey ? shift : base)[event.keyCode] ||\n    event.key || \"Unidentified\"\n  // Edge sometimes produces wrong names (Issue #3)\n  if (name == \"Esc\") name = \"Escape\"\n  if (name == \"Del\") name = \"Delete\"\n  // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/\n  if (name == \"Left\") name = \"ArrowLeft\"\n  if (name == \"Up\") name = \"ArrowUp\"\n  if (name == \"Right\") name = \"ArrowRight\"\n  if (name == \"Down\") name = \"ArrowDown\"\n  return name\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy93M2Mta2V5bmFtZS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0EsMEVBQTBFLEdBQUc7O0FBRTdFO0FBQ0EsZ0JBQWdCLFFBQVE7O0FBRXhCO0FBQ0EsZ0JBQWdCLFNBQVM7O0FBRXpCO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3czYy1rZXluYW1lL2luZGV4LmpzPzhkNzQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHZhciBiYXNlID0ge1xuICA4OiBcIkJhY2tzcGFjZVwiLFxuICA5OiBcIlRhYlwiLFxuICAxMDogXCJFbnRlclwiLFxuICAxMjogXCJOdW1Mb2NrXCIsXG4gIDEzOiBcIkVudGVyXCIsXG4gIDE2OiBcIlNoaWZ0XCIsXG4gIDE3OiBcIkNvbnRyb2xcIixcbiAgMTg6IFwiQWx0XCIsXG4gIDIwOiBcIkNhcHNMb2NrXCIsXG4gIDI3OiBcIkVzY2FwZVwiLFxuICAzMjogXCIgXCIsXG4gIDMzOiBcIlBhZ2VVcFwiLFxuICAzNDogXCJQYWdlRG93blwiLFxuICAzNTogXCJFbmRcIixcbiAgMzY6IFwiSG9tZVwiLFxuICAzNzogXCJBcnJvd0xlZnRcIixcbiAgMzg6IFwiQXJyb3dVcFwiLFxuICAzOTogXCJBcnJvd1JpZ2h0XCIsXG4gIDQwOiBcIkFycm93RG93blwiLFxuICA0NDogXCJQcmludFNjcmVlblwiLFxuICA0NTogXCJJbnNlcnRcIixcbiAgNDY6IFwiRGVsZXRlXCIsXG4gIDU5OiBcIjtcIixcbiAgNjE6IFwiPVwiLFxuICA5MTogXCJNZXRhXCIsXG4gIDkyOiBcIk1ldGFcIixcbiAgMTA2OiBcIipcIixcbiAgMTA3OiBcIitcIixcbiAgMTA4OiBcIixcIixcbiAgMTA5OiBcIi1cIixcbiAgMTEwOiBcIi5cIixcbiAgMTExOiBcIi9cIixcbiAgMTQ0OiBcIk51bUxvY2tcIixcbiAgMTQ1OiBcIlNjcm9sbExvY2tcIixcbiAgMTYwOiBcIlNoaWZ0XCIsXG4gIDE2MTogXCJTaGlmdFwiLFxuICAxNjI6IFwiQ29udHJvbFwiLFxuICAxNjM6IFwiQ29udHJvbFwiLFxuICAxNjQ6IFwiQWx0XCIsXG4gIDE2NTogXCJBbHRcIixcbiAgMTczOiBcIi1cIixcbiAgMTg2OiBcIjtcIixcbiAgMTg3OiBcIj1cIixcbiAgMTg4OiBcIixcIixcbiAgMTg5OiBcIi1cIixcbiAgMTkwOiBcIi5cIixcbiAgMTkxOiBcIi9cIixcbiAgMTkyOiBcImBcIixcbiAgMjE5OiBcIltcIixcbiAgMjIwOiBcIlxcXFxcIixcbiAgMjIxOiBcIl1cIixcbiAgMjIyOiBcIidcIlxufVxuXG5leHBvcnQgdmFyIHNoaWZ0ID0ge1xuICA0ODogXCIpXCIsXG4gIDQ5OiBcIiFcIixcbiAgNTA6IFwiQFwiLFxuICA1MTogXCIjXCIsXG4gIDUyOiBcIiRcIixcbiAgNTM6IFwiJVwiLFxuICA1NDogXCJeXCIsXG4gIDU1OiBcIiZcIixcbiAgNTY6IFwiKlwiLFxuICA1NzogXCIoXCIsXG4gIDU5OiBcIjpcIixcbiAgNjE6IFwiK1wiLFxuICAxNzM6IFwiX1wiLFxuICAxODY6IFwiOlwiLFxuICAxODc6IFwiK1wiLFxuICAxODg6IFwiPFwiLFxuICAxODk6IFwiX1wiLFxuICAxOTA6IFwiPlwiLFxuICAxOTE6IFwiP1wiLFxuICAxOTI6IFwiflwiLFxuICAyMTk6IFwie1wiLFxuICAyMjA6IFwifFwiLFxuICAyMjE6IFwifVwiLFxuICAyMjI6IFwiXFxcIlwiXG59XG5cbnZhciBtYWMgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgJiYgL01hYy8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pXG52YXIgaWUgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgJiYgL01TSUUgXFxkfFRyaWRlbnRcXC8oPzpbNy05XXxcXGR7Mix9KVxcLi4qcnY6KFxcZCspLy5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpXG5cbi8vIEZpbGwgaW4gdGhlIGRpZ2l0IGtleXNcbmZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykgYmFzZVs0OCArIGldID0gYmFzZVs5NiArIGldID0gU3RyaW5nKGkpXG5cbi8vIFRoZSBmdW5jdGlvbiBrZXlzXG5mb3IgKHZhciBpID0gMTsgaSA8PSAyNDsgaSsrKSBiYXNlW2kgKyAxMTFdID0gXCJGXCIgKyBpXG5cbi8vIEFuZCB0aGUgYWxwaGFiZXRpYyBrZXlzXG5mb3IgKHZhciBpID0gNjU7IGkgPD0gOTA7IGkrKykge1xuICBiYXNlW2ldID0gU3RyaW5nLmZyb21DaGFyQ29kZShpICsgMzIpXG4gIHNoaWZ0W2ldID0gU3RyaW5nLmZyb21DaGFyQ29kZShpKVxufVxuXG4vLyBGb3IgZWFjaCBjb2RlIHRoYXQgZG9lc24ndCBoYXZlIGEgc2hpZnQtZXF1aXZhbGVudCwgY29weSB0aGUgYmFzZSBuYW1lXG5mb3IgKHZhciBjb2RlIGluIGJhc2UpIGlmICghc2hpZnQuaGFzT3duUHJvcGVydHkoY29kZSkpIHNoaWZ0W2NvZGVdID0gYmFzZVtjb2RlXVxuXG5leHBvcnQgZnVuY3Rpb24ga2V5TmFtZShldmVudCkge1xuICAvLyBPbiBtYWNPUywga2V5cyBoZWxkIHdpdGggU2hpZnQgYW5kIENtZCBkb24ndCByZWZsZWN0IHRoZSBlZmZlY3Qgb2YgU2hpZnQgaW4gYC5rZXlgLlxuICAvLyBPbiBJRSwgc2hpZnQgZWZmZWN0IGlzIG5ldmVyIGluY2x1ZGVkIGluIGAua2V5YC5cbiAgdmFyIGlnbm9yZUtleSA9IG1hYyAmJiBldmVudC5tZXRhS2V5ICYmIGV2ZW50LnNoaWZ0S2V5ICYmICFldmVudC5jdHJsS2V5ICYmICFldmVudC5hbHRLZXkgfHxcbiAgICAgIGllICYmIGV2ZW50LnNoaWZ0S2V5ICYmIGV2ZW50LmtleSAmJiBldmVudC5rZXkubGVuZ3RoID09IDEgfHxcbiAgICAgIGV2ZW50LmtleSA9PSBcIlVuaWRlbnRpZmllZFwiXG4gIHZhciBuYW1lID0gKCFpZ25vcmVLZXkgJiYgZXZlbnQua2V5KSB8fFxuICAgIChldmVudC5zaGlmdEtleSA/IHNoaWZ0IDogYmFzZSlbZXZlbnQua2V5Q29kZV0gfHxcbiAgICBldmVudC5rZXkgfHwgXCJVbmlkZW50aWZpZWRcIlxuICAvLyBFZGdlIHNvbWV0aW1lcyBwcm9kdWNlcyB3cm9uZyBuYW1lcyAoSXNzdWUgIzMpXG4gIGlmIChuYW1lID09IFwiRXNjXCIpIG5hbWUgPSBcIkVzY2FwZVwiXG4gIGlmIChuYW1lID09IFwiRGVsXCIpIG5hbWUgPSBcIkRlbGV0ZVwiXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vZW4tdXMvbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzg4NjA1NzEvXG4gIGlmIChuYW1lID09IFwiTGVmdFwiKSBuYW1lID0gXCJBcnJvd0xlZnRcIlxuICBpZiAobmFtZSA9PSBcIlVwXCIpIG5hbWUgPSBcIkFycm93VXBcIlxuICBpZiAobmFtZSA9PSBcIlJpZ2h0XCIpIG5hbWUgPSBcIkFycm93UmlnaHRcIlxuICBpZiAobmFtZSA9PSBcIkRvd25cIikgbmFtZSA9IFwiQXJyb3dEb3duXCJcbiAgcmV0dXJuIG5hbWVcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/w3c-keyname/index.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22C%3A%5C%5CUsers%5C%5C91965%5C%5CDesktop%5C%5Cblogging%5C%5Csrc%5C%5Capp%5C%5Ccreate%5C%5Cpage.tsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);